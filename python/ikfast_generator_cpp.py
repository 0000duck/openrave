#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Software License Agreement (Lesser GPL)
#
# Copyright (C) 2009-2010 Rosen Diankov
#
# ikfast is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# at your option) any later version.
#
# ikfast is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
from __future__ import with_statement # for python 2.5

import sys, copy, time, datetime
try:
    from openravepy.metaclass import AutoReloader
except:
    class AutoReloader:
        pass

# import the correct iktypes from openravepy (if present)
try:
    from openravepy import IkParameterization
    IkType = IkParameterization.Type
except:
    class IkType:
        Transform6D=1
        Rotation3D=2
        Translation3D=3
        Direction3D=4
        Ray4D=5

from sympy import *

try:
    from itertools import izip, combinations
except ImportError:
    def combinations(items,n):
        if n == 0: yield[]
        else:
            for  i in xrange(len(items)):
                for cc in combinations(items[i+1:],n-1):
                    yield [items[i]]+cc

class fmod(core.function.Function):
    nargs = 2
    is_real = True

def customcse(exprs,symbols=None):
    replacements,reduced_exprs = cse(exprs,symbols=symbols)
    newreplacements = []
    # look for opany expressions of the order of (x**(1/a))**b, usually computer wants x^(b/a)
    for r in replacements:
        if r[1].is_Pow and r[1].exp.is_real and r[1].base.is_Symbol:
            baseexpr = r[1].base.subs(replacements)
            if baseexpr.is_Pow and baseexpr.exp.is_real:
                newreplacements.append((r[0],baseexpr.base**(r[1].exp*baseexpr.exp)))
                continue
        newreplacements.append(r)
    return newreplacements,reduced_exprs

class CodeGenerator(AutoReloader):
    """Generates C++ code from an AST generated by IKFastSolver

    Generated C++ code structure::

      typedef double IKReal;
      class IKSolution
      {
      public:
          void GetSolution(IKReal* psolution, const IKReal* pfree) const;
      };

      bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<SOLUTION>& vsolutions);
      bool fk(const IKReal* joints, IKReal* eetrans, IKReal* eerot);
    """
    dictequations = [] # dictionary of symbols already written
    symbolgen = cse_main.numbered_symbols('x')
    strprinter = printing.StrPrinter()
    freevars = None # list of free variables in the solution
    freevardependencies = None # list of variables depending on the free variables
    functions = dict()

    def generate(self, solvertree, kinematicshash=''):
        print 'generating c++ code...'
        code = """/// autogenerated analytical inverse kinematics code from ikfast program
/// \\author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// generated %s
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object:
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -shared -Wl,-soname,ik.so -o ik.so ik.cpp
#include <cmath>
#include <cassert>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \\param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                assert(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \\return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

inline float IKasin(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline float IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

"""%str(datetime.datetime.now())
        code += solvertree.generate(self)
        code += solvertree.end(self)

        code += """

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
IKSolver solver;
return solver.ik(eetrans,eerot,pfree,vsolutions);
}

IKFAST_API const char* getKinematicsHash() { return "%s"; }
"""%(kinematicshash)

        code += """
#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n"
               "Returns the ik solutions given the transformation of the end effector specified by\\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n"
               "There are %d free parameters that have to be specified.\\n\\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\\n");
        return -1;
    }

    printf("Found %d ik solutions:\\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\\n");
    }
    return 0;
}

#endif
"""
        return code

    def generateChain(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Transform6D
        # generate the fk
        if node.Tfk:
            code += "/// solves the forward kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            subexprs,reduced_exprs=customcse (node.Tfk[0:3,0:4].subs([(v[0],Symbol('j[%d]'%v[1])) for v in allvars]))
            outputnames = ['eerot[0]','eerot[1]','eerot[2]','eetrans[0]','eerot[3]','eerot[4]','eerot[5]','eetrans[1]','eerot[6]','eerot[7]','eerot[8]','eetrans[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = [var for var,expr in subexprs]
                fcode = 'IKReal ' + ','.join(str(var) for var,expr in subexprs) + ';\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'
        code += "class IKSolver {\npublic:\n"
        code += 'IKReal '
        
        for var in node.solvejointvars:
            code += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            code += '%s, c%s, s%s,\n'%(name,name,name)

        for i in range(3):
            for j in range(3):
                code += "new_r%d%d, r%d%d,\n"%(i,j,i,j)
        code += "new_px, new_py, new_pz, px, py, pz;\n\n"
        
        rotsubs = [(Symbol("r%d%d"%(i,j)),Symbol("new_r%d%d"%(i,j))) for i in range(3) for j in range(3)]
        rotsubs += [(Symbol("px"),Symbol("new_px")),(Symbol("py"),Symbol("new_py")),(Symbol("pz"),Symbol("new_pz"))]

        code += "bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d]; c%s=cos(pfree[%d]); s%s=sin(pfree[%d]);\n'%(name,i,name,i,name,i)
        for i in range(3):
            for j in range(3):
                fcode += "r%d%d = eerot[%d*3+%d];\n"%(i,j,i,j)
        fcode += "px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\n"
        psymbols = ["new_px","new_py","new_pz"]
        for i in range(3):
            for j in range(3):
                fcode += self.writeEquations(lambda k: "new_r%d%d"%(i,j),node.Tee[4*i+j])
            fcode += self.writeEquations(lambda k: psymbols[i],node.Tee[4*i+3])
        for i in range(3):
            for j in range(3):
                fcode += "r%d%d = new_r%d%d; "%(i,j,i,j)
        fcode += "px = new_px; py = new_py; pz = new_pz;\n"

        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"

        # write other functions
        for name,functioncode in self.functions.iteritems():
            code += self.indentCode(functioncode,4)
        code += "};\n"
        return code
    def endChain(self, node):
        return ""

    def generateIKChainRotation3D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Rotation3D
        if node.Rfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            subexprs,reduced_exprs=customcse (node.Rfk[0:3,0:3].subs([(v[0],Symbol('j[%d]'%v[1])) for v in allvars]))
            outputnames = ['eerot[0]','eerot[1]','eerot[2]','eerot[3]','eerot[4]','eerot[5]','eerot[6]','eerot[7]','eerot[8]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'

        code += "class IKSolver {\npublic:\n"
        code += 'IKReal '
        for var in node.solvejointvars:
            code += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            code += '%s, c%s, s%s,\n'%(name,name,name)
        for i in range(3):
            for j in range(3):
                code += "new_r%d%d, r%d%d"%(i,j,i,j)
                if i == 2 and j == 2:
                    code += ';\n\n'
                else:
                    code += ',\n'

        code += "bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d]; c%s=cos(pfree[%d]); s%s=sin(pfree[%d]);\n'%(name,i,name,i,name,i)
        for i in range(3):
            for j in range(3):
                fcode += "r%d%d = eerot[%d*3+%d];\n"%(i,j,i,j)
        
        rotsubs = [(Symbol("r%d%d"%(i,j)),Symbol("new_r%d%d"%(i,j))) for i in range(3) for j in range(3)]
        for i in range(3):
            for j in range(3):
                fcode += self.writeEquations(lambda k: "new_r%d%d"%(i,j),node.Ree[i,j])
        for i in range(3):
            for j in range(3):
                fcode += "r%d%d = new_r%d%d; "%(i,j,i,j)
        fcode += '\n'
        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"
        # write other functions
        for name,functioncode in self.functions.iteritems():
            code += self.indentCode(functioncode,4)
        code += "};\n"
        return code
    def endIKChainRotation3D(self, node):
        return ""

    def generateIKChainTranslation3D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Translation3D
        if node.Pfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            allsubs = [(v[0],Symbol('j[%d]'%v[1])) for v in allvars]
            eqs = []
            for eq in node.Pfk[0:3]:
                eqs.append(eq.subs(allsubs))
            subexprs,reduced_exprs=customcse (eqs)
            outputnames = ['eetrans[0]','eetrans[1]','eetrans[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'

        code += "class IKSolver {\npublic:\n"
        code += 'IKReal '
        for var in node.solvejointvars:
            code += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            code += '%s, c%s, s%s,\n'%(name,name,name)
        code += "new_px, new_py, new_pz, px, py, pz;\n\n"

        code += "bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d]; c%s=cos(pfree[%d]); s%s=sin(pfree[%d]);\n'%(name,i,name,i,name,i)
        fcode += "px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\n"

        rotsubs = [(Symbol("px"),Symbol("new_px")),(Symbol("py"),Symbol("new_py")),(Symbol("pz"),Symbol("new_pz"))]
        psymbols = ["new_px","new_py","new_pz"]
        for i in range(3):
            fcode += self.writeEquations(lambda k: psymbols[i],node.Pee[i])
        fcode += "px = new_px; py = new_py; pz = new_pz;\n"
        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"
        # write other functions
        for name,functioncode in self.functions.iteritems():
            code += self.indentCode(functioncode,4)
        code += "};\n"
        return code
    def endIKChainTranslation3D(self, node):
        return ""

    def generateIKChainDirection3D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Direction3D
        if node.Dfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            allsubs = [(v[0],Symbol('j[%d]'%v[1])) for v in allvars]
            eqs = []
            for eq in node.Dfk:
                eqs.append(eq.subs(allsubs))
            subexprs,reduced_exprs=customcse (eqs)
            outputnames = ['eerot[0]','eerot[1]','eerot[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'

        code += "class IKSolver {\npublic:\n"
        code += 'IKReal '
        for var in node.solvejointvars:
            code += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            code += '%s, c%s, s%s,\n'%(name,name,name)
        for i in range(3):
            code += "new_r0%d, r0%d"%(i,i)
        
        code += "bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d]; c%s=cos(pfree[%d]); s%s=sin(pfree[%d]);\n'%(name,i,name,i,name,i)
        for i in range(3):
            fcode += "r0%d = eerot[%d];\n"%(i,i)
        rotsubs = [(Symbol("r%d%d"%(0,i)),Symbol("new_r%d%d"%(0,i))) for i in range(3)]

        for i in range(3):
            fcode += self.writeEquations(lambda k: "new_r%d%d"%(0,i),node.Dee[i])
        for i in range(3):
            fcode += "r0%d = new_r0%d; "%(i,i)

        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"

        # write other functions
        for name,functioncode in self.functions.iteritems():
            code += self.indentCode(functioncode,4)

        return code
    def endIKChainDirection3D(self, node):
        return ''

    def generateIKChainRay4D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Ray4D
        if node.Dfk and node.Pfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            allsubs = [(v[0],Symbol('j[%d]'%v[1])) for v in allvars]
            eqs = []
            for eq in node.Pfk[0:3]:
                eqs.append(eq.subs(allsubs))
            for eq in node.Dfk[0:3]:
                eqs.append(eq.subs(allsubs))
            subexprs,reduced_exprs=customcse (eqs)
            outputnames = ['eetrans[0]','eetrans[1]','eetrans[2]','eerot[0]','eerot[1]','eerot[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'

        code += "class IKSolver {\npublic:\n"
        code += 'IKReal '
        for var in node.solvejointvars:
            code += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            code += '%s, c%s, s%s,\n'%(name,i,name,i,name,i)
        for i in range(3):
            code += "new_r0%d, r0%d,\n"%(i,i)
        code += "new_px, new_py, new_pz, px, py, pz;\n"

        code += "bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        fcode += "px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\n"
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d]; c%s=cos(pfree[%d]); s%s=sin(pfree[%d]);\n'%(name,i,name,i,name,i)
        for i in range(3):
            fcode += "r0%d = eerot[%d];\n"%(i,i)
        fcode += "px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n"

        rotsubs = [(Symbol("r%d%d"%(0,i)),Symbol("new_r%d%d"%(0,i))) for i in range(3)]
        rotsubs += [(Symbol("px"),Symbol("new_px")),(Symbol("py"),Symbol("new_py")),(Symbol("pz"),Symbol("new_pz"))]

        psymbols = ["new_px","new_py","new_pz"]
        for i in range(3):
            fcode += self.writeEquations(lambda k: "new_r%d%d"%(0,i),node.Dee[i])
            fcode += self.writeEquations(lambda k: psymbols[i],node.Pee[i])
        for i in range(3):
            fcode += "r0%d = new_r0%d; "%(i,i)
        fcode += "\nIKReal new_pdotd = new_px*new_r00+new_py*new_r01+new_pz*new_r02;\n"
        fcode += "px = new_px-new_pdotd * new_r00; py = new_py- new_pdotd * new_r01; pz = new_pz - new_pdotd * new_r02;\n\n"

        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"

        # write other functions
        for name,functioncode in self.functions.iteritems():
            code += self.indentCode(functioncode,4)
        code += "};\n"
        return code
    def endIKChainRay4D(self, node):
        return ''

    def generateIKChainLookat3D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Lookat3D
        if node.Dfk and node.Pfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            allsubs = [(v[0],Symbol('j[%d]'%v[1])) for v in allvars]
            eqs = []
            for eq in node.Pfk[0:3]:
                eqs.append(eq.subs(allsubs))
            for eq in node.Dfk[0:3]:
                eqs.append(eq.subs(allsubs))
            subexprs,reduced_exprs=customcse (eqs)
            outputnames = ['eetrans[0]','eetrans[1]','eetrans[2]','eerot[0]','eerot[1]','eerot[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'

        code += "class IKSolver {\npublic:\n"
        code += 'IKReal '
        for var in node.solvejointvars:
            code += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            code += '%s, c%s, s%s,\n'%(name,name,name)
        code += "new_px, new_py, new_pz, px, py, pz;\n\n"

        code += "bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        fcode += "px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];\n\n"
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d]; c%s=cos(pfree[%d]); s%s=sin(pfree[%d]);\n'%(name,i,name,i,name,i)

        rotsubs = [(Symbol("px"),Symbol("new_px")),(Symbol("py"),Symbol("new_py")),(Symbol("pz"),Symbol("new_pz"))]
        psymbols = ["new_px","new_py","new_pz"]
        for i in range(3):
            fcode += self.writeEquations(lambda k: psymbols[i],node.Pee[i])
        fcode += "px = new_px; py = new_py; pz = new_pz;\n"
        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n\n"
        # write other functions
        for name,functioncode in self.functions.iteritems():
            code += self.indentCode(functioncode,4)
        code += "};\n"
        return code
    def endIKChainLookat3D(self, node):
        return ''

    def generateSolution(self, node,declarearray=True,acceptfreevars=True):
        code = ''
        numsolutions = 0
        eqcode = ''
        name = node.jointname
        node.HasFreeVar = False
        allnumsolutions = 0
        if node.jointeval is not None:
            numsolutions = len(node.jointeval)
            equations = []
            names = []
            for i,expr in enumerate(node.jointeval):
                if acceptfreevars:
                    m = None
                    for freevar in self.freevars:
                        if expr.has_any_symbols(Symbol(freevar)):
                            # has free variables, so have to look for a*freevar+b form
                            a = Wild('a',exclude=[Symbol(freevar)])
                            b = Wild('b',exclude=[Symbol(freevar)])
                            m = expr.match(a*Symbol(freevar)+b)
                            if m is not None:
                                self.freevardependencies.append((freevar,name))
                                assert(len(node.jointeval)==1)
                                code += 'IKReal ' + self.writeEquations(lambda i: '%smul'%name, m[a])
                                code += self.writeEquations(lambda i: name, m[b])
                                node.HasFreeVar = True
                                return code
                            else:
                                print 'failed to extract free variable %s for %s from'%(freevar,node.jointname), expr
    #                             m = dict()
    #                             m[a] = Real(-1,30)
    #                             m[b] = Real(0,30)

                equations.append(expr)
                names.append('%sarray[%d]'%(name,allnumsolutions+i))
                equations.append(sin(Symbol('%sarray[%d]'%(name,allnumsolutions+i))))
                names.append('s%sarray[%d]'%(name,allnumsolutions+i))
                equations.append(cos(Symbol('%sarray[%d]'%(name,allnumsolutions+i))))
                names.append('c%sarray[%d]'%(name,allnumsolutions+i))
            eqcode += self.writeEquations(lambda i: names[i], equations)
            if node.AddPiIfNegativeEq:
                for i in range(numsolutions):
                    eqcode += '%sarray[%d] = %sarray[%d] > 0 ? %sarray[%d]-IKPI : %sarray[%d]+IKPI;\n'%(name,allnumsolutions+numsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i)
                    eqcode += 's%sarray[%d] = -s%sarray[%d];\n'%(name,allnumsolutions+numsolutions+i,name,allnumsolutions+i)
                    eqcode += 'c%sarray[%d] = -c%sarray[%d];\n'%(name,allnumsolutions+numsolutions+i,name,allnumsolutions+i)
                numsolutions *= 2
            for i in range(numsolutions):
                if node.IsHinge:
                    eqcode += 'if( %sarray[%d] > IKPI )\n    %sarray[%d]-=IK2PI;\nelse if( %sarray[%d] < -IKPI )\n    %sarray[%d]+=IK2PI;\n'%(name,allnumsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i)
                eqcode += '%svalid[%d] = true;\n'%(name,allnumsolutions+i)
            allnumsolutions += numsolutions
        # might also have cos solutions ...
        if node.jointevalcos is not None:
            numsolutions = 2*len(node.jointevalcos)
            eqcode += self.writeEquations(lambda i: 'c%sarray[%d]'%(name,allnumsolutions+2*i),node.jointevalcos)
            for i in range(len(node.jointevalcos)):
                eqcode += 'if( c%sarray[%d] >= -1.0001 && c%sarray[%d] <= 1.0001 )\n{\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    %svalid[%d] = %svalid[%d] = true;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i+1)
                eqcode += '    %sarray[%d] = IKacos(c%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    s%sarray[%d] = IKsin(%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                # second solution
                eqcode += '    c%sarray[%d] = c%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '    %sarray[%d] = -%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '    s%sarray[%d] = -s%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '}\n'
                eqcode += 'else if( isnan(c%sarray[%d]) )\n{\n'%(name,allnumsolutions+2*i)
                eqcode += '    // probably any value will work\n'
                eqcode += '    %svalid[%d] = true;\n'%(name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = 1; s%sarray[%d] = 0; %sarray[%d] = 0;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '}\n'
            allnumsolutions += numsolutions

        if node.jointevalsin is not None:
            numsolutions = 2*len(node.jointevalsin)
            eqcode += self.writeEquations(lambda i: 's%sarray[%d]'%(name,allnumsolutions+2*i),node.jointevalsin)
            for i in range(len(node.jointevalsin)):
                eqcode += 'if( s%sarray[%d] >= -1.0001 && s%sarray[%d] <= 1.0001 )\n{\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    %svalid[%d] = %svalid[%d] = true;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i+1)
                eqcode += '    %sarray[%d] = IKasin(s%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = IKcos(%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                # second solution
                eqcode += '    s%sarray[%d] = s%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '    %sarray[%d] = %sarray[%d] > 0 ? (IKPI-%sarray[%d]) : (-IKPI-%sarray[%d]);\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i,name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = -c%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '}\n'
                eqcode += 'else if( isnan(s%sarray[%d]) )\n{\n'%(name,allnumsolutions+2*i)
                eqcode += '    // probably any value will work\n'
                eqcode += '    %svalid[%d] = true;\n'%(name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = 1; s%sarray[%d] = 0; %sarray[%d] = 0;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '}\n'
            allnumsolutions += numsolutions

        if not declarearray:
            return eqcode,allnumsolutions

        code += '{\nIKReal %sarray[%d], c%sarray[%d], s%sarray[%d];\n'%(name,allnumsolutions,name,allnumsolutions,name,allnumsolutions)
        code += 'bool %svalid[%d]={false};\n'%(name,allnumsolutions)
        code += eqcode
        if allnumsolutions > 1:
            for i,j in combinations(range(allnumsolutions),2):
                code += 'if( %svalid[%d] && %svalid[%d] && IKabs(c%sarray[%d]-c%sarray[%d]) < 0.0001 && IKabs(s%sarray[%d]-s%sarray[%d]) < 0.0001 )\n    %svalid[%d]=false;\n'%(name,i,name,j,name,i,name,j,name,i,name,j,name,j)
        code += 'for(int i%s = 0; i%s < %d; ++i%s)\n{\n'%(name,name,allnumsolutions,name)
        code += 'if( !%svalid[i%s] ) { continue; }\n'%(name,name)
        code += '%s = %sarray[i%s]; c%s = c%sarray[i%s]; s%s = s%sarray[i%s];\n\n'%(name,name,name,name,name,name,name,name,name)
        return code

    def endSolution(self, node):
        if node.HasFreeVar:
            self.freevardependencies.pop()
            return ''
        return '}\n}\n'

    def generateConditionedSolution(self, node):
        name=node.solversolutions[0].jointname
        assert all([name == s.jointname for s in node.solversolutions])
        origequations = copy.copy(self.dictequations)
        maxchecks = max([len(s.checkforzeros) for s in node.solversolutions])
        allnumsolutions = 0
        checkcode = ''
        for solversolution in node.solversolutions:
            assert len(solversolution.checkforzeros) > 0
            self.dictequations = copy.copy(origequations)
            checkcode += '{\n'
            checkcode += self.writeEquations(lambda i: 'evalcond[%d]'%(i),solversolution.checkforzeros)
            checkcode += 'if( '
            for i in range(len(solversolution.checkforzeros)):
                if i != 0:
                    checkcode += ' && '
                checkcode += 'IKabs(evalcond[%d]) %s %f '%(i,'<=' if solversolution.FeasibleIsZeros else '>',node.thresh)
            checkcode += ' )\n{\n'
            scode,numsolutions = self.generateSolution(solversolution,declarearray=False,acceptfreevars=False)
            scode += 'numsolutions%s = %d;\n'%(name,numsolutions)
            allnumsolutions = max(allnumsolutions,numsolutions)
            checkcode += self.indentCode(scode,4)
            checkcode += '\n} else\n'
        checkcode += '{\n    continue;\n}\n'  # if got here, then current solution branch is not good, so skip
        checkcode += '}\n'*len(node.solversolutions)
        checkcode += 'if( numsolutions%s == 0 ) { continue; }\n'%name

        code = '{\nIKReal evalcond[%d]; int numsolutions%s = 0;\n'%(maxchecks,name)
        code += 'IKReal %sarray[%d], c%sarray[%d], s%sarray[%d];\n'%(name,allnumsolutions,name,allnumsolutions,name,allnumsolutions)
        code += 'bool %svalid[%d]={false};\n'%(name,allnumsolutions)
        code += self.indentCode(checkcode,4)
        if allnumsolutions > 1:
            for i,j in combinations(range(allnumsolutions),2):
                code += 'if( %svalid[%d] && %svalid[%d] && IKabs(c%sarray[%d]-c%sarray[%d]) < 0.0001 && IKabs(s%sarray[%d]-s%sarray[%d]) < 0.0001 )\n    %svalid[%d]=false;\n'%(name,i,name,j,name,i,name,j,name,i,name,j,name,j)
        code += 'for(int i%s = 0; i%s < numsolutions%s; ++i%s)\n{\n'%(name,name,name,name)
        code += 'if( !%svalid[i%s] ) { continue; }\n'%(name,name)
        code += '%s = %sarray[i%s]; c%s = c%sarray[i%s]; s%s = s%sarray[i%s];\n\n'%(name,name,name,name,name,name,name,name,name)
        self.dictequations = origequations
        return code

    def endConditionedSolution(self, node):
        return '}\n}\n'

    def generatePolynomialRoots(self, node):
        D=node.poly.degree
        polyroots=self.using_polyroots(D)
        name = node.jointname
        polyvar = node.poly.symbols[0].name[0]
        code = 'IKReal op[%d+1], zeror[%d];\nint numroots;\n'%(D,D)
        numevals = 0
        if node.postcheckforzeros is not None:
            numevals = max(numevals,len(node.postcheckforzeros))
        if node.postcheckfornonzeros is not None:
            numevals = max(numevals,len(node.postcheckfornonzeros))
        if node.postcheckforrange is not None:
            numevals = max(numevals,len(node.postcheckforrange))
        if numevals > 0:
            code += 'IKReal %sevalpoly[%d];\n'%(name,numevals)
        code += self.writeEquations(lambda i: 'op[%d]'%(i),[node.poly.coeff(i) for i in range(D,-1,-1)])
        code += "%s(op,zeror,numroots);\n"%(polyroots)
        code += 'IKReal %sarray[%d], c%sarray[%d], s%sarray[%d], temp%sarray[%d];\n'%(name,len(node.jointeval)*D,name,len(node.jointeval)*D,name,len(node.jointeval)*D,name,len(node.jointeval))
        code += 'int numsolutions = 0;\n'
        code += 'for(int i%s = 0; i%s < numroots; ++i%s)\n{\n'%(name,name,name)
        fcode = '%s = zeror[i%s];\n'%(node.poly.symbols[0].name,name)
        origequations = copy.copy(self.dictequations)
        fcode += self.writeEquations(lambda i: 'temp%sarray[%d]'%(name,i), node.jointeval)
        self.dictequations = origequations
        fcode += 'for(int k%s = 0; k%s < %d; ++k%s)\n{\n'%(name,name,len(node.jointeval),name)
        fcode += '%sarray[numsolutions] = temp%sarray[k%s];\n'%(name,name,name)
        if node.IsHinge:
            fcode += 'if( %sarray[numsolutions] > IKPI )\n    %sarray[numsolutions]-=IK2PI;\nelse if( %sarray[numsolutions] < -IKPI )\n    %sarray[numsolutions]+=IK2PI;\n'%(name,name,name,name)
        fcode += '%c%sarray[numsolutions] = zeror[i%s];\n'%(polyvar,name,name)
        if polyvar == 'c':
            fcode += 's%sarray[numsolutions] = IKsin(%sarray[numsolutions]);\n'%(name,name)
        else:
            fcode += 'c%sarray[numsolutions] = IKcos(%sarray[numsolutions]);\n'%(name,name)
        fcode += 'bool valid = true;\n'
        # test all the solutions up to now for validity
        fcode += 'for( int j%s = 0; j%s < numsolutions; ++j%s)\n{\n'%(name,name,name)
        fcode += '    if( IKabs(c%sarray[j%s]-c%sarray[numsolutions]) < 0.0001 && IKabs(s%sarray[j%s]-s%sarray[numsolutions]) < 0.0001 )\n    {\n        valid=false; break;\n    }\n'%(name,name,name,name,name,name)
        fcode += '}\n'
        fcode += 'if( valid ) { numsolutions++; }\n'
        fcode += '}\n'
        code += self.indentCode(fcode,4)
        code += '}\n'
        code += 'for(int i%s = 0; i%s < numsolutions; ++i%s)\n    {\n'%(name,name,name)
        code += '    %s = %sarray[i%s]; c%s = c%sarray[i%s]; s%s = s%sarray[i%s];\n\n'%(name,name,name,name,name,name,name,name,name)
        if node.postcheckforzeros is not None and len(node.postcheckforzeros) > 0:
            fcode = self.writeEquations(lambda i: '%sevalpoly[%d]'%(name,i),node.postcheckforzeros)
            fcode += 'if( '
            for i in range(len(node.postcheckforzeros)):
                if i != 0:
                    fcode += ' || '
                fcode += 'IKabs(%sevalpoly[%d]) < %f '%(name,i,node.thresh)
            fcode += ' )\n{\n    continue;\n}\n'
            code += self.indentCode(fcode,4)
        if node.postcheckfornonzeros is not None and len(node.postcheckfornonzeros) > 0:
            fcode = self.writeEquations(lambda i: '%sevalpoly[%d]'%(name,i),node.postcheckfornonzeros)
            fcode += 'if( '
            for i in range(len(node.postcheckfornonzeros)):
                if i != 0:
                    fcode += ' || '
                fcode += 'IKabs(%sevalpoly[%d]) > %f '%(name,i,node.thresh)
            fcode += ' )\n{\n    continue;\n}\n'
            code += self.indentCode(fcode,4)
        if node.postcheckforrange is not None and len(node.postcheckforrange) > 0:
            fcode = self.writeEquations(lambda i: '%sevalpoly[%d]'%(name,i),node.postcheckforrange)
            fcode += 'if( '
            for i in range(len(node.postcheckforrange)):
                if i != 0:
                    fcode += ' || '
                fcode += ' (%sevalpoly[%d] < %f || %sevalpoly[%d] > %f) '%(name,i,-1.0-node.thresh,name,i,1.0+node.thresh)
            fcode += ' )\n{\n    continue;\n}\n'
            code += self.indentCode(fcode,4)

        return code
    def endPolynomialRoots(self, node):
        return '    }\n'

    def generateConicRoots(self, node):
        conicsolver=self.using_conicsolver()
        name = node.jointname
        cvar = Symbol('c%s'%name)
        svar = Symbol('s%s'%name)
        code = 'IKReal coniccoeffs[6], %sarray[4];\nint numsolutions;\n'%(name)
        if node.checkforzeros is not None and len(node.checkforzeros) > 0:
            code += 'IKReal %seval[%d];\n'%(name,len(node.checkforzeros))
            fcode = self.writeEquations(lambda i: '%seval[%d]'%(name,i),node.checkforzeros)
            fcode += 'if( '
            for i in range(len(node.checkforzeros)):
                if i != 0:
                    fcode += ' || '
                fcode += 'IKabs(%sevalpoly[%d]) < %f '%(name,i,node.thresh)
            fcode += ' )\n{\n    continue;\n}\n'
            code += self.indentCode(fcode,4)
        
        conicpoly = Poly(node.jointeval[0],cvar,svar)
        coeffs = [conicpoly.coeff(2,0),0.5*conicpoly.coeff(1,1),0.5*conicpoly.coeff(1,0),conicpoly.coeff(0,2),0.5*conicpoly.coeff(0,1),conicpoly.coeff(0,0)]
        code += self.writeEquations(lambda i: 'coniccoeffs[%d]'%(i),coeffs)
        code += '%s(coniccoeffs,%sarray,numsolutions);\n'%(conicsolver,name)
        code += 'for(int i%s = 0; i%s < numsolutions; ++i%s)\n{\n'%(name,name,name)
        code += '    %s = %sarray[i%s]; c%s = IKcos(%s); s%s = IKsin(%s);\n\n'%(name, name,name,name,name,name,name)
        return code
    def endConicRoots(self, node):
        return '    }\n'

    def generateBranch(self, node):
        origequations = copy.copy(self.dictequations)
        name = node.jointname
        code = '{\nIKReal %seval;\n'%name
        code += self.writeEquations(lambda x: '%seval'%name,[node.jointeval])
        for branch in node.jointbranches:
            branchcode = ''
            self.dictequations = copy.copy(origequations)
            for n in branch[1]:
                branchcode += n.generate(self)
            for n in reversed(branch[1]):
                branchcode += n.end(self)
            branchcode = self.indentCode(branchcode,4)
            if branch[0] is None:
                code += '{\n' + branchcode + '\n}\n'
            else:
                code += 'if( %seval >= %f && %seval <= %f )\n{\n'%(name,branch[0]-0.00001,name,branch[0]+0.00001)
                code += branchcode + '\n} else\n'
        code += '}\n'
        self.dictequations = origequations
        return code
    def endBranch(self, node):
        return ''
    def generateBranchConds(self, node):
        origequations = copy.copy(self.dictequations)
        code = '{\n'
        numevals = None
        for branch in node.jointbranches:
            if branch[0] is not None:
                if numevals is None or numevals < len(branch[0]):
                    numevals=len(branch[0])
        if numevals is not None:
            code += 'IKReal evalcond[%d];\n'%numevals
        for branch in node.jointbranches:
            self.dictequations = copy.copy(origequations)
            if branch[0] is None:
                branchcode = 'if( 1 )\n{\n'
            else:
                branchcode = self.writeEquations(lambda x: 'evalcond[%d]'%x,branch[0])
                branchcode += 'if( '
                for i in range(len(branch[0])):
                    if i != 0:
                        branchcode += ' && '
                    branchcode += 'IKabs(evalcond[%d]) < %f '%(i,node.thresh)
                branchcode += ' )\n{\n'
            for n in branch[1]:
                branchcode += n.generate(self)
            for n in reversed(branch[1]):
                branchcode += n.end(self)
            code += self.indentCode(branchcode,4)+'\n} else\n{\n'
        code += '}\n'*(len(node.jointbranches)+1)
        self.dictequations = origequations
        return code
    def endBranchConds(self, node):
        return ''
    def generateCheckZeros(self, node):
        origequations = copy.copy(self.dictequations)
        name = node.jointname
        code = 'IKReal %seval[%d];\n'%(name,len(node.jointcheckeqs))
        code += self.writeEquations(lambda i: '%seval[%d]'%(name,i),node.jointcheckeqs)
        if len(node.jointcheckeqs) > 0:
            code += 'if( '
            for i in range(len(node.jointcheckeqs)):
                if i != 0:
                    if node.anycondition:
                        code += ' || '
                    else:
                        code += ' && '
                code += 'IKabs(%seval[%d]) < %f '%(name,i,node.thresh)
            code += ' )\n{\n'
            self.dictequations = copy.copy(origequations)
            code += self.indentCode(self.generateTree(node.zerobranch),4)
            code += '\n} else\n'
        code += '{\n'
        self.dictequations = copy.copy(origequations)
        code += self.indentCode(self.generateTree(node.nonzerobranch),4)
        code += '\n}\n'
        self.dictequations = origequations
        return '{\n' + self.indentCode(code,4) + '\n}\n'
    def endCheckZeros(self, node):
        return ''
    def generateFreeParameter(self, node):
        #print 'free variable ',node.jointname,': ',self.freevars
        self.freevars.append(node.jointname)
        self.freevardependencies.append((node.jointname,node.jointname))
        code = 'IKReal %smul = 1;\n%s=0;\n'%(node.jointname,node.jointname)
        return code+self.generateTree(node.jointtree)
    def endFreeParameter(self, node):
        self.freevars.pop()
        self.freevardependencies.pop()
        return ''
    def generateSetJoint(self, node):
        code = '{\n%s = %f; s%s = %f; c%s = %f;\n'%(node.jointname,node.jointvalue,node.jointname,sin(node.jointvalue),node.jointname,cos(node.jointvalue))
        return code
    def endSetJoint(self, node):
        return '}\n'
    def generateBreak(self,node):
        return 'continue;\n'
    def endBreak(self,node):
        return ''
    def generateRotation(self, node):
        if not node.functionid in self.functions:
            code = 'inline void rotationfunction%d(std::vector<IKSolution>& vsolutions) {\n'%(node.functionid)
            origequations = self.dictequations
            self.dictequations = []
            listequations = []
            names = []
            for i in range(3):
                for j in range(3):
                    listequations.append(node.T[i,j])
                    names.append(Symbol('new_r%d%d'%(i,j)))
            code += self.indentCode(self.writeEquations(lambda i: names[i],listequations),4)
            code += self.indentCode(self.generateTree(node.jointtree),4)
            code += '}'
            self.dictequations = origequations
            self.functions[node.functionid] = code
        return 'rotationfunction%d(vsolutions);\n'%(node.functionid)

    def endRotation(self, node):
        return ''
    def generateDirection(self, node):
        code = ''
        listequations = []
        names = []
        for i in range(3):
            listequations.append(node.D[i])
            names.append(Symbol('new_r%d%d'%(0,i)))
        code += self.writeEquations(lambda i: names[i],listequations)
        code += self.generateTree(node.jointtree)
        return code
    def endDirection(self, node):
        return ''
    def generateStoreSolution(self, node):
        code = 'vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();\n'
        code += 'solution.basesol.resize(%d);\n'%len(node.alljointvars)
        for i,var in enumerate(node.alljointvars):
            code += 'solution.basesol[%d].foffset = %s;\n'%(i,var)
            
            vardeps = [vardep for vardep in self.freevardependencies if vardep[1]==var.name]
            if len(vardeps) > 0:
                freevarname = vardeps[0][0]
                ifreevar = [j for j in range(len(self.freevars)) if freevarname==self.freevars[j]]
                code += 'solution.basesol[%d].fmul = %smul;\n'%(i,var.name)
                code += 'solution.basesol[%d].freeind = %d;\n'%(i,ifreevar[0])
        code += 'solution.vfree.resize(%d);\n'%len(self.freevars)
        for i,varname in enumerate(self.freevars):
            ind = [j for j in range(len(node.alljointvars)) if varname==node.alljointvars[j].name]
            code += 'solution.vfree[%d] = %d;\n'%(i,ind[0])
        return code
    def endStoreSolution(self, node):
        return ''
    def generateSequence(self, node):
        code = ''
        for tree in node.jointtrees:
            code += self.generateTree(tree)
        return code
    def endSequence(self, node):
        return ''
    def generateTree(self,tree):
        code = ''
        for n in tree:
            code += n.generate(self)
        for n in reversed(tree):
            code += n.end(self)
        return code
    def writeEquations(self, varnamefn, exprs):
        code = ''
        [replacements,reduced_exprs] = customcse(exprs,symbols=self.symbolgen)
        for rep in replacements:                
            comparerep = rep[1].subs(self.dictequations)
            found = False
            for x in self.dictequations:
                if comparerep-x[1].subs(self.dictequations)==0:
                    self.dictequations.append((rep[0],x[0]))
                    code += 'IKReal %s=%s;\n'%(rep[0],x[0])
                    found = True
                    break
            if not found:
                self.dictequations.append(rep)
                code2,sepcode2 = self.writeExprCode(rep[1])
                code += sepcode2+'IKReal %s=%s;\n'%(rep[0],code2)
        for i,rexpr in enumerate(reduced_exprs):
            code2,sepcode2 = self.writeExprCode(rexpr)
            code += sepcode2+'%s=%s;\n'%(varnamefn(i), code2)
        return code

    def writeExprCode(self, expr):
        # go through all arguments and chop them
        code = ''
        sepcode = ''
        if expr.is_Function:
            if expr.func == abs:
                code += 'IKabs('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
            elif expr.func == acos:
                code += 'IKacos('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
                sepcode += 'if( (%s) < -1.0001 || (%s) > 1.0001 )\n    continue;\n'%(code2,code2)
            elif expr.func == asin:
                code += 'IKasin('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
                sepcode += 'if( (%s) < -1.0001 || (%s) > 1.0001 )\n    continue;\n'%(code2,code2)
            elif expr.func == atan2:
                code += 'IKatan2('
                # check for divides by 0 in arguments, this could give two possible solutions?!?
                # if common arguments is nan! solution is lost!
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2+', '
                code3,sepcode2 = self.writeExprCode(expr.args[1])
                code += code3
                sepcode += sepcode2
            elif expr.func == sin:
#                 if expr.args[0].is_Symbol and expr.args[0].name[0] == 'j':
#                     # probably already have initialized
#                     code += '(s%s'%expr.args[0].name
#                 else:
                code += 'IKsin('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
            elif expr.func == cos:
#                 if expr.args[0].is_Symbol and expr.args[0].name[0] == 'j':
#                     # probably already have initialized
#                     code += '(c%s'%expr.args[0].name
#                 else:
                code += 'IKcos('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
            elif expr.func == fmod:
                code += 'IKfmod('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2+', '
                code3,sepcode2 = self.writeExprCode(expr.args[1])
                code += code3
                sepcode += sepcode2
            else:
                code += expr.func.__name__ + '('
                for arg in expr.args:
                    code2,sepcode2 = self.writeExprCode(arg)
                    code += code2
                    sepcode += sepcode2
                    if not arg == expr.args[-1]:
                        code += ','
            return code + ')',sepcode
        elif expr.is_Mul:
            code += '('
            for arg in expr.args:
                code2,sepcode2 = self.writeExprCode(arg)
                code += '('+code2+')'
                sepcode += sepcode2
                if not arg == expr.args[-1]:
                    code += '*'
            return code + ')',sepcode
        elif expr.is_Pow:
            exprbase,sepcode = self.writeExprCode(expr.base)
            if expr.exp.is_real:
                if expr.exp.is_integer and expr.exp.evalf() > 0:
                    code += '('+exprbase+')'
                    for i in range(1,expr.exp.evalf()):
                        code += '*('+exprbase+')'
                    return code,sepcode
                elif expr.exp-0.5 == 0:
                    sepcode += 'if( (%s) < (IKReal)-0.00001 )\n    continue;\n'%exprbase
                    return 'IKsqrt('+exprbase+')',sepcode
                elif expr.exp < 0:
                    # check if exprbase is 0
                    if expr.exp+1 == 0:
                        return '((IKabs('+exprbase+') != 0)?((IKReal)1/('+exprbase+')):(IKReal)1.0e30)',sepcode
                    return '((IKabs('+exprbase+') != 0)?(pow(' + exprbase + ',' + str(expr.exp.evalf()) + ')):(IKReal)1.0e30)',sepcode
                    
            exprexp,sepcode2 = self.writeExprCode(expr.exp)
            sepcode += sepcode2
            return 'pow(' + exprbase + ',' + exprexp + ')',sepcode
        elif expr.is_Add:
            code += '('
            for arg in expr.args:
                code2,sepcode2 = self.writeExprCode(arg)
                code += '('+code2+')'
                sepcode += sepcode2
                if not arg == expr.args[-1]:
                    code += '+'
            return code + ')',sepcode

        return self.strprinter.doprint(expr.evalf()),sepcode

    def indentCode(self, code, numspaces):
        # actually a lot of time can be wasted in this phase...
        if True:
            return code
        else:
            lcode = list(code)
            locations = [i for i in range(len(lcode)-1) if lcode[i]=='\n']
            locations.reverse()
            insertcode = [' ' for i in range(numspaces)]
            for loc in locations:
                lcode[loc+1:0] = insertcode
            lcode[:0] = insertcode
            return ''.join(lcode)

    def using_polyroots(self, deg):
        name = 'polyroots%d'%deg
        if not name in self.functions:
            if deg == 1:            
                fcode = """static void %s(IKReal rawcoeffs[deg+1], IKReal rawroots[deg], int& numroots) {
    rawroots[0] = -rawcoeffs[1]/rawcoeffs[0];
    numroots=1;
}
"""%name
            elif deg == 2:
                fcode = """static void %s(IKReal rawcoeffs[2+1], IKReal rawroots[2], int& numroots) {
    IKReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = 0.5*(-rawcoeffs[1]+det)/rawcoeffs[0];
        rawroots[1] = 0.5*(-rawcoeffs[1]-det)/rawcoeffs[0];
        numroots = 2;
    }
}
"""%name
            elif False:#deg == 3: # amazing, cubic formula is not as accurate as iterative method...
                fcode = """static void %s(IKReal rawcoeffs[%d+1], IKReal rawroots[%d], int& numroots)
{
    using std::complex;
    assert(rawcoeffs[0] != 0);
    IKReal a0 = rawcoeffs[3]/rawcoeffs[0], a1 = rawcoeffs[2]/rawcoeffs[0], a2 = rawcoeffs[1]/rawcoeffs[0];
    IKReal a2_3 = a2/3.0;
    IKReal Q = (3*a1-a2*a2)/9, R = (9*a2*a1-27*a0-2*a2*a2*a2)/54;
    complex<IKReal> D(Q*Q*Q+R*R,0.0);
    complex<IKReal> Dsqrt = sqrt(D);
    complex<IKReal> S, T;
    if( imag(Dsqrt) != 0 ) {
        S = pow(complex<IKReal>(R,0)+Dsqrt,IKReal(1.0/3.0));
        T = pow(complex<IKReal>(R,0)-Dsqrt,IKReal(1.0/3.0));
    }
    else {
        IKReal temp = R+real(Dsqrt);
        S = pow(IKabs(temp),IKReal(1.0/3.0));
        if( temp < 0 ) {
            S = -S;
        }
        temp = R-real(Dsqrt);
        T = pow(IKabs(temp),IKReal(1.0/3.0));
        if( temp < 0 ) {
            T = -T;
        }
    }
    complex<IKReal> B = S+T, A = S-T;
    numroots = 0;
    if( IKabs(imag(B)) < std::numeric_limits<IKReal>::epsilon() ) {
        rawroots[numroots++] = -a2_3+real(B);
    }
    complex<IKReal> Arot = complex<IKReal>(0,SQRT_3)*A;
    if( IKabs(imag(B-Arot)) < std::numeric_limits<IKReal>::epsilon() ) {
        rawroots[numroots++] = -a2_3-0.5*real(B-Arot);
        rawroots[numroots++] = -a2_3-0.5*real(B+Arot);
    }
}
"""%name
            else:
                fcode = """/// Durand-Kerner polynomial root finding method
static void %s(IKReal rawcoeffs[%d+1], IKReal rawroots[%d], int& numroots)
{
    using std::complex;
    assert(rawcoeffs[0] != 0);
    const IKReal tol = 128.0*std::numeric_limits<IKReal>::epsilon();
    complex<IKReal> coeffs[%d];
    const int maxsteps = 50;
    for(int i = 0; i < %d; ++i) {
        coeffs[i] = complex<IKReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IKReal> roots[%d];
    IKReal err[%d];
    roots[0] = complex<IKReal>(1,0);
    roots[1] = complex<IKReal>(0.4,0.9); // any complex number not a root of unity is works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < %d; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < %d; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IKReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < %d; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < %d; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }
    numroots = 0;
    for(int i = 0; i < %d; ++i) {
        if( IKabs(imag(roots[i])) < std::numeric_limits<IKReal>::epsilon() ) {
            rawroots[numroots++] = real(roots[i]);
        }
    }
}
"""%(name,deg,deg,deg,deg,deg,deg,deg,deg,deg,deg,deg)
            self.functions[name] = fcode
        return name

    def using_conicsolver(self):
        """ the general method to solve an intersection of two conics C1 and C2 is to first
        note that any solution to their intersection is also a solution of
        x^T C x = 0, where C = t0*C0 + t1*C1
        for t0, t1 in Reals. Without loss of generality, we set t1 = 1, and find t0 when
        C becomes degenerate, ie det(C) = 0. This produces a cubic equation in t0,
        which gives 4 solutions. Gathering all the equations produced by the degenerate
        conic should give rise to two equations of lines. Intersect these lines with the simpler of the
        two conics, the unit circle: c^2+s^2-1 = 0
        """
        polyroots2=self.using_polyroots(2)
        polyroots3=self.using_polyroots(3)
        name = 'conicsolver'
        if not name in self.functions:
            fcode = """/// intersection of a conic and the unit circle
static void %s(IKReal C0[6], IKReal roots[4], int& numroots)
{
    IKReal rawcoeffs[4] = {-1,
                           C0[5] - C0[0] - C0[3],
                           C0[0]*C0[5] + C0[3]*C0[5] - C0[0]*C0[3] + C0[1]*C0[1] - C0[2]*C0[2] - C0[4]*C0[4],
                           C0[0]*C0[3]*C0[5] + 2*C0[1]*C0[2]*C0[4] - C0[0]*C0[4]*C0[4] - C0[3]*C0[2]*C0[2] - C0[5]*C0[1]*C0[1]};
    IKReal proots[3];
    int numproots, numyroots;
    %s(rawcoeffs,proots,numproots);
    numroots = 0;
    int iroot=0;
    IKReal a, b, c, d, e, f;
    a = C0[0]+proots[iroot]; b = C0[1]; c = C0[3]+proots[iroot]; d = C0[2]; e = C0[4]; f = C0[5]-proots[iroot];
    IKReal adjugate[9] = {c*f-e*e, -b*f+e*d, b*e-c*d, -b*f+d*e, a*f-d*d, -a*e+b*d, b*e-d*c, -a*e+d*b, a*c-b*b};
    // find the greatest absolute value of adjugate and take that column
    int maxindex = 0;
    IKReal val = IKabs(adjugate[maxindex]);
    for(int i = 1; i < 9; ++i) {
        IKReal newval = IKabs(adjugate[i]);
        if( val < newval ) {
            val = newval;
            maxindex = i;
        }
    }
    maxindex = maxindex%%3;
    if( adjugate[0] > 0 || adjugate[4] > 0 || adjugate[8] > 0 || adjugate[4*maxindex] >= 0 ) {
        // according to the structure of the matrix, should be always negative if a solution exists...
        return;
    }
    IKReal bmult = 1.0/IKsqrt(-adjugate[4*maxindex]);
    IKReal p[3] = {adjugate[maxindex]*bmult, adjugate[3+maxindex]*bmult, adjugate[6+maxindex]*bmult}; // intersection point
    // C = C0 - [p_x] = 2gh^t, C is rank1
    IKReal C[9] = {a,b+p[2],d-p[1],b-p[2],c,e+p[0],d+p[1],e-p[0],f};
    maxindex = 0;
    val = IKabs(C[maxindex]);
    for(int i = 1; i < 9; ++i) {
        IKReal newval = IKabs(C[i]);
        if( val < newval ) {
            val = newval;
            maxindex = i;
        }
    }
    int row = maxindex/3;
    int col = maxindex%%3;
    IKReal lineequation[3], coeffs[3], yintersections[2];
    for(int i = 0; i < 2; ++i) {
        if( i == 0 ) {
            lineequation[0] = C[3*row];
            lineequation[1] = C[3*row+1];
            lineequation[2] = C[3*row+2];
        }
        else {
            lineequation[0] = C[col];
            lineequation[1] = C[3+col];
            lineequation[2] = C[6+col];
        }

        if( IKabs(lineequation[0]) < std::numeric_limits<IKReal>::epsilon() ) {
            yintersections[0] = -lineequation[2]/lineequation[1];
            IKReal x = 1-yintersections[0]*yintersections[0];
            if( x <= 0 && x > -std::numeric_limits<IKReal>::epsilon() ) {
                roots[numroots++] = yintersections[0] > 0 ? IKPI_2 : -IKPI_2;
            }
            else {
                x = IKsqrt(x);
                roots[numroots++] = IKatan2(yintersections[0], x);
                roots[numroots] = IKPI - roots[numroots-1]; numroots++;
            }
        }
        else {
            coeffs[0] = lineequation[0]*lineequation[0]+lineequation[1]*lineequation[1];
            coeffs[1] = 2*lineequation[1]*lineequation[2];
            coeffs[2] = lineequation[2]*lineequation[2]-lineequation[0]*lineequation[0];
            %s(coeffs,yintersections,numyroots);
            for(int j = 0; j < numyroots; ++j) {
                roots[numroots++] = IKatan2(yintersections[j],-(lineequation[1]*yintersections[j]+lineequation[2])/lineequation[0]);
            }
        }
    }
}
"""%(name,polyroots3,polyroots2)
            self.functions[name] = fcode
        return name
