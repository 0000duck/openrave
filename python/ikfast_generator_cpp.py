#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Software License Agreement (Lesser GPL)
#
# Copyright (C) 2009-2010 Rosen Diankov
#
# ikfast is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# at your option) any later version.
#
# ikfast is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
from __future__ import with_statement # for python 2.5

import sys, copy, time, datetime
try:
    from openravepy.metaclass import AutoReloader
except:
    class AutoReloader:
        pass

# import the correct iktypes from openravepy (if present)
try:
    from openravepy import IkParameterization
    IkType = IkParameterization.Type
except:
    class IkType:
        Transform6D=1
        Rotation3D=2
        Translation3D=3
        Direction3D=4
        Ray4D=5

from sympy import *

try:
    from itertools import izip, combinations
except ImportError:
    def combinations(items,n):
        if n == 0: yield[]
        else:
            for  i in xrange(len(items)):
                for cc in combinations(items[i+1:],n-1):
                    yield [items[i]]+cc

def customcse(exprs,symbols=None):
    replacements,reduced_exprs = cse(exprs,symbols=symbols)
    newreplacements = []
    # look for opany expressions of the order of (x**(1/a))**b, usually computer wants x^(b/a)
    for r in replacements:
        if r[1].is_Pow and r[1].exp.is_real and r[1].base.is_Symbol:
            baseexpr = r[1].base.subs(replacements)
            if baseexpr.is_Pow and baseexpr.exp.is_real:
                newreplacements.append((r[0],baseexpr.base**(r[1].exp*baseexpr.exp)))
                continue
        newreplacements.append(r)
    return newreplacements,reduced_exprs

class CodeGenerator(AutoReloader):
    """Generates C++ code from an AST generated by IKFastSolver

    Generated C++ code structure::

      typedef double IKReal;
      class IKSolution
      {
      public:
          void GetSolution(IKReal* psolution, const IKReal* pfree) const;
      };

      bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<SOLUTION>& vsolutions);
      bool fk(const IKReal* joints, IKReal* eetrans, IKReal* eerot);
    """
    dictequations = [] # dictionary of symbols already written
    symbolgen = cse_main.numbered_symbols('x')
    strprinter = printing.StrPrinter()
    freevars = None # list of free variables in the solution
    freevardependencies = None # list of variables depending on the free variables

    def generate(self, solvertree):
        print 'generating c++ code...'
        code = """/// autogenerated analytical inverse kinematics code from ikfast program
/// \\author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// generated %s
/// To compile with gcc use: gcc -lstdc++ 
/// To compile without any main function use: gcc -lstdc++ -DIKFAST_NO_MAIN
#include <math.h>
#include <assert.h>
#include <vector>
#include <float.h>

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \\param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                assert(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \\return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKasin(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

inline float IKacos(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

"""%str(datetime.datetime.now())
        code += solvertree.generate(self)
        code += solvertree.end(self)

        code += """
#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\\n\\n"
               "Returns the ik solutions given the transformation of the end effector specified by\\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\\n"
               "There are %d free parameters that have to be specified.\\n\\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\\n");
        return -1;
    }

    printf("Found %d ik solutions:\\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\\n");
    }
    return 0;
}

#endif
"""
        return code

    def generateChain(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Transform6D
        # generate the fk
        if node.Tfk:
            code += "/// solves the forward kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            subexprs,reduced_exprs=customcse (node.Tfk[0:3,0:4].subs([(v[0],Symbol('j[%d]'%v[1])) for v in allvars]))
            outputnames = ['eerot[0]','eerot[1]','eerot[2]','eetrans[0]','eerot[3]','eerot[4]','eerot[5]','eetrans[1]','eerot[6]','eerot[7]','eerot[8]','eetrans[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = [var for var,expr in subexprs]
                fcode = 'IKReal ' + ','.join(str(var) for var,expr in subexprs) + ';\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'
        code += "/// solves the inverse kinematics equations.\n"
        code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
        code += "IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        fcode += 'IKReal '
        
        for var in node.solvejointvars:
            fcode += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d], c%s=cos(pfree[%d]), s%s=sin(pfree[%d]),\n'%(name,i,name,i,name,i)

        for i in range(3):
            for j in range(3):
                fcode += "new_r%d%d, r%d%d = eerot[%d*3+%d],\n"%(i,j,i,j,i,j)
        fcode += "new_px, new_py, new_pz, px = eetrans[0], py = eetrans[1], pz = eetrans[2];\n\n"
        
        rotsubs = [(Symbol("r%d%d"%(i,j)),Symbol("new_r%d%d"%(i,j))) for i in range(3) for j in range(3)]
        rotsubs += [(Symbol("px"),Symbol("new_px")),(Symbol("py"),Symbol("new_py")),(Symbol("pz"),Symbol("new_pz"))]

        psymbols = ["new_px","new_py","new_pz"]
        for i in range(3):
            for j in range(3):
                fcode += self.writeEquations(lambda k: "new_r%d%d"%(i,j),node.Tee[4*i+j])
            fcode += self.writeEquations(lambda k: psymbols[i],node.Tee[4*i+3])
        for i in range(3):
            for j in range(3):
                fcode += "r%d%d = new_r%d%d; "%(i,j,i,j)
        fcode += "px = new_px; py = new_py; pz = new_pz;\n"

        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"
        return code
    def endChain(self, node):
        return ""

    def generateIKChainRotation3D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Rotation3D
        if node.Rfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            subexprs,reduced_exprs=customcse (node.Rfk[0:3,0:3].subs([(v[0],Symbol('j[%d]'%v[1])) for v in allvars]))
            outputnames = ['eerot[0]','eerot[1]','eerot[2]','eerot[3]','eerot[4]','eerot[5]','eerot[6]','eerot[7]','eerot[8]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'
        code += "/// solves the inverse kinematics equations.\n"
        code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
        code += "IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        fcode += 'IKReal '
        
        for var in node.solvejointvars:
            fcode += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d], c%s=cos(pfree[%d]), s%s=sin(pfree[%d]),\n'%(name,i,name,i,name,i)
        for i in range(3):
            for j in range(3):
                fcode += "new_r%d%d, r%d%d = eerot[%d*3+%d]"%(i,j,i,j,i,j)
                if i == 2 and j == 2:
                    fcode += ';\n\n'
                else:
                    fcode += ',\n'
        
        rotsubs = [(Symbol("r%d%d"%(i,j)),Symbol("new_r%d%d"%(i,j))) for i in range(3) for j in range(3)]
        for i in range(3):
            for j in range(3):
                fcode += self.writeEquations(lambda k: "new_r%d%d"%(i,j),node.Ree[i,j])
        for i in range(3):
            for j in range(3):
                fcode += "r%d%d = new_r%d%d; "%(i,j,i,j)
        fcode += '\n'
        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"
        return code
    def endIKChainRotation3D(self, node):
        return ""

    def generateIKChainTranslation3D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Translation3D
        if node.Pfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            allsubs = [(v[0],Symbol('j[%d]'%v[1])) for v in allvars]
            eqs = []
            for eq in node.Pfk[0:3]:
                eqs.append(eq.subs(allsubs))
            subexprs,reduced_exprs=customcse (eqs)
            outputnames = ['eetrans[0]','eetrans[1]','eetrans[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'
        code += "/// solves the inverse kinematics equations.\n"
        code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
        code += "IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        fcode += 'IKReal '
        
        for var in node.solvejointvars:
            fcode += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d], c%s=cos(pfree[%d]), s%s=sin(pfree[%d]),\n'%(name,i,name,i,name,i)
        fcode += "new_px, new_py, new_pz, px = eetrans[0], py = eetrans[1], pz = eetrans[2];\n\n"
        rotsubs = [(Symbol("px"),Symbol("new_px")),(Symbol("py"),Symbol("new_py")),(Symbol("pz"),Symbol("new_pz"))]
        psymbols = ["new_px","new_py","new_pz"]
        for i in range(3):
            fcode += self.writeEquations(lambda k: psymbols[i],node.Pee[i])
        fcode += "px = new_px; py = new_py; pz = new_pz;\n"
        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"
        return code
    def endIKChainTranslation3D(self, node):
        return ""

    def generateIKChainDirection3D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Direction3D
        if node.Dfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            allsubs = [(v[0],Symbol('j[%d]'%v[1])) for v in allvars]
            eqs = []
            for eq in node.Dfk:
                eqs.append(eq.subs(allsubs))
            subexprs,reduced_exprs=customcse (eqs)
            outputnames = ['eerot[0]','eerot[1]','eerot[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'
        code += "/// solves the inverse kinematics equations.\n"
        code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
        code += "IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        fcode += 'IKReal '
        
        for var in node.solvejointvars:
            fcode += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d], c%s=cos(pfree[%d]), s%s=sin(pfree[%d]),\n'%(name,i,name,i,name,i)

        for i in range(3):
            fcode += "new_r0%d, r0%d = eerot[%d]"%(i,i,i)
            if i == 2:
                fcode += ';\n\n'
            else:
                fcode += ',\n'
        rotsubs = [(Symbol("r%d%d"%(0,i)),Symbol("new_r%d%d"%(0,i))) for i in range(3)]

        for i in range(3):
            fcode += self.writeEquations(lambda k: "new_r%d%d"%(0,i),node.Dee[i])
        for i in range(3):
            fcode += "r0%d = new_r0%d; "%(i,i)

        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"
        return code
    def endIKChainDirection3D(self, node):
        return ''

    def generateIKChainRay4D(self, node):
        self.freevars = []
        self.freevardependencies = []
        self.dictequations = []
        self.symbolgen = cse_main.numbered_symbols('x')
        
        code = "IKFAST_API int getNumFreeParameters() { return %d; }\n"%len(node.freejointvars)
        if len(node.freejointvars) == 0:
            code += "IKFAST_API int* getFreeParameters() { return NULL; }\n"
        else:
            code += "IKFAST_API int* getFreeParameters() { static int freeparams[] = {"
            for i,freejointvar in enumerate(node.freejointvars):
                code += "%d"%(freejointvar[1])
                if i < len(node.freejointvars)-1:
                    code += ", "
            code += "}; return freeparams; }\n"
        code += "IKFAST_API int getNumJoints() { return %d; }\n\n"%(len(node.freejointvars)+len(node.solvejointvars))
        code += "IKFAST_API int getIKRealSize() { return sizeof(IKReal); }\n\n"
        code += 'IKFAST_API int getIKType() { return %d; }\n\n'%IkType.Ray4D
        if node.Dfk and node.Pfk:
            code += "/// solves the inverse kinematics equations.\n"
            code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
            code += "IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {\n"
            allvars = node.solvejointvars + node.freejointvars
            allsubs = [(v[0],Symbol('j[%d]'%v[1])) for v in allvars]
            eqs = []
            for eq in node.Pfk[0:3]:
                eqs.append(eq.subs(allsubs))
            for eq in node.Dfk[0:3]:
                eqs.append(eq.subs(allsubs))
            subexprs,reduced_exprs=customcse (eqs)
            outputnames = ['eetrans[0]','eetrans[1]','eetrans[2]','eerot[0]','eerot[1]','eerot[2]']
            fcode = ''
            if len(subexprs) > 0:
                fcode = 'IKReal '
                vars = []
                for var,expr in subexprs:
                    fcode += str(var) + ', '
                    vars.append(var)
                fcode += '__dummy__;\n'
                for var,expr in subexprs:
                    fcode += self.writeEquations(lambda k: str(var),collect(expr,vars))
            for i in range(len(outputnames)):
                fcode += self.writeEquations(lambda k: outputnames[i],reduced_exprs[i])
            code += self.indentCode(fcode,4)
            code += '}\n\n'
        code += "/// solves the inverse kinematics equations.\n"
        code += "/// \\param pfree is an array specifying the free joints of the chain.\n"
        code += "IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {\n"
        code += "for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {\n"
        fcode = "vsolutions.resize(0); vsolutions.reserve(8);\n"
        fcode += 'IKReal '
        
        for var in node.solvejointvars:
            fcode += '%s, c%s, s%s,\n'%(var[0].name,var[0].name,var[0].name)
        for i in range(len(node.freejointvars)):
            name = node.freejointvars[i][0].name
            fcode += '%s=pfree[%d], c%s=cos(pfree[%d]), s%s=sin(pfree[%d]),\n'%(name,i,name,i,name,i)
        for i in range(3):
            fcode += "new_r0%d, r0%d = eerot[%d],\n"%(i,i,i)
        fcode += "new_px, new_py, new_pz, px = eetrans[0], py = eetrans[1], pz = eetrans[2];\n"

        rotsubs = [(Symbol("r%d%d"%(0,i)),Symbol("new_r%d%d"%(0,i))) for i in range(3)]
        rotsubs += [(Symbol("px"),Symbol("new_px")),(Symbol("py"),Symbol("new_py")),(Symbol("pz"),Symbol("new_pz"))]

        psymbols = ["new_px","new_py","new_pz"]
        for i in range(3):
            fcode += self.writeEquations(lambda k: "new_r%d%d"%(0,i),node.Dee[i])
            fcode += self.writeEquations(lambda k: psymbols[i],node.Pee[i])
        for i in range(3):
            fcode += "r0%d = new_r0%d; "%(i,i)
        fcode += "\nIKReal new_pdotd = new_px*new_r00+new_py*new_r01+new_pz*new_r02;\n"
        fcode += "px = new_px-new_pdotd * new_r00; py = new_py- new_pdotd * new_r01; pz = new_pz - new_pdotd * new_r02;\n\n"

        fcode += self.generateTree(node.jointtree)
        code += self.indentCode(fcode,4) + "}\nreturn vsolutions.size()>0;\n}\n"
        return code
    def endIKChainRay4D(self, node):
        return ''

    def generateSolution(self, node,declarearray=True,acceptfreevars=True):
        code = ''
        numsolutions = 0
        eqcode = ''
        name = node.jointname
        node.HasFreeVar = False
        allnumsolutions = 0
        if node.jointeval is not None:
            numsolutions = len(node.jointeval)
            equations = []
            names = []
            for i,expr in enumerate(node.jointeval):
                if acceptfreevars:
                    m = None
                    for freevar in self.freevars:
                        if expr.has_any_symbols(Symbol(freevar)):
                            # has free variables, so have to look for a*freevar+b form
                            a = Wild('a',exclude=[Symbol(freevar)])
                            b = Wild('b',exclude=[Symbol(freevar)])
                            m = expr.match(a*Symbol(freevar)+b)
                            if m is not None:
                                self.freevardependencies.append((freevar,name))
                                assert(len(node.jointeval)==1)
                                code += 'IKReal ' + self.writeEquations(lambda i: '%smul'%name, m[a])
                                code += self.writeEquations(lambda i: name, m[b])
                                node.HasFreeVar = True
                                return code
                            else:
                                print 'failed to extract free variable %s for %s from'%(freevar,node.jointname), expr
    #                             m = dict()
    #                             m[a] = Real(-1,30)
    #                             m[b] = Real(0,30)

                equations.append(expr)
                names.append('%sarray[%d]'%(name,allnumsolutions+i))
                equations.append(sin(Symbol('%sarray[%d]'%(name,allnumsolutions+i))))
                names.append('s%sarray[%d]'%(name,allnumsolutions+i))
                equations.append(cos(Symbol('%sarray[%d]'%(name,allnumsolutions+i))))
                names.append('c%sarray[%d]'%(name,allnumsolutions+i))
            eqcode += self.writeEquations(lambda i: names[i], equations)
            if node.AddPiIfNegativeEq:
                for i in range(numsolutions):
                    eqcode += '%sarray[%d] = %sarray[%d] > 0 ? %sarray[%d]-IKPI : %sarray[%d]+IKPI;\n'%(name,allnumsolutions+numsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i)
                    eqcode += 's%sarray[%d] = -s%sarray[%d];\n'%(name,allnumsolutions+numsolutions+i,name,allnumsolutions+i)
                    eqcode += 'c%sarray[%d] = -c%sarray[%d];\n'%(name,allnumsolutions+numsolutions+i,name,allnumsolutions+i)
                numsolutions *= 2
            for i in range(numsolutions):
                if node.IsHinge:
                    eqcode += 'if( %sarray[%d] > IKPI )\n    %sarray[%d]-=IK2PI;\nelse if( %sarray[%d] < -IKPI )\n    %sarray[%d]+=IK2PI;\n'%(name,allnumsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i,name,allnumsolutions+i)
                eqcode += '%svalid[%d] = true;\n'%(name,allnumsolutions+i)
            allnumsolutions += numsolutions
        # might also have cos solutions ...
        if node.jointevalcos is not None:
            numsolutions = 2*len(node.jointevalcos)
            eqcode += self.writeEquations(lambda i: 'c%sarray[%d]'%(name,allnumsolutions+2*i),node.jointevalcos)
            for i in range(len(node.jointevalcos)):
                eqcode += 'if( c%sarray[%d] >= -1.0001 && c%sarray[%d] <= 1.0001 )\n{\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    %svalid[%d] = %svalid[%d] = true;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i+1)
                eqcode += '    %sarray[%d] = IKacos(c%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    s%sarray[%d] = IKsin(%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                # second solution
                eqcode += '    c%sarray[%d] = c%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '    %sarray[%d] = -%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '    s%sarray[%d] = -s%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '}\n'
                eqcode += 'else if( isnan(c%sarray[%d]) )\n{\n'%(name,allnumsolutions+2*i)
                eqcode += '    // probably any value will work\n'
                eqcode += '    %svalid[%d] = true;\n'%(name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = 1; s%sarray[%d] = 0; %sarray[%d] = 0;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '}\n'
            allnumsolutions += numsolutions

        if node.jointevalsin is not None:
            numsolutions = 2*len(node.jointevalsin)
            eqcode += self.writeEquations(lambda i: 's%sarray[%d]'%(name,allnumsolutions+2*i),node.jointevalsin)
            for i in range(len(node.jointevalsin)):
                eqcode += 'if( s%sarray[%d] >= -1.0001 && s%sarray[%d] <= 1.0001 )\n{\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    %svalid[%d] = %svalid[%d] = true;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i+1)
                eqcode += '    %sarray[%d] = IKasin(s%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = IKcos(%sarray[%d]);\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                # second solution
                eqcode += '    s%sarray[%d] = s%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '    %sarray[%d] = %sarray[%d] > 0 ? (IKPI-%sarray[%d]) : (-IKPI-%sarray[%d]);\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i,name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = -c%sarray[%d];\n'%(name,allnumsolutions+2*i+1,name,allnumsolutions+2*i)
                eqcode += '}\n'
                eqcode += 'else if( isnan(s%sarray[%d]) )\n{\n'%(name,allnumsolutions+2*i)
                eqcode += '    // probably any value will work\n'
                eqcode += '    %svalid[%d] = true;\n'%(name,allnumsolutions+2*i)
                eqcode += '    c%sarray[%d] = 1; s%sarray[%d] = 0; %sarray[%d] = 0;\n'%(name,allnumsolutions+2*i,name,allnumsolutions+2*i,name,allnumsolutions+2*i)
                eqcode += '}\n'
            allnumsolutions += numsolutions

        if not declarearray:
            return eqcode,allnumsolutions

        code += '{\nIKReal %sarray[%d], c%sarray[%d], s%sarray[%d];\n'%(name,allnumsolutions,name,allnumsolutions,name,allnumsolutions)
        code += 'bool %svalid[%d]={false};\n'%(name,allnumsolutions)
        code += eqcode
        if allnumsolutions > 1:
            for i,j in combinations(range(allnumsolutions),2):
                code += 'if( %svalid[%d] && %svalid[%d] && IKabs(c%sarray[%d]-c%sarray[%d]) < 0.0001 && IKabs(s%sarray[%d]-s%sarray[%d]) < 0.0001 )\n    %svalid[%d]=false;\n'%(name,i,name,j,name,i,name,j,name,i,name,j,name,j)
        code += 'for(int i%s = 0; i%s < %d; ++i%s)\n{\n'%(name,name,allnumsolutions,name)
        code += 'if( !%svalid[i%s] ) { continue; }\n'%(name,name)
        code += '%s = %sarray[i%s]; c%s = c%sarray[i%s]; s%s = s%sarray[i%s];\n\n'%(name,name,name,name,name,name,name,name,name)
        return code

    def endSolution(self, node):
        if node.HasFreeVar:
            self.freevardependencies.pop()
            return ''
        return '}\n}\n'

    def generateConditionedSolution(self, node):
        name=node.solversolutions[0].jointname
        assert all([name == s.jointname for s in node.solversolutions])
        origequations = copy.copy(self.dictequations)
        maxchecks = max([len(s.checkforzeros) for s in node.solversolutions])
        allnumsolutions = 0
        checkcode = ''
        for solversolution in node.solversolutions:
            assert len(solversolution.checkforzeros) > 0
            self.dictequations = copy.copy(origequations)
            checkcode += '{\n'
            checkcode += self.writeEquations(lambda i: 'evalcond[%d]'%(i),solversolution.checkforzeros)
            checkcode += 'if( '
            for i in range(len(solversolution.checkforzeros)):
                if i != 0:
                    checkcode += ' && '
                checkcode += 'IKabs(evalcond[%d]) %s %f '%(i,'<=' if solversolution.FeasibleIsZeros else '>',node.thresh)
            checkcode += ' )\n{\n'
            scode,numsolutions = self.generateSolution(solversolution,declarearray=False,acceptfreevars=False)
            scode += 'numsolutions%s = %d;\n'%(name,numsolutions)
            allnumsolutions = max(allnumsolutions,numsolutions)
            checkcode += self.indentCode(scode,4)
            checkcode += '\n} else\n'
        checkcode += '{\n    continue;\n}\n'  # if got here, then current solution branch is not good, so skip
        checkcode += '}\n'*len(node.solversolutions)
        checkcode += 'if( numsolutions%s == 0 ) { continue; }\n'%name

        code = '{\nIKReal evalcond[%d]; int numsolutions%s = 0;\n'%(maxchecks,name)
        code += 'IKReal %sarray[%d], c%sarray[%d], s%sarray[%d];\n'%(name,allnumsolutions,name,allnumsolutions,name,allnumsolutions)
        code += 'bool %svalid[%d]={false};\n'%(name,allnumsolutions)
        code += self.indentCode(checkcode,4)
        if allnumsolutions > 1:
            for i,j in combinations(range(allnumsolutions),2):
                code += 'if( %svalid[%d] && %svalid[%d] && IKabs(c%sarray[%d]-c%sarray[%d]) < 0.0001 && IKabs(s%sarray[%d]-s%sarray[%d]) < 0.0001 )\n    %svalid[%d]=false;\n'%(name,i,name,j,name,i,name,j,name,i,name,j,name,j)
        code += 'for(int i%s = 0; i%s < numsolutions%s; ++i%s)\n{\n'%(name,name,name,name)
        code += 'if( !%svalid[i%s] ) { continue; }\n'%(name,name)
        code += '%s = %sarray[i%s]; c%s = c%sarray[i%s]; s%s = s%sarray[i%s];\n\n'%(name,name,name,name,name,name,name,name,name)
        self.dictequations = origequations
        return code

    def endConditionedSolution(self, node):
        return '}\n}\n'

    def generateBranch(self, node):
        origequations = copy.copy(self.dictequations)
        name = node.jointname
        code = '{\nIKReal %seval;\n'%name
        code += self.writeEquations(lambda x: '%seval'%name,[node.jointeval])
        for branch in node.jointbranches:
            branchcode = ''
            self.dictequations = copy.copy(origequations)
            for n in branch[1]:
                branchcode += n.generate(self)
            for n in reversed(branch[1]):
                branchcode += n.end(self)
            branchcode = self.indentCode(branchcode,4)
            if branch[0] is None:
                code += '{\n' + branchcode + '\n}\n'
            else:
                code += 'if( %seval >= %f && %seval <= %f )\n{\n'%(name,branch[0]-0.00001,name,branch[0]+0.00001)
                code += branchcode + '\n} else\n'
        code += '}\n'
        self.dictequations = origequations
        return code
    def endBranch(self, node):
        return ''
    def generateBranchConds(self, node):
        origequations = copy.copy(self.dictequations)
        code = '{\n'
        if any([branch[0] for branch in node.jointbranches]):
            code += 'IKReal evalcond;\n'
        for branch in node.jointbranches:
            self.dictequations = copy.copy(origequations)
            if branch[0] is None:
                branchcode = 'if( 1 )\n{\n'
            else:
                branchcode = self.writeEquations(lambda x: 'evalcond',branch[0])
                branchcode += 'if( IKabs(evalcond) < 0.00001 )\n{\n'
            for n in branch[1]:
                branchcode += n.generate(self)
            for n in reversed(branch[1]):
                branchcode += n.end(self)
            code += self.indentCode(branchcode,4)+'\n} else\n{\n'
        code += '}\n'*(len(node.jointbranches)+1)
        self.dictequations = origequations
        return code
    def endBranchConds(self, node):
        return ''
    def generateCheckZeros(self, node):
        origequations = copy.copy(self.dictequations)
        name = node.jointname
        code = 'IKReal %seval[%d];\n'%(name,len(node.jointcheckeqs))
        code += self.writeEquations(lambda i: '%seval[%d]'%(name,i),node.jointcheckeqs)
        if len(node.jointcheckeqs) > 0:
            code += 'if( '
            for i in range(len(node.jointcheckeqs)):
                if i != 0:
                    if node.anycondition:
                        code += ' || '
                    else:
                        code += ' && '
                code += 'IKabs(%seval[%d]) < %f '%(name,i,node.thresh)
            code += ' )\n{\n'
            self.dictequations = copy.copy(origequations)
            code += self.indentCode(self.generateTree(node.zerobranch),4)
            code += '\n} else\n'
        code += '{\n'
        self.dictequations = copy.copy(origequations)
        code += self.indentCode(self.generateTree(node.nonzerobranch),4)
        code += '\n}\n'
        self.dictequations = origequations
        return '{\n' + self.indentCode(code,4) + '\n}\n'
    def endCheckZeros(self, node):
        return ''
    def generateFreeParameter(self, node):
        #print 'free variable ',node.jointname,': ',self.freevars
        self.freevars.append(node.jointname)
        self.freevardependencies.append((node.jointname,node.jointname))
        code = 'IKReal %smul = 1;\n%s=0;\n'%(node.jointname,node.jointname)
        return code+self.generateTree(node.jointtree)
    def endFreeParameter(self, node):
        self.freevars.pop()
        self.freevardependencies.pop()
        return ''
    def generateSetJoint(self, node):
        code = '{\n%s = %f; s%s = %f; c%s = %f;\n'%(node.jointname,node.jointvalue,node.jointname,sin(node.jointvalue),node.jointname,cos(node.jointvalue))
        return code
    def endSetJoint(self, node):
        return '}\n'
    def generateBreak(self,node):
        return 'continue;\n'
    def endBreak(self,node):
        return ''
    def generateRotation(self, node):
        code = ''
        listequations = []
        names = []
        for i in range(3):
            for j in range(3):
                listequations.append(node.T[i,j])
                names.append(Symbol('new_r%d%d'%(i,j)))
        code += self.writeEquations(lambda i: names[i],listequations)
        code += self.generateTree(node.jointtree)
        return code
    def endRotation(self, node):
        return ''
    def generateDirection(self, node):
        code = ''
        listequations = []
        names = []
        for i in range(3):
            listequations.append(node.D[i])
            names.append(Symbol('new_r%d%d'%(0,i)))
        code += self.writeEquations(lambda i: names[i],listequations)
        code += self.generateTree(node.jointtree)
        return code
    def endDirection(self, node):
        return ''
    def generateStoreSolution(self, node):
        code = 'vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();\n'
        code += 'solution.basesol.resize(%d);\n'%len(node.alljointvars)
        for i,var in enumerate(node.alljointvars):
            code += 'solution.basesol[%d].foffset = %s;\n'%(i,var)
            
            vardeps = [vardep for vardep in self.freevardependencies if vardep[1]==var.name]
            if len(vardeps) > 0:
                freevarname = vardeps[0][0]
                ifreevar = [j for j in range(len(self.freevars)) if freevarname==self.freevars[j]]
                code += 'solution.basesol[%d].fmul = %smul;\n'%(i,var.name)
                code += 'solution.basesol[%d].freeind = %d;\n'%(i,ifreevar[0])
        code += 'solution.vfree.resize(%d);\n'%len(self.freevars)
        for i,varname in enumerate(self.freevars):
            ind = [j for j in range(len(node.alljointvars)) if varname==node.alljointvars[j].name]
            code += 'solution.vfree[%d] = %d;\n'%(i,ind[0])
        return code
    def endStoreSolution(self, node):
        return ''
    def generateSequence(self, node):
        code = ''
        for tree in node.jointtrees:
            code += self.generateTree(tree)
        return code
    def endSequence(self, node):
        return ''
    def generateTree(self,tree):
        code = ''
        for n in tree:
            code += n.generate(self)
        for n in reversed(tree):
            code += n.end(self)
        return code
    def writeEquations(self, varnamefn, exprs):
        code = ''
        [replacements,reduced_exprs] = customcse(exprs,symbols=self.symbolgen)
        for rep in replacements:                
            eqns = filter(lambda x: rep[1]-x[1]==0, self.dictequations)
            if len(eqns) > 0:
                self.dictequations.append((rep[0],eqns[0][0]))
                code += 'IKReal %s=%s;\n'%(rep[0],eqns[0][0])
            else:
                self.dictequations.append(rep)
                code2,sepcode2 = self.writeExprCode(rep[1])
                code += sepcode2+'IKReal %s=%s;\n'%(rep[0],code2)

        for i,rexpr in enumerate(reduced_exprs):
            code2,sepcode2 = self.writeExprCode(rexpr)
            code += sepcode2+'%s=%s;\n'%(varnamefn(i), code2)
        return code

    def writeExprCode(self, expr):
        # go through all arguments and chop them
        code = ''
        sepcode = ''
        if expr.is_Function:
            if expr.func == abs:
                code += 'IKabs('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
            elif expr.func == acos:
                code += 'IKacos('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
                sepcode += 'if( (%s) < -1.0001 || (%s) > 1.0001 )\n    continue;\n'%(code2,code2)
            elif expr.func == asin:
                code += 'IKasin('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
                sepcode += 'if( (%s) < -1.0001 || (%s) > 1.0001 )\n    continue;\n'%(code2,code2)
            elif expr.func == atan2:
                code += 'IKatan2('
                # check for divides by 0 in arguments, this could give two possible solutions?!?
                # if common arguments is nan! solution is lost!
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2+', '
                code3,sepcode2 = self.writeExprCode(expr.args[1])
                code += code3
                sepcode += sepcode2
            elif expr.func == sin:
#                 if expr.args[0].is_Symbol and expr.args[0].name[0] == 'j':
#                     # probably already have initialized
#                     code += '(s%s'%expr.args[0].name
#                 else:
                code += 'IKsin('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
            elif expr.func == cos:
#                 if expr.args[0].is_Symbol and expr.args[0].name[0] == 'j':
#                     # probably already have initialized
#                     code += '(c%s'%expr.args[0].name
#                 else:
                code += 'IKcos('
                code2,sepcode = self.writeExprCode(expr.args[0])
                code += code2
            else:
                code += expr.func.__name__ + '('
                for arg in expr.args:
                    code2,sepcode2 = self.writeExprCode(arg)
                    code += code2
                    sepcode += sepcode2
                    if not arg == expr.args[-1]:
                        code += ','
            return code + ')',sepcode
        elif expr.is_Mul:
            code += '('
            for arg in expr.args:
                code2,sepcode2 = self.writeExprCode(arg)
                code += '('+code2+')'
                sepcode += sepcode2
                if not arg == expr.args[-1]:
                    code += '*'
            return code + ')',sepcode
        elif expr.is_Pow:
            exprbase,sepcode = self.writeExprCode(expr.base)
            if expr.exp.is_real:
                if expr.exp.is_integer and expr.exp.evalf() > 0:
                    code += '('+exprbase+')'
                    for i in range(1,expr.exp.evalf()):
                        code += '*('+exprbase+')'
                    return code,sepcode
                elif expr.exp-0.5 == 0:
                    sepcode += 'if( (%s) < (IKReal)-0.00001 )\n    continue;\n'%exprbase
                    return 'IKsqrt('+exprbase+')',sepcode
                elif expr.exp < 0:
                    # check if exprbase is 0
                    if expr.exp+1 == 0:
                        return '((IKabs('+exprbase+') != 0)?((IKReal)1/('+exprbase+')):(IKReal)1.0e30)',sepcode
                    return '((IKabs('+exprbase+') != 0)?(pow(' + exprbase + ',' + str(expr.exp.evalf()) + ')):(IKReal)1.0e30)',sepcode
                    
            exprexp,sepcode2 = self.writeExprCode(expr.exp)
            sepcode += sepcode2
            return 'pow(' + exprbase + ',' + exprexp + ')',sepcode
        elif expr.is_Add:
            code += '('
            for arg in expr.args:
                code2,sepcode2 = self.writeExprCode(arg)
                code += '('+code2+')'
                sepcode += sepcode2
                if not arg == expr.args[-1]:
                    code += '+'
            return code + ')',sepcode

        return self.strprinter.doprint(expr.evalf()),sepcode

    def indentCode(self, code, numspaces):
        lcode = list(code)
        locations = [i for i in range(len(lcode)) if lcode[i]=='\n']
        locations.reverse()
        insertcode = [' ' for i in range(numspaces)]
        for loc in locations:
            lcode[loc+1:0] = insertcode
        lcode[:0] = insertcode
        return ''.join(lcode)
