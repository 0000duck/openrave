// -*- coding: utf-8 -*-
/**
\mainpage Open Robotics Automation Virtual Environment

\section main_intro Introduction

%OpenRAVE provides an environment for testing, developing, and deploying motion planning and
higher-level intelligence algorithms in real-world robotics applications. The \homepage{official
home page} provdes for examples, usage cases, and installation instructions.

%OpenRAVE includes a seamless integration of simulation, visualization, planning, scripting and
control. The plugin architecture allows users to easily write custom controllers or extend
functionality. With %OpenRAVE plugins, any planning algorithm, robot controller, or sensing
subsystem can be distributed and dynamically loaded at run-time, which frees developers from
struggling with monolithic code-bases. Users of %OpenRAVE can concentrate on the development of
planning and scripting aspects of a problem without having to explicitly manage the details of robot
kinematics and dynamics, collision detection, world updates, and robot control. It should be noted
that %OpenRAVE's sole focus on simulation and analysis of geometric and dynamic information allows
is to be easily integrated into existing robotics systems that concentrate on low-level control,
message protocols, and perception systems.

\section main_started Getting Started
- \subpage installation
- \subpage p_basic_usage
- \subpage conventions
- \subpage environment_variables

\section main_system Components

- \subpage database_generation
- <a href="http://openrave.programmingvision.com/index.php/Started:Formats">XML File Format</a>
- Scripting
 - \openravepy{Python Scripting with <b>openravepy </b>}
 - \octave{Octave/MATLAB Scripting}

\section main_architecture Architecture
- \subpage architecture_concepts
- \subpage writing_plugins
- \subpage plotting3d

\section main_reference Reference
- \subpage interfaces
- \subpage geometric_primitives
- \subpage affine_math

\~english
Documentation in Other Languages: \japanesedoc
\~japanese
他言語ドキュメント: \englishdoc
\~

 */

/** \page p_basic_usage Basic Usage and Loading Environments

To check out the plugins loaded type
\verbatim
openrave --listplugins
\endverbatim

To load a simple robot into the scene type:
\verbatim
openrave robots/puma.robot.xml
\endverbatim

If a plugin declares a ProblemInsance named \b MyProblem, then to launch the problem at startup type
\verbatim
openrave robots/puma.robot.xml -problem MyProblem 'myarguments'
\endverbatim

*/

/** \page conventions System Conventions and Guidelines

This is the set of conventions all users are highly recommended to follow. Sticking to them will
guarantee that a certain party's %OpenRAVE modules can inter-operate with other modules.

- Internal matrices are in column-order, row-major format. If this is confusing, check out this
guide. This means affine matrix representation is using the standard math way. All matrices are
serialized in column-major format, this is to make it simpler for Octave/Matlab to convert between
matrices. Note that python expects row-major matrices, which require transposition when passed
around the two interfaces.

- Quaternions, the preferred way of representing rotations, are defined with the scalar value as
the first component. For example [w x y z] or [cos sin*axis].

- A pose is an affine transformation specified as a quaternion and translation. It serializes into
7 values, the first 4 being the quaternion.

- Distances between two rotations is \f$\cos^{-1} | q_1 \cdot q_2 |\f$, where each rotation is
  represented as a quaternion. For rotations close to each other, this is sometimes approximated as: \f$\min\left( | q1 - q2 | \; , \; | q1 + q2 |\right)\f$.

- A robot's up direction is on the positive z-axis, forward direction is the positive x-axis.

- Mobile manipulation is performed in the XY plane.

- The origin of a robot should be defined so that its base perfectly rests on a floor at z=0, and
its rotation around the z-axis is the center of rotation when the base makes a natural in-place
turn.

- All objects/robots of human-environment scale should be specified in meters. There are many
default thresholds and parameters that assume this convention, and not following it will result in
explosion of computation. A more general convention is that the unit should be chosen so that the
arm length of the robot is closest to 1.

- Every body added to the environment should have a unique name.

- Every link/manipulator/sensor/joint in a robot/kinbody should have a name that will
differentiate it from the others.

\section Internal

The rotation of kinbody joint axes is clockwise instead of the counter-clockwise standard. However,
the only place this convention pops up is when defining the robot file and when using Joint.GetAxis
directly. Every other place in the code is consistent with how the links move, not how the joint
axes are defined. For example, the Jacobian explains how a point will move given the angles
specified through KinBody.SetJointValues.

*/

/** \page environment_variables Environment Variables

This page describes system environment variables read by %OpenRAVE environments on
initialization. \envvarwiki{This page} describes how to set environment variables for the particular
system running %OpenRAVE.

- \b OPENRAVE_PLUGINS - Use ':' to separate each directory (';' for Windows). At startup, %OpenRAVE
  searches for every shared object/dll plugin in these directories and loads them. The default
  plugins in $OPENRAVE_INSTALL/share/openrave/plugins are always loaded, so there is no need to
  include them.

- \b OPENRAVE_DATA - Use ':' to separate each directory (';' for Windows). Everytime %OpenRAVE loads
  a file, it will search it in these directories. The default data directory
  $OPENRAVE_INSTALL/share/openrave is always included, so there's no need to specify it again.

- \b OPENRAVE_HOME - Used to set the directory where all openrave specific cached data is stored
  like inverse kinematics solvers, robot pre-processed data, database generation results, etc. The
  default directory is <b>$HOME/.openrave</b>.


*/

/** \page database_generation Robot Database Generators

For now see <a href="http://openrave.programmingvision.com/index.php/Main_Page#Robot-specific_Database_Generation">Database Generation</a>.

*/

/** \page architecture_concepts Introduction to the OpenRAVE Architecture 

\section fundamental_structure Fundamental Structure

\image html openrave_architecture.jpg
\image latex openrave_architecture.pdf "%OpenRAVE architecture" width=15cm

%OpenRAVE is divided in four main components as shown in the above figure:

- <b>Core Layer</b> The core is composed of a set of \ref interfaces defining how plugins share
information, and it provides an environment interface that maintains a world state, which serves as
the gateway to all functions offered through %OpenRAVE. The global openrave state manages the loaded
plugins, multiple independent environments, and logging. On the other hand, the \ref OpenRAVE::EnvironmentBase "environment" combines collision checkers, viewers, physics engines, the kinematic world, and all
its interfaces into a coherent robotics world state.

- <b>Plugins Layer</b> %OpenRAVE is designed as a plugin-based architecture where a plugin offers
implementations of the \ref interfaces that are loaded dynamically into the \ref
OpenRAVE::EnvironmentBase "environment". Plugins can be linked with other robotics libraries
allowing OpenRAVE to expand its functionality, or it can offer OpenRAVE services to another robotics
system. A plugin needs to export several functions that allow %OpenRAVE to gather information about
what functions it provides and create its interfaces. During startup, %OpenRAVE parses the \ref
environment_variables "OPENRAVE_PLUGINS" environment variable and loads all the shared objects it
finds. If the shared object exports the correct functions, the plugin and its interfaces are
registered with the %OpenRAVE run-time database, and the rest of the environment loading
occurs. Plugins themselves can query functionality offer by other plugins through the environment's
\ref plugin_functionality "interface querying functions".
 - Refer to \ref writing_plugins for a tutorial on how to build and
compile plugins.

- <b>Scripting Layer</b> %OpenRAVE provides scripting environments for \openravepy{Python} and
\octave{Octave/Matlab}. Python communicates with the core layer directly with in-memory calls,
making it extremely fast. On the other hand, the Octave/Matlab scripting protocol send commands
through TCP/IP, with a plugin offering a text server on the %OpenRAVE core side. Scripting allows
real-time modifications to any aspect of the environment without requiring shutdown, making it ideal
to testing new algorithms. The Python scripting is so powerful, that most of the %OpenRAVE examples
and demo code are offered through it. In fact, users should treat the scripting language as an
integral part of the entire system, not as a replacement to the C++ API.

- <b>Robot Database Layer</b> Kinematically and dynamically analyze and the robot and its task and
  store such information for later re-use.


All the base planners and problem interfaces should be applicable to any robot structure you can
throw at it. One of OpenRAVE's strongest points when compared with other planning packages is the
idea of being able to apply algorithms in openrave to any robot, with very little
modification. Recently, a planning database structure has been introduced that allows computation of
properties like convex hull decomposition, grasp sets, reachability maps, analytic inverse
kinematics, etc. If the robot is defined properly, then all these functions should work out of the
box.

Although the low level stuff is general, the examples usually single out one environment and one
robot to show you the technology. Some examples like graspplanning.py are more applicable in that
they just re-use the grasp sets and ik databases for moving the robot.

It is possible to send a \b help command to every \ref InterfaceBase "interface" to get a
description of the commands it supports and what they do.


\section environment Environments

- Locking Environments
- Plugin Management
- Cloning

One of the strengths of %OpenRAVE is in allowing multiple \ref OpenRAVE::EnvironmentBase "environments" work simultaneously in the same process.

*/


/** \page writing_plugins Writing C++ Plugins

You can find a complete stand-alone plugin example in the share/openrave/examples/plugincpp folder. To build it just type: 

\example plugincpp.cpp

*/

/** \defgroup interfaces Base Interface Classes

Interfaces are provided by plugins and are usually dynamically loaded into %OpenRAVE. All interfaces
are derived from the \ref InterfaceBase class and contain basic information such as the type, the
owning \ref OpenRAVE::EnvironmentBase "environment", setting user data, cloning, and allowing custom string commands to be sent.

Every instantiated interface belongs to only one \ref OpenRAVE::EnvironmentBase
"environment". Interfaces can be cloned using \ref OpenRAVE::InterfaceBase::Clone.

 */

/** \defgroup geometric_primitives Geometric Primitives

A set of geometric primitives and functions offering collision detection and other distance measurement capabilities.

*/

/** \defgroup affine_math Affine Math

A set of classes and functions that provide the basic affine math operations with vectors, matrices, and quaternions.

*/

/** \defgroup interfaces_all List of All Plugin Interfaces

This lists the set of interfaces that are distributed with the %OpenRAVE distribution.

- \subpage interfaces_controller
*/

/** \defgroup interfaces_controller List of Controller Interfaces

This lists the set of offered \ref OpenRAVE::ControllerBase interfaces.

*/
