// -*- coding: utf-8 -*-
/**
\~

\mainpage Open Robotics Automation Virtual Environment

\~english

%OpenRAVE provides an environment for testing, developing, and deploying motion planning and
higher-level intelligence algorithms in real-world robotics applications. This document covers the
core %OpenRAVE concepts, the C++ API, examples, and usage of the plugins offered in the base
installation. Please visit the \homepage{<b>official home page</b>} for up to date information on
robotics systems using %OpenRAVE, official %OpenRAVE releases, and videos/tutorials.

\~japanese

%OpenRAVEは現実世界の自律型ロボットアプリケーションをターゲットとし，そのテストと開発のためのモーションプランニングと高度な知的アルゴリズムを備えた開発環境を提供します．このドキュメントは%OpenRAVEの主要な概念，C++のAPI，使用例，インストール時に提供されたプラグインの使い方について記載しています．%OpenRAVEを用いたロボットシステム，%OpenRAVEの公式リリース，ビデオ／チュートリアルなどの最新情報は\homepage{<b>公式HP</b>}をご参照ください．

\~english

%OpenRAVE includes a seamless integration of simulation, visualization, planning, scripting and
control. The plugin architecture allows users to easily write custom controllers or extend
functionality. Using %OpenRAVE plugins, any planning algorithm, robot control, or sensing-based
subsystem can be distributed and dynamically loaded at run-time; this distributed nature frees
developers from struggling with monolithic code-bases. Users of %OpenRAVE can concentrate on the
development of planning and scripting aspects of a problem without having to explicitly manage the
details of robot kinematics and dynamics, collision detection, world updates, and robot control. It
should be noted that %OpenRAVE's sole focus on simulation and analysis of geometric and dynamic
information allows is to be easily integrated into existing robotics systems that concentrate on
low-level control, message protocols, and perception systems.

\~japanese
%OpenRAVEはシミュレーション，可視化，動作計画，スクリプトと制御機能等の統合環境を備えています．そのプラグインアーキテクチャを使い，ユーザーは簡単にコントローラの変更や機能の拡張をすることができます．使用するプラグイン，動作計画アルゴリズム，ロボットの自律制御，またはセンシングを考慮した動作は個々のモジュールになっており，実行時に動的に呼び出されます．これによって開発者は多くのモジュールが１つの大きな塊となった巨大なコードと格闘することから解放されます．さらに%OpenRAVEのユーザーは，ロボットの運動学と動力学、幾何学的干渉、環境変化、ロボット制御などの詳細が分からなくても知的動作とスクリプトの開発に集中することができます．また%OpenRAVEは，制御ドライバ，通信規格，認識システム等に焦点をあてた世の中に存在する他のロボットシステムとは異なり，幾何学と動力学のシミュレーションと解析に焦点をおいているため，それらのシステムとも容易に共存することが可能です．

\~english  \section main_started Getting Started
\~japanese \section main_started はじめに
\~
- \subpage installation
- \subpage p_basic_usage
- \subpage conventions
- \subpage environment_variables

\~english  \section main_architecture Architecture
\~japanese \section main_architecture 構造
\~
- \subpage architecture_concepts
- \subpage interface_concepts
- \subpage writing_plugins
- \ref arch_controller_writing

\~english  \section main_system Components
\~japanese \section main_system 構成要素
\~
- \subpage database_generation
- <a href="http://openrave.programmingvision.com/index.php/Started:Formats">XML File Format</a>
- Scripting
 - \openravepy{Python Scripting with <b>openravepy </b>}
 - \octave{Octave/MATLAB Scripting}
- \ref arch_cloning

\~english \section main_reference Reference
\~japanese \section main_reference 参考資料
\~
- \subpage interfaces
- \provided_interfaces{List of Interface Implementations}
- \subpage executables
- \subpage geometric_primitives
- \subpage affine_math
- \subpage cpp_examples

\~english Documentation in Other Languages: \japanesedoc
\~japanese 他言語ドキュメント: \englishdoc
\~
 */

/** 
\~english  \page p_basic_usage Basic Usage and Loading Environments

To check out the plugins loaded type
\verbatim
openrave --listplugins
\endverbatim

To load a simple robot into the scene type:
\verbatim
openrave robots/puma.robot.xml
\endverbatim

If a plugin declares a ProblemInsance named \b MyProblem, then to launch the problem at startup type
\verbatim
openrave robots/puma.robot.xml -problem MyProblem 'myarguments'
\endverbatim

The \openrave_py{openrave.py} program is similar to \c openrave, but supports much more
functionality. In fact, \c openrave potentially calls into \openrave_py{openrave.py} for commands it
cannot support.

\~japanese \page p_basic_usage 基本的な使い方

提供されているプラグインのリストを表示するには次のコマンドを実行して下さい．
\verbatim
openrave --listplugins
\endverbatim

xmlファイルで定義されたロボットをOpenRAVE環境に読み出すには次のコマンドを実行して下さい．
\verbatim
openrave robots/puma.robot.xml
\endverbatim

プラグインが<b>MyProblem</b>という問題例を定義している場合，次のコマンドで起動することができます．
\verbatim
openrave robots/puma.robot.xml -problem MyProblem 'myarguments'
\endverbatim

openraveと似たコマンドに\openrave_py{openrave.py}というコマンドがあります．こちらはPythonで書かれているためOpenRAVEで提供されているすべてのモジュールにアクセスすることが可能で非常に機能的です．一方，openraveコマンドは既にC++でコンパイルされているため，Pythonがインストールされている開発環境でなくても実行することが可能です．

*/

/** 

\~english \page conventions System Conventions and Guidelines

This is the set of conventions all users are highly recommended to follow. Sticking to them will
guarantee that a certain party's %OpenRAVE modules can inter-operate with other modules.

- Internal matrices are in column-order, row-major format. If this is confusing, check out this
guide. This means affine matrix representation is using the standard math way. All matrices are
serialized in column-major format, this is to make it simpler for Octave/Matlab to convert between
matrices. Note that python expects row-major matrices, which require transposition when passed
around the two interfaces.

- Quaternions, the preferred way of representing rotations, are defined with the scalar value as
the first component. For example <b>[w x y z]</b> or <b>[cos sin*axis]</b>.

- A pose is an affine transformation specified as a quaternion and translation. It serializes into
7 values, the first 4 being the quaternion.

- Distances between two rotations is \f$\cos^{-1} | q_1 \cdot q_2 |\f$, where each rotation is
  represented as a quaternion. For rotations close to each other, this is sometimes approximated as: \f$\min\left( | q1 - q2 | \; , \; | q1 + q2 |\right)\f$.

- A robot's up direction is on the positive z-axis, forward direction is the positive x-axis.

- Mobile manipulation is performed in the XY plane.

- The origin of a robot should be defined so that its base perfectly rests on a floor at z=0, and
its rotation around the z-axis is the center of rotation when the base makes a natural in-place
turn.

- All objects/robots of human-environment scale should be specified in meters. There are many
default thresholds and parameters that assume this convention, and not following it will result in
explosion of computation. A more general convention is that the unit should be chosen so that the
arm length of the robot is closest to 1.

- Every body added to the environment should have a unique name.

- Every link/manipulator/sensor/joint in a robot/kinbody should have a name that will
differentiate it from the others.

- Joint axis rotation is counter-cockwise.

\~japanese \page conventions システム開発上で覚えておくべきこと

すべてのOpenRAVEモジュールは以下のルールに従っています．新しいモジュールを作成する際にも，この規則を守れば互いの機能を使うことが容易になりますので是非覚えておきましょう．

- 座標は右手系です．

- OpenRAVEの変換行列は列ベクトルを使い，メモリ配置は横（行）に並べます（詳細は[[Started:MatrixFormats|
  ここで参照]]）．言い換えると標準的な線形代数の慣習に従っています．しかし，Octave/Matlabの使い方を容易
  にするためにシリアライズする際にはメモリ配置を縦（列）で入出力します．Pythonの行列メモリ配置は横（行）
  並びであるため，シリアライズを行った場合には転置する必要があることに注意して下さい．

- 回転を示す時にはクオータニオンを使うことが推奨されます．クオータニオンのスカラーは最初の要素です．
  例えば<b>[w x y z]</b>か<b>[cos sin*axis]</b>・

- \b poseは変換行列をクオータニオンと移動で指定されています．7値にシリアライズされていて，最初の4つがクオータ
  ニオンの値を示し，残りの3つは移動の<b>[x y z]</b>を示しています．

- 2つの回転の距離は\f$\cos^{-1} | q_1 \cdot q_2 |\f$で定義されています．\f$q_1\f$，\f$q_2\f$はクオータニオンとして表現され，最小角度を示しています．回転が互いに近い場合は\f$\min\left( | q1 - q2 | \; , \; | q1 + q2 |\right)\f$に近似することが出来ます．

- ロボットの上方向は\b +Z軸，進行方向は\b +X軸とします．

- モバイルマニピュレーションは\b XY平面でのみ行うことができます．

- ロボットの座標原点は，ベースリンクがZ=0の平面に配置されます．ロボットが移動し，回転する時にもっとも自
  然的な回転軸の原点が座標原点に一致します．

- 人間環境で活動するロボットの長さの単位はメートル（m)です．あらゆるしきい値がそれを仮定しているた
  め，別の単位を使う場合は計算時間が膨大になる可能性があります．単位を選ぶ時にもっとも一般的な慣習
  は，<b>アームの長さ</b>を大体1にすることです．

- OpenRAVE環境に加えられている物体は固有の名前を持つ必要があります．

- 物体の中で定義されているリンク，マニピュレーター，センサー，関節の名前は互いに固有である必要があります．

- 関節の回転方向は逆時計回りになっています．

*/

/**
\~english \page environment_variables Environment Variables

This page describes system environment variables read by %OpenRAVE environments on
initialization. \envvarwiki{This page} describes how to set environment variables for the particular
system running %OpenRAVE.

- \b OPENRAVE_PLUGINS - Use ':' to separate each directory (';' for Windows). At startup, %OpenRAVE
  searches for every shared object/dll plugin in these directories and loads them. The default
  plugins in \c $OPENRAVE_INSTALL/share/openrave/plugins are always loaded, so there is no need to
  include them.

- \b OPENRAVE_DATA - Use ':' to separate each directory (';' for Windows). Every time %OpenRAVE loads
  a file, it will search it in these directories. The default data directory
  \c $OPENRAVE_INSTALL/share/openrave is always included, so there's no need to specify it again.

- \b OPENRAVE_HOME - Used to set the directory where all openrave specific cached data is stored
  like inverse kinematics solvers, robot preprocessed data, database generation results, etc. The
  default directory is <b>$HOME/.openrave</b>.

\~japanese \page environment_variables 環境変数の設定

このページでは%OpenRAVEが最初に読み出す環境変数の設定の方法について説明します．

- \b OPENRAVE_PLUGINS - %OpenRAVEは起動時に，ここに設定されたディレクトリの全てのobject/dllプラグインを探索し読み出します．複数のディレクトリを設定する場合，個々のディレクトリは ':' （Windows環境の場合は ';' ）を使って分けてください．\c $OPENRAVE_INSTALL/share/openrave/pluginsにあるデフォルトのプラグインは常に読み出されますので，設定する必要はありません．

- \b OPENRAVE_DATA - %OpenRAVEは常に，ここに設定されたディレクトリのファイルを探索し読み出します．複数のディレクトリを設定する場合，個々のディレクトリは ':' （Windows環境の場合は ';' ）を使って分けてください．デフォルトは\c $OPENRAVE_INSTALL/share/openraveですので，これは再度設定する必要はありません．

- \b OPENRAVE_HOME - 全ての%OpenRAVEの固有データを保存する場所を指定しています．%OpenRAVEの固有データとは，逆運動学の解析結果のようなロボットの事前に計算された結果や生成されたデータベース等のことです．デフォルトのディレクトリは<b>$HOME/.openrave</b>です．

*/

/** 
\page database_generation Robot Database Generators

For now see <a href="http://openrave.programmingvision.com/index.php/Main_Page#Robot-specific_Database_Generation">Database Generation</a>.

*/

/** 
\page writing_plugins Writing Plugins and Interfaces

\section writing_plugins_contents Contents
- \ref writing_plugins_hash
- \ref writing_plugins_example
- \ref writing_plugins_build
- \ref writing_plugins_usage
- \ref writing_plugins_doc

Every plugin needs to export several functions as defined in \ref plugin_exports to notify %OpenRAVE
what interfaces it has. When a plugin is first loaded, it is validated by the environment and its
\ref OpenRAVEGetPluginAttributes function will be called in order so the %OpenRAVE core can register
the names of its provided interfaces. Plugins themselves can query functionality offer by other
plugins through the environment's \ref env_plugin_functionality "interface querying functions".

\section writing_plugins_hash Loading Plugins

Many mechanisms have been put in place to prevent mismatching/old plugins to be loaded by the
core. Using interfaces from stale plugins can lead to unexpected crashes that are very difficult to
debug. It is possible to automatically come up with a unique hash of the interface functions and
members by running each interface through a C++ lexer and then creating a 128bit unique md5 hash.
In order to protect plugins compiled with a different version, %OpenRAVE creates a md5 hash from
each interface class definition using \ref cpp-gen-md5 and stores them in \ref rave/classhashes.h.

The interface hash can be retrieved using \ref OpenRAVE::RaveGetInterfaceHash. For an interface to
be loaded successfully, the plugin has to check that the hash the core is using matches the hash
compiled with the plugin. These types of checks ensure that stale plugins will never be loaded;
helper functions are offered in \ref rave/plugin.h, which all plugin authors should use.

\section writing_plugins_example Providing a Simple Interface

Example \ref plugincpp.cpp "plugincpp.cpp" creates a \ref OpenRAVE::ProblemInstance interface named \b MyProblem and have it offer two commands: \b numbodies and \b load.

\dontinclude plugincpp.cpp

The first \#include the compiler sees has to be \ref rave/rave.h. Then for the main C++ file, we include \ref rave/plugin.h for several helper functions.

\until {

Now register the two commands of the problem. \c boost::bind is necessary for specifying member functions as callbacks.

\skipline MyProblemInstance(
\until }

Provide the implementations for the member functions:
\skipline bool
\until };

It is recommend to plugin authors to include \ref rave/plugin.h in their main C++
file, this will provide implementations for the export functions and ask the user to provide a new
set of functions \ref CreateInterfaceValidated and \ref GetPluginAttributesValidated.

Providing \b MyProblem would look like:

\skipline InterfaceBasePtr
\until }

In order to tell %OpenRAVE what is provided, have to define:

\skipline GetPluginAttributesValidated
\until }

\section writing_plugins_build Building the Plugin

\subsection writing_plugins_cmake Using CMake

The main build system of %OpenRAVE is cmake, and \ref FindOpenRAVE.cmake "FindOpenRAVE.cmake" can be used to find the %OpenRAVE installation (found in <tt>$OPENRAVE_INSTALL/share/openrave/cppexamples/FindOpenRAVE.cmake</tt>). An example of the \c CMakeLists.txt file for compiling a plugin using \ref FindOpenRAVE.cmake "FindOpenRAVE.cmake" is:

\verbatim
cmake_minimum_required (VERSION 2.4)
project (plugincpp)

# Include OpenRAVE paths
include(FindOpenRAVE.cmake) 
if( NOT OPENRAVE_FOUND )
  message(FATAL_ERROR "could not find openrave, check for openrave-config in path")
endif( NOT OPENRAVE_FOUND )

# Create the plugincpp plugin
include_directories(${OPENRAVE_INCLUDE_DIRS} ${CMAKE_CURRENT_SOURCE_DIR})
link_directories(${OPENRAVE_LINK_DIRS})
add_library(plugincpp SHARED plugincpp.cpp)
set_target_properties(plugincpp PROPERTIES COMPILE_FLAGS "${OPENRAVE_CXXFLAGS}")
set_target_properties(plugincpp PROPERTIES LINK_FLAGS "${OPENRAVE_LINK_FLAGS}")
target_link_libraries(plugincpp ${OPENRAVE_LIBRARY})
\endverbatim

\subsection writing_plugins_linux Other Build Systems

If not using CMake, then here's how the development files are organized:

<b>Linux Users</b>

Depending on where openrave was installed, a \ref openrave_config should have been created in the \c $OPENRAVE_INSTALL/bin
directory. It is possible to call <tt>openrave-config --cflags</tt> to get the correct paths and
flags to include in gcc to link with \c libopenrave.so.

<b>Windows Users</b>

Because Windows does not provide a way to share libraries and DLLs, All the include headers and DLLs
of libraries that %OpenRAVE links with are provided in the \c $OPENRAVE_INSTALL\\bin and \c
$OPENRAVE_INSTALL\\include directories.

\section writing_plugins_usage Using the Plugin

There are several ways to load the generated plugin.

- The most simplest method is to add its installation directory to the \ref environment_variables "OPENRAVE_PLUGINS" environment variable. %OpenRAVE will automatically load it up at start up. You can confirm this is the case using:
\verbatim
openrave --listplugins
\endverbatim

- A more explicit way is to load it from the command line using any one of the following methods:
\verbatim
openrave --loadplugin $SOMEPATH/libplugincpp
openrave --loadplugin $SOMEPATH/libplugincpp.so
openrave --loadplugin ./libplugincpp.so
\endverbatim
 where \c $SOMEPATH is the absolute/relative path of the shared object. 

- Another way is to load it from the C++/Python/APIs:<br/>
\b C++
\code
env->LoadPlugin("libplugincpp");
\endcode
\b Python
\verbatim
env.LoadPlugin('libplugincpp');
\endverbatim
\b Octave
\verbatim
orEnvLoadPlugin('libplugincpp');
\endverbatim

Once the plugin is loaded, we can create the interface and call its commands to load an environment and return the number of bodies:

\b C++
\code
ProblemInstancePtr prob = env->CreateProblem("MyProblem");
env->LoadProblem(prob,"");
stringstream sinput, sout;
// input the load command
sinput << "load data/lab1.env.xml";
if( !prob->SendCommand(sout,sinput) ) {
    RAVELOG_WARN("command failed!\n");
}
else {
    sinput.str(""); // have to reset the stream from the previous command
    sinput << "numbodies"; // input the numbodies command
    prob->SendCommand(sout,sinput);
    int numbodies;
    sout >> numbodies;
    RAVELOG_INFO("number of bodies are: %d\n",numbodies);
}
\endcode

\b Python
\verbatim
prob = env.CreateProblem('MyProblem')
env.LoadProblem(prob,args='')
cmdout = prob.SendCommand('load data/lab1.env.xml')
if cmdout is None:
    raveLogWarn('command failed!')
else:
    cmdout = prob.SendCommand('numbodies')
    print 'number of bodies are: ',cmdout
\endverbatim

\b Octave (only simple commands possible)
\verbatim
prob = orEnvCreateProblem('MyProblem');
orProblemSendCommand('load data/lab1.env.xml',prob);
numbodies = orProblemSendCommand('numbodies',prob);
disp(['number of bodies are: ' num2str(numbodies)])
\endverbatim

\section writing_plugins_doc Documenting Interfaces

The format of all interface documentation is the widely adopted standard <a
href="http://docutils.sourceforge.net/rst.html">reStructuredText</a>. The description of an
interface and all information about its usage should be provided by two places:

- OpenRAVE::InterfaceBase::GetDescription() - Returns the full documentation of the interface
  description. If opening new sections, do not to use '-'.

- OpenRAVE::InterfaceBase::RegisterCommand() - Help string in every command registered. If opening new sections,
do not to use '-', '=', and '~'.

These descriptions are automatically parsed using Sphinx and put on the web.

The reason why doxygen and other commenting tools are not adopted for plugin documentation is
because the \ref interfaces are the only binding between plugins. Even if the header file or
provided functions of a particular plugin were provided, other plugins would not be able to use them
if not offered through the %OpenRAVE's channels.

*/

/**
\page cpp_examples C++ Examples

\section cpp_examples_build Building

All C++ examples are stored in \c $OPENRAVE_INSTALL/share/openrave/cppexamples. Use the \c CMakeLists.txt file the build the examples by:
\verbatim
cd `openrave-config --prefix`/share/openrave/cppexamples
mkdir build
cd build
cmake ..
make
\endverbatim

\section cpp_examples_plugins Examples Plugins

- \ref customreader.cpp
- \ref plugincpp.cpp

\section cpp_examples_programs Examples loading the OpenRAVE core:

- \ref ikfastloader.cpp
- \ref orcollision.cpp
- \ref orloadviewer.cpp

*/

/** \defgroup plugin_exports Plugin Export Functions

    Every plugin needs to export these functions
*/

/** \defgroup interfaces Base Interface Classes

A list of the %OpenRAVE interface templates. See \ref arch_interface for an explanation.
 */

/** \defgroup geometric_primitives Geometric Primitives

A set of geometric primitives and functions offering collision detection and other distance measurement capabilities.

*/

/** \defgroup affine_math Affine Math

A set of classes and functions that provide the basic affine math operations with vectors, matrices, and quaternions.

*/

/**
\example FindOpenRAVE.cmake

Allows %OpenRAVE installation to be found when using the CMake build system.
*/

/**
\page executables Executable Programs

- \subpage openrave
- \subpage openrave-config
- \subpage \openrave_py{openrave.py}
- \subpage \openrave_py{openrave-hash.py}

*/

/**
\page openrave_config openrave-config

Used to find the %OpenRAVE installation location and all the include/development/examples files.

Usage:
\verbatim
openrave-config
  [--prefix[=DIR]]
  [--exec-prefix[=DIR]]
  [--version] [--cflags]
  [--libs]
  [--libs-core]
  [--libs-only-l]
  [--libs-only-L]
  [--cflags-only-I]
  [--shared-libs]
  [--python-dir]
  [--octave-dir]
  [--matlab-dir]
  [--usage | --help]
\endverbatim

*/
