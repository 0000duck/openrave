#define IKFAST_NAMESPACE ik_pr2_leftarm_torso
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 67 generated on 2013-07-25 16:09:52.153131
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==67);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
#ifndef isfinite
#define isfinite _isfinite
#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61;
x0=IKcos(j[1]);
x1=IKcos(j[3]);
x2=IKsin(j[2]);
x3=IKsin(j[1]);
x4=IKsin(j[3]);
x5=IKcos(j[5]);
x6=IKcos(j[4]);
x7=IKcos(j[2]);
x8=IKsin(j[4]);
x9=IKsin(j[5]);
x10=IKcos(j[7]);
x11=IKsin(j[7]);
x12=IKsin(j[6]);
x13=IKcos(j[6]);
x14=((1.0)*x8);
x15=((0.18)*x5);
x16=((1.0)*x1);
x17=((0.321)*x4);
x18=((0.18)*x9);
x19=((0.18)*x8);
x20=((1.0)*x6);
x21=((1.0)*x13);
x22=((0.18)*x6);
x23=((0.321)*x6);
x24=((1.0)*x12);
x25=((0.321)*x1);
x26=(x3*x7);
x27=((-1.0)*x8);
x28=(x0*x2);
x29=(x4*x7);
x30=(x2*x6);
x31=(x0*x7);
x32=((-1.0)*x6);
x33=(x3*x4);
x34=(x2*x3);
x35=(x1*x7*x8);
x36=(x14*x31);
x37=(x16*x6*x7);
x38=((((-1.0)*x16*x3))+((x28*x4)));
x39=(((x0*x4))+(((-1.0)*x16*x34)));
x40=(((x0*x1))+((x2*x33)));
x41=((((-1.0)*x37))+((x2*x8)));
x42=((((-1.0)*x33))+(((-1.0)*x16*x28)));
x43=(x38*x5);
x44=(x38*x9);
x45=(((x1*x14*x7))+((x2*x20)));
x46=(x40*x9);
x47=(x42*x6);
x48=(((x29*x9))+((x41*x5)));
x49=(((x39*x6))+((x26*x27)));
x50=(((x29*x5))+((x9*(((((-1.0)*x14*x2))+x37)))));
x51=(x13*x48);
x52=(((x27*x31))+x47);
x53=(((x27*x39))+((x26*x32)));
x54=(x49*x5);
x55=(x5*x52);
x56=(x12*x53);
x57=(x46+x54);
x58=(((x9*(((((-1.0)*x20*x39))+((x14*x26))))))+((x40*x5)));
x59=(x44+x55);
x60=(x13*x57);
x61=(x13*x59);
eerot[0]=(((x11*((x43+((x9*(((((-1.0)*x20*x42))+x36))))))))+((x10*((((x12*((((x27*x42))+((x31*x32))))))+x61)))));
eerot[1]=(((x10*((((x9*((x36+((x32*x42))))))+x43))))+(((-1.0)*x11*((((x24*(((((-1.0)*x20*x31))+(((-1.0)*x14*x42))))))+((x21*x59)))))));
eerot[2]=(((x12*((((x5*(((((-1.0)*x36))+x47))))+x44))))+((x13*((((x31*x6))+((x42*x8)))))));
eetrans[0]=((-0.05)+((x23*x31))+(((0.1)*x0))+((x8*(((((-1.0)*x25*x28))+(((-1.0)*x17*x3))))))+((x13*((((x19*x42))+((x22*x31))))))+(((0.4)*x31))+((x12*((((x15*x52))+((x18*x38)))))));
eerot[3]=(((x10*((x56+x60))))+((x11*x58)));
eerot[4]=(((x11*(((((-1.0)*x56))+(((-1.0)*x60))))))+((x10*x58)));
eerot[5]=(((x12*x57))+((x13*((((x39*x8))+((x26*x6)))))));
eetrans[1]=((0.188)+((x8*((((x0*x17))+(((-1.0)*x25*x34))))))+(((0.1)*x3))+((x13*((((x22*x26))+((x19*x39))))))+((x23*x26))+(((0.4)*x26))+((x12*((((x18*x40))+((x15*x49)))))));
eerot[6]=(((x10*((x51+((x12*x45))))))+((x11*x50)));
eerot[7]=(((x11*(((((-1.0)*x24*x45))+(((-1.0)*x21*x48))))))+((x10*x50)));
eerot[8]=(((x12*x48))+(((-1.0)*x13*x45)));
IkReal x62=((1.0)*x2);
IkReal x63=((1.0)*x7);
eetrans[2]=((0.739675)+(((-1.0)*x25*x63*x8))+((x12*((((x18*x29))+((x15*x41))))))+(((-1.0)*x23*x62))+(((-0.4)*x2))+j[0]+((x13*(((((-1.0)*x1*x19*x63))+(((-1.0)*x22*x62)))))));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j18,cj18,sj18,htj18,j18mul,j19,cj19,sj19,htj19,j19mul,j20,cj20,sj20,htj20,j20mul,j21,cj21,sj21,htj21,j21mul,j12,cj12,sj12,htj12,j17,cj17,sj17,htj17,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij18[2], _nj18,_ij19[2], _nj19,_ij20[2], _nj20,_ij21[2], _nj21,_ij12[2], _nj12,_ij17[2], _nj17;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j18=numeric_limits<IkReal>::quiet_NaN(); _ij18[0] = -1; _ij18[1] = -1; _nj18 = -1; j19=numeric_limits<IkReal>::quiet_NaN(); _ij19[0] = -1; _ij19[1] = -1; _nj19 = -1; j20=numeric_limits<IkReal>::quiet_NaN(); _ij20[0] = -1; _ij20[1] = -1; _nj20 = -1; j21=numeric_limits<IkReal>::quiet_NaN(); _ij21[0] = -1; _ij21[1] = -1; _nj21 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]);
j17=pfree[1]; cj17=cos(pfree[1]); sj17=sin(pfree[1]);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((0.05)+(((-0.18)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((-0.188)+(((-0.18)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.739675)+(((-1.0)*j12))+pz+(((-0.18)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*py*r20))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*pz*r00)));
rxp0_2=((((-1.0)*px*r10))+((py*r00)));
rxp1_0=((((-1.0)*py*r21))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*pz*r01)));
rxp1_2=((((-1.0)*px*r11))+((py*r01)));
rxp2_0=((((-1.0)*py*r22))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*pz*r02)));
rxp2_2=((((-1.0)*px*r12))+((py*r02)));
{
IkReal dummyeval[1];
IkReal gconst0;
gconst0=((-1.0)*py);
IkReal gconst1;
gconst1=((0.642)*sj17);
IkReal gconst2;
gconst2=((-1.0)*py);
IkReal gconst3;
gconst3=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst4;
gconst4=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst5;
gconst5=((-1.0)*py);
IkReal gconst6;
gconst6=((0.642)*sj17);
IkReal gconst7;
gconst7=((-1.0)*py);
IkReal gconst8;
gconst8=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst9;
gconst9=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst10;
gconst10=((2.0)*px);
IkReal gconst11;
gconst11=((2.0)*px);
IkReal gconst12;
gconst12=((0.4)*py);
IkReal gconst13;
gconst13=((0.4)*py);
IkReal gconst14;
gconst14=((2.0)*px);
IkReal gconst15;
gconst15=((2.0)*px);
IkReal gconst16;
gconst16=((0.4)*py);
IkReal gconst17;
gconst17=((0.4)*py);
IkReal gconst18;
gconst18=py;
IkReal gconst19;
gconst19=((0.642)*sj17);
IkReal gconst20;
gconst20=py;
IkReal gconst21;
gconst21=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst22;
gconst22=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst23;
gconst23=py;
IkReal gconst24;
gconst24=((0.642)*sj17);
IkReal gconst25;
gconst25=py;
IkReal gconst26;
gconst26=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst27;
gconst27=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal x64=(gconst20*gconst21);
IkReal x65=(gconst23*gconst27);
IkReal x66=(gconst25*gconst26);
IkReal x67=(gconst18*gconst22);
dummyeval[0]=((((-1.0)*x64*x66))+(((-1.0)*x65*x67))+(((-1.0)*gconst19*gconst22*gconst24*gconst26))+((x64*x65))+((x66*x67)));
if( IKabs(dummyeval[0]) < 0.0000001000000000  )
{
continue;

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x68=((1.0)*gconst8);
IkReal x69=(gconst3*gconst7);
IkReal x70=(gconst0*gconst8);
IkReal x71=(gconst13*gconst15);
IkReal x72=((1.0)*gconst22);
IkReal x73=(gconst19*gconst24);
IkReal x74=(gconst0*gconst9);
IkReal x75=(gconst1*gconst6);
IkReal x76=(gconst27*gconst5);
IkReal x77=(gconst2*gconst3);
IkReal x78=((1.0)*gconst4);
IkReal x79=(gconst17*gconst5);
IkReal x80=(gconst12*gconst14);
IkReal x81=(gconst2*gconst9);
IkReal x82=((1.0)*gconst16);
IkReal x83=(gconst18*gconst25);
IkReal x84=(gconst12*gconst7);
IkReal x85=(gconst18*gconst9);
IkReal x86=(gconst20*gconst27);
IkReal x87=(gconst26*gconst4);
IkReal x88=(gconst1*gconst24);
IkReal x89=(gconst11*gconst3);
IkReal x90=((1.0)*gconst26);
IkReal x91=(gconst20*gconst21);
IkReal x92=(gconst13*gconst16);
IkReal x93=(gconst18*gconst23);
IkReal x94=(gconst21*gconst25);
IkReal x95=(gconst2*gconst21);
IkReal x96=(gconst12*gconst2);
IkReal x97=(gconst5*gconst9);
IkReal x98=(gconst20*gconst3);
IkReal x99=(gconst4*gconst7);
IkReal x100=(gconst11*gconst12);
IkReal x101=(gconst14*gconst17);
IkReal x102=(gconst15*gconst4);
IkReal x103=((1.0)*gconst13);
IkReal x104=(gconst10*gconst8);
IkReal x105=(gconst0*gconst16);
IkReal x106=(gconst23*gconst27);
IkReal x107=(gconst22*gconst25);
IkReal x108=(gconst10*gconst16);
IkReal x109=(gconst19*gconst6);
IkReal x110=(gconst22*gconst7);
IkReal x111=(gconst0*gconst7);
IkReal x112=(gconst17*gconst23);
IkReal x113=(gconst10*gconst14);
IkReal x114=(gconst11*gconst21);
IkReal x115=(gconst12*gconst20);
IkReal x116=(gconst18*gconst26);
IkReal x117=(gconst14*gconst9);
IkReal x118=(gconst13*gconst7);
IkReal x119=(gconst16*gconst22);
IkReal x120=(gconst23*x91);
IkReal x121=(gconst10*gconst25*gconst26);
IkReal x122=(gconst15*gconst22*gconst26);
IkReal x123=(gconst14*gconst18*gconst27);
op[0]=((((-1.0)*gconst27*x72*x93))+((gconst22*gconst26*x83))+(((-1.0)*gconst25*x90*x91))+((gconst21*gconst23*x86))+(((-1.0)*gconst26*x72*x73)));
op[1]=((((-1.0)*gconst10*x106*x72))+(((-1.0)*gconst17*x72*x93))+((x106*x114))+(((-1.0)*gconst13*x73*x90))+((gconst13*gconst26*x83))+((gconst10*gconst26*x107))+(((-1.0)*x123*x72))+((gconst14*gconst21*x86))+(((-1.0)*gconst11*x90*x94))+(((-1.0)*gconst25*x82*x91))+((x112*x91))+((gconst15*gconst22*x116))+((x119*x83))+(((-1.0)*gconst25*x115*x90))+(((-1.0)*gconst16*x72*x73))+((gconst12*gconst23*x86))+(((-1.0)*gconst15*x90*x91))+(((-1.0)*gconst27*x103*x93)));
op[2]=((((-1.0)*gconst22*x68*x73))+(((-1.0)*gconst18*x101*x72))+(((-1.0)*gconst26*x109*x72))+((x107*x108))+((gconst15*gconst18*x119))+((x110*x116))+(((-1.0)*gconst15*x114*x90))+((x112*x115))+((x112*x114))+(((-1.0)*gconst2*x90*x94))+((gconst23*gconst3*x86))+((gconst9*x120))+(((-1.0)*gconst17*x103*x93))+((gconst14*gconst27*x114))+((x101*x91))+(((-1.0)*gconst13*x73*x82))+(((-1.0)*gconst27*x78*x93))+(((-1.0)*gconst7*x90*x91))+(((-1.0)*gconst25*x100*x90))+((x116*x71))+(((-1.0)*gconst27*x113*x72))+((x106*x95))+(((-1.0)*gconst25*x68*x91))+((gconst22*gconst8*x83))+((gconst13*x121))+(((-1.0)*gconst25*x90*x98))+(((-1.0)*gconst26*x72*x88))+((x76*x91))+((gconst0*gconst26*x107))+(((-1.0)*gconst15*x82*x91))+(((-1.0)*gconst10*x103*x106))+((x83*x87))+((gconst10*x122))+((x80*x86))+(((-1.0)*gconst15*x115*x90))+((x83*x92))+(((-1.0)*gconst25*x115*x82))+(((-1.0)*gconst26*x73*x78))+(((-1.0)*gconst10*x112*x72))+(((-1.0)*gconst23*x72*x85))+(((-1.0)*gconst18*x72*x76))+(((-1.0)*x103*x123))+(((-1.0)*gconst11*x82*x94))+(((-1.0)*gconst0*x106*x72))+((x100*x106)));
op[3]=((((-1.0)*gconst17*gconst18*gconst23*gconst4))+((gconst16*gconst18*gconst25*gconst4))+((gconst15*gconst18*gconst22*gconst8))+(((-1.0)*gconst16*gconst19*gconst22*gconst6))+((gconst11*gconst12*gconst14*gconst27))+(((-1.0)*gconst16*gconst20*gconst21*gconst7))+(((-1.0)*gconst10*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst13*gconst14*gconst27))+((gconst0*gconst16*gconst22*gconst25))+((gconst0*gconst15*gconst22*gconst26))+((gconst14*gconst2*gconst21*gconst27))+((gconst10*gconst13*gconst15*gconst26))+(((-1.0)*gconst16*gconst2*gconst21*gconst25))+((gconst11*gconst23*gconst27*gconst3))+(((-1.0)*gconst10*gconst13*gconst17*gconst23))+((gconst11*gconst14*gconst17*gconst21))+(((-1.0)*gconst15*gconst20*gconst26*gconst3))+((gconst12*gconst14*gconst17*gconst20))+(((-1.0)*gconst14*gconst18*gconst22*gconst9))+(((-1.0)*gconst13*gconst18*gconst27*gconst5))+(((-1.0)*gconst16*gconst20*gconst25*gconst3))+((gconst11*gconst21*gconst23*gconst9))+(((-1.0)*gconst11*gconst12*gconst15*gconst26))+(((-1.0)*gconst11*gconst21*gconst26*gconst7))+((gconst14*gconst20*gconst21*gconst9))+((gconst16*gconst18*gconst22*gconst7))+(((-1.0)*gconst17*gconst18*gconst22*gconst5))+(((-1.0)*gconst15*gconst2*gconst21*gconst26))+((gconst12*gconst20*gconst23*gconst9))+((gconst13*gconst18*gconst25*gconst8))+(((-1.0)*gconst13*gconst18*gconst23*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst20))+((gconst10*gconst25*gconst26*gconst4))+(((-1.0)*gconst10*gconst22*gconst27*gconst5))+((gconst14*gconst20*gconst27*gconst3))+((gconst15*gconst18*gconst26*gconst4))+((gconst13*gconst15*gconst16*gconst18))+((gconst10*gconst22*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst23))+(((-1.0)*gconst15*gconst20*gconst21*gconst8))+(((-1.0)*gconst11*gconst15*gconst16*gconst21))+(((-1.0)*gconst10*gconst14*gconst17*gconst22))+(((-1.0)*gconst11*gconst12*gconst16*gconst25))+(((-1.0)*gconst13*gconst19*gconst24*gconst8))+((gconst11*gconst12*gconst17*gconst23))+((gconst12*gconst2*gconst23*gconst27))+(((-1.0)*gconst13*gconst14*gconst17*gconst18))+((gconst17*gconst20*gconst23*gconst3))+(((-1.0)*gconst13*gconst19*gconst26*gconst6))+((gconst17*gconst20*gconst21*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst26))+((gconst10*gconst15*gconst16*gconst22))+(((-1.0)*gconst1*gconst16*gconst22*gconst24))+(((-1.0)*gconst0*gconst13*gconst23*gconst27))+((gconst11*gconst21*gconst27*gconst5))+((gconst13*gconst18*gconst26*gconst7))+((gconst17*gconst2*gconst21*gconst23))+(((-1.0)*gconst10*gconst23*gconst27*gconst4))+(((-1.0)*gconst0*gconst14*gconst22*gconst27))+((gconst0*gconst13*gconst25*gconst26))+(((-1.0)*gconst11*gconst25*gconst26*gconst3))+(((-1.0)*gconst1*gconst13*gconst24*gconst26))+((gconst10*gconst22*gconst26*gconst7))+((gconst12*gconst20*gconst27*gconst5))+(((-1.0)*gconst14*gconst18*gconst27*gconst4))+(((-1.0)*gconst12*gconst20*gconst26*gconst7))+(((-1.0)*gconst11*gconst21*gconst25*gconst8))+(((-1.0)*gconst16*gconst19*gconst24*gconst4))+((gconst10*gconst13*gconst16*gconst25))+(((-1.0)*gconst12*gconst20*gconst25*gconst8)));
op[4]=(((gconst12*gconst14*gconst2*gconst27))+(((-1.0)*gconst11*gconst15*gconst26*gconst3))+(((-1.0)*gconst10*gconst17*gconst23*gconst4))+((gconst10*gconst15*gconst22*gconst8))+(((-1.0)*gconst13*gconst17*gconst18*gconst5))+((gconst2*gconst23*gconst27*gconst3))+((gconst18*gconst22*gconst7*gconst8))+((gconst14*gconst17*gconst2*gconst21))+((gconst20*gconst27*gconst3*gconst5))+(((-1.0)*gconst2*gconst21*gconst25*gconst8))+((gconst11*gconst12*gconst14*gconst17))+(((-1.0)*gconst18*gconst27*gconst4*gconst5))+(((-1.0)*gconst10*gconst13*gconst14*gconst17))+(((-1.0)*gconst2*gconst21*gconst26*gconst7))+(((-1.0)*gconst12*gconst15*gconst2*gconst26))+((gconst10*gconst16*gconst22*gconst7))+((gconst13*gconst15*gconst18*gconst8))+((gconst12*gconst17*gconst2*gconst23))+((gconst10*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst13*gconst16*gconst24))+((gconst11*gconst14*gconst27*gconst3))+(((-1.0)*gconst0*gconst13*gconst14*gconst27))+(((-1.0)*gconst1*gconst22*gconst24*gconst8))+((gconst18*gconst25*gconst4*gconst8))+(((-1.0)*gconst12*gconst16*gconst20*gconst7))+(((-1.0)*gconst13*gconst14*gconst18*gconst9))+((gconst0*gconst13*gconst16*gconst25))+((gconst13*gconst16*gconst18*gconst7))+(((-1.0)*gconst20*gconst26*gconst3*gconst7))+((gconst11*gconst12*gconst27*gconst5))+(((-1.0)*gconst0*gconst14*gconst17*gconst22))+(((-1.0)*gconst20*gconst25*gconst3*gconst8))+(((-1.0)*gconst12*gconst15*gconst20*gconst8))+(((-1.0)*gconst19*gconst26*gconst4*gconst6))+(((-1.0)*gconst15*gconst16*gconst2*gconst21))+(((-1.0)*gconst10*gconst14*gconst22*gconst9))+((gconst10*gconst13*gconst25*gconst8))+(((-1.0)*gconst18*gconst22*gconst5*gconst9))+((gconst10*gconst13*gconst26*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst16))+((gconst0*gconst13*gconst15*gconst26))+(((-1.0)*gconst12*gconst16*gconst2*gconst25))+(((-1.0)*gconst20*gconst21*gconst7*gconst8))+(((-1.0)*gconst11*gconst12*gconst26*gconst7))+(((-1.0)*gconst2*gconst25*gconst26*gconst3))+((gconst2*gconst21*gconst27*gconst5))+(((-1.0)*gconst14*gconst17*gconst18*gconst4))+((gconst2*gconst21*gconst23*gconst9))+(((-1.0)*gconst13*gconst16*gconst19*gconst6))+(((-1.0)*gconst0*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst14*gconst27*gconst4))+(((-1.0)*gconst11*gconst12*gconst25*gconst8))+((gconst12*gconst14*gconst20*gconst9))+((gconst18*gconst26*gconst4*gconst7))+(((-1.0)*gconst0*gconst23*gconst27*gconst4))+((gconst20*gconst21*gconst5*gconst9))+((gconst11*gconst12*gconst23*gconst9))+(((-1.0)*gconst0*gconst22*gconst27*gconst5))+(((-1.0)*gconst10*gconst13*gconst27*gconst5))+(((-1.0)*gconst1*gconst22*gconst26*gconst6))+((gconst10*gconst15*gconst26*gconst4))+(((-1.0)*gconst10*gconst13*gconst23*gconst9))+((gconst11*gconst17*gconst23*gconst3))+(((-1.0)*gconst10*gconst17*gconst22*gconst5))+((gconst0*gconst15*gconst16*gconst22))+(((-1.0)*gconst11*gconst16*gconst21*gconst7))+((gconst0*gconst25*gconst26*gconst4))+(((-1.0)*gconst19*gconst24*gconst4*gconst8))+((gconst0*gconst22*gconst25*gconst8))+(((-1.0)*gconst18*gconst23*gconst4*gconst9))+((gconst11*gconst14*gconst21*gconst9))+(((-1.0)*gconst11*gconst16*gconst25*gconst3))+(((-1.0)*gconst11*gconst15*gconst21*gconst8))+((gconst14*gconst17*gconst20*gconst3))+((gconst12*gconst17*gconst20*gconst5))+((gconst11*gconst17*gconst21*gconst5))+(((-1.0)*gconst19*gconst22*gconst6*gconst8))+((gconst15*gconst16*gconst18*gconst4))+((gconst0*gconst22*gconst26*gconst7))+((gconst20*gconst23*gconst3*gconst9))+(((-1.0)*gconst1*gconst24*gconst26*gconst4))+((gconst10*gconst16*gconst25*gconst4))+(((-1.0)*gconst0*gconst13*gconst17*gconst23))+(((-1.0)*gconst15*gconst16*gconst20*gconst3)));
op[5]=(((gconst0*gconst13*gconst26*gconst7))+(((-1.0)*gconst16*gconst2*gconst25*gconst3))+(((-1.0)*gconst13*gconst18*gconst5*gconst9))+(((-1.0)*gconst16*gconst19*gconst4*gconst6))+((gconst17*gconst20*gconst3*gconst5))+(((-1.0)*gconst0*gconst14*gconst27*gconst4))+((gconst10*gconst15*gconst16*gconst4))+(((-1.0)*gconst0*gconst17*gconst23*gconst4))+(((-1.0)*gconst10*gconst13*gconst14*gconst9))+(((-1.0)*gconst16*gconst20*gconst3*gconst7))+((gconst12*gconst20*gconst5*gconst9))+(((-1.0)*gconst0*gconst14*gconst22*gconst9))+((gconst11*gconst14*gconst17*gconst3))+((gconst0*gconst15*gconst22*gconst8))+(((-1.0)*gconst0*gconst13*gconst14*gconst17))+(((-1.0)*gconst15*gconst2*gconst21*gconst8))+((gconst10*gconst25*gconst4*gconst8))+(((-1.0)*gconst11*gconst25*gconst3*gconst8))+(((-1.0)*gconst1*gconst16*gconst22*gconst6))+(((-1.0)*gconst15*gconst2*gconst26*gconst3))+(((-1.0)*gconst11*gconst26*gconst3*gconst7))+((gconst17*gconst2*gconst23*gconst3))+((gconst0*gconst16*gconst25*gconst4))+((gconst10*gconst26*gconst4*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst8))+((gconst14*gconst2*gconst21*gconst9))+(((-1.0)*gconst0*gconst13*gconst27*gconst5))+((gconst17*gconst2*gconst21*gconst5))+((gconst12*gconst14*gconst17*gconst2))+(((-1.0)*gconst16*gconst2*gconst21*gconst7))+((gconst11*gconst23*gconst3*gconst9))+((gconst10*gconst13*gconst16*gconst7))+((gconst11*gconst12*gconst17*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst8))+((gconst12*gconst2*gconst27*gconst5))+((gconst11*gconst21*gconst5*gconst9))+(((-1.0)*gconst13*gconst19*gconst6*gconst8))+(((-1.0)*gconst10*gconst23*gconst4*gconst9))+((gconst0*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst16*gconst24*gconst4))+((gconst14*gconst20*gconst3*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst2))+(((-1.0)*gconst0*gconst13*gconst23*gconst9))+(((-1.0)*gconst11*gconst15*gconst16*gconst3))+((gconst16*gconst18*gconst4*gconst7))+((gconst12*gconst2*gconst23*gconst9))+(((-1.0)*gconst12*gconst2*gconst26*gconst7))+((gconst10*gconst22*gconst7*gconst8))+(((-1.0)*gconst1*gconst13*gconst24*gconst8))+(((-1.0)*gconst15*gconst20*gconst3*gconst8))+(((-1.0)*gconst12*gconst20*gconst7*gconst8))+((gconst11*gconst12*gconst14*gconst9))+(((-1.0)*gconst10*gconst14*gconst17*gconst4))+((gconst13*gconst18*gconst7*gconst8))+((gconst10*gconst13*gconst15*gconst8))+(((-1.0)*gconst17*gconst18*gconst4*gconst5))+(((-1.0)*gconst10*gconst22*gconst5*gconst9))+(((-1.0)*gconst11*gconst21*gconst7*gconst8))+((gconst14*gconst2*gconst27*gconst3))+(((-1.0)*gconst1*gconst13*gconst26*gconst6))+(((-1.0)*gconst10*gconst27*gconst4*gconst5))+(((-1.0)*gconst14*gconst18*gconst4*gconst9))+((gconst0*gconst15*gconst26*gconst4))+((gconst15*gconst18*gconst4*gconst8))+(((-1.0)*gconst10*gconst13*gconst17*gconst5))+((gconst0*gconst13*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst5))+(((-1.0)*gconst11*gconst12*gconst16*gconst7))+((gconst11*gconst27*gconst3*gconst5))+((gconst0*gconst16*gconst22*gconst7)));
op[6]=((((-1.0)*gconst22*x68*x75))+(((-1.0)*gconst2*x69*x90))+((x79*x89))+((x110*x70))+((x100*x97))+(((-1.0)*gconst23*x74*x78))+((x79*x96))+((x117*x89))+(((-1.0)*gconst15*x68*x89))+((gconst23*gconst9*x77))+(((-1.0)*gconst15*x68*x96))+(((-1.0)*gconst13*x75*x82))+(((-1.0)*gconst5*x72*x74))+(((-1.0)*gconst2*x82*x84))+(((-1.0)*gconst9*x113*x78))+((x97*x98))+((gconst18*gconst8*x99))+((gconst25*gconst4*x70))+((x101*x77))+((x102*x105))+((x102*x104))+(((-1.0)*gconst25*x68*x77))+(((-1.0)*gconst10*x78*x79))+((x108*x99))+((x111*x87))+(((-1.0)*gconst20*x68*x69))+(((-1.0)*gconst14*x103*x74))+((x76*x77))+(((-1.0)*gconst10*x103*x97))+(((-1.0)*gconst4*x109*x68))+(((-1.0)*gconst0*x103*x79))+((x111*x92))+((gconst21*gconst5*x81))+(((-1.0)*gconst0*x101*x78))+(((-1.0)*gconst26*x75*x78))+(((-1.0)*gconst11*x68*x84))+((x104*x118))+((x80*x81))+((x70*x71))+(((-1.0)*gconst4*x68*x88))+(((-1.0)*gconst0*x76*x78))+(((-1.0)*gconst11*x69*x82))+(((-1.0)*gconst15*x77*x82))+(((-1.0)*gconst5*x78*x85))+(((-1.0)*gconst7*x68*x95)));
op[7]=((((-1.0)*gconst10*x78*x97))+((x89*x97))+(((-1.0)*gconst2*x69*x82))+(((-1.0)*gconst5*x103*x74))+(((-1.0)*gconst0*x78*x79))+((x117*x77))+((gconst12*gconst5*x81))+((x118*x70))+(((-1.0)*gconst2*x68*x84))+(((-1.0)*gconst13*x68*x75))+(((-1.0)*gconst11*x68*x69))+(((-1.0)*gconst14*x74*x78))+(((-1.0)*gconst15*x68*x77))+(((-1.0)*gconst16*x75*x78))+((x105*x99))+((x77*x79))+((x102*x70))+((x104*x99)));
op[8]=((((-1.0)*gconst5*x74*x78))+((x70*x99))+(((-1.0)*gconst2*x68*x69))+((x77*x97))+(((-1.0)*gconst4*x68*x75)));
polyroots8(op,zeror,numroots);
IkReal j15array[8], cj15array[8], sj15array[8], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[8]={true,true,true,true,true,true,true,true};
_nj15 = 8;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
IkReal dummyeval[1];
IkReal gconst44;
IkReal x124=((4.0)*sj17);
IkReal x125=((0.8)*sj17);
IkReal x126=(py*sj15);
IkReal x127=(cj15*px);
gconst44=IKsign(((((-1.0)*x124*(x126*x126)))+(((-8.0)*sj17*x126*x127))+((x125*x126))+((x125*x127))+(((-1.0)*x124*(pz*pz)))+(((-1.0)*x124*(x127*x127)))+(((-0.04)*sj17))));
IkReal x128=((20.0)*sj17);
IkReal x129=(cj15*px);
IkReal x130=(py*sj15);
IkReal x131=((100.0)*sj17);
dummyeval[0]=((((-1.0)*x131*(pz*pz)))+(((-1.0)*x131*(x129*x129)))+(((-1.0)*sj17))+((x128*x130))+(((-200.0)*sj17*x129*x130))+((x128*x129))+(((-1.0)*x131*(x130*x130))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x132=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x132;
evalcond[2]=x132;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst51;
IkReal x133=((321.0)*cj18);
IkReal x134=(cj15*px);
IkReal x135=(py*sj15);
gconst51=IKsign(((40.0)+(((-321.0)*pz*sj18))+(((32.1)*cj18))+(((-1.0)*x133*x134))+(((-1.0)*x133*x135))+(((-400.0)*x135))+(((-400.0)*x134))));
IkReal x136=(cj15*px);
IkReal x137=((10.0)*cj18);
IkReal x138=(py*sj15);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x138))+(((-12.4610591900312)*x136))+(((-10.0)*pz*sj18))+(((-1.0)*x137*x138))+(((-1.0)*x136*x137))+cj18);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x139=((10.0)*sj18);
dummyeval[0]=((((-1.0)*py*sj15*x139))+(((-1.0)*cj15*px*x139))+(((10.0)*cj18*pz))+sj18+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x140=IKsin(j16);
IkReal x141=IKcos(j16);
IkReal x142=(cj15*px);
IkReal x143=(py*sj15);
IkReal x144=((1.0)*x141);
IkReal x145=((0.8)*x141);
evalcond[0]=((0.721)*x140);
evalcond[1]=(((x140*x143))+((x140*x142))+(((-0.1)*x140)));
evalcond[2]=((0.721)+(((-1.0)*x143*x144))+(((-1.0)*x142*x144))+(((0.1)*x141)));
evalcond[3]=((-0.5768)+(((-0.08)*x141))+((x142*x145))+((x143*x145)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x846=IKsin(j16);
IkReal x847=IKcos(j16);
IkReal x848=(cj15*px);
IkReal x849=(py*sj15);
IkReal x850=((1.0)*x847);
IkReal x851=((0.8)*x847);
evalcond[0]=((0.079)*x846);
evalcond[1]=(((x846*x849))+((x846*x848))+(((-0.1)*x846)));
evalcond[2]=((0.079)+(((-1.0)*x849*x850))+(((-1.0)*x848*x850))+(((0.1)*x847)));
evalcond[3]=((-0.0632)+((x848*x851))+(((-0.08)*x847))+((x849*x851)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x852=((321000.0)*sj18);
IkReal x853=(py*sj15);
IkReal x854=(cj15*px);
IkReal x855=((1000.0)*pz);
IkReal x856=((321.0)*sj18);
IkReal x857=(cj18*pz);
CheckValue<IkReal> x858=IKPowWithIntegerCheck(((((-1.0)*x852*x853))+(((-1.0)*x852*x854))+(((400000.0)*pz))+(((32100.0)*sj18))+(((321000.0)*x857))),-1);
if(!x858.valid){
continue;
}
CheckValue<IkReal> x859=IKPowWithIntegerCheck(((((32.1)*sj18))+(((-1.0)*x853*x856))+(((321.0)*x857))+(((400.0)*pz))+(((-1.0)*x854*x856))),-1);
if(!x859.valid){
continue;
}
if( IKabs(((x858.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x859.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x854*x855))+((x853*x855)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x858.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x859.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x854*x855))+((x853*x855))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x858.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))), ((x859.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x854*x855))+((x853*x855))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x860=IKsin(j16);
IkReal x861=IKcos(j16);
IkReal x862=((0.321)*sj18);
IkReal x863=((0.321)*cj18);
IkReal x864=(py*sj15);
IkReal x865=(cj15*px);
IkReal x866=(pz*x860);
IkReal x867=(x861*x865);
evalcond[0]=(pz+((x861*x862))+(((0.4)*x860))+((x860*x863)));
evalcond[1]=((((-0.1)*x860))+((x860*x864))+((x860*x865))+((pz*x861))+x862);
evalcond[2]=((0.1)+(((-1.0)*x865))+(((-1.0)*x864))+(((-1.0)*x860*x862))+((x861*x863))+(((0.4)*x861)));
evalcond[3]=((0.4)+(((-1.0)*x867))+(((0.1)*x861))+(((-1.0)*x861*x864))+x866+x863);
evalcond[4]=((-0.066959)+(((-0.8)*x866))+(((0.2)*x864))+(((0.2)*x865))+(((-1.0)*pp))+(((0.8)*x861*x864))+(((0.8)*x867))+(((-0.08)*x861)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x868=((1000.0)*pz);
CheckValue<IkReal> x869 = IKatan2WithCheck((gconst51*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((cj15*px*x868))+((py*sj15*x868))+(((128.4)*sj18))))),(gconst51*(((-160.0)+(((-256.8)*cj18))+((pz*x868))+(((-103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x869.valid){
continue;
}
j16array[0]=x869.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x870=IKsin(j16);
IkReal x871=IKcos(j16);
IkReal x872=((0.321)*sj18);
IkReal x873=((0.321)*cj18);
IkReal x874=(py*sj15);
IkReal x875=(cj15*px);
IkReal x876=(pz*x870);
IkReal x877=(x871*x875);
evalcond[0]=(((x871*x872))+((x870*x873))+pz+(((0.4)*x870)));
evalcond[1]=(((x870*x875))+((x870*x874))+(((-0.1)*x870))+x872+((pz*x871)));
evalcond[2]=((0.1)+((x871*x873))+(((-1.0)*x874))+(((-1.0)*x875))+(((0.4)*x871))+(((-1.0)*x870*x872)));
evalcond[3]=((0.4)+(((0.1)*x871))+(((-1.0)*x877))+(((-1.0)*x871*x874))+x873+x876);
evalcond[4]=((-0.066959)+(((0.2)*x875))+(((0.2)*x874))+(((-0.8)*x876))+(((0.8)*x871*x874))+(((-1.0)*pp))+(((-0.08)*x871))+(((0.8)*x877)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x878=(cj15*py);
IkReal x879=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x878))+x879);
evalcond[2]=((((-1.0)*x879))+x878);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst52;
IkReal x880=((321.0)*cj18);
IkReal x881=(cj15*px);
IkReal x882=(py*sj15);
gconst52=IKsign(((-40.0)+(((-321.0)*pz*sj18))+((x880*x882))+((x880*x881))+(((-32.1)*cj18))+(((400.0)*x882))+(((400.0)*x881))));
IkReal x883=(py*sj15);
IkReal x884=((10.0)*cj18);
IkReal x885=(cj15*px);
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj18))+((x883*x884))+(((12.4610591900312)*x883))+(((12.4610591900312)*x885))+(((-1.0)*cj18))+((x884*x885)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x886=((10.0)*sj18);
dummyeval[0]=((((10.0)*cj18*pz))+(((-1.0)*sj18))+((py*sj15*x886))+((cj15*px*x886))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x887=IKsin(j16);
IkReal x888=IKcos(j16);
IkReal x889=((1.0)*py*sj15);
IkReal x890=((1.0)*cj15*px);
IkReal x891=((0.8)*x888);
evalcond[0]=((0.721)*x887);
evalcond[1]=((((-1.0)*x887*x889))+(((-1.0)*x887*x890))+(((0.1)*x887)));
evalcond[2]=((0.721)+(((-1.0)*x888*x890))+(((-1.0)*x888*x889))+(((0.1)*x888)));
evalcond[3]=((-0.5768)+((py*sj15*x891))+((cj15*px*x891))+(((-0.08)*x888)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x892=IKsin(j16);
IkReal x893=IKcos(j16);
IkReal x894=((1.0)*py*sj15);
IkReal x895=((1.0)*cj15*px);
IkReal x896=((0.8)*x893);
evalcond[0]=((0.079)*x892);
evalcond[1]=((((-1.0)*x892*x894))+(((-1.0)*x892*x895))+(((0.1)*x892)));
evalcond[2]=((0.079)+(((-1.0)*x893*x895))+(((-1.0)*x893*x894))+(((0.1)*x893)));
evalcond[3]=((-0.0632)+((py*sj15*x896))+((cj15*px*x896))+(((-0.08)*x893)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x897=((321000.0)*sj18);
IkReal x898=(py*sj15);
IkReal x899=(cj15*px);
IkReal x900=((1000.0)*pz);
IkReal x901=((321.0)*sj18);
IkReal x902=(cj18*pz);
CheckValue<IkReal> x903=IKPowWithIntegerCheck(((((321000.0)*x902))+(((400000.0)*pz))+((x897*x898))+((x897*x899))+(((-32100.0)*sj18))),-1);
if(!x903.valid){
continue;
}
CheckValue<IkReal> x904=IKPowWithIntegerCheck(((((400.0)*pz))+((x899*x901))+(((-32.1)*sj18))+((x898*x901))+(((321.0)*x902))),-1);
if(!x904.valid){
continue;
}
if( IKabs(((x903.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x904.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x899*x900))+((x898*x900))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x903.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x904.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x899*x900))+((x898*x900))+(((128.4)*sj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x903.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))), ((x904.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x899*x900))+((x898*x900))+(((128.4)*sj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x905=IKsin(j16);
IkReal x906=IKcos(j16);
IkReal x907=((0.321)*sj18);
IkReal x908=((0.321)*cj18);
IkReal x909=(cj15*px);
IkReal x910=(py*sj15);
IkReal x911=(pz*x905);
IkReal x912=((1.0)*x905);
IkReal x913=((1.0)*x906);
IkReal x914=(x906*x909);
evalcond[0]=(((x905*x908))+(((0.4)*x905))+pz+(((-1.0)*x906*x907)));
evalcond[1]=((0.1)+((x905*x907))+((x906*x908))+(((0.4)*x906))+(((-1.0)*x910))+(((-1.0)*x909)));
evalcond[2]=((0.4)+(((-1.0)*x910*x913))+x911+x908+(((0.1)*x906))+(((-1.0)*x909*x913)));
evalcond[3]=((((-1.0)*pz*x913))+(((-1.0)*x910*x912))+x907+(((0.1)*x905))+(((-1.0)*x909*x912)));
evalcond[4]=((-0.066959)+(((0.2)*x910))+(((0.2)*x909))+(((0.8)*x906*x910))+(((-0.08)*x906))+(((-1.0)*pp))+(((-0.8)*x911))+(((0.8)*x914)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x915=((1000.0)*pz);
CheckValue<IkReal> x916 = IKatan2WithCheck((gconst52*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*py*sj15*x915))+(((-1.0)*cj15*px*x915))+(((128.4)*sj18))))),(gconst52*(((160.0)+(((-1.0)*pz*x915))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x916.valid){
continue;
}
j16array[0]=x916.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x917=IKsin(j16);
IkReal x918=IKcos(j16);
IkReal x919=((0.321)*sj18);
IkReal x920=((0.321)*cj18);
IkReal x921=(cj15*px);
IkReal x922=(py*sj15);
IkReal x923=(pz*x917);
IkReal x924=((1.0)*x917);
IkReal x925=((1.0)*x918);
IkReal x926=(x918*x921);
evalcond[0]=((((-1.0)*x918*x919))+pz+((x917*x920))+(((0.4)*x917)));
evalcond[1]=((0.1)+((x918*x920))+((x917*x919))+(((-1.0)*x921))+(((-1.0)*x922))+(((0.4)*x918)));
evalcond[2]=((0.4)+(((0.1)*x918))+(((-1.0)*x921*x925))+x923+x920+(((-1.0)*x922*x925)));
evalcond[3]=((((-1.0)*pz*x925))+(((0.1)*x917))+(((-1.0)*x921*x924))+x919+(((-1.0)*x922*x924)));
evalcond[4]=((-0.066959)+(((-0.08)*x918))+(((0.2)*x921))+(((0.2)*x922))+(((-0.8)*x923))+(((0.8)*x926))+(((-1.0)*pp))+(((0.8)*x918*x922)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x927=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x927;
evalcond[2]=x927;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst53;
IkReal x928=((321.0)*cj18);
IkReal x929=(cj15*px);
IkReal x930=(py*sj15);
gconst53=IKsign(((40.0)+(((-321.0)*pz*sj18))+(((-1.0)*x928*x930))+(((-1.0)*x928*x929))+(((32.1)*cj18))+(((-400.0)*x930))+(((-400.0)*x929))));
IkReal x931=(cj15*px);
IkReal x932=((10.0)*cj18);
IkReal x933=(py*sj15);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x933))+(((-12.4610591900312)*x931))+(((-10.0)*pz*sj18))+(((-1.0)*x931*x932))+cj18+(((-1.0)*x932*x933)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x934=((10.0)*sj18);
dummyeval[0]=((((10.0)*cj18*pz))+sj18+(((-1.0)*cj15*px*x934))+(((-1.0)*py*sj15*x934))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x935=IKsin(j16);
IkReal x936=IKcos(j16);
IkReal x937=(cj15*px);
IkReal x938=(py*sj15);
IkReal x939=((1.0)*x936);
IkReal x940=((0.8)*x936);
evalcond[0]=((0.721)*x935);
evalcond[1]=((((-0.1)*x935))+((x935*x937))+((x935*x938)));
evalcond[2]=((0.721)+(((0.1)*x936))+(((-1.0)*x938*x939))+(((-1.0)*x937*x939)));
evalcond[3]=((-0.5768)+(((-0.08)*x936))+((x938*x940))+((x937*x940)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x941=IKsin(j16);
IkReal x942=IKcos(j16);
IkReal x943=(cj15*px);
IkReal x944=(py*sj15);
IkReal x945=((1.0)*x942);
IkReal x946=((0.8)*x942);
evalcond[0]=((0.079)*x941);
evalcond[1]=(((x941*x943))+((x941*x944))+(((-0.1)*x941)));
evalcond[2]=((0.079)+(((-1.0)*x944*x945))+(((-1.0)*x943*x945))+(((0.1)*x942)));
evalcond[3]=((-0.0632)+(((-0.08)*x942))+((x943*x946))+((x944*x946)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x947=((321000.0)*sj18);
IkReal x948=(py*sj15);
IkReal x949=(cj15*px);
IkReal x950=((1000.0)*pz);
IkReal x951=((321.0)*sj18);
IkReal x952=(cj18*pz);
CheckValue<IkReal> x953=IKPowWithIntegerCheck(((((-1.0)*x947*x948))+(((-1.0)*x947*x949))+(((400000.0)*pz))+(((32100.0)*sj18))+(((321000.0)*x952))),-1);
if(!x953.valid){
continue;
}
CheckValue<IkReal> x954=IKPowWithIntegerCheck(((((32.1)*sj18))+(((321.0)*x952))+(((400.0)*pz))+(((-1.0)*x949*x951))+(((-1.0)*x948*x951))),-1);
if(!x954.valid){
continue;
}
if( IKabs(((x953.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x954.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x949*x950))+((x948*x950)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x953.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x954.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x949*x950))+((x948*x950))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x953.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))), ((x954.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x949*x950))+((x948*x950))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x955=IKsin(j16);
IkReal x956=IKcos(j16);
IkReal x957=((0.321)*sj18);
IkReal x958=((0.321)*cj18);
IkReal x959=(py*sj15);
IkReal x960=(cj15*px);
IkReal x961=(pz*x955);
IkReal x962=(x956*x960);
evalcond[0]=(((x955*x958))+((x956*x957))+pz+(((0.4)*x955)));
evalcond[1]=(((x955*x959))+(((-0.1)*x955))+((pz*x956))+x957+((x955*x960)));
evalcond[2]=((0.1)+(((-1.0)*x960))+(((-1.0)*x959))+((x956*x958))+(((0.4)*x956))+(((-1.0)*x955*x957)));
evalcond[3]=((0.4)+(((0.1)*x956))+(((-1.0)*x962))+(((-1.0)*x956*x959))+x961+x958);
evalcond[4]=((-0.066959)+(((0.8)*x962))+(((-0.8)*x961))+(((-1.0)*pp))+(((0.2)*x959))+(((0.2)*x960))+(((-0.08)*x956))+(((0.8)*x956*x959)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x963=((1000.0)*pz);
CheckValue<IkReal> x964 = IKatan2WithCheck((gconst53*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((py*sj15*x963))+(((128.4)*sj18))+((cj15*px*x963))))),(gconst53*(((-160.0)+(((-256.8)*cj18))+((pz*x963))+(((-103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x964.valid){
continue;
}
j16array[0]=x964.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x965=IKsin(j16);
IkReal x966=IKcos(j16);
IkReal x967=((0.321)*sj18);
IkReal x968=((0.321)*cj18);
IkReal x969=(py*sj15);
IkReal x970=(cj15*px);
IkReal x971=(pz*x965);
IkReal x972=(x966*x970);
evalcond[0]=(((x965*x968))+pz+((x966*x967))+(((0.4)*x965)));
evalcond[1]=((((-0.1)*x965))+((x965*x970))+((pz*x966))+((x965*x969))+x967);
evalcond[2]=((0.1)+(((-1.0)*x970))+(((-1.0)*x965*x967))+(((-1.0)*x969))+((x966*x968))+(((0.4)*x966)));
evalcond[3]=((0.4)+(((-1.0)*x972))+(((0.1)*x966))+x971+x968+(((-1.0)*x966*x969)));
evalcond[4]=((-0.066959)+(((-0.8)*x971))+(((-1.0)*pp))+(((0.8)*x966*x969))+(((0.2)*x970))+(((0.2)*x969))+(((-0.08)*x966))+(((0.8)*x972)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x973=(cj15*py);
IkReal x974=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((((-1.0)*x973))+x974);
evalcond[2]=((((-1.0)*x974))+x973);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst54;
IkReal x975=((321.0)*cj18);
IkReal x976=(cj15*px);
IkReal x977=(py*sj15);
gconst54=IKsign(((-40.0)+((x975*x976))+((x975*x977))+(((-321.0)*pz*sj18))+(((400.0)*x976))+(((400.0)*x977))+(((-32.1)*cj18))));
IkReal x978=(py*sj15);
IkReal x979=((10.0)*cj18);
IkReal x980=(cj15*px);
dummyeval[0]=((-1.24610591900312)+((x978*x979))+(((-10.0)*pz*sj18))+((x979*x980))+(((-1.0)*cj18))+(((12.4610591900312)*x978))+(((12.4610591900312)*x980)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x981=((10.0)*sj18);
dummyeval[0]=(((cj15*px*x981))+(((10.0)*cj18*pz))+((py*sj15*x981))+(((-1.0)*sj18))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x982=IKsin(j16);
IkReal x983=IKcos(j16);
IkReal x984=((1.0)*py*sj15);
IkReal x985=((1.0)*cj15*px);
IkReal x986=((0.8)*x983);
evalcond[0]=((0.721)*x982);
evalcond[1]=((((0.1)*x982))+(((-1.0)*x982*x984))+(((-1.0)*x982*x985)));
evalcond[2]=((0.721)+(((0.1)*x983))+(((-1.0)*x983*x984))+(((-1.0)*x983*x985)));
evalcond[3]=((-0.5768)+((cj15*px*x986))+((py*sj15*x986))+(((-0.08)*x983)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x987=IKsin(j16);
IkReal x988=IKcos(j16);
IkReal x989=((1.0)*py*sj15);
IkReal x990=((1.0)*cj15*px);
IkReal x991=((0.8)*x988);
evalcond[0]=((0.079)*x987);
evalcond[1]=((((0.1)*x987))+(((-1.0)*x987*x989))+(((-1.0)*x987*x990)));
evalcond[2]=((0.079)+(((0.1)*x988))+(((-1.0)*x988*x989))+(((-1.0)*x988*x990)));
evalcond[3]=((-0.0632)+((cj15*px*x991))+((py*sj15*x991))+(((-0.08)*x988)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x992=((321000.0)*sj18);
IkReal x993=(py*sj15);
IkReal x994=(cj15*px);
IkReal x995=((1000.0)*pz);
IkReal x996=((321.0)*sj18);
IkReal x997=(cj18*pz);
CheckValue<IkReal> x998=IKPowWithIntegerCheck(((((321000.0)*x997))+((x992*x994))+((x992*x993))+(((400000.0)*pz))+(((-32100.0)*sj18))),-1);
if(!x998.valid){
continue;
}
CheckValue<IkReal> x999=IKPowWithIntegerCheck((((x993*x996))+((x994*x996))+(((400.0)*pz))+(((321.0)*x997))+(((-32.1)*sj18))),-1);
if(!x999.valid){
continue;
}
if( IKabs(((x998.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x999.value)*((((x993*x995))+(((-100.0)*pz))+((x994*x995))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x998.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x999.value)*((((x993*x995))+(((-100.0)*pz))+((x994*x995))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x998.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))), ((x999.value)*((((x993*x995))+(((-100.0)*pz))+((x994*x995))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1000=IKsin(j16);
IkReal x1001=IKcos(j16);
IkReal x1002=((0.321)*sj18);
IkReal x1003=((0.321)*cj18);
IkReal x1004=(cj15*px);
IkReal x1005=(py*sj15);
IkReal x1006=(pz*x1000);
IkReal x1007=((1.0)*x1000);
IkReal x1008=((1.0)*x1001);
IkReal x1009=(x1001*x1004);
evalcond[0]=((((0.4)*x1000))+((x1000*x1003))+pz+(((-1.0)*x1001*x1002)));
evalcond[1]=((0.1)+(((-1.0)*x1005))+(((-1.0)*x1004))+(((0.4)*x1001))+((x1000*x1002))+((x1001*x1003)));
evalcond[2]=((0.4)+(((0.1)*x1001))+x1006+x1003+(((-1.0)*x1005*x1008))+(((-1.0)*x1004*x1008)));
evalcond[3]=((((0.1)*x1000))+(((-1.0)*pz*x1008))+x1002+(((-1.0)*x1005*x1007))+(((-1.0)*x1004*x1007)));
evalcond[4]=((-0.066959)+(((0.2)*x1004))+(((0.2)*x1005))+(((0.8)*x1001*x1005))+(((-0.08)*x1001))+(((-1.0)*pp))+(((0.8)*x1009))+(((-0.8)*x1006)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1010=((1000.0)*pz);
CheckValue<IkReal> x1011 = IKatan2WithCheck((gconst54*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*cj15*px*x1010))+(((-1.0)*py*sj15*x1010))+(((128.4)*sj18))))),(gconst54*(((160.0)+(((-1.0)*pz*x1010))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1011.valid){
continue;
}
j16array[0]=x1011.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1012=IKsin(j16);
IkReal x1013=IKcos(j16);
IkReal x1014=((0.321)*sj18);
IkReal x1015=((0.321)*cj18);
IkReal x1016=(cj15*px);
IkReal x1017=(py*sj15);
IkReal x1018=(pz*x1012);
IkReal x1019=((1.0)*x1012);
IkReal x1020=((1.0)*x1013);
IkReal x1021=(x1013*x1016);
evalcond[0]=((((0.4)*x1012))+((x1012*x1015))+pz+(((-1.0)*x1013*x1014)));
evalcond[1]=((0.1)+(((0.4)*x1013))+((x1013*x1015))+((x1012*x1014))+(((-1.0)*x1016))+(((-1.0)*x1017)));
evalcond[2]=((0.4)+x1018+x1015+(((-1.0)*x1016*x1020))+(((-1.0)*x1017*x1020))+(((0.1)*x1013)));
evalcond[3]=((((-1.0)*pz*x1020))+x1014+(((-1.0)*x1017*x1019))+(((-1.0)*x1016*x1019))+(((0.1)*x1012)));
evalcond[4]=((-0.066959)+(((-0.08)*x1013))+(((-1.0)*pp))+(((0.8)*x1013*x1017))+(((-0.8)*x1018))+(((0.2)*x1017))+(((0.2)*x1016))+(((0.8)*x1021)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1022=((-1.0)*cj15*py);
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x1022;
evalcond[2]=x1022;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*pz*sj18))+cj18);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst55;
CheckValue<IkReal> x1023 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1023.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1024=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1024.valid){
continue;
}
if( (((1.24610591900312)*(x1024.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1024.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst55=((((-1.0)*(x1023.value)))+(((-1.0)*(IKasin(((1.24610591900312)*(x1024.value)))))));
IkReal gconst56;
gconst56=IKsin(gconst55);
IkReal gconst57;
gconst57=IKcos(gconst55);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst55))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst57))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst57+(((-10.0)*gconst56*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1025=(gconst56*pz);
CheckValue<IkReal> x1026=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1025))+(((32.1)*gconst57))),-1);
if(!x1026.valid){
continue;
}
CheckValue<IkReal> x1027=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst57))+(((-321000.0)*x1025))),-1);
if(!x1027.valid){
continue;
}
if( IKabs(((x1026.value)*(((((-100.0)*pz))+(((128.4)*gconst56))+(((103.041)*gconst56*gconst57)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1027.value)*(((-10000.0)+(((103041.0)*(gconst56*gconst56))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1026.value)*(((((-100.0)*pz))+(((128.4)*gconst56))+(((103.041)*gconst56*gconst57))))))+IKsqr(((x1027.value)*(((-10000.0)+(((103041.0)*(gconst56*gconst56)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1026.value)*(((((-100.0)*pz))+(((128.4)*gconst56))+(((103.041)*gconst56*gconst57))))), ((x1027.value)*(((-10000.0)+(((103041.0)*(gconst56*gconst56)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1028=IKcos(j16);
IkReal x1029=IKsin(j16);
IkReal x1030=((0.321)*gconst56);
IkReal x1031=((0.321)*gconst57);
IkReal x1032=(pz*x1029);
evalcond[0]=(x1030+(((-0.1)*x1029))+((pz*x1028)));
evalcond[1]=((0.4)+x1032+x1031+(((0.1)*x1028)));
evalcond[2]=((-0.32)+(((-0.08)*x1028))+(((-0.2568)*gconst57))+(((-0.8)*x1032)));
evalcond[3]=((((0.4)*x1029))+((x1028*x1030))+((x1029*x1031))+pz);
evalcond[4]=((0.1)+(((0.4)*x1028))+(((-1.0)*x1029*x1030))+((x1028*x1031)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1033=pz*pz;
IkReal x1034=((321.0)*gconst56);
CheckValue<IkReal> x1035=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1033))),-1);
if(!x1035.valid){
continue;
}
CheckValue<IkReal> x1036=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1033))),-1);
if(!x1036.valid){
continue;
}
if( IKabs(((x1035.value)*(((((-3210.0)*gconst57*pz))+x1034+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1036.value)*(((-40.0)+(((-1.0)*pz*x1034))+(((-32.1)*gconst57)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1035.value)*(((((-3210.0)*gconst57*pz))+x1034+(((-4000.0)*pz))))))+IKsqr(((x1036.value)*(((-40.0)+(((-1.0)*pz*x1034))+(((-32.1)*gconst57))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1035.value)*(((((-3210.0)*gconst57*pz))+x1034+(((-4000.0)*pz))))), ((x1036.value)*(((-40.0)+(((-1.0)*pz*x1034))+(((-32.1)*gconst57))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1037=IKcos(j16);
IkReal x1038=IKsin(j16);
IkReal x1039=((0.321)*gconst56);
IkReal x1040=((0.321)*gconst57);
IkReal x1041=(pz*x1038);
evalcond[0]=((((-0.1)*x1038))+x1039+((pz*x1037)));
evalcond[1]=((0.4)+(((0.1)*x1037))+x1041+x1040);
evalcond[2]=((-0.32)+(((-0.08)*x1037))+(((-0.8)*x1041))+(((-0.2568)*gconst57)));
evalcond[3]=((((0.4)*x1038))+((x1038*x1040))+pz+((x1037*x1039)));
evalcond[4]=((0.1)+(((0.4)*x1037))+((x1037*x1040))+(((-1.0)*x1038*x1039)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1042=pz*pz;
IkReal x1043=((321.0)*gconst56);
CheckValue<IkReal> x1044=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1042))),-1);
if(!x1044.valid){
continue;
}
CheckValue<IkReal> x1045=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1042))),-1);
if(!x1045.valid){
continue;
}
if( IKabs(((x1044.value)*(((((-3210.0)*gconst57*pz))+x1043+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1045.value)*(((40.0)+((pz*x1043))+(((32.1)*gconst57)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1044.value)*(((((-3210.0)*gconst57*pz))+x1043+(((-4000.0)*pz))))))+IKsqr(((x1045.value)*(((40.0)+((pz*x1043))+(((32.1)*gconst57))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1044.value)*(((((-3210.0)*gconst57*pz))+x1043+(((-4000.0)*pz))))), ((x1045.value)*(((40.0)+((pz*x1043))+(((32.1)*gconst57))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1046=IKcos(j16);
IkReal x1047=IKsin(j16);
IkReal x1048=((0.321)*gconst56);
IkReal x1049=((0.321)*gconst57);
IkReal x1050=(pz*x1047);
evalcond[0]=(x1048+(((-0.1)*x1047))+((pz*x1046)));
evalcond[1]=((0.4)+x1050+x1049+(((0.1)*x1046)));
evalcond[2]=((-0.32)+(((-0.8)*x1050))+(((-0.2568)*gconst57))+(((-0.08)*x1046)));
evalcond[3]=((((0.4)*x1047))+pz+((x1047*x1049))+((x1046*x1048)));
evalcond[4]=((0.1)+(((0.4)*x1046))+(((-1.0)*x1047*x1048))+((x1046*x1049)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst58;
CheckValue<IkReal> x1051 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1051.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1052=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1052.valid){
continue;
}
if( (((1.24610591900312)*(x1052.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1052.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst58=((3.14159265358979)+(((-1.0)*(x1051.value)))+(IKasin(((1.24610591900312)*(x1052.value)))));
IkReal gconst59;
gconst59=IKsin(gconst58);
IkReal gconst60;
gconst60=IKcos(gconst58);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst58))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst60))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst60+(((-10.0)*gconst59*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1053=(gconst59*pz);
CheckValue<IkReal> x1054=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1053))+(((32.1)*gconst60))),-1);
if(!x1054.valid){
continue;
}
CheckValue<IkReal> x1055=IKPowWithIntegerCheck(((40000.0)+(((-321000.0)*x1053))+(((32100.0)*gconst60))),-1);
if(!x1055.valid){
continue;
}
if( IKabs(((x1054.value)*(((((-100.0)*pz))+(((103.041)*gconst59*gconst60))+(((128.4)*gconst59)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1055.value)*(((-10000.0)+(((103041.0)*(gconst59*gconst59))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1054.value)*(((((-100.0)*pz))+(((103.041)*gconst59*gconst60))+(((128.4)*gconst59))))))+IKsqr(((x1055.value)*(((-10000.0)+(((103041.0)*(gconst59*gconst59)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1054.value)*(((((-100.0)*pz))+(((103.041)*gconst59*gconst60))+(((128.4)*gconst59))))), ((x1055.value)*(((-10000.0)+(((103041.0)*(gconst59*gconst59)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1056=IKcos(j16);
IkReal x1057=IKsin(j16);
IkReal x1058=((0.321)*gconst59);
IkReal x1059=((0.321)*gconst60);
IkReal x1060=(pz*x1057);
evalcond[0]=(x1058+(((-0.1)*x1057))+((pz*x1056)));
evalcond[1]=((0.4)+x1059+x1060+(((0.1)*x1056)));
evalcond[2]=((-0.32)+(((-0.08)*x1056))+(((-0.8)*x1060))+(((-0.2568)*gconst60)));
evalcond[3]=(((x1056*x1058))+((x1057*x1059))+(((0.4)*x1057))+pz);
evalcond[4]=((0.1)+((x1056*x1059))+(((0.4)*x1056))+(((-1.0)*x1057*x1058)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1061=pz*pz;
IkReal x1062=((321.0)*gconst59);
CheckValue<IkReal> x1063=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1061))),-1);
if(!x1063.valid){
continue;
}
CheckValue<IkReal> x1064=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1061))),-1);
if(!x1064.valid){
continue;
}
if( IKabs(((x1063.value)*(((((-3210.0)*gconst60*pz))+x1062+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1064.value)*(((-40.0)+(((-1.0)*pz*x1062))+(((-32.1)*gconst60)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1063.value)*(((((-3210.0)*gconst60*pz))+x1062+(((-4000.0)*pz))))))+IKsqr(((x1064.value)*(((-40.0)+(((-1.0)*pz*x1062))+(((-32.1)*gconst60))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1063.value)*(((((-3210.0)*gconst60*pz))+x1062+(((-4000.0)*pz))))), ((x1064.value)*(((-40.0)+(((-1.0)*pz*x1062))+(((-32.1)*gconst60))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1065=IKcos(j16);
IkReal x1066=IKsin(j16);
IkReal x1067=((0.321)*gconst59);
IkReal x1068=((0.321)*gconst60);
IkReal x1069=(pz*x1066);
evalcond[0]=(x1067+(((-0.1)*x1066))+((pz*x1065)));
evalcond[1]=((0.4)+x1069+x1068+(((0.1)*x1065)));
evalcond[2]=((-0.32)+(((-0.08)*x1065))+(((-0.8)*x1069))+(((-0.2568)*gconst60)));
evalcond[3]=((((0.4)*x1066))+((x1066*x1068))+pz+((x1065*x1067)));
evalcond[4]=((0.1)+(((0.4)*x1065))+(((-1.0)*x1066*x1067))+((x1065*x1068)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1070=pz*pz;
IkReal x1071=((321.0)*gconst59);
CheckValue<IkReal> x1072=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1070))),-1);
if(!x1072.valid){
continue;
}
CheckValue<IkReal> x1073=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1070))),-1);
if(!x1073.valid){
continue;
}
if( IKabs(((x1072.value)*(((((-3210.0)*gconst60*pz))+x1071+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1073.value)*(((40.0)+((pz*x1071))+(((32.1)*gconst60)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1072.value)*(((((-3210.0)*gconst60*pz))+x1071+(((-4000.0)*pz))))))+IKsqr(((x1073.value)*(((40.0)+((pz*x1071))+(((32.1)*gconst60))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1072.value)*(((((-3210.0)*gconst60*pz))+x1071+(((-4000.0)*pz))))), ((x1073.value)*(((40.0)+((pz*x1071))+(((32.1)*gconst60))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1074=IKcos(j16);
IkReal x1075=IKsin(j16);
IkReal x1076=((0.321)*gconst59);
IkReal x1077=((0.321)*gconst60);
IkReal x1078=(pz*x1075);
evalcond[0]=(x1076+((pz*x1074))+(((-0.1)*x1075)));
evalcond[1]=((0.4)+x1078+x1077+(((0.1)*x1074)));
evalcond[2]=((-0.32)+(((-0.08)*x1074))+(((-0.8)*x1078))+(((-0.2568)*gconst60)));
evalcond[3]=(((x1074*x1076))+(((0.4)*x1075))+((x1075*x1077))+pz);
evalcond[4]=((0.1)+(((-1.0)*x1075*x1076))+((x1074*x1077))+(((0.4)*x1074)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1079=(pz*sj18);
CheckValue<IkReal> x1080=IKPowWithIntegerCheck(((40.0)+(((32.1)*cj18))+(((-321.0)*x1079))),-1);
if(!x1080.valid){
continue;
}
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((-321000.0)*x1079))),-1);
if(!x1081.valid){
continue;
}
if( IKabs(((x1080.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1081.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1080.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1081.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1080.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1081.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1082=IKcos(j16);
IkReal x1083=IKsin(j16);
IkReal x1084=((0.321)*sj18);
IkReal x1085=((0.321)*cj18);
IkReal x1086=(pz*x1083);
evalcond[0]=(((pz*x1082))+x1084+(((-0.1)*x1083)));
evalcond[1]=((0.4)+x1086+x1085+(((0.1)*x1082)));
evalcond[2]=((-0.066959)+(((-0.8)*x1086))+(((-1.0)*pp))+(((-0.08)*x1082)));
evalcond[3]=(((x1082*x1084))+pz+(((0.4)*x1083))+((x1083*x1085)));
evalcond[4]=((0.1)+((x1082*x1085))+(((0.4)*x1082))+(((-1.0)*x1083*x1084)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1087=pz*pz;
IkReal x1088=((321.0)*sj18);
CheckValue<IkReal> x1089=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1087))),-1);
if(!x1089.valid){
continue;
}
CheckValue<IkReal> x1090=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1087))),-1);
if(!x1090.valid){
continue;
}
if( IKabs(((x1089.value)*(((((-836.9875)*pz))+x1088+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1090.value)*(((-8.369875)+(((-1.0)*pz*x1088))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1089.value)*(((((-836.9875)*pz))+x1088+(((-12500.0)*pp*pz))))))+IKsqr(((x1090.value)*(((-8.369875)+(((-1.0)*pz*x1088))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1089.value)*(((((-836.9875)*pz))+x1088+(((-12500.0)*pp*pz))))), ((x1090.value)*(((-8.369875)+(((-1.0)*pz*x1088))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1091=IKcos(j16);
IkReal x1092=IKsin(j16);
IkReal x1093=((0.321)*sj18);
IkReal x1094=((0.321)*cj18);
IkReal x1095=(pz*x1092);
evalcond[0]=(x1093+((pz*x1091))+(((-0.1)*x1092)));
evalcond[1]=((0.4)+x1094+x1095+(((0.1)*x1091)));
evalcond[2]=((-0.066959)+(((-0.8)*x1095))+(((-1.0)*pp))+(((-0.08)*x1091)));
evalcond[3]=(pz+((x1092*x1094))+((x1091*x1093))+(((0.4)*x1092)));
evalcond[4]=((0.1)+(((-1.0)*x1092*x1093))+((x1091*x1094))+(((0.4)*x1091)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1096=pz*pz;
IkReal x1097=((321.0)*sj18);
CheckValue<IkReal> x1098=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1096))),-1);
if(!x1098.valid){
continue;
}
CheckValue<IkReal> x1099=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1096))),-1);
if(!x1099.valid){
continue;
}
if( IKabs(((x1098.value)*(((((-3210.0)*cj18*pz))+x1097+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1099.value)*(((40.0)+(((32.1)*cj18))+((pz*x1097)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1098.value)*(((((-3210.0)*cj18*pz))+x1097+(((-4000.0)*pz))))))+IKsqr(((x1099.value)*(((40.0)+(((32.1)*cj18))+((pz*x1097))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1098.value)*(((((-3210.0)*cj18*pz))+x1097+(((-4000.0)*pz))))), ((x1099.value)*(((40.0)+(((32.1)*cj18))+((pz*x1097))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1100=IKcos(j16);
IkReal x1101=IKsin(j16);
IkReal x1102=((0.321)*sj18);
IkReal x1103=((0.321)*cj18);
IkReal x1104=(pz*x1101);
evalcond[0]=(x1102+((pz*x1100))+(((-0.1)*x1101)));
evalcond[1]=((0.4)+x1104+x1103+(((0.1)*x1100)));
evalcond[2]=((-0.066959)+(((-0.8)*x1104))+(((-0.08)*x1100))+(((-1.0)*pp)));
evalcond[3]=(((x1101*x1103))+pz+(((0.4)*x1101))+((x1100*x1102)));
evalcond[4]=((0.1)+(((0.4)*x1100))+((x1100*x1103))+(((-1.0)*x1101*x1102)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1105=(cj15*py);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=((-1.0)*x1105);
evalcond[2]=x1105;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj18))+(((-1.0)*cj18)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst61;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1106=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1106.valid){
continue;
}
if( (((1.24610591900312)*(x1106.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1106.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1107 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1107.valid){
continue;
}
gconst61=((IKasin(((1.24610591900312)*(x1106.value))))+(((-1.0)*(x1107.value))));
IkReal gconst62;
gconst62=IKsin(gconst61);
IkReal gconst63;
gconst63=IKcos(gconst61);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst61))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst63))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst63))+(((-10.0)*gconst62*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1108=(gconst62*pz);
CheckValue<IkReal> x1109=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1108))+(((-32.1)*gconst63))),-1);
if(!x1109.valid){
continue;
}
CheckValue<IkReal> x1110=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst63))+(((321000.0)*x1108))),-1);
if(!x1110.valid){
continue;
}
if( IKabs(((x1109.value)*(((((100.0)*pz))+(((103.041)*gconst62*gconst63))+(((128.4)*gconst62)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1110.value)*(((-10000.0)+(((103041.0)*(gconst62*gconst62))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1109.value)*(((((100.0)*pz))+(((103.041)*gconst62*gconst63))+(((128.4)*gconst62))))))+IKsqr(((x1110.value)*(((-10000.0)+(((103041.0)*(gconst62*gconst62)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1109.value)*(((((100.0)*pz))+(((103.041)*gconst62*gconst63))+(((128.4)*gconst62))))), ((x1110.value)*(((-10000.0)+(((103041.0)*(gconst62*gconst62)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1111=IKsin(j16);
IkReal x1112=IKcos(j16);
IkReal x1113=((0.321)*gconst63);
IkReal x1114=((0.321)*gconst62);
IkReal x1115=(pz*x1111);
evalcond[0]=((0.4)+x1113+x1115+(((0.1)*x1112)));
evalcond[1]=((((-1.0)*pz*x1112))+x1114+(((0.1)*x1111)));
evalcond[2]=((-0.32)+(((-0.8)*x1115))+(((-0.08)*x1112))+(((-0.2568)*gconst63)));
evalcond[3]=(((x1111*x1113))+(((-1.0)*x1112*x1114))+pz+(((0.4)*x1111)));
evalcond[4]=((0.1)+((x1111*x1114))+((x1112*x1113))+(((0.4)*x1112)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1116=pz*pz;
IkReal x1117=((321.0)*gconst62);
CheckValue<IkReal> x1118=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1116))),-1);
if(!x1118.valid){
continue;
}
CheckValue<IkReal> x1119=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1116))),-1);
if(!x1119.valid){
continue;
}
if( IKabs(((x1118.value)*(((((-3210.0)*gconst63*pz))+(((-4000.0)*pz))+(((-1.0)*x1117)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1119.value)*(((-40.0)+((pz*x1117))+(((-32.1)*gconst63)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1118.value)*(((((-3210.0)*gconst63*pz))+(((-4000.0)*pz))+(((-1.0)*x1117))))))+IKsqr(((x1119.value)*(((-40.0)+((pz*x1117))+(((-32.1)*gconst63))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1118.value)*(((((-3210.0)*gconst63*pz))+(((-4000.0)*pz))+(((-1.0)*x1117))))), ((x1119.value)*(((-40.0)+((pz*x1117))+(((-32.1)*gconst63))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1120=IKsin(j16);
IkReal x1121=IKcos(j16);
IkReal x1122=((0.321)*gconst63);
IkReal x1123=((0.321)*gconst62);
IkReal x1124=(pz*x1120);
evalcond[0]=((0.4)+x1122+x1124+(((0.1)*x1121)));
evalcond[1]=(x1123+(((-1.0)*pz*x1121))+(((0.1)*x1120)));
evalcond[2]=((-0.32)+(((-0.8)*x1124))+(((-0.2568)*gconst63))+(((-0.08)*x1121)));
evalcond[3]=(((x1120*x1122))+(((-1.0)*x1121*x1123))+pz+(((0.4)*x1120)));
evalcond[4]=((0.1)+((x1120*x1123))+((x1121*x1122))+(((0.4)*x1121)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1125=pz*pz;
IkReal x1126=((321.0)*gconst62);
CheckValue<IkReal> x1127=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1125))),-1);
if(!x1127.valid){
continue;
}
CheckValue<IkReal> x1128=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1125))),-1);
if(!x1128.valid){
continue;
}
if( IKabs(((x1127.value)*((x1126+(((4000.0)*pz))+(((3210.0)*gconst63*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1128.value)*(((-40.0)+((pz*x1126))+(((-32.1)*gconst63)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1127.value)*((x1126+(((4000.0)*pz))+(((3210.0)*gconst63*pz))))))+IKsqr(((x1128.value)*(((-40.0)+((pz*x1126))+(((-32.1)*gconst63))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1127.value)*((x1126+(((4000.0)*pz))+(((3210.0)*gconst63*pz))))), ((x1128.value)*(((-40.0)+((pz*x1126))+(((-32.1)*gconst63))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1129=IKsin(j16);
IkReal x1130=IKcos(j16);
IkReal x1131=((0.321)*gconst63);
IkReal x1132=((0.321)*gconst62);
IkReal x1133=(pz*x1129);
evalcond[0]=((0.4)+x1133+x1131+(((0.1)*x1130)));
evalcond[1]=(x1132+(((-1.0)*pz*x1130))+(((0.1)*x1129)));
evalcond[2]=((-0.32)+(((-0.08)*x1130))+(((-0.8)*x1133))+(((-0.2568)*gconst63)));
evalcond[3]=(((x1129*x1131))+(((-1.0)*x1130*x1132))+pz+(((0.4)*x1129)));
evalcond[4]=((0.1)+((x1130*x1131))+((x1129*x1132))+(((0.4)*x1130)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst64;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1134=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1134.valid){
continue;
}
if( (((1.24610591900312)*(x1134.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1134.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1135 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1135.valid){
continue;
}
gconst64=((3.14159265358979)+(((-1.0)*(IKasin(((1.24610591900312)*(x1134.value))))))+(((-1.0)*(x1135.value))));
IkReal gconst65;
gconst65=IKsin(gconst64);
IkReal gconst66;
gconst66=IKcos(gconst64);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst64))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst66))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*gconst65*pz))+(((-1.0)*gconst66)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1136=(gconst65*pz);
CheckValue<IkReal> x1137=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1136))+(((-32.1)*gconst66))),-1);
if(!x1137.valid){
continue;
}
CheckValue<IkReal> x1138=IKPowWithIntegerCheck(((40000.0)+(((321000.0)*x1136))+(((32100.0)*gconst66))),-1);
if(!x1138.valid){
continue;
}
if( IKabs(((x1137.value)*(((((100.0)*pz))+(((128.4)*gconst65))+(((103.041)*gconst65*gconst66)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1138.value)*(((-10000.0)+(((103041.0)*(gconst65*gconst65))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1137.value)*(((((100.0)*pz))+(((128.4)*gconst65))+(((103.041)*gconst65*gconst66))))))+IKsqr(((x1138.value)*(((-10000.0)+(((103041.0)*(gconst65*gconst65)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1137.value)*(((((100.0)*pz))+(((128.4)*gconst65))+(((103.041)*gconst65*gconst66))))), ((x1138.value)*(((-10000.0)+(((103041.0)*(gconst65*gconst65)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1139=IKsin(j16);
IkReal x1140=IKcos(j16);
IkReal x1141=((0.321)*gconst65);
IkReal x1142=((0.321)*gconst66);
IkReal x1143=(pz*x1139);
evalcond[0]=((0.4)+x1142+x1143+(((0.1)*x1140)));
evalcond[1]=(x1141+(((-1.0)*pz*x1140))+(((0.1)*x1139)));
evalcond[2]=((-0.32)+(((-0.8)*x1143))+(((-0.08)*x1140))+(((-0.2568)*gconst66)));
evalcond[3]=((((-1.0)*x1140*x1141))+(((0.4)*x1139))+pz+((x1139*x1142)));
evalcond[4]=((0.1)+((x1140*x1142))+((x1139*x1141))+(((0.4)*x1140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1144=pz*pz;
IkReal x1145=((321.0)*gconst65);
CheckValue<IkReal> x1146=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1144))),-1);
if(!x1146.valid){
continue;
}
CheckValue<IkReal> x1147=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1144))),-1);
if(!x1147.valid){
continue;
}
if( IKabs(((x1146.value)*(((((-1.0)*x1145))+(((-4000.0)*pz))+(((-3210.0)*gconst66*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1147.value)*(((-40.0)+((pz*x1145))+(((-32.1)*gconst66)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1146.value)*(((((-1.0)*x1145))+(((-4000.0)*pz))+(((-3210.0)*gconst66*pz))))))+IKsqr(((x1147.value)*(((-40.0)+((pz*x1145))+(((-32.1)*gconst66))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1146.value)*(((((-1.0)*x1145))+(((-4000.0)*pz))+(((-3210.0)*gconst66*pz))))), ((x1147.value)*(((-40.0)+((pz*x1145))+(((-32.1)*gconst66))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1148=IKsin(j16);
IkReal x1149=IKcos(j16);
IkReal x1150=((0.321)*gconst65);
IkReal x1151=((0.321)*gconst66);
IkReal x1152=(pz*x1148);
evalcond[0]=((0.4)+x1151+x1152+(((0.1)*x1149)));
evalcond[1]=(x1150+(((-1.0)*pz*x1149))+(((0.1)*x1148)));
evalcond[2]=((-0.32)+(((-0.08)*x1149))+(((-0.8)*x1152))+(((-0.2568)*gconst66)));
evalcond[3]=((((-1.0)*x1149*x1150))+pz+((x1148*x1151))+(((0.4)*x1148)));
evalcond[4]=((0.1)+((x1149*x1151))+((x1148*x1150))+(((0.4)*x1149)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1153=pz*pz;
IkReal x1154=((321.0)*gconst65);
CheckValue<IkReal> x1155=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1153))),-1);
if(!x1155.valid){
continue;
}
CheckValue<IkReal> x1156=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1153))),-1);
if(!x1156.valid){
continue;
}
if( IKabs(((x1155.value)*((x1154+(((4000.0)*pz))+(((3210.0)*gconst66*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1156.value)*(((-40.0)+((pz*x1154))+(((-32.1)*gconst66)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1155.value)*((x1154+(((4000.0)*pz))+(((3210.0)*gconst66*pz))))))+IKsqr(((x1156.value)*(((-40.0)+((pz*x1154))+(((-32.1)*gconst66))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1155.value)*((x1154+(((4000.0)*pz))+(((3210.0)*gconst66*pz))))), ((x1156.value)*(((-40.0)+((pz*x1154))+(((-32.1)*gconst66))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1157=IKsin(j16);
IkReal x1158=IKcos(j16);
IkReal x1159=((0.321)*gconst65);
IkReal x1160=((0.321)*gconst66);
IkReal x1161=(pz*x1157);
evalcond[0]=((0.4)+(((0.1)*x1158))+x1160+x1161);
evalcond[1]=((((0.1)*x1157))+x1159+(((-1.0)*pz*x1158)));
evalcond[2]=((-0.32)+(((-0.08)*x1158))+(((-0.2568)*gconst66))+(((-0.8)*x1161)));
evalcond[3]=((((-1.0)*x1158*x1159))+((x1157*x1160))+pz+(((0.4)*x1157)));
evalcond[4]=((0.1)+(((0.4)*x1158))+((x1158*x1160))+((x1157*x1159)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1162=(pz*sj18);
CheckValue<IkReal> x1163=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1162))+(((-32.1)*cj18))),-1);
if(!x1163.valid){
continue;
}
CheckValue<IkReal> x1164=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((321000.0)*x1162))),-1);
if(!x1164.valid){
continue;
}
if( IKabs(((x1163.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1164.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1163.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1164.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1163.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1164.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1165=IKsin(j16);
IkReal x1166=IKcos(j16);
IkReal x1167=((0.321)*sj18);
IkReal x1168=((0.321)*cj18);
IkReal x1169=(pz*x1165);
evalcond[0]=((0.4)+x1168+x1169+(((0.1)*x1166)));
evalcond[1]=(x1167+(((0.1)*x1165))+(((-1.0)*pz*x1166)));
evalcond[2]=((-0.066959)+(((-0.08)*x1166))+(((-1.0)*pp))+(((-0.8)*x1169)));
evalcond[3]=((((-1.0)*x1166*x1167))+((x1165*x1168))+(((0.4)*x1165))+pz);
evalcond[4]=((0.1)+((x1165*x1167))+((x1166*x1168))+(((0.4)*x1166)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1170=pz*pz;
IkReal x1171=((321.0)*sj18);
CheckValue<IkReal> x1172=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1170))),-1);
if(!x1172.valid){
continue;
}
CheckValue<IkReal> x1173=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1170))),-1);
if(!x1173.valid){
continue;
}
if( IKabs(((x1172.value)*(((((-836.9875)*pz))+(((-1.0)*x1171))+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1173.value)*(((-8.369875)+((pz*x1171))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1172.value)*(((((-836.9875)*pz))+(((-1.0)*x1171))+(((-12500.0)*pp*pz))))))+IKsqr(((x1173.value)*(((-8.369875)+((pz*x1171))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1172.value)*(((((-836.9875)*pz))+(((-1.0)*x1171))+(((-12500.0)*pp*pz))))), ((x1173.value)*(((-8.369875)+((pz*x1171))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1174=IKsin(j16);
IkReal x1175=IKcos(j16);
IkReal x1176=((0.321)*sj18);
IkReal x1177=((0.321)*cj18);
IkReal x1178=(pz*x1174);
evalcond[0]=((0.4)+x1177+x1178+(((0.1)*x1175)));
evalcond[1]=(x1176+(((0.1)*x1174))+(((-1.0)*pz*x1175)));
evalcond[2]=((-0.066959)+(((-0.08)*x1175))+(((-1.0)*pp))+(((-0.8)*x1178)));
evalcond[3]=(((x1174*x1177))+(((0.4)*x1174))+pz+(((-1.0)*x1175*x1176)));
evalcond[4]=((0.1)+((x1174*x1176))+(((0.4)*x1175))+((x1175*x1177)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1179=pz*pz;
IkReal x1180=((321.0)*sj18);
CheckValue<IkReal> x1181=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1179))),-1);
if(!x1181.valid){
continue;
}
CheckValue<IkReal> x1182=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1179))),-1);
if(!x1182.valid){
continue;
}
if( IKabs(((x1181.value)*((x1180+(((4000.0)*pz))+(((3210.0)*cj18*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1182.value)*(((-40.0)+((pz*x1180))+(((-32.1)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1181.value)*((x1180+(((4000.0)*pz))+(((3210.0)*cj18*pz))))))+IKsqr(((x1182.value)*(((-40.0)+((pz*x1180))+(((-32.1)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1181.value)*((x1180+(((4000.0)*pz))+(((3210.0)*cj18*pz))))), ((x1182.value)*(((-40.0)+((pz*x1180))+(((-32.1)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1183=IKsin(j16);
IkReal x1184=IKcos(j16);
IkReal x1185=((0.321)*sj18);
IkReal x1186=((0.321)*cj18);
IkReal x1187=(pz*x1183);
evalcond[0]=((0.4)+x1186+x1187+(((0.1)*x1184)));
evalcond[1]=(x1185+(((-1.0)*pz*x1184))+(((0.1)*x1183)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*x1187))+(((-0.08)*x1184)));
evalcond[3]=(((x1183*x1186))+(((0.4)*x1183))+(((-1.0)*x1184*x1185))+pz);
evalcond[4]=((0.1)+((x1184*x1186))+((x1183*x1185))+(((0.4)*x1184)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1188=(px*sj15);
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x1188;
evalcond[2]=x1188;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*pz*sj18))+cj18);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst67;
CheckValue<IkReal> x1189 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1189.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1190=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1190.valid){
continue;
}
if( (((1.24610591900312)*(x1190.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1190.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst67=((((-1.0)*(x1189.value)))+(((-1.0)*(IKasin(((1.24610591900312)*(x1190.value)))))));
IkReal gconst68;
gconst68=IKsin(gconst67);
IkReal gconst69;
gconst69=IKcos(gconst67);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst67))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst69))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst69+(((-10.0)*gconst68*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1191=(gconst68*pz);
CheckValue<IkReal> x1192=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1191))+(((32.1)*gconst69))),-1);
if(!x1192.valid){
continue;
}
CheckValue<IkReal> x1193=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst69))+(((-321000.0)*x1191))),-1);
if(!x1193.valid){
continue;
}
if( IKabs(((x1192.value)*(((((-100.0)*pz))+(((128.4)*gconst68))+(((103.041)*gconst68*gconst69)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1193.value)*(((-10000.0)+(((103041.0)*(gconst68*gconst68))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1192.value)*(((((-100.0)*pz))+(((128.4)*gconst68))+(((103.041)*gconst68*gconst69))))))+IKsqr(((x1193.value)*(((-10000.0)+(((103041.0)*(gconst68*gconst68)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1192.value)*(((((-100.0)*pz))+(((128.4)*gconst68))+(((103.041)*gconst68*gconst69))))), ((x1193.value)*(((-10000.0)+(((103041.0)*(gconst68*gconst68)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1194=IKcos(j16);
IkReal x1195=IKsin(j16);
IkReal x1196=((0.321)*gconst69);
IkReal x1197=((0.321)*gconst68);
IkReal x1198=(pz*x1195);
evalcond[0]=(x1197+((pz*x1194))+(((-0.1)*x1195)));
evalcond[1]=((0.4)+x1198+x1196+(((0.1)*x1194)));
evalcond[2]=((-0.32)+(((-0.2568)*gconst69))+(((-0.08)*x1194))+(((-0.8)*x1198)));
evalcond[3]=(((x1194*x1197))+((x1195*x1196))+(((0.4)*x1195))+pz);
evalcond[4]=((0.1)+((x1194*x1196))+(((-1.0)*x1195*x1197))+(((0.4)*x1194)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1199=pz*pz;
IkReal x1200=((321.0)*gconst68);
CheckValue<IkReal> x1201=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1199))),-1);
if(!x1201.valid){
continue;
}
CheckValue<IkReal> x1202=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1199))),-1);
if(!x1202.valid){
continue;
}
if( IKabs(((x1201.value)*((x1200+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1202.value)*(((-40.0)+(((-1.0)*pz*x1200))+(((-32.1)*gconst69)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1201.value)*((x1200+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))))+IKsqr(((x1202.value)*(((-40.0)+(((-1.0)*pz*x1200))+(((-32.1)*gconst69))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1201.value)*((x1200+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))), ((x1202.value)*(((-40.0)+(((-1.0)*pz*x1200))+(((-32.1)*gconst69))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1203=IKcos(j16);
IkReal x1204=IKsin(j16);
IkReal x1205=((0.321)*gconst69);
IkReal x1206=((0.321)*gconst68);
IkReal x1207=(pz*x1204);
evalcond[0]=(x1206+(((-0.1)*x1204))+((pz*x1203)));
evalcond[1]=((0.4)+x1205+x1207+(((0.1)*x1203)));
evalcond[2]=((-0.32)+(((-0.08)*x1203))+(((-0.8)*x1207))+(((-0.2568)*gconst69)));
evalcond[3]=(((x1204*x1205))+(((0.4)*x1204))+((x1203*x1206))+pz);
evalcond[4]=((0.1)+(((-1.0)*x1204*x1206))+(((0.4)*x1203))+((x1203*x1205)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1208=pz*pz;
IkReal x1209=((321.0)*gconst68);
CheckValue<IkReal> x1210=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1208))),-1);
if(!x1210.valid){
continue;
}
CheckValue<IkReal> x1211=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1208))),-1);
if(!x1211.valid){
continue;
}
if( IKabs(((x1210.value)*((x1209+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1211.value)*(((40.0)+((pz*x1209))+(((32.1)*gconst69)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1210.value)*((x1209+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))))+IKsqr(((x1211.value)*(((40.0)+((pz*x1209))+(((32.1)*gconst69))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1210.value)*((x1209+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))), ((x1211.value)*(((40.0)+((pz*x1209))+(((32.1)*gconst69))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1212=IKcos(j16);
IkReal x1213=IKsin(j16);
IkReal x1214=((0.321)*gconst69);
IkReal x1215=((0.321)*gconst68);
IkReal x1216=(pz*x1213);
evalcond[0]=(x1215+(((-0.1)*x1213))+((pz*x1212)));
evalcond[1]=((0.4)+x1216+x1214+(((0.1)*x1212)));
evalcond[2]=((-0.32)+(((-0.08)*x1212))+(((-0.2568)*gconst69))+(((-0.8)*x1216)));
evalcond[3]=(((x1212*x1215))+((x1213*x1214))+pz+(((0.4)*x1213)));
evalcond[4]=((0.1)+((x1212*x1214))+(((-1.0)*x1213*x1215))+(((0.4)*x1212)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst70;
CheckValue<IkReal> x1217 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1217.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1218=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1218.valid){
continue;
}
if( (((1.24610591900312)*(x1218.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1218.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst70=((3.14159265358979)+(((-1.0)*(x1217.value)))+(IKasin(((1.24610591900312)*(x1218.value)))));
IkReal gconst71;
gconst71=IKsin(gconst70);
IkReal gconst72;
gconst72=IKcos(gconst70);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst70))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst72))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*gconst71*pz))+gconst72);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1219=(gconst71*pz);
CheckValue<IkReal> x1220=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1219))+(((32.1)*gconst72))),-1);
if(!x1220.valid){
continue;
}
CheckValue<IkReal> x1221=IKPowWithIntegerCheck(((40000.0)+(((-321000.0)*x1219))+(((32100.0)*gconst72))),-1);
if(!x1221.valid){
continue;
}
if( IKabs(((x1220.value)*(((((-100.0)*pz))+(((103.041)*gconst71*gconst72))+(((128.4)*gconst71)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1221.value)*(((-10000.0)+(((103041.0)*(gconst71*gconst71))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1220.value)*(((((-100.0)*pz))+(((103.041)*gconst71*gconst72))+(((128.4)*gconst71))))))+IKsqr(((x1221.value)*(((-10000.0)+(((103041.0)*(gconst71*gconst71)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1220.value)*(((((-100.0)*pz))+(((103.041)*gconst71*gconst72))+(((128.4)*gconst71))))), ((x1221.value)*(((-10000.0)+(((103041.0)*(gconst71*gconst71)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1222=IKcos(j16);
IkReal x1223=IKsin(j16);
IkReal x1224=((0.321)*gconst71);
IkReal x1225=((0.321)*gconst72);
IkReal x1226=(pz*x1223);
evalcond[0]=(x1224+((pz*x1222))+(((-0.1)*x1223)));
evalcond[1]=((0.4)+(((0.1)*x1222))+x1226+x1225);
evalcond[2]=((-0.32)+(((-0.08)*x1222))+(((-0.2568)*gconst72))+(((-0.8)*x1226)));
evalcond[3]=(((x1223*x1225))+pz+(((0.4)*x1223))+((x1222*x1224)));
evalcond[4]=((0.1)+(((0.4)*x1222))+((x1222*x1225))+(((-1.0)*x1223*x1224)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1227=pz*pz;
IkReal x1228=((321.0)*gconst71);
CheckValue<IkReal> x1229=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1227))),-1);
if(!x1229.valid){
continue;
}
CheckValue<IkReal> x1230=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1227))),-1);
if(!x1230.valid){
continue;
}
if( IKabs(((x1229.value)*(((((-3210.0)*gconst72*pz))+x1228+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1230.value)*(((-40.0)+(((-1.0)*pz*x1228))+(((-32.1)*gconst72)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1229.value)*(((((-3210.0)*gconst72*pz))+x1228+(((-4000.0)*pz))))))+IKsqr(((x1230.value)*(((-40.0)+(((-1.0)*pz*x1228))+(((-32.1)*gconst72))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1229.value)*(((((-3210.0)*gconst72*pz))+x1228+(((-4000.0)*pz))))), ((x1230.value)*(((-40.0)+(((-1.0)*pz*x1228))+(((-32.1)*gconst72))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1231=IKcos(j16);
IkReal x1232=IKsin(j16);
IkReal x1233=((0.321)*gconst71);
IkReal x1234=((0.321)*gconst72);
IkReal x1235=(pz*x1232);
evalcond[0]=(x1233+((pz*x1231))+(((-0.1)*x1232)));
evalcond[1]=((0.4)+x1234+x1235+(((0.1)*x1231)));
evalcond[2]=((-0.32)+(((-0.2568)*gconst72))+(((-0.08)*x1231))+(((-0.8)*x1235)));
evalcond[3]=(pz+(((0.4)*x1232))+((x1231*x1233))+((x1232*x1234)));
evalcond[4]=((0.1)+(((0.4)*x1231))+((x1231*x1234))+(((-1.0)*x1232*x1233)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1236=pz*pz;
IkReal x1237=((321.0)*gconst71);
CheckValue<IkReal> x1238=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1236))),-1);
if(!x1238.valid){
continue;
}
CheckValue<IkReal> x1239=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1236))),-1);
if(!x1239.valid){
continue;
}
if( IKabs(((x1238.value)*(((((-3210.0)*gconst72*pz))+x1237+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1239.value)*(((40.0)+((pz*x1237))+(((32.1)*gconst72)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1238.value)*(((((-3210.0)*gconst72*pz))+x1237+(((-4000.0)*pz))))))+IKsqr(((x1239.value)*(((40.0)+((pz*x1237))+(((32.1)*gconst72))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1238.value)*(((((-3210.0)*gconst72*pz))+x1237+(((-4000.0)*pz))))), ((x1239.value)*(((40.0)+((pz*x1237))+(((32.1)*gconst72))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1240=IKcos(j16);
IkReal x1241=IKsin(j16);
IkReal x1242=((0.321)*gconst71);
IkReal x1243=((0.321)*gconst72);
IkReal x1244=(pz*x1241);
evalcond[0]=(x1242+((pz*x1240))+(((-0.1)*x1241)));
evalcond[1]=((0.4)+x1243+x1244+(((0.1)*x1240)));
evalcond[2]=((-0.32)+(((-0.8)*x1244))+(((-0.2568)*gconst72))+(((-0.08)*x1240)));
evalcond[3]=(((x1240*x1242))+(((0.4)*x1241))+pz+((x1241*x1243)));
evalcond[4]=((0.1)+((x1240*x1243))+(((0.4)*x1240))+(((-1.0)*x1241*x1242)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1245=(pz*sj18);
CheckValue<IkReal> x1246=IKPowWithIntegerCheck(((40.0)+(((32.1)*cj18))+(((-321.0)*x1245))),-1);
if(!x1246.valid){
continue;
}
CheckValue<IkReal> x1247=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((-321000.0)*x1245))),-1);
if(!x1247.valid){
continue;
}
if( IKabs(((x1246.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1247.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1246.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1247.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1246.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1247.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1248=IKcos(j16);
IkReal x1249=IKsin(j16);
IkReal x1250=((0.321)*sj18);
IkReal x1251=((0.321)*cj18);
IkReal x1252=(pz*x1249);
evalcond[0]=(x1250+((pz*x1248))+(((-0.1)*x1249)));
evalcond[1]=((0.4)+x1252+x1251+(((0.1)*x1248)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*x1252))+(((-0.08)*x1248)));
evalcond[3]=((((0.4)*x1249))+pz+((x1249*x1251))+((x1248*x1250)));
evalcond[4]=((0.1)+(((-1.0)*x1249*x1250))+(((0.4)*x1248))+((x1248*x1251)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1253=pz*pz;
IkReal x1254=((321.0)*sj18);
CheckValue<IkReal> x1255=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1253))),-1);
if(!x1255.valid){
continue;
}
CheckValue<IkReal> x1256=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1253))),-1);
if(!x1256.valid){
continue;
}
if( IKabs(((x1255.value)*((x1254+(((-836.9875)*pz))+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1256.value)*(((-8.369875)+(((-1.0)*pz*x1254))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1255.value)*((x1254+(((-836.9875)*pz))+(((-12500.0)*pp*pz))))))+IKsqr(((x1256.value)*(((-8.369875)+(((-1.0)*pz*x1254))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1255.value)*((x1254+(((-836.9875)*pz))+(((-12500.0)*pp*pz))))), ((x1256.value)*(((-8.369875)+(((-1.0)*pz*x1254))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1257=IKcos(j16);
IkReal x1258=IKsin(j16);
IkReal x1259=((0.321)*sj18);
IkReal x1260=((0.321)*cj18);
IkReal x1261=(pz*x1258);
evalcond[0]=(x1259+(((-0.1)*x1258))+((pz*x1257)));
evalcond[1]=((0.4)+x1261+x1260+(((0.1)*x1257)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x1257))+(((-0.8)*x1261)));
evalcond[3]=(((x1258*x1260))+pz+((x1257*x1259))+(((0.4)*x1258)));
evalcond[4]=((0.1)+(((-1.0)*x1258*x1259))+((x1257*x1260))+(((0.4)*x1257)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1262=pz*pz;
IkReal x1263=((321.0)*sj18);
CheckValue<IkReal> x1264=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1262))),-1);
if(!x1264.valid){
continue;
}
CheckValue<IkReal> x1265=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1262))),-1);
if(!x1265.valid){
continue;
}
if( IKabs(((x1264.value)*((x1263+(((-3210.0)*cj18*pz))+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1265.value)*(((40.0)+(((32.1)*cj18))+((pz*x1263)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1264.value)*((x1263+(((-3210.0)*cj18*pz))+(((-4000.0)*pz))))))+IKsqr(((x1265.value)*(((40.0)+(((32.1)*cj18))+((pz*x1263))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1264.value)*((x1263+(((-3210.0)*cj18*pz))+(((-4000.0)*pz))))), ((x1265.value)*(((40.0)+(((32.1)*cj18))+((pz*x1263))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1266=IKcos(j16);
IkReal x1267=IKsin(j16);
IkReal x1268=((0.321)*sj18);
IkReal x1269=((0.321)*cj18);
IkReal x1270=(pz*x1267);
evalcond[0]=(x1268+(((-0.1)*x1267))+((pz*x1266)));
evalcond[1]=((0.4)+x1270+x1269+(((0.1)*x1266)));
evalcond[2]=((-0.066959)+(((-0.8)*x1270))+(((-1.0)*pp))+(((-0.08)*x1266)));
evalcond[3]=(pz+((x1267*x1269))+((x1266*x1268))+(((0.4)*x1267)));
evalcond[4]=((0.1)+(((-1.0)*x1267*x1268))+((x1266*x1269))+(((0.4)*x1266)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1271=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(py)));
evalcond[1]=x1271;
evalcond[2]=((-1.0)*x1271);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj18))+(((-1.0)*cj18)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst73;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1272=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1272.valid){
continue;
}
if( (((1.24610591900312)*(x1272.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1272.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1273 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1273.valid){
continue;
}
gconst73=((IKasin(((1.24610591900312)*(x1272.value))))+(((-1.0)*(x1273.value))));
IkReal gconst74;
gconst74=IKsin(gconst73);
IkReal gconst75;
gconst75=IKcos(gconst73);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst73))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst75))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst75))+(((-10.0)*gconst74*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1274=(gconst74*pz);
CheckValue<IkReal> x1275=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1274))+(((-32.1)*gconst75))),-1);
if(!x1275.valid){
continue;
}
CheckValue<IkReal> x1276=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst75))+(((321000.0)*x1274))),-1);
if(!x1276.valid){
continue;
}
if( IKabs(((x1275.value)*(((((100.0)*pz))+(((103.041)*gconst74*gconst75))+(((128.4)*gconst74)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1276.value)*(((-10000.0)+(((103041.0)*(gconst74*gconst74))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1275.value)*(((((100.0)*pz))+(((103.041)*gconst74*gconst75))+(((128.4)*gconst74))))))+IKsqr(((x1276.value)*(((-10000.0)+(((103041.0)*(gconst74*gconst74)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1275.value)*(((((100.0)*pz))+(((103.041)*gconst74*gconst75))+(((128.4)*gconst74))))), ((x1276.value)*(((-10000.0)+(((103041.0)*(gconst74*gconst74)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1277=IKsin(j16);
IkReal x1278=IKcos(j16);
IkReal x1279=((0.321)*gconst74);
IkReal x1280=((0.321)*gconst75);
IkReal x1281=(pz*x1277);
evalcond[0]=((0.4)+x1281+x1280+(((0.1)*x1278)));
evalcond[1]=(x1279+(((-1.0)*pz*x1278))+(((0.1)*x1277)));
evalcond[2]=((-0.32)+(((-0.08)*x1278))+(((-0.2568)*gconst75))+(((-0.8)*x1281)));
evalcond[3]=((((0.4)*x1277))+((x1277*x1280))+pz+(((-1.0)*x1278*x1279)));
evalcond[4]=((0.1)+((x1277*x1279))+(((0.4)*x1278))+((x1278*x1280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1282=pz*pz;
IkReal x1283=((321.0)*gconst74);
CheckValue<IkReal> x1284=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1282))),-1);
if(!x1284.valid){
continue;
}
CheckValue<IkReal> x1285=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1282))),-1);
if(!x1285.valid){
continue;
}
if( IKabs(((x1284.value)*(((((-3210.0)*gconst75*pz))+(((-4000.0)*pz))+(((-1.0)*x1283)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1285.value)*(((-40.0)+(((-32.1)*gconst75))+((pz*x1283)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1284.value)*(((((-3210.0)*gconst75*pz))+(((-4000.0)*pz))+(((-1.0)*x1283))))))+IKsqr(((x1285.value)*(((-40.0)+(((-32.1)*gconst75))+((pz*x1283))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1284.value)*(((((-3210.0)*gconst75*pz))+(((-4000.0)*pz))+(((-1.0)*x1283))))), ((x1285.value)*(((-40.0)+(((-32.1)*gconst75))+((pz*x1283))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1286=IKsin(j16);
IkReal x1287=IKcos(j16);
IkReal x1288=((0.321)*gconst74);
IkReal x1289=((0.321)*gconst75);
IkReal x1290=(pz*x1286);
evalcond[0]=((0.4)+x1289+x1290+(((0.1)*x1287)));
evalcond[1]=(x1288+(((0.1)*x1286))+(((-1.0)*pz*x1287)));
evalcond[2]=((-0.32)+(((-0.8)*x1290))+(((-0.08)*x1287))+(((-0.2568)*gconst75)));
evalcond[3]=(pz+((x1286*x1289))+(((-1.0)*x1287*x1288))+(((0.4)*x1286)));
evalcond[4]=((0.1)+((x1287*x1289))+((x1286*x1288))+(((0.4)*x1287)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1291=pz*pz;
IkReal x1292=((321.0)*gconst74);
CheckValue<IkReal> x1293=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1291))),-1);
if(!x1293.valid){
continue;
}
CheckValue<IkReal> x1294=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1291))),-1);
if(!x1294.valid){
continue;
}
if( IKabs(((x1293.value)*((x1292+(((3210.0)*gconst75*pz))+(((4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1294.value)*(((-40.0)+((pz*x1292))+(((-32.1)*gconst75)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1293.value)*((x1292+(((3210.0)*gconst75*pz))+(((4000.0)*pz))))))+IKsqr(((x1294.value)*(((-40.0)+((pz*x1292))+(((-32.1)*gconst75))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1293.value)*((x1292+(((3210.0)*gconst75*pz))+(((4000.0)*pz))))), ((x1294.value)*(((-40.0)+((pz*x1292))+(((-32.1)*gconst75))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1295=IKsin(j16);
IkReal x1296=IKcos(j16);
IkReal x1297=((0.321)*gconst74);
IkReal x1298=((0.321)*gconst75);
IkReal x1299=(pz*x1295);
evalcond[0]=((0.4)+x1298+x1299+(((0.1)*x1296)));
evalcond[1]=(x1297+(((0.1)*x1295))+(((-1.0)*pz*x1296)));
evalcond[2]=((-0.32)+(((-0.08)*x1296))+(((-0.8)*x1299))+(((-0.2568)*gconst75)));
evalcond[3]=(((x1295*x1298))+(((0.4)*x1295))+pz+(((-1.0)*x1296*x1297)));
evalcond[4]=((0.1)+((x1296*x1298))+((x1295*x1297))+(((0.4)*x1296)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst76;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1300=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1300.valid){
continue;
}
if( (((1.24610591900312)*(x1300.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1300.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1301 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1301.valid){
continue;
}
gconst76=((3.14159265358979)+(((-1.0)*(IKasin(((1.24610591900312)*(x1300.value))))))+(((-1.0)*(x1301.value))));
IkReal gconst77;
gconst77=IKsin(gconst76);
IkReal gconst78;
gconst78=IKcos(gconst76);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst76))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst78))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst78))+(((-10.0)*gconst77*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1302=(gconst77*pz);
CheckValue<IkReal> x1303=IKPowWithIntegerCheck(((-40.0)+(((-32.1)*gconst78))+(((-321.0)*x1302))),-1);
if(!x1303.valid){
continue;
}
CheckValue<IkReal> x1304=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst78))+(((321000.0)*x1302))),-1);
if(!x1304.valid){
continue;
}
if( IKabs(((x1303.value)*(((((100.0)*pz))+(((103.041)*gconst77*gconst78))+(((128.4)*gconst77)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1304.value)*(((-10000.0)+(((103041.0)*(gconst77*gconst77))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1303.value)*(((((100.0)*pz))+(((103.041)*gconst77*gconst78))+(((128.4)*gconst77))))))+IKsqr(((x1304.value)*(((-10000.0)+(((103041.0)*(gconst77*gconst77)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1303.value)*(((((100.0)*pz))+(((103.041)*gconst77*gconst78))+(((128.4)*gconst77))))), ((x1304.value)*(((-10000.0)+(((103041.0)*(gconst77*gconst77)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1305=IKsin(j16);
IkReal x1306=IKcos(j16);
IkReal x1307=((0.321)*gconst77);
IkReal x1308=((0.321)*gconst78);
IkReal x1309=(pz*x1305);
evalcond[0]=((0.4)+x1308+x1309+(((0.1)*x1306)));
evalcond[1]=(x1307+(((-1.0)*pz*x1306))+(((0.1)*x1305)));
evalcond[2]=((-0.32)+(((-0.08)*x1306))+(((-0.8)*x1309))+(((-0.2568)*gconst78)));
evalcond[3]=((((-1.0)*x1306*x1307))+(((0.4)*x1305))+((x1305*x1308))+pz);
evalcond[4]=((0.1)+((x1306*x1308))+(((0.4)*x1306))+((x1305*x1307)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1310=pz*pz;
IkReal x1311=((321.0)*gconst77);
CheckValue<IkReal> x1312=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1310))),-1);
if(!x1312.valid){
continue;
}
CheckValue<IkReal> x1313=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1310))),-1);
if(!x1313.valid){
continue;
}
if( IKabs(((x1312.value)*(((((-1.0)*x1311))+(((-3210.0)*gconst78*pz))+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1313.value)*(((-40.0)+((pz*x1311))+(((-32.1)*gconst78)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1312.value)*(((((-1.0)*x1311))+(((-3210.0)*gconst78*pz))+(((-4000.0)*pz))))))+IKsqr(((x1313.value)*(((-40.0)+((pz*x1311))+(((-32.1)*gconst78))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1312.value)*(((((-1.0)*x1311))+(((-3210.0)*gconst78*pz))+(((-4000.0)*pz))))), ((x1313.value)*(((-40.0)+((pz*x1311))+(((-32.1)*gconst78))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1314=IKsin(j16);
IkReal x1315=IKcos(j16);
IkReal x1316=((0.321)*gconst77);
IkReal x1317=((0.321)*gconst78);
IkReal x1318=(pz*x1314);
evalcond[0]=((0.4)+x1317+x1318+(((0.1)*x1315)));
evalcond[1]=(x1316+(((-1.0)*pz*x1315))+(((0.1)*x1314)));
evalcond[2]=((-0.32)+(((-0.08)*x1315))+(((-0.2568)*gconst78))+(((-0.8)*x1318)));
evalcond[3]=((((-1.0)*x1315*x1316))+((x1314*x1317))+(((0.4)*x1314))+pz);
evalcond[4]=((0.1)+((x1314*x1316))+(((0.4)*x1315))+((x1315*x1317)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1319=pz*pz;
IkReal x1320=((321.0)*gconst77);
CheckValue<IkReal> x1321=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1319))),-1);
if(!x1321.valid){
continue;
}
CheckValue<IkReal> x1322=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1319))),-1);
if(!x1322.valid){
continue;
}
if( IKabs(((x1321.value)*((x1320+(((3210.0)*gconst78*pz))+(((4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1322.value)*(((-40.0)+((pz*x1320))+(((-32.1)*gconst78)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1321.value)*((x1320+(((3210.0)*gconst78*pz))+(((4000.0)*pz))))))+IKsqr(((x1322.value)*(((-40.0)+((pz*x1320))+(((-32.1)*gconst78))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1321.value)*((x1320+(((3210.0)*gconst78*pz))+(((4000.0)*pz))))), ((x1322.value)*(((-40.0)+((pz*x1320))+(((-32.1)*gconst78))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1323=IKsin(j16);
IkReal x1324=IKcos(j16);
IkReal x1325=((0.321)*gconst77);
IkReal x1326=((0.321)*gconst78);
IkReal x1327=(pz*x1323);
evalcond[0]=((0.4)+x1326+x1327+(((0.1)*x1324)));
evalcond[1]=(x1325+(((-1.0)*pz*x1324))+(((0.1)*x1323)));
evalcond[2]=((-0.32)+(((-0.08)*x1324))+(((-0.2568)*gconst78))+(((-0.8)*x1327)));
evalcond[3]=((((0.4)*x1323))+(((-1.0)*x1324*x1325))+((x1323*x1326))+pz);
evalcond[4]=((0.1)+(((0.4)*x1324))+((x1323*x1325))+((x1324*x1326)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1328=(pz*sj18);
CheckValue<IkReal> x1329=IKPowWithIntegerCheck(((-40.0)+(((-32.1)*cj18))+(((-321.0)*x1328))),-1);
if(!x1329.valid){
continue;
}
CheckValue<IkReal> x1330=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((321000.0)*x1328))),-1);
if(!x1330.valid){
continue;
}
if( IKabs(((x1329.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1330.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1329.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1330.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1329.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1330.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1331=IKsin(j16);
IkReal x1332=IKcos(j16);
IkReal x1333=((0.321)*sj18);
IkReal x1334=((0.321)*cj18);
IkReal x1335=(pz*x1331);
evalcond[0]=((0.4)+x1335+x1334+(((0.1)*x1332)));
evalcond[1]=(x1333+(((0.1)*x1331))+(((-1.0)*pz*x1332)));
evalcond[2]=((-0.066959)+(((-0.08)*x1332))+(((-1.0)*pp))+(((-0.8)*x1335)));
evalcond[3]=(((x1331*x1334))+pz+(((-1.0)*x1332*x1333))+(((0.4)*x1331)));
evalcond[4]=((0.1)+((x1331*x1333))+(((0.4)*x1332))+((x1332*x1334)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1336=pz*pz;
IkReal x1337=((321.0)*sj18);
CheckValue<IkReal> x1338=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1336))),-1);
if(!x1338.valid){
continue;
}
CheckValue<IkReal> x1339=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1336))),-1);
if(!x1339.valid){
continue;
}
if( IKabs(((x1338.value)*(((((-836.9875)*pz))+(((-1.0)*x1337))+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1339.value)*(((-8.369875)+((pz*x1337))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1338.value)*(((((-836.9875)*pz))+(((-1.0)*x1337))+(((-12500.0)*pp*pz))))))+IKsqr(((x1339.value)*(((-8.369875)+((pz*x1337))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1338.value)*(((((-836.9875)*pz))+(((-1.0)*x1337))+(((-12500.0)*pp*pz))))), ((x1339.value)*(((-8.369875)+((pz*x1337))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1340=IKsin(j16);
IkReal x1341=IKcos(j16);
IkReal x1342=((0.321)*sj18);
IkReal x1343=((0.321)*cj18);
IkReal x1344=(pz*x1340);
evalcond[0]=((0.4)+x1343+x1344+(((0.1)*x1341)));
evalcond[1]=(x1342+(((0.1)*x1340))+(((-1.0)*pz*x1341)));
evalcond[2]=((-0.066959)+(((-0.08)*x1341))+(((-0.8)*x1344))+(((-1.0)*pp)));
evalcond[3]=((((-1.0)*x1341*x1342))+((x1340*x1343))+(((0.4)*x1340))+pz);
evalcond[4]=((0.1)+((x1340*x1342))+((x1341*x1343))+(((0.4)*x1341)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1345=pz*pz;
IkReal x1346=((321.0)*sj18);
CheckValue<IkReal> x1347=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1345))),-1);
if(!x1347.valid){
continue;
}
CheckValue<IkReal> x1348=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1345))),-1);
if(!x1348.valid){
continue;
}
if( IKabs(((x1347.value)*((x1346+(((4000.0)*pz))+(((3210.0)*cj18*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1348.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x1346)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1347.value)*((x1346+(((4000.0)*pz))+(((3210.0)*cj18*pz))))))+IKsqr(((x1348.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x1346))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1347.value)*((x1346+(((4000.0)*pz))+(((3210.0)*cj18*pz))))), ((x1348.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x1346))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1349=IKsin(j16);
IkReal x1350=IKcos(j16);
IkReal x1351=((0.321)*sj18);
IkReal x1352=((0.321)*cj18);
IkReal x1353=(pz*x1349);
evalcond[0]=((0.4)+x1353+x1352+(((0.1)*x1350)));
evalcond[1]=(x1351+(((-1.0)*pz*x1350))+(((0.1)*x1349)));
evalcond[2]=((-0.066959)+(((-0.08)*x1350))+(((-1.0)*pp))+(((-0.8)*x1353)));
evalcond[3]=((((-1.0)*x1350*x1351))+((x1349*x1352))+(((0.4)*x1349))+pz);
evalcond[4]=((0.1)+(((0.4)*x1350))+((x1349*x1351))+((x1350*x1352)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1354=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x1354;
evalcond[2]=x1354;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst79;
gconst79=IKsign(((160000.0)+(((103041.0)*(sj18*sj18)))+(((256800.0)*cj18))+(((103041.0)*(cj18*cj18)))));
dummyeval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+(sj18*sj18)+(cj18*cj18));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*py*sj15))+(((10.0)*cj15*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*py*sj15))+(((10.0)*cj15*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst80;
CheckValue<IkReal> x1355 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1355.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1356=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1356.valid){
continue;
}
if( (x1356.value) < -1-IKFAST_SINCOS_THRESH || (x1356.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst80=((((-1.0)*(x1355.value)))+(IKasin(x1356.value)));
IkReal gconst81;
gconst81=IKsin(gconst80);
IkReal gconst82;
gconst82=IKcos(gconst80);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst80))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst81*py))+(((0.2)*gconst82*px))+(((-1.0)*pp))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst81*py))+(((10.0)*gconst82*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst81*py))+(((10.0)*gconst82*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1357=((10.0)*cj18);
IkReal x1358=(gconst82*px);
IkReal x1359=(gconst81*py);
dummyeval[0]=((1.24610591900312)+cj18+(((-12.4610591900312)*x1358))+(((-12.4610591900312)*x1359))+(((-1.0)*x1357*x1359))+(((-1.0)*x1357*x1358)));
dummyeval[1]=((1.0)+(((-10.0)*x1358))+(((-10.0)*x1359)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1360=(gconst81*py);
IkReal x1361=(gconst82*px);
IkReal x1362=((321.0)*cj18);
CheckValue<IkReal> x1363=IKPowWithIntegerCheck(((40.0)+(((32.1)*cj18))+(((-400.0)*x1361))+(((-400.0)*x1360))+(((-1.0)*x1361*x1362))+(((-1.0)*x1360*x1362))),-1);
if(!x1363.valid){
continue;
}
CheckValue<IkReal> x1364=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1360))+(((-1.0)*x1361))),-1);
if(!x1364.valid){
continue;
}
if( IKabs(((x1363.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1364.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1363.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1364.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1363.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1364.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1365=IKsin(j16);
IkReal x1366=IKcos(j16);
IkReal x1367=((0.321)*sj18);
IkReal x1368=(gconst82*px);
IkReal x1369=(gconst81*py);
IkReal x1370=((0.321)*cj18);
IkReal x1371=((1.0)*x1368);
IkReal x1372=(x1366*x1369);
evalcond[0]=(((x1365*x1370))+((x1366*x1367))+(((0.4)*x1365)));
evalcond[1]=(x1367+((x1365*x1368))+((x1365*x1369))+(((-0.1)*x1365)));
evalcond[2]=((0.4)+x1370+(((0.1)*x1366))+(((-1.0)*x1372))+(((-1.0)*x1366*x1371)));
evalcond[3]=((-0.32)+(((-0.08)*x1366))+(((-0.2568)*cj18))+(((0.8)*x1366*x1368))+(((0.8)*x1372)));
evalcond[4]=((0.1)+(((-1.0)*x1369))+((x1366*x1370))+(((0.4)*x1366))+(((-1.0)*x1371))+(((-1.0)*x1365*x1367)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1373=(gconst82*px);
IkReal x1374=(gconst81*py);
CheckValue<IkReal> x1375=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1373))+(((1000.0)*x1374))),-1);
if(!x1375.valid){
continue;
}
CheckValue<IkReal> x1376=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1374))+(((-1.0)*x1373))),-1);
if(!x1376.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1375.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1376.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1375.value)))+IKsqr(((x1376.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1375.value)), ((x1376.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1377=IKsin(j16);
IkReal x1378=IKcos(j16);
IkReal x1379=((0.321)*sj18);
IkReal x1380=(gconst82*px);
IkReal x1381=(gconst81*py);
IkReal x1382=((0.321)*cj18);
IkReal x1383=((1.0)*x1380);
IkReal x1384=(x1378*x1381);
evalcond[0]=((((0.4)*x1377))+((x1377*x1382))+((x1378*x1379)));
evalcond[1]=(x1379+(((-0.1)*x1377))+((x1377*x1381))+((x1377*x1380)));
evalcond[2]=((0.4)+x1382+(((-1.0)*x1384))+(((0.1)*x1378))+(((-1.0)*x1378*x1383)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((0.8)*x1378*x1380))+(((-0.08)*x1378))+(((0.8)*x1384)));
evalcond[4]=((0.1)+(((-1.0)*x1383))+(((0.4)*x1378))+(((-1.0)*x1377*x1379))+(((-1.0)*x1381))+((x1378*x1382)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1385=(gconst82*px);
IkReal x1386=(gconst81*py);
CheckValue<IkReal> x1387=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1386))+(((1000.0)*x1385))),-1);
if(!x1387.valid){
continue;
}
CheckValue<IkReal> x1388=IKPowWithIntegerCheck(((-0.1)+x1385+x1386),-1);
if(!x1388.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1387.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1388.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1387.value)))+IKsqr(((x1388.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1387.value)), ((x1388.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1389=IKsin(j16);
IkReal x1390=IKcos(j16);
IkReal x1391=((0.321)*sj18);
IkReal x1392=(gconst82*px);
IkReal x1393=(gconst81*py);
IkReal x1394=((0.321)*cj18);
IkReal x1395=((1.0)*x1392);
IkReal x1396=(x1390*x1393);
evalcond[0]=(((x1390*x1391))+(((0.4)*x1389))+((x1389*x1394)));
evalcond[1]=((((-0.1)*x1389))+x1391+((x1389*x1393))+((x1389*x1392)));
evalcond[2]=((0.4)+x1394+(((0.1)*x1390))+(((-1.0)*x1390*x1395))+(((-1.0)*x1396)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((0.8)*x1390*x1392))+(((-0.08)*x1390))+(((0.8)*x1396)));
evalcond[4]=((0.1)+(((-1.0)*x1389*x1391))+((x1390*x1394))+(((0.4)*x1390))+(((-1.0)*x1393))+(((-1.0)*x1395)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst83;
CheckValue<IkReal> x1397 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1397.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1398=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1398.valid){
continue;
}
if( (x1398.value) < -1-IKFAST_SINCOS_THRESH || (x1398.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst83=((3.14159265358979)+(((-1.0)*(x1397.value)))+(((-1.0)*(IKasin(x1398.value)))));
IkReal gconst84;
gconst84=IKsin(gconst83);
IkReal gconst85;
gconst85=IKcos(gconst83);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst83))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst84*py))+(((-1.0)*pp))+(((0.2)*gconst85*px))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst85*px))+(((10.0)*gconst84*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst85*px))+(((10.0)*gconst84*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1399=(gconst84*py);
IkReal x1400=((10.0)*cj18);
IkReal x1401=(gconst85*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1399*x1400))+cj18+(((-12.4610591900312)*x1399))+(((-1.0)*x1400*x1401))+(((-12.4610591900312)*x1401)));
dummyeval[1]=((1.0)+(((-10.0)*x1399))+(((-10.0)*x1401)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1402=(gconst84*py);
IkReal x1403=((321.0)*cj18);
IkReal x1404=(gconst85*px);
CheckValue<IkReal> x1405=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1402))+(((-400.0)*x1404))+(((32.1)*cj18))+(((-1.0)*x1402*x1403))+(((-1.0)*x1403*x1404))),-1);
if(!x1405.valid){
continue;
}
CheckValue<IkReal> x1406=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1404))+(((-1.0)*x1402))),-1);
if(!x1406.valid){
continue;
}
if( IKabs(((x1405.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1406.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1405.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1406.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1405.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1406.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1407=IKsin(j16);
IkReal x1408=IKcos(j16);
IkReal x1409=((0.321)*sj18);
IkReal x1410=(gconst85*px);
IkReal x1411=((0.321)*cj18);
IkReal x1412=(gconst84*py);
IkReal x1413=((0.8)*x1408);
IkReal x1414=((1.0)*x1408);
evalcond[0]=((((0.4)*x1407))+((x1407*x1411))+((x1408*x1409)));
evalcond[1]=(((x1407*x1410))+((x1407*x1412))+(((-0.1)*x1407))+x1409);
evalcond[2]=((0.4)+(((-1.0)*x1412*x1414))+(((-1.0)*x1410*x1414))+x1411+(((0.1)*x1408)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1412*x1413))+(((-0.08)*x1408))+((x1410*x1413)));
evalcond[4]=((0.1)+(((0.4)*x1408))+(((-1.0)*x1407*x1409))+((x1408*x1411))+(((-1.0)*x1412))+(((-1.0)*x1410)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1415=(gconst85*px);
IkReal x1416=(gconst84*py);
CheckValue<IkReal> x1417=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1416))+(((1000.0)*x1415))),-1);
if(!x1417.valid){
continue;
}
CheckValue<IkReal> x1418=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1416))+(((-1.0)*x1415))),-1);
if(!x1418.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1417.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1418.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1417.value)))+IKsqr(((x1418.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1417.value)), ((x1418.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1419=IKsin(j16);
IkReal x1420=IKcos(j16);
IkReal x1421=((0.321)*sj18);
IkReal x1422=(gconst85*px);
IkReal x1423=((0.321)*cj18);
IkReal x1424=(gconst84*py);
IkReal x1425=((0.8)*x1420);
IkReal x1426=((1.0)*x1420);
evalcond[0]=(((x1420*x1421))+(((0.4)*x1419))+((x1419*x1423)));
evalcond[1]=((((-0.1)*x1419))+((x1419*x1424))+((x1419*x1422))+x1421);
evalcond[2]=((0.4)+(((0.1)*x1420))+(((-1.0)*x1424*x1426))+(((-1.0)*x1422*x1426))+x1423);
evalcond[3]=((-0.32)+((x1424*x1425))+(((-0.2568)*cj18))+((x1422*x1425))+(((-0.08)*x1420)));
evalcond[4]=((0.1)+((x1420*x1423))+(((0.4)*x1420))+(((-1.0)*x1424))+(((-1.0)*x1422))+(((-1.0)*x1419*x1421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1427=(gconst85*px);
IkReal x1428=(gconst84*py);
CheckValue<IkReal> x1429=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1427))+(((1000.0)*x1428))),-1);
if(!x1429.valid){
continue;
}
CheckValue<IkReal> x1430=IKPowWithIntegerCheck(((-0.1)+x1427+x1428),-1);
if(!x1430.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1429.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1430.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1429.value)))+IKsqr(((x1430.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1429.value)), ((x1430.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1431=IKsin(j16);
IkReal x1432=IKcos(j16);
IkReal x1433=((0.321)*sj18);
IkReal x1434=(gconst85*px);
IkReal x1435=((0.321)*cj18);
IkReal x1436=(gconst84*py);
IkReal x1437=((0.8)*x1432);
IkReal x1438=((1.0)*x1432);
evalcond[0]=(((x1432*x1433))+((x1431*x1435))+(((0.4)*x1431)));
evalcond[1]=((((-0.1)*x1431))+x1433+((x1431*x1436))+((x1431*x1434)));
evalcond[2]=((0.4)+(((-1.0)*x1436*x1438))+(((-1.0)*x1434*x1438))+(((0.1)*x1432))+x1435);
evalcond[3]=((-0.32)+((x1436*x1437))+(((-0.2568)*cj18))+(((-0.08)*x1432))+((x1434*x1437)));
evalcond[4]=((0.1)+((x1432*x1435))+(((-1.0)*x1436))+(((-1.0)*x1434))+(((-1.0)*x1431*x1433))+(((0.4)*x1432)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst86;
CheckValue<IkReal> x1439 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1439.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1440=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1440.valid){
continue;
}
if( (x1440.value) < -1-IKFAST_SINCOS_THRESH || (x1440.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst86=((((-1.0)*(x1439.value)))+(IKasin(x1440.value)));
IkReal gconst87;
gconst87=IKsin(gconst86);
IkReal gconst88;
gconst88=IKcos(gconst86);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst86))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*gconst88*px))+(((0.2568)*cj18))+(((0.2)*gconst87*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst88*px))+(((10.0)*gconst87*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst88*px))+(((10.0)*gconst87*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1441=((10.0)*cj18);
IkReal x1442=(gconst88*px);
IkReal x1443=(gconst87*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1441*x1442))+(((-1.0)*x1441*x1443))+cj18+(((-12.4610591900312)*x1442))+(((-12.4610591900312)*x1443)));
dummyeval[1]=((1.0)+(((-10.0)*x1443))+(((-10.0)*x1442)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1444=(gconst88*px);
IkReal x1445=((321.0)*cj18);
IkReal x1446=(gconst87*py);
CheckValue<IkReal> x1447=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1445*x1446))+(((32.1)*cj18))+(((-400.0)*x1446))+(((-400.0)*x1444))+(((-1.0)*x1444*x1445))),-1);
if(!x1447.valid){
continue;
}
CheckValue<IkReal> x1448=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1444))+(((-1.0)*x1446))),-1);
if(!x1448.valid){
continue;
}
if( IKabs(((x1447.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1448.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1447.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1448.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1447.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1448.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1449=IKsin(j16);
IkReal x1450=IKcos(j16);
IkReal x1451=((0.321)*sj18);
IkReal x1452=(gconst87*py);
IkReal x1453=(gconst88*px);
IkReal x1454=((0.321)*cj18);
IkReal x1455=((1.0)*x1453);
IkReal x1456=((0.8)*x1450);
evalcond[0]=(((x1450*x1451))+(((0.4)*x1449))+((x1449*x1454)));
evalcond[1]=(x1451+((x1449*x1453))+((x1449*x1452))+(((-0.1)*x1449)));
evalcond[2]=((0.4)+(((-1.0)*x1450*x1452))+x1454+(((0.1)*x1450))+(((-1.0)*x1450*x1455)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1450))+((x1452*x1456))+((x1453*x1456)));
evalcond[4]=((0.1)+(((-1.0)*x1455))+((x1450*x1454))+(((-1.0)*x1452))+(((-1.0)*x1449*x1451))+(((0.4)*x1450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1457=(gconst88*px);
IkReal x1458=(gconst87*py);
CheckValue<IkReal> x1459=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1457))+(((1000.0)*x1458))),-1);
if(!x1459.valid){
continue;
}
CheckValue<IkReal> x1460=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1458))+(((-1.0)*x1457))),-1);
if(!x1460.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1459.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1460.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1459.value)))+IKsqr(((x1460.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1459.value)), ((x1460.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1461=IKsin(j16);
IkReal x1462=IKcos(j16);
IkReal x1463=((0.321)*sj18);
IkReal x1464=(gconst87*py);
IkReal x1465=(gconst88*px);
IkReal x1466=((0.321)*cj18);
IkReal x1467=((1.0)*x1465);
IkReal x1468=((0.8)*x1462);
evalcond[0]=((((0.4)*x1461))+((x1461*x1466))+((x1462*x1463)));
evalcond[1]=(((x1461*x1464))+((x1461*x1465))+(((-0.1)*x1461))+x1463);
evalcond[2]=((0.4)+(((-1.0)*x1462*x1467))+(((-1.0)*x1462*x1464))+x1466+(((0.1)*x1462)));
evalcond[3]=((-0.32)+(((-0.08)*x1462))+(((-0.2568)*cj18))+((x1465*x1468))+((x1464*x1468)));
evalcond[4]=((0.1)+(((0.4)*x1462))+(((-1.0)*x1467))+((x1462*x1466))+(((-1.0)*x1461*x1463))+(((-1.0)*x1464)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1469=(gconst87*py);
IkReal x1470=(gconst88*px);
CheckValue<IkReal> x1471=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1469))+(((1000.0)*x1470))),-1);
if(!x1471.valid){
continue;
}
CheckValue<IkReal> x1472=IKPowWithIntegerCheck(((-0.1)+x1469+x1470),-1);
if(!x1472.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1471.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1472.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1471.value)))+IKsqr(((x1472.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1471.value)), ((x1472.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1473=IKsin(j16);
IkReal x1474=IKcos(j16);
IkReal x1475=((0.321)*sj18);
IkReal x1476=(gconst87*py);
IkReal x1477=(gconst88*px);
IkReal x1478=((0.321)*cj18);
IkReal x1479=((1.0)*x1477);
IkReal x1480=((0.8)*x1474);
evalcond[0]=(((x1474*x1475))+((x1473*x1478))+(((0.4)*x1473)));
evalcond[1]=(((x1473*x1477))+((x1473*x1476))+x1475+(((-0.1)*x1473)));
evalcond[2]=((0.4)+(((-1.0)*x1474*x1476))+(((0.1)*x1474))+(((-1.0)*x1474*x1479))+x1478);
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1476*x1480))+((x1477*x1480))+(((-0.08)*x1474)));
evalcond[4]=((0.1)+((x1474*x1478))+(((-1.0)*x1476))+(((-1.0)*x1479))+(((0.4)*x1474))+(((-1.0)*x1473*x1475)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst89;
CheckValue<IkReal> x1481 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1481.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1482=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1482.valid){
continue;
}
if( (x1482.value) < -1-IKFAST_SINCOS_THRESH || (x1482.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst89=((3.14159265358979)+(((-1.0)*(x1481.value)))+(((-1.0)*(IKasin(x1482.value)))));
IkReal gconst90;
gconst90=IKsin(gconst89);
IkReal gconst91;
gconst91=IKcos(gconst89);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst89))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst91*px))+(((-1.0)*pp))+(((0.2)*gconst90*py))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst90*py))+(((10.0)*gconst91*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst90*py))+(((10.0)*gconst91*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1483=((10.0)*cj18);
IkReal x1484=(gconst91*px);
IkReal x1485=(gconst90*py);
dummyeval[0]=((1.24610591900312)+cj18+(((-1.0)*x1483*x1485))+(((-1.0)*x1483*x1484))+(((-12.4610591900312)*x1484))+(((-12.4610591900312)*x1485)));
dummyeval[1]=((1.0)+(((-10.0)*x1484))+(((-10.0)*x1485)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1486=(gconst91*px);
IkReal x1487=((321.0)*cj18);
IkReal x1488=(gconst90*py);
CheckValue<IkReal> x1489=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1488))+(((-400.0)*x1486))+(((-1.0)*x1487*x1488))+(((32.1)*cj18))+(((-1.0)*x1486*x1487))),-1);
if(!x1489.valid){
continue;
}
CheckValue<IkReal> x1490=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1488))+(((-1.0)*x1486))),-1);
if(!x1490.valid){
continue;
}
if( IKabs(((x1489.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1490.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1489.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1490.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1489.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1490.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1491=IKsin(j16);
IkReal x1492=IKcos(j16);
IkReal x1493=((0.321)*sj18);
IkReal x1494=(gconst90*py);
IkReal x1495=(gconst91*px);
IkReal x1496=((0.321)*cj18);
IkReal x1497=((1.0)*x1495);
IkReal x1498=((0.8)*x1492);
evalcond[0]=(((x1491*x1496))+((x1492*x1493))+(((0.4)*x1491)));
evalcond[1]=(((x1491*x1494))+((x1491*x1495))+(((-0.1)*x1491))+x1493);
evalcond[2]=((0.4)+(((-1.0)*x1492*x1494))+(((-1.0)*x1492*x1497))+(((0.1)*x1492))+x1496);
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1494*x1498))+((x1495*x1498))+(((-0.08)*x1492)));
evalcond[4]=((0.1)+(((-1.0)*x1497))+(((-1.0)*x1494))+((x1492*x1496))+(((-1.0)*x1491*x1493))+(((0.4)*x1492)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1499=(gconst91*px);
IkReal x1500=(gconst90*py);
CheckValue<IkReal> x1501=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1500))+(((1000.0)*x1499))),-1);
if(!x1501.valid){
continue;
}
CheckValue<IkReal> x1502=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1500))+(((-1.0)*x1499))),-1);
if(!x1502.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1501.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1502.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1501.value)))+IKsqr(((x1502.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1501.value)), ((x1502.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1503=IKsin(j16);
IkReal x1504=IKcos(j16);
IkReal x1505=((0.321)*sj18);
IkReal x1506=(gconst90*py);
IkReal x1507=(gconst91*px);
IkReal x1508=((0.321)*cj18);
IkReal x1509=((1.0)*x1507);
IkReal x1510=((0.8)*x1504);
evalcond[0]=(((x1504*x1505))+((x1503*x1508))+(((0.4)*x1503)));
evalcond[1]=(x1505+((x1503*x1506))+((x1503*x1507))+(((-0.1)*x1503)));
evalcond[2]=((0.4)+(((-1.0)*x1504*x1506))+(((-1.0)*x1504*x1509))+x1508+(((0.1)*x1504)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1507*x1510))+((x1506*x1510))+(((-0.08)*x1504)));
evalcond[4]=((0.1)+(((-1.0)*x1509))+(((-1.0)*x1506))+((x1504*x1508))+(((-1.0)*x1503*x1505))+(((0.4)*x1504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1511=(gconst91*px);
IkReal x1512=(gconst90*py);
CheckValue<IkReal> x1513=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1512))+(((1000.0)*x1511))),-1);
if(!x1513.valid){
continue;
}
CheckValue<IkReal> x1514=IKPowWithIntegerCheck(((-0.1)+x1511+x1512),-1);
if(!x1514.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1513.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1514.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1513.value)))+IKsqr(((x1514.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1513.value)), ((x1514.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1515=IKsin(j16);
IkReal x1516=IKcos(j16);
IkReal x1517=((0.321)*sj18);
IkReal x1518=(gconst90*py);
IkReal x1519=(gconst91*px);
IkReal x1520=((0.321)*cj18);
IkReal x1521=((1.0)*x1519);
IkReal x1522=((0.8)*x1516);
evalcond[0]=(((x1516*x1517))+((x1515*x1520))+(((0.4)*x1515)));
evalcond[1]=(x1517+((x1515*x1519))+((x1515*x1518))+(((-0.1)*x1515)));
evalcond[2]=((0.4)+(((-1.0)*x1516*x1518))+x1520+(((0.1)*x1516))+(((-1.0)*x1516*x1521)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1519*x1522))+((x1518*x1522))+(((-0.08)*x1516)));
evalcond[4]=((0.1)+(((-1.0)*x1515*x1517))+(((-1.0)*x1518))+(((-1.0)*x1521))+((x1516*x1520))+(((0.4)*x1516)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1523=(py*sj15);
IkReal x1524=(cj15*px);
CheckValue<IkReal> x1525=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1524))+(((1000.0)*x1523))),-1);
if(!x1525.valid){
continue;
}
CheckValue<IkReal> x1526=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1523))+(((-1.0)*x1524))),-1);
if(!x1526.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1525.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1526.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1525.value)))+IKsqr(((x1526.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1525.value)), ((x1526.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1527=IKsin(j16);
IkReal x1528=IKcos(j16);
IkReal x1529=((0.321)*sj18);
IkReal x1530=(cj15*px);
IkReal x1531=((0.321)*cj18);
IkReal x1532=(py*sj15);
IkReal x1533=((0.8)*x1528);
IkReal x1534=((1.0)*x1528);
evalcond[0]=(((x1528*x1529))+(((0.4)*x1527))+((x1527*x1531)));
evalcond[1]=(((x1527*x1532))+((x1527*x1530))+x1529+(((-0.1)*x1527)));
evalcond[2]=((0.4)+(((-1.0)*x1530*x1534))+(((-1.0)*x1532*x1534))+x1531+(((0.1)*x1528)));
evalcond[3]=((0.1)+(((-1.0)*x1532))+(((-1.0)*x1530))+(((0.4)*x1528))+((x1528*x1531))+(((-1.0)*x1527*x1529)));
evalcond[4]=((-0.066959)+((x1530*x1533))+((x1532*x1533))+(((-1.0)*pp))+(((-0.08)*x1528))+(((0.2)*x1532))+(((0.2)*x1530)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1535=(py*sj15);
IkReal x1536=(cj15*px);
CheckValue<IkReal> x1537=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1535))+(((1000.0)*x1536))),-1);
if(!x1537.valid){
continue;
}
CheckValue<IkReal> x1538=IKPowWithIntegerCheck(((-0.1)+x1536+x1535),-1);
if(!x1538.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1537.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1538.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1537.value)))+IKsqr(((x1538.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1537.value)), ((x1538.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1539=IKsin(j16);
IkReal x1540=IKcos(j16);
IkReal x1541=((0.321)*sj18);
IkReal x1542=(cj15*px);
IkReal x1543=((0.321)*cj18);
IkReal x1544=(py*sj15);
IkReal x1545=((0.8)*x1540);
IkReal x1546=((1.0)*x1540);
evalcond[0]=((((0.4)*x1539))+((x1539*x1543))+((x1540*x1541)));
evalcond[1]=(((x1539*x1542))+((x1539*x1544))+x1541+(((-0.1)*x1539)));
evalcond[2]=((0.4)+x1543+(((-1.0)*x1542*x1546))+(((-1.0)*x1544*x1546))+(((0.1)*x1540)));
evalcond[3]=((0.1)+(((-1.0)*x1544))+(((-1.0)*x1542))+(((0.4)*x1540))+((x1540*x1543))+(((-1.0)*x1539*x1541)));
evalcond[4]=((-0.066959)+((x1544*x1545))+(((-1.0)*pp))+(((-0.08)*x1540))+(((0.2)*x1544))+(((0.2)*x1542))+((x1542*x1545)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1547=((321000.0)*sj18);
IkReal x1548=(py*sj15);
IkReal x1549=(cj15*px);
IkReal x1550=((321000.0)*cj18);
CheckValue<IkReal> x1551 = IKatan2WithCheck((gconst79*(((((-1.0)*x1547*x1549))+(((-1.0)*x1547*x1548))+(((32100.0)*sj18))))),(gconst79*(((-40000.0)+((x1549*x1550))+(((-32100.0)*cj18))+((x1548*x1550))+(((400000.0)*x1549))+(((400000.0)*x1548))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1551.valid){
continue;
}
j16array[0]=x1551.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1552=IKsin(j16);
IkReal x1553=IKcos(j16);
IkReal x1554=((0.321)*sj18);
IkReal x1555=(cj15*px);
IkReal x1556=((0.321)*cj18);
IkReal x1557=(py*sj15);
IkReal x1558=((0.8)*x1553);
IkReal x1559=((1.0)*x1553);
evalcond[0]=(((x1553*x1554))+((x1552*x1556))+(((0.4)*x1552)));
evalcond[1]=(((x1552*x1555))+((x1552*x1557))+x1554+(((-0.1)*x1552)));
evalcond[2]=((0.4)+(((0.1)*x1553))+(((-1.0)*x1555*x1559))+x1556+(((-1.0)*x1557*x1559)));
evalcond[3]=((0.1)+(((-1.0)*x1557))+(((-1.0)*x1555))+((x1553*x1556))+(((-1.0)*x1552*x1554))+(((0.4)*x1553)));
evalcond[4]=((-0.066959)+((x1555*x1558))+((x1557*x1558))+(((-1.0)*pp))+(((-0.08)*x1553))+(((0.2)*x1557))+(((0.2)*x1555)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1560=(cj15*py);
IkReal x1561=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=(x1561+(((-1.0)*x1560)));
evalcond[2]=(x1560+(((-1.0)*x1561)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst92;
gconst92=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1562=(cj15*px);
IkReal x1563=(py*sj15);
IkReal x1564=((10.0)*cj18);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x1563))+(((-12.4610591900312)*x1562))+(((-1.0)*x1562*x1564))+cj18+(((-1.0)*x1563*x1564)));
dummyeval[1]=((1.0)+(((-10.0)*x1563))+(((-10.0)*x1562)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst93;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1565=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1565.valid){
continue;
}
if( (x1565.value) < -1-IKFAST_SINCOS_THRESH || (x1565.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1566 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1566.valid){
continue;
}
gconst93=((((-1.0)*(IKasin(x1565.value))))+(((-1.0)*(x1566.value))));
IkReal gconst94;
gconst94=IKsin(gconst93);
IkReal gconst95;
gconst95=IKcos(gconst93);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst93))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*gconst94*py))+(((0.2568)*cj18))+(((0.2)*gconst95*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst105;
gconst105=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst95*px))+(((-10.0)*gconst94*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1567=((10.0)*gconst94*py);
IkReal x1568=((10.0)*gconst95*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*cj18*x1568))+(((-1.0)*cj18*x1567))+cj18+(((-12.4610591900312)*gconst94*py))+(((-12.4610591900312)*gconst95*px)));
dummyeval[1]=((1.0)+(((-1.0)*x1568))+(((-1.0)*x1567)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1569=(gconst95*px);
IkReal x1570=(gconst94*py);
IkReal x1571=((321.0)*cj18);
CheckValue<IkReal> x1572=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1569))+(((-1.0)*x1570*x1571))+(((32.1)*cj18))+(((-1.0)*x1569*x1571))+(((-400.0)*x1570))),-1);
if(!x1572.valid){
continue;
}
CheckValue<IkReal> x1573=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1569))+(((-1.0)*x1570))),-1);
if(!x1573.valid){
continue;
}
if( IKabs(((x1572.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1573.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1572.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1573.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1572.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1573.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1574=IKsin(j16);
IkReal x1575=IKcos(j16);
IkReal x1576=((0.321)*sj18);
IkReal x1577=(gconst95*px);
IkReal x1578=((0.321)*cj18);
IkReal x1579=(gconst94*py);
IkReal x1580=((0.8)*x1575);
IkReal x1581=((1.0)*x1575);
IkReal x1582=((1.0)*x1574);
evalcond[0]=((((-1.0)*x1575*x1576))+(((0.4)*x1574))+((x1574*x1578)));
evalcond[1]=((((-1.0)*x1577*x1582))+x1576+(((-1.0)*x1579*x1582))+(((0.1)*x1574)));
evalcond[2]=((0.4)+(((-1.0)*x1577*x1581))+x1578+(((-1.0)*x1579*x1581))+(((0.1)*x1575)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1575))+((x1577*x1580))+((x1579*x1580)));
evalcond[4]=((0.1)+((x1575*x1578))+(((0.4)*x1575))+((x1574*x1576))+(((-1.0)*x1577))+(((-1.0)*x1579)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1583=(gconst94*py);
IkReal x1584=(gconst95*px);
CheckValue<IkReal> x1585=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1583))+(((-1000.0)*x1584))),-1);
if(!x1585.valid){
continue;
}
CheckValue<IkReal> x1586=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1584))+(((-1.0)*x1583))),-1);
if(!x1586.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1585.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1586.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1585.value)))+IKsqr(((x1586.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1585.value)), ((x1586.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1587=IKsin(j16);
IkReal x1588=IKcos(j16);
IkReal x1589=((0.321)*sj18);
IkReal x1590=(gconst95*px);
IkReal x1591=((0.321)*cj18);
IkReal x1592=(gconst94*py);
IkReal x1593=((0.8)*x1588);
IkReal x1594=((1.0)*x1588);
IkReal x1595=((1.0)*x1587);
evalcond[0]=(((x1587*x1591))+(((0.4)*x1587))+(((-1.0)*x1588*x1589)));
evalcond[1]=((((-1.0)*x1592*x1595))+x1589+(((-1.0)*x1590*x1595))+(((0.1)*x1587)));
evalcond[2]=((0.4)+(((-1.0)*x1592*x1594))+x1591+(((-1.0)*x1590*x1594))+(((0.1)*x1588)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1590*x1593))+((x1592*x1593))+(((-0.08)*x1588)));
evalcond[4]=((0.1)+((x1587*x1589))+((x1588*x1591))+(((0.4)*x1588))+(((-1.0)*x1590))+(((-1.0)*x1592)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1596=(gconst95*px);
IkReal x1597=(gconst94*py);
IkReal x1598=((321000.0)*cj18);
IkReal x1599=((321000.0)*sj18);
CheckValue<IkReal> x1600 = IKatan2WithCheck((gconst105*(((((32100.0)*sj18))+(((-1.0)*x1597*x1599))+(((-1.0)*x1596*x1599))))),(gconst105*(((40000.0)+(((32100.0)*cj18))+(((-400000.0)*x1597))+(((-400000.0)*x1596))+(((-1.0)*x1597*x1598))+(((-1.0)*x1596*x1598))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1600.valid){
continue;
}
j16array[0]=x1600.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1601=IKsin(j16);
IkReal x1602=IKcos(j16);
IkReal x1603=((0.321)*sj18);
IkReal x1604=(gconst95*px);
IkReal x1605=((0.321)*cj18);
IkReal x1606=(gconst94*py);
IkReal x1607=((0.8)*x1602);
IkReal x1608=((1.0)*x1602);
IkReal x1609=((1.0)*x1601);
evalcond[0]=((((0.4)*x1601))+((x1601*x1605))+(((-1.0)*x1602*x1603)));
evalcond[1]=(x1603+(((-1.0)*x1606*x1609))+(((0.1)*x1601))+(((-1.0)*x1604*x1609)));
evalcond[2]=((0.4)+x1605+(((-1.0)*x1606*x1608))+(((0.1)*x1602))+(((-1.0)*x1604*x1608)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1602))+((x1606*x1607))+((x1604*x1607)));
evalcond[4]=((0.1)+(((0.4)*x1602))+(((-1.0)*x1606))+(((-1.0)*x1604))+((x1601*x1603))+((x1602*x1605)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst96;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1610=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1610.valid){
continue;
}
if( (x1610.value) < -1-IKFAST_SINCOS_THRESH || (x1610.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1611 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1611.valid){
continue;
}
gconst96=((3.14159265358979)+(IKasin(x1610.value))+(((-1.0)*(x1611.value))));
IkReal gconst97;
gconst97=IKsin(gconst96);
IkReal gconst98;
gconst98=IKcos(gconst96);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst96))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*gconst98*px))+(((0.2568)*cj18))+(((0.2)*gconst97*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst106;
gconst106=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst97*py))+(((-10.0)*gconst98*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1612=(gconst97*py);
IkReal x1613=(gconst98*px);
IkReal x1614=((10.0)*cj18);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x1613))+(((-12.4610591900312)*x1612))+cj18+(((-1.0)*x1613*x1614))+(((-1.0)*x1612*x1614)));
dummyeval[1]=((1.0)+(((-10.0)*x1613))+(((-10.0)*x1612)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1615=(gconst97*py);
IkReal x1616=((321.0)*cj18);
IkReal x1617=(gconst98*px);
CheckValue<IkReal> x1618=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1615))+(((-400.0)*x1617))+(((-1.0)*x1616*x1617))+(((32.1)*cj18))+(((-1.0)*x1615*x1616))),-1);
if(!x1618.valid){
continue;
}
CheckValue<IkReal> x1619=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1617))+(((-1.0)*x1615))),-1);
if(!x1619.valid){
continue;
}
if( IKabs(((x1618.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1619.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1618.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1619.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1618.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1619.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1620=IKsin(j16);
IkReal x1621=IKcos(j16);
IkReal x1622=(gconst97*py);
IkReal x1623=((0.321)*sj18);
IkReal x1624=((0.321)*cj18);
IkReal x1625=((0.8)*x1621);
IkReal x1626=((1.0)*gconst98*px);
evalcond[0]=(((x1620*x1624))+(((0.4)*x1620))+(((-1.0)*x1621*x1623)));
evalcond[1]=(x1623+(((-1.0)*x1620*x1622))+(((-1.0)*x1620*x1626))+(((0.1)*x1620)));
evalcond[2]=((0.4)+x1624+(((-1.0)*x1621*x1622))+(((-1.0)*x1621*x1626))+(((0.1)*x1621)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1622*x1625))+(((-0.08)*x1621))+((gconst98*px*x1625)));
evalcond[4]=((0.1)+((x1620*x1623))+(((-1.0)*x1622))+(((0.4)*x1621))+(((-1.0)*x1626))+((x1621*x1624)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1627=(gconst97*py);
IkReal x1628=(gconst98*px);
CheckValue<IkReal> x1629=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1627))+(((-1000.0)*x1628))),-1);
if(!x1629.valid){
continue;
}
CheckValue<IkReal> x1630=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1628))+(((-1.0)*x1627))),-1);
if(!x1630.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1629.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1630.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1629.value)))+IKsqr(((x1630.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1629.value)), ((x1630.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1631=IKsin(j16);
IkReal x1632=IKcos(j16);
IkReal x1633=(gconst97*py);
IkReal x1634=((0.321)*sj18);
IkReal x1635=((0.321)*cj18);
IkReal x1636=((0.8)*x1632);
IkReal x1637=((1.0)*gconst98*px);
evalcond[0]=((((-1.0)*x1632*x1634))+(((0.4)*x1631))+((x1631*x1635)));
evalcond[1]=(x1634+(((0.1)*x1631))+(((-1.0)*x1631*x1637))+(((-1.0)*x1631*x1633)));
evalcond[2]=((0.4)+x1635+(((0.1)*x1632))+(((-1.0)*x1632*x1633))+(((-1.0)*x1632*x1637)));
evalcond[3]=((-0.32)+(((-0.08)*x1632))+(((-0.2568)*cj18))+((gconst98*px*x1636))+((x1633*x1636)));
evalcond[4]=((0.1)+(((-1.0)*x1637))+(((-1.0)*x1633))+((x1632*x1635))+(((0.4)*x1632))+((x1631*x1634)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1638=(gconst97*py);
IkReal x1639=(gconst98*px);
IkReal x1640=((321000.0)*sj18);
IkReal x1641=((321000.0)*cj18);
CheckValue<IkReal> x1642 = IKatan2WithCheck((gconst106*(((((-1.0)*x1638*x1640))+(((-1.0)*x1639*x1640))+(((32100.0)*sj18))))),(gconst106*(((40000.0)+(((32100.0)*cj18))+(((-1.0)*x1638*x1641))+(((-1.0)*x1639*x1641))+(((-400000.0)*x1638))+(((-400000.0)*x1639))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1642.valid){
continue;
}
j16array[0]=x1642.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1643=IKsin(j16);
IkReal x1644=IKcos(j16);
IkReal x1645=(gconst97*py);
IkReal x1646=((0.321)*sj18);
IkReal x1647=((0.321)*cj18);
IkReal x1648=((0.8)*x1644);
IkReal x1649=((1.0)*gconst98*px);
evalcond[0]=((((-1.0)*x1644*x1646))+((x1643*x1647))+(((0.4)*x1643)));
evalcond[1]=(x1646+(((-1.0)*x1643*x1649))+(((0.1)*x1643))+(((-1.0)*x1643*x1645)));
evalcond[2]=((0.4)+(((-1.0)*x1644*x1645))+(((-1.0)*x1644*x1649))+x1647+(((0.1)*x1644)));
evalcond[3]=((-0.32)+(((-0.08)*x1644))+(((-0.2568)*cj18))+((gconst98*px*x1648))+((x1645*x1648)));
evalcond[4]=((0.1)+(((-1.0)*x1645))+(((-1.0)*x1649))+((x1644*x1647))+((x1643*x1646))+(((0.4)*x1644)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst99;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1650=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1650.valid){
continue;
}
if( (x1650.value) < -1-IKFAST_SINCOS_THRESH || (x1650.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1651 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1651.valid){
continue;
}
gconst99=((((-1.0)*(IKasin(x1650.value))))+(((-1.0)*(x1651.value))));
IkReal gconst100;
gconst100=IKsin(gconst99);
IkReal gconst101;
gconst101=IKcos(gconst99);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst99))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst101*px))+(((0.2)*gconst100*py))+(((-1.0)*pp))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst107;
gconst107=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst101*px))+(((-10.0)*gconst100*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1652=((10.0)*cj18);
IkReal x1653=(gconst100*py);
IkReal x1654=(gconst101*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1652*x1653))+(((-1.0)*x1652*x1654))+(((-12.4610591900312)*x1654))+(((-12.4610591900312)*x1653))+cj18);
dummyeval[1]=((1.0)+(((-10.0)*x1653))+(((-10.0)*x1654)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1655=(gconst100*py);
IkReal x1656=((321.0)*cj18);
IkReal x1657=(gconst101*px);
CheckValue<IkReal> x1658=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1656*x1657))+(((-1.0)*x1655*x1656))+(((32.1)*cj18))+(((-400.0)*x1657))+(((-400.0)*x1655))),-1);
if(!x1658.valid){
continue;
}
CheckValue<IkReal> x1659=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1655))+(((-1.0)*x1657))),-1);
if(!x1659.valid){
continue;
}
if( IKabs(((x1658.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1659.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1658.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1659.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1658.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1659.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1660=IKsin(j16);
IkReal x1661=IKcos(j16);
IkReal x1662=(gconst101*px);
IkReal x1663=((0.321)*sj18);
IkReal x1664=(gconst100*py);
IkReal x1665=((0.321)*cj18);
IkReal x1666=((1.0)*x1660);
IkReal x1667=((1.0)*x1661);
IkReal x1668=((0.8)*x1661);
evalcond[0]=(((x1660*x1665))+(((-1.0)*x1661*x1663))+(((0.4)*x1660)));
evalcond[1]=((((-1.0)*x1662*x1666))+x1663+(((0.1)*x1660))+(((-1.0)*x1664*x1666)));
evalcond[2]=((0.4)+(((-1.0)*x1662*x1667))+x1665+(((0.1)*x1661))+(((-1.0)*x1664*x1667)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1662*x1668))+((x1664*x1668))+(((-0.08)*x1661)));
evalcond[4]=((0.1)+((x1660*x1663))+(((-1.0)*x1662))+(((-1.0)*x1664))+((x1661*x1665))+(((0.4)*x1661)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1669=(gconst100*py);
IkReal x1670=(gconst101*px);
CheckValue<IkReal> x1671=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1669))+(((-1000.0)*x1670))),-1);
if(!x1671.valid){
continue;
}
CheckValue<IkReal> x1672=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1669))+(((-1.0)*x1670))),-1);
if(!x1672.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1671.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1672.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1671.value)))+IKsqr(((x1672.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1671.value)), ((x1672.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1673=IKsin(j16);
IkReal x1674=IKcos(j16);
IkReal x1675=(gconst101*px);
IkReal x1676=((0.321)*sj18);
IkReal x1677=(gconst100*py);
IkReal x1678=((0.321)*cj18);
IkReal x1679=((1.0)*x1673);
IkReal x1680=((1.0)*x1674);
IkReal x1681=((0.8)*x1674);
evalcond[0]=(((x1673*x1678))+(((0.4)*x1673))+(((-1.0)*x1674*x1676)));
evalcond[1]=(x1676+(((0.1)*x1673))+(((-1.0)*x1677*x1679))+(((-1.0)*x1675*x1679)));
evalcond[2]=((0.4)+(((-1.0)*x1677*x1680))+(((-1.0)*x1675*x1680))+x1678+(((0.1)*x1674)));
evalcond[3]=((-0.32)+(((-0.08)*x1674))+(((-0.2568)*cj18))+((x1677*x1681))+((x1675*x1681)));
evalcond[4]=((0.1)+((x1674*x1678))+((x1673*x1676))+(((0.4)*x1674))+(((-1.0)*x1677))+(((-1.0)*x1675)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1682=(gconst101*px);
IkReal x1683=((321000.0)*cj18);
IkReal x1684=(gconst100*py);
IkReal x1685=((321000.0)*sj18);
CheckValue<IkReal> x1686 = IKatan2WithCheck((gconst107*(((((-1.0)*x1682*x1685))+(((32100.0)*sj18))+(((-1.0)*x1684*x1685))))),(gconst107*(((40000.0)+(((32100.0)*cj18))+(((-1.0)*x1682*x1683))+(((-1.0)*x1683*x1684))+(((-400000.0)*x1684))+(((-400000.0)*x1682))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1686.valid){
continue;
}
j16array[0]=x1686.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1687=IKsin(j16);
IkReal x1688=IKcos(j16);
IkReal x1689=(gconst101*px);
IkReal x1690=((0.321)*sj18);
IkReal x1691=(gconst100*py);
IkReal x1692=((0.321)*cj18);
IkReal x1693=((1.0)*x1687);
IkReal x1694=((1.0)*x1688);
IkReal x1695=((0.8)*x1688);
evalcond[0]=((((-1.0)*x1688*x1690))+(((0.4)*x1687))+((x1687*x1692)));
evalcond[1]=(x1690+(((-1.0)*x1691*x1693))+(((0.1)*x1687))+(((-1.0)*x1689*x1693)));
evalcond[2]=((0.4)+x1692+(((-1.0)*x1691*x1694))+(((0.1)*x1688))+(((-1.0)*x1689*x1694)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1691*x1695))+((x1689*x1695))+(((-0.08)*x1688)));
evalcond[4]=((0.1)+(((-1.0)*x1691))+(((-1.0)*x1689))+((x1688*x1692))+(((0.4)*x1688))+((x1687*x1690)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst102;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1696=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1696.valid){
continue;
}
if( (x1696.value) < -1-IKFAST_SINCOS_THRESH || (x1696.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1697 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1697.valid){
continue;
}
gconst102=((3.14159265358979)+(IKasin(x1696.value))+(((-1.0)*(x1697.value))));
IkReal gconst103;
gconst103=IKsin(gconst102);
IkReal gconst104;
gconst104=IKcos(gconst102);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j15+(((-1.0)*gconst102)))))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst104*px))+(((-1.0)*pp))+(((0.2568)*cj18))+(((0.2)*gconst103*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst108;
gconst108=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst104*px))+(((-10.0)*gconst103*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1698=(gconst103*py);
IkReal x1699=((10.0)*gconst104*px);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*gconst104*px))+(((-1.0)*cj18*x1699))+(((-10.0)*cj18*x1698))+cj18+(((-12.4610591900312)*x1698)));
dummyeval[1]=((1.0)+(((-1.0)*x1699))+(((-10.0)*x1698)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1700=(gconst103*py);
IkReal x1701=((321.0)*cj18);
IkReal x1702=(gconst104*px);
CheckValue<IkReal> x1703=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1702))+(((-400.0)*x1700))+(((32.1)*cj18))+(((-1.0)*x1700*x1701))+(((-1.0)*x1701*x1702))),-1);
if(!x1703.valid){
continue;
}
CheckValue<IkReal> x1704=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1700))+(((-1.0)*x1702))),-1);
if(!x1704.valid){
continue;
}
if( IKabs(((x1703.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1704.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1703.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1704.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1703.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1704.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1705=IKsin(j16);
IkReal x1706=IKcos(j16);
IkReal x1707=((0.321)*sj18);
IkReal x1708=((0.321)*cj18);
IkReal x1709=(gconst103*py);
IkReal x1710=(gconst104*px);
IkReal x1711=((0.8)*x1706);
IkReal x1712=((1.0)*x1706);
IkReal x1713=((1.0)*x1705);
evalcond[0]=((((0.4)*x1705))+((x1705*x1708))+(((-1.0)*x1706*x1707)));
evalcond[1]=((((-1.0)*x1710*x1713))+x1707+(((-1.0)*x1709*x1713))+(((0.1)*x1705)));
evalcond[2]=((0.4)+(((-1.0)*x1710*x1712))+x1708+(((-1.0)*x1709*x1712))+(((0.1)*x1706)));
evalcond[3]=((-0.32)+((x1710*x1711))+(((-0.2568)*cj18))+((x1709*x1711))+(((-0.08)*x1706)));
evalcond[4]=((0.1)+(((0.4)*x1706))+(((-1.0)*x1709))+(((-1.0)*x1710))+((x1706*x1708))+((x1705*x1707)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1714=(gconst103*py);
IkReal x1715=(gconst104*px);
CheckValue<IkReal> x1716=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1714))+(((-1000.0)*x1715))),-1);
if(!x1716.valid){
continue;
}
CheckValue<IkReal> x1717=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1715))+(((-1.0)*x1714))),-1);
if(!x1717.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1716.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1717.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1716.value)))+IKsqr(((x1717.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1716.value)), ((x1717.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1718=IKsin(j16);
IkReal x1719=IKcos(j16);
IkReal x1720=((0.321)*sj18);
IkReal x1721=((0.321)*cj18);
IkReal x1722=(gconst103*py);
IkReal x1723=(gconst104*px);
IkReal x1724=((0.8)*x1719);
IkReal x1725=((1.0)*x1719);
IkReal x1726=((1.0)*x1718);
evalcond[0]=(((x1718*x1721))+(((-1.0)*x1719*x1720))+(((0.4)*x1718)));
evalcond[1]=(x1720+(((-1.0)*x1722*x1726))+(((-1.0)*x1723*x1726))+(((0.1)*x1718)));
evalcond[2]=((0.4)+x1721+(((-1.0)*x1722*x1725))+(((-1.0)*x1723*x1725))+(((0.1)*x1719)));
evalcond[3]=((-0.32)+((x1723*x1724))+(((-0.08)*x1719))+((x1722*x1724))+(((-0.2568)*cj18)));
evalcond[4]=((0.1)+((x1718*x1720))+(((-1.0)*x1723))+(((-1.0)*x1722))+((x1719*x1721))+(((0.4)*x1719)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1727=(gconst103*py);
IkReal x1728=(gconst104*px);
IkReal x1729=((321000.0)*sj18);
IkReal x1730=((321000.0)*cj18);
CheckValue<IkReal> x1731 = IKatan2WithCheck((gconst108*(((((-1.0)*x1728*x1729))+(((32100.0)*sj18))+(((-1.0)*x1727*x1729))))),(gconst108*(((40000.0)+(((32100.0)*cj18))+(((-400000.0)*x1728))+(((-400000.0)*x1727))+(((-1.0)*x1728*x1730))+(((-1.0)*x1727*x1730))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1731.valid){
continue;
}
j16array[0]=x1731.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1732=IKsin(j16);
IkReal x1733=IKcos(j16);
IkReal x1734=((0.321)*sj18);
IkReal x1735=((0.321)*cj18);
IkReal x1736=(gconst103*py);
IkReal x1737=(gconst104*px);
IkReal x1738=((0.8)*x1733);
IkReal x1739=((1.0)*x1733);
IkReal x1740=((1.0)*x1732);
evalcond[0]=((((-1.0)*x1733*x1734))+(((0.4)*x1732))+((x1732*x1735)));
evalcond[1]=(x1734+(((-1.0)*x1736*x1740))+(((0.1)*x1732))+(((-1.0)*x1737*x1740)));
evalcond[2]=((0.4)+x1735+(((0.1)*x1733))+(((-1.0)*x1736*x1739))+(((-1.0)*x1737*x1739)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1736*x1738))+((x1737*x1738))+(((-0.08)*x1733)));
evalcond[4]=((0.1)+(((0.4)*x1733))+((x1732*x1734))+((x1733*x1735))+(((-1.0)*x1737))+(((-1.0)*x1736)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1741=(py*sj15);
IkReal x1742=((321.0)*cj18);
IkReal x1743=(cj15*px);
CheckValue<IkReal> x1744=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1741*x1742))+(((32.1)*cj18))+(((-400.0)*x1743))+(((-400.0)*x1741))+(((-1.0)*x1742*x1743))),-1);
if(!x1744.valid){
continue;
}
CheckValue<IkReal> x1745=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1741))+(((-1.0)*x1743))),-1);
if(!x1745.valid){
continue;
}
if( IKabs(((x1744.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1745.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1744.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1745.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1744.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1745.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1746=IKsin(j16);
IkReal x1747=IKcos(j16);
IkReal x1748=((0.321)*sj18);
IkReal x1749=(cj15*px);
IkReal x1750=((0.321)*cj18);
IkReal x1751=(py*sj15);
IkReal x1752=((0.8)*x1747);
IkReal x1753=((1.0)*x1751);
evalcond[0]=(((x1746*x1750))+(((-1.0)*x1747*x1748))+(((0.4)*x1746)));
evalcond[1]=(x1748+(((-1.0)*x1746*x1749))+(((-1.0)*x1746*x1753))+(((0.1)*x1746)));
evalcond[2]=((0.4)+(((-1.0)*x1747*x1749))+x1750+(((-1.0)*x1747*x1753))+(((0.1)*x1747)));
evalcond[3]=((0.1)+((x1747*x1750))+((x1746*x1748))+(((-1.0)*x1749))+(((-1.0)*x1753))+(((0.4)*x1747)));
evalcond[4]=((-0.066959)+(((0.2)*x1751))+(((0.2)*x1749))+((x1749*x1752))+(((-0.08)*x1747))+(((-1.0)*pp))+((x1751*x1752)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1754=(py*sj15);
IkReal x1755=(cj15*px);
CheckValue<IkReal> x1756=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1755))+(((-1000.0)*x1754))),-1);
if(!x1756.valid){
continue;
}
CheckValue<IkReal> x1757=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1755))+(((-1.0)*x1754))),-1);
if(!x1757.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1756.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1757.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1756.value)))+IKsqr(((x1757.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1756.value)), ((x1757.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1758=IKsin(j16);
IkReal x1759=IKcos(j16);
IkReal x1760=((0.321)*sj18);
IkReal x1761=(cj15*px);
IkReal x1762=((0.321)*cj18);
IkReal x1763=(py*sj15);
IkReal x1764=((0.8)*x1759);
IkReal x1765=((1.0)*x1763);
evalcond[0]=((((-1.0)*x1759*x1760))+((x1758*x1762))+(((0.4)*x1758)));
evalcond[1]=(x1760+(((0.1)*x1758))+(((-1.0)*x1758*x1761))+(((-1.0)*x1758*x1765)));
evalcond[2]=((0.4)+(((-1.0)*x1759*x1761))+x1762+(((-1.0)*x1759*x1765))+(((0.1)*x1759)));
evalcond[3]=((0.1)+(((-1.0)*x1761))+(((-1.0)*x1765))+((x1759*x1762))+((x1758*x1760))+(((0.4)*x1759)));
evalcond[4]=((-0.066959)+(((-0.08)*x1759))+(((0.2)*x1763))+(((0.2)*x1761))+(((-1.0)*pp))+((x1761*x1764))+((x1763*x1764)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1766=((321000.0)*cj18);
IkReal x1767=(cj15*px);
IkReal x1768=(py*sj15);
IkReal x1769=((321000.0)*sj18);
CheckValue<IkReal> x1770 = IKatan2WithCheck((gconst92*(((((32100.0)*sj18))+(((-1.0)*x1767*x1769))+(((-1.0)*x1768*x1769))))),(gconst92*(((40000.0)+(((32100.0)*cj18))+(((-1.0)*x1766*x1767))+(((-1.0)*x1766*x1768))+(((-400000.0)*x1767))+(((-400000.0)*x1768))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1770.valid){
continue;
}
j16array[0]=x1770.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1771=IKsin(j16);
IkReal x1772=IKcos(j16);
IkReal x1773=((0.321)*sj18);
IkReal x1774=(cj15*px);
IkReal x1775=((0.321)*cj18);
IkReal x1776=(py*sj15);
IkReal x1777=((0.8)*x1772);
IkReal x1778=((1.0)*x1776);
evalcond[0]=((((-1.0)*x1772*x1773))+(((0.4)*x1771))+((x1771*x1775)));
evalcond[1]=(x1773+(((-1.0)*x1771*x1778))+(((0.1)*x1771))+(((-1.0)*x1771*x1774)));
evalcond[2]=((0.4)+(((-1.0)*x1772*x1774))+(((-1.0)*x1772*x1778))+x1775+(((0.1)*x1772)));
evalcond[3]=((0.1)+(((0.4)*x1772))+(((-1.0)*x1774))+((x1771*x1773))+(((-1.0)*x1778))+((x1772*x1775)));
evalcond[4]=((-0.066959)+(((-0.08)*x1772))+((x1776*x1777))+(((0.2)*x1776))+(((0.2)*x1774))+(((-1.0)*pp))+((x1774*x1777)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1779=IKPowWithIntegerCheck(sj17,-1);
if(!x1779.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1779.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1779.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1779.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[2];
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj17*(IKsin(j18)))));
evalcond[1]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*(IKcos(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst45;
IkReal x1780=((321.0)*cj18);
IkReal x1781=(cj15*px);
IkReal x1782=(py*sj15);
gconst45=IKsign(((-40.0)+(((321.0)*cj17*pz*sj18))+(((-32.1)*cj18))+(((400.0)*x1782))+(((400.0)*x1781))+((x1780*x1782))+((x1780*x1781))));
IkReal x1783=(py*sj15);
IkReal x1784=((10.0)*cj18);
IkReal x1785=(cj15*px);
dummyeval[0]=((-1.24610591900312)+((x1783*x1784))+(((12.4610591900312)*x1785))+(((12.4610591900312)*x1783))+(((10.0)*cj17*pz*sj18))+((x1784*x1785))+(((-1.0)*cj18)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst46;
gconst46=IKsign(((160000.0)+(((103041.0)*(cj17*cj17)*(sj18*sj18)))+(((256800.0)*cj18))+(((103041.0)*(cj18*cj18)))));
dummyeval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+(cj18*cj18)+(((cj17*cj17)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1786=(cj15*px);
IkReal x1787=(py*sj15);
IkReal x1788=((321000.0)*cj18);
IkReal x1789=((321000.0)*cj17*sj18);
CheckValue<IkReal> x1790 = IKatan2WithCheck((gconst46*(((((32100.0)*cj17*sj18))+(((-1.0)*x1787*x1789))+(((-1.0)*pz*x1788))+(((-400000.0)*pz))+(((-1.0)*x1786*x1789))))),(gconst46*(((-40000.0)+(((400000.0)*x1786))+(((400000.0)*x1787))+(((-1.0)*pz*x1789))+((x1787*x1788))+(((-32100.0)*cj18))+((x1786*x1788))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1790.valid){
continue;
}
j16array[0]=x1790.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x1791=IKsin(j16);
IkReal x1792=IKcos(j16);
IkReal x1793=((0.321)*sj18);
IkReal x1794=(cj15*px);
IkReal x1795=(py*sj15);
IkReal x1796=(px*sj15);
IkReal x1797=((1.0)*sj17);
IkReal x1798=(cj15*py);
IkReal x1799=((0.321)*cj18);
IkReal x1800=(pz*x1792);
IkReal x1801=((1.0)*x1794);
IkReal x1802=((0.321)*x1792);
IkReal x1803=(sj17*x1791);
IkReal x1804=(pz*x1791);
IkReal x1805=((0.8)*x1792);
IkReal x1806=(cj17*x1791);
evalcond[0]=(((cj17*x1792*x1793))+(((0.4)*x1791))+pz+((x1791*x1799)));
evalcond[1]=((0.1)+(((-1.0)*x1801))+(((0.4)*x1792))+((x1792*x1799))+(((-1.0)*x1795))+(((-1.0)*x1793*x1806)));
evalcond[2]=((0.4)+x1799+(((0.1)*x1792))+(((-1.0)*x1792*x1795))+x1804+(((-1.0)*x1792*x1801)));
evalcond[3]=((-0.066959)+((x1795*x1805))+((x1794*x1805))+(((-0.08)*x1792))+(((-1.0)*pp))+(((0.2)*x1794))+(((0.2)*x1795))+(((-0.8)*x1804)));
evalcond[4]=((((-1.0)*x1797*x1800))+((cj17*x1796))+(((0.1)*x1803))+(((-1.0)*x1791*x1794*x1797))+(((-1.0)*x1791*x1795*x1797))+(((-1.0)*cj17*x1798)));
evalcond[5]=(((sj17*x1796))+((cj17*x1800))+x1793+((x1795*x1806))+((x1794*x1806))+(((-1.0)*x1797*x1798))+(((-0.1)*x1806)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1807=(cj17*sj18);
IkReal x1808=((1000.0)*pz);
CheckValue<IkReal> x1809 = IKatan2WithCheck((gconst45*(((((-103.041)*cj18*x1807))+(((-1.0)*cj15*px*x1808))+(((100.0)*pz))+(((-1.0)*py*sj15*x1808))+(((-128.4)*x1807))))),(gconst45*(((160.0)+(((-1.0)*pz*x1808))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1809.valid){
continue;
}
j16array[0]=x1809.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x1810=IKsin(j16);
IkReal x1811=IKcos(j16);
IkReal x1812=((0.321)*sj18);
IkReal x1813=(cj15*px);
IkReal x1814=(py*sj15);
IkReal x1815=(px*sj15);
IkReal x1816=((1.0)*sj17);
IkReal x1817=(cj15*py);
IkReal x1818=((0.321)*cj18);
IkReal x1819=(pz*x1811);
IkReal x1820=((1.0)*x1813);
IkReal x1821=((0.321)*x1811);
IkReal x1822=(sj17*x1810);
IkReal x1823=(pz*x1810);
IkReal x1824=((0.8)*x1811);
IkReal x1825=(cj17*x1810);
evalcond[0]=((((0.4)*x1810))+pz+((cj17*x1811*x1812))+((x1810*x1818)));
evalcond[1]=((0.1)+(((-1.0)*x1820))+(((-1.0)*x1812*x1825))+(((0.4)*x1811))+((x1811*x1818))+(((-1.0)*x1814)));
evalcond[2]=((0.4)+(((0.1)*x1811))+(((-1.0)*x1811*x1820))+(((-1.0)*x1811*x1814))+x1823+x1818);
evalcond[3]=((-0.066959)+(((-0.08)*x1811))+(((-1.0)*pp))+(((0.2)*x1813))+(((0.2)*x1814))+(((-0.8)*x1823))+((x1814*x1824))+((x1813*x1824)));
evalcond[4]=((((-1.0)*cj17*x1817))+(((-1.0)*x1810*x1814*x1816))+(((-1.0)*x1816*x1819))+(((-1.0)*x1810*x1813*x1816))+((cj17*x1815))+(((0.1)*x1822)));
evalcond[5]=(((sj17*x1815))+(((-1.0)*x1816*x1817))+x1812+((cj17*x1819))+(((-0.1)*x1825))+((x1814*x1825))+((x1813*x1825)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1826=cj15*cj15;
IkReal x1827=px*px;
IkReal x1828=py*py;
IkReal x1829=sj15*sj15;
IkReal x1830=((5.0)*pp);
IkReal x1831=(py*sj15);
IkReal x1832=(pz*sj17);
IkReal x1833=((0.4)*cj17);
IkReal x1834=(px*sj15);
IkReal x1835=(cj15*px*sj17);
IkReal x1836=((4.0)*cj17*py);
IkReal x1837=((4.0)*cj15*cj17*sj15);
CheckValue<IkReal> x1838 = IKatan2WithCheck((gconst44*(((((-1.0)*cj15*px*x1832))+(((-1.0)*cj15*py*x1833))+(((-1.0)*px*x1829*x1836))+(((-1.0)*x1831*x1832))+(((0.334795)*x1832))+((x1830*x1832))+((px*x1826*x1836))+(((-1.0)*x1827*x1837))+((x1833*x1834))+((x1828*x1837))))),(gconst44*((((sj17*x1826*x1827))+(((-4.0)*cj17*pz*x1834))+(((0.5)*pp*sj17))+(((-0.434795)*sj17*x1831))+((sj17*x1828*x1829))+(((-1.0)*sj17*x1830*x1831))+(((2.0)*x1831*x1835))+(((-0.434795)*x1835))+(((0.0334795)*sj17))+((cj15*pz*x1836))+(((-1.0)*x1830*x1835))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1838.valid){
continue;
}
j16array[0]=x1838.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[2];
IkReal x1839=IKcos(j16);
IkReal x1840=IKsin(j16);
IkReal x1841=((1.0)*py);
IkReal x1842=(cj15*px);
IkReal x1843=(py*sj15);
IkReal x1844=(sj17*x1840);
IkReal x1845=((0.8)*x1839);
evalcond[0]=((-0.066959)+(((0.2)*x1843))+(((0.2)*x1842))+(((-1.0)*pp))+(((-0.8)*pz*x1840))+(((-0.08)*x1839))+((x1842*x1845))+((x1843*x1845)));
evalcond[1]=((((0.1)*x1844))+(((-1.0)*sj15*x1841*x1844))+(((-1.0)*cj15*cj17*x1841))+((cj17*px*sj15))+(((-1.0)*x1842*x1844))+(((-1.0)*pz*sj17*x1839)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=cj16;
dummyeval[1]=cj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1846=((1.0)*py);
IkReal x1847=(cj15*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*x1847))+(((0.2)*py*sj15))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*sj17*x1847))+(((-1.0)*cj15*cj17*x1846))+(((-1.0)*sj15*sj17*x1846))+((cj17*px*sj15))+(((0.1)*sj17)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1848=((3.11526479750779)*cj15);
IkReal x1849=((3.11526479750779)*sj15);
if( IKabs((((py*sj17*x1848))+(((0.311526479750779)*cj17))+(((-1.0)*cj17*py*x1849))+(((-1.0)*px*sj17*x1849))+(((-1.0)*cj17*px*x1848)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((py*sj17*x1848))+(((0.311526479750779)*cj17))+(((-1.0)*cj17*py*x1849))+(((-1.0)*px*sj17*x1849))+(((-1.0)*cj17*px*x1848))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((((py*sj17*x1848))+(((0.311526479750779)*cj17))+(((-1.0)*cj17*py*x1849))+(((-1.0)*px*sj17*x1849))+(((-1.0)*cj17*px*x1848))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1850=IKsin(j18);
IkReal x1851=IKcos(j18);
IkReal x1852=(py*sj15);
IkReal x1853=(px*sj15);
IkReal x1854=(cj15*px);
IkReal x1855=((0.321)*x1850);
IkReal x1856=((1.0)*cj15*py);
evalcond[0]=((0.4)+(((0.321)*x1851))+pz);
evalcond[1]=(((sj17*x1855))+x1853+(((-1.0)*x1856)));
evalcond[2]=((0.1)+(((-1.0)*x1854))+(((-1.0)*x1852))+(((-1.0)*cj17*x1855)));
evalcond[3]=((0.253041)+(((0.2)*x1854))+(((0.2)*x1852))+(((0.2568)*x1851))+(((-1.0)*pp)));
evalcond[4]=(((sj17*x1853))+(((-1.0)*sj17*x1856))+(((-0.1)*cj17))+x1855+((cj17*x1852))+((cj17*x1854)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1857=(cj15*px);
IkReal x1858=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.2)*x1858))+(((0.2)*x1857))+(((0.8)*pz))+(((-1.0)*pp)));
evalcond[2]=(((sj17*x1858))+((sj17*x1857))+(((-1.0)*cj15*cj17*py))+(((-0.1)*sj17))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1859=IKcos(j18);
IkReal x1860=(cj15*px);
IkReal x1861=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1859))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1861))+(((-1.0)*x1860))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x1860))+(((0.2)*x1861))+(((0.2568)*x1859))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1862=IKcos(j18);
IkReal x1863=(cj15*px);
IkReal x1864=(py*sj15);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1862)));
evalcond[1]=((0.1)+(((-0.321)*(IKsin(j18))))+(((-1.0)*x1864))+(((-1.0)*x1863)));
evalcond[2]=((0.253041)+(((0.2)*x1864))+(((0.2)*x1863))+(((0.2568)*x1862))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1865=IKcos(j18);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1865)));
evalcond[1]=((0.273041)+(((0.2568)*x1865))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1866=IKcos(j18);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1866)));
evalcond[1]=((0.273041)+(((0.2568)*x1866))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1867=IKcos(j18);
IkReal x1868=(cj15*px);
IkReal x1869=(py*sj15);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1867)));
evalcond[1]=((0.1)+(((-1.0)*x1869))+(((-1.0)*x1868))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x1868))+(((0.2)*x1869))+(((0.2568)*x1867))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1870=IKcos(j18);
IkReal x1871=(cj15*px);
IkReal x1872=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1870))+pz);
evalcond[1]=((0.1)+(((-0.321)*(IKsin(j18))))+(((-1.0)*x1871))+(((-1.0)*x1872)));
evalcond[2]=((0.253041)+(((0.2568)*x1870))+(((0.2)*x1871))+(((0.2)*x1872))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j17), 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1873=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1873))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x1873))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j17), 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1874=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1874))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x1874))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1875=IKPowWithIntegerCheck(sj17,-1);
if(!x1875.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1875.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1875.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1875.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1876=IKsin(j18);
IkReal x1877=IKcos(j18);
IkReal x1878=(py*sj15);
IkReal x1879=((1.0)*cj15);
IkReal x1880=(px*sj15);
IkReal x1881=((0.321)*x1876);
evalcond[0]=((-0.4)+(((-0.321)*x1877))+pz);
evalcond[1]=(((sj17*x1881))+x1880+(((-1.0)*py*x1879)));
evalcond[2]=((0.1)+(((-1.0)*px*x1879))+(((-1.0)*x1878))+((cj17*x1881)));
evalcond[3]=((0.253041)+(((0.2568)*x1877))+(((0.2)*cj15*px))+(((0.2)*x1878))+(((-1.0)*pp)));
evalcond[4]=(((sj17*x1880))+x1881+(((-1.0)*py*sj17*x1879))+(((-1.0)*cj17*px*x1879))+(((-1.0)*cj17*x1878))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1882=IKPowWithIntegerCheck(cj17,-1);
if(!x1882.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1882.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1882.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1882.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1883=IKsin(j18);
IkReal x1884=IKcos(j18);
IkReal x1885=(py*sj15);
IkReal x1886=((1.0)*cj15);
IkReal x1887=(px*sj15);
IkReal x1888=((0.321)*x1883);
evalcond[0]=((-0.4)+(((-0.321)*x1884))+pz);
evalcond[1]=(((sj17*x1888))+x1887+(((-1.0)*py*x1886)));
evalcond[2]=((0.1)+(((-1.0)*px*x1886))+(((-1.0)*x1885))+((cj17*x1888)));
evalcond[3]=((0.253041)+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2568)*x1884))+(((0.2)*x1885)));
evalcond[4]=((((-1.0)*cj17*x1885))+(((-1.0)*py*sj17*x1886))+((sj17*x1887))+(((-1.0)*cj17*px*x1886))+x1888+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1889=IKPowWithIntegerCheck(sj17,-1);
if(!x1889.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1889.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1889.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1889.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1890=IKsin(j18);
IkReal x1891=IKcos(j18);
IkReal x1892=(py*sj15);
IkReal x1893=((1.0)*cj15);
IkReal x1894=(px*sj15);
IkReal x1895=((0.321)*x1890);
evalcond[0]=((-0.4)+(((-0.321)*x1891))+pz);
evalcond[1]=(((sj17*x1895))+x1894+(((-1.0)*py*x1893)));
evalcond[2]=((0.1)+(((-1.0)*px*x1893))+(((-1.0)*x1892))+((cj17*x1895)));
evalcond[3]=((0.253041)+(((0.2568)*x1891))+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1892)));
evalcond[4]=(((sj17*x1894))+(((-1.0)*cj17*x1892))+(((-1.0)*py*sj17*x1893))+(((-1.0)*cj17*px*x1893))+x1895+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1896=((1.0)*sj16);
IkReal x1897=(cj15*px);
IkReal x1898=(py*sj15);
IkReal x1899=((0.8)*cj16);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1897*x1899))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+((x1898*x1899))+(((-0.08)*cj16))+(((0.2)*x1898))+(((0.2)*x1897)));
evalcond[2]=((((-1.0)*cj16*pz))+(((-1.0)*x1896*x1898))+(((-1.0)*x1896*x1897))+(((0.1)*sj16)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1900=IKcos(j18);
IkReal x1901=(py*sj15);
IkReal x1902=((1.0)*cj16);
IkReal x1903=((1.0)*cj15);
IkReal x1904=(cj15*px);
IkReal x1905=((0.321)*x1900);
evalcond[0]=(((sj16*x1905))+(((0.4)*sj16))+pz);
evalcond[1]=((((-1.0)*py*x1903))+((px*sj15))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1900))+(((-1.0)*pp))+(((0.2)*x1901))+(((0.2)*x1904)));
evalcond[3]=((0.1)+(((-1.0)*px*x1903))+(((-1.0)*x1901))+(((0.4)*cj16))+((cj16*x1905)));
evalcond[4]=((0.4)+(((-1.0)*x1902*x1904))+(((-1.0)*x1901*x1902))+((pz*sj16))+x1905+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1906=(cj15*px);
IkReal x1907=((0.8)*cj16);
IkReal x1908=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-1.0)*pp))+(((0.2)*x1908))+(((0.2)*x1906))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1906*x1907))+((x1907*x1908)));
evalcond[2]=((((-0.1)*sj16))+((sj16*x1908))+((sj16*x1906))+((cj16*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1909=IKcos(j18);
IkReal x1910=(py*sj15);
IkReal x1911=((1.0)*cj16);
IkReal x1912=((1.0)*cj15);
IkReal x1913=(cj15*px);
IkReal x1914=((0.321)*x1909);
evalcond[0]=((((0.4)*sj16))+pz+((sj16*x1914)));
evalcond[1]=((((-1.0)*py*x1912))+((px*sj15))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1909))+(((-1.0)*pp))+(((0.2)*x1913))+(((0.2)*x1910)));
evalcond[3]=((0.1)+(((-1.0)*px*x1912))+(((-1.0)*x1910))+(((0.4)*cj16))+((cj16*x1914)));
evalcond[4]=((0.4)+(((-1.0)*x1911*x1913))+(((-1.0)*x1910*x1911))+((pz*sj16))+x1914+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1915=(py*sj15);
IkReal x1916=((0.8)*cj16);
IkReal x1917=(cj15*px);
IkReal x1918=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x1918;
evalcond[2]=((-0.066959)+((x1916*x1917))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+(((0.2)*x1917))+(((0.2)*x1915))+((x1915*x1916)));
evalcond[3]=x1918;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst47;
gconst47=IKsign(((((321.0)*(cj16*cj16)))+(((321.0)*(sj16*sj16)))));
dummyeval[0]=((sj16*sj16)+(cj16*cj16));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1919=IKcos(j18);
IkReal x1920=(cj15*px);
IkReal x1921=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x1919))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1920))+(((-1.0)*x1921))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1919))+(((-1.0)*pp))+(((0.2)*x1920))+(((0.2)*x1921)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j16), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1922=IKcos(j18);
IkReal x1923=(cj15*px);
IkReal x1924=(py*sj15);
evalcond[0]=((0.4)+pz+(((0.321)*x1922)));
evalcond[1]=((0.1)+(((-1.0)*x1923))+(((-1.0)*x1924))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1922))+(((-1.0)*pp))+(((0.2)*x1924))+(((0.2)*x1923)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j16), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1925=IKcos(j18);
IkReal x1926=(cj15*px);
IkReal x1927=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1925))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1927))+(((-1.0)*x1926))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1925))+(((-1.0)*pp))+(((0.2)*x1926))+(((0.2)*x1927)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1928=(cj16*sj16);
IkReal x1929=(py*sj15);
IkReal x1930=((3.11526479750779)*cj16);
IkReal x1931=((1000.0)*pz);
IkReal x1932=(cj15*px);
CheckValue<IkReal> x1933=IKPowWithIntegerCheck(cj16,-1);
if(!x1933.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1933.value)*(((((-1000.0)*x1928*x1932))+(((-1000.0)*x1928*x1929))+(((100.0)*x1928))+((x1931*(sj16*sj16)))+(((-1.0)*x1931)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1930*x1932))+((x1929*x1930))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1933.value)*(((((-1000.0)*x1928*x1932))+(((-1000.0)*x1928*x1929))+(((100.0)*x1928))+((x1931*(sj16*sj16)))+(((-1.0)*x1931))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1930*x1932))+((x1929*x1930))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1933.value)*(((((-1000.0)*x1928*x1932))+(((-1000.0)*x1928*x1929))+(((100.0)*x1928))+((x1931*(sj16*sj16)))+(((-1.0)*x1931))))), ((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1930*x1932))+((x1929*x1930))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1934=IKcos(j18);
IkReal x1935=IKsin(j18);
IkReal x1936=(py*sj15);
IkReal x1937=(cj15*px);
IkReal x1938=((1.0)*cj16);
IkReal x1939=((0.321)*x1934);
IkReal x1940=((0.321)*x1935);
evalcond[0]=(((sj16*x1939))+(((0.4)*sj16))+pz+((cj16*x1940)));
evalcond[1]=((0.253041)+(((0.2568)*x1934))+(((-1.0)*pp))+(((0.2)*x1936))+(((0.2)*x1937)));
evalcond[2]=((((-0.1)*sj16))+((sj16*x1936))+((sj16*x1937))+x1940+((cj16*pz)));
evalcond[3]=((0.4)+(((-1.0)*x1937*x1938))+((pz*sj16))+x1939+(((-1.0)*x1936*x1938))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*sj16*x1940))+(((-1.0)*x1936))+(((-1.0)*x1937))+(((0.4)*cj16))+((cj16*x1939)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1941=((250.0)*sj16);
IkReal x1942=(py*sj15);
IkReal x1943=(cj15*px);
CheckValue<IkReal> x1944=IKPowWithIntegerCheck(cj16,-1);
if(!x1944.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1944.value)*(((((-1000.0)*pz))+((x1941*x1943))+((x1941*x1942))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1942))+(((-0.778816199376947)*x1943)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1944.value)*(((((-1000.0)*pz))+((x1941*x1943))+((x1941*x1942))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1942))+(((-0.778816199376947)*x1943))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1944.value)*(((((-1000.0)*pz))+((x1941*x1943))+((x1941*x1942))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1942))+(((-0.778816199376947)*x1943))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1945=IKcos(j18);
IkReal x1946=IKsin(j18);
IkReal x1947=(py*sj15);
IkReal x1948=(cj15*px);
IkReal x1949=((1.0)*cj16);
IkReal x1950=((0.321)*x1945);
IkReal x1951=((0.321)*x1946);
evalcond[0]=((((0.4)*sj16))+((cj16*x1951))+pz+((sj16*x1950)));
evalcond[1]=((0.253041)+(((0.2568)*x1945))+(((-1.0)*pp))+(((0.2)*x1948))+(((0.2)*x1947)));
evalcond[2]=((((-0.1)*sj16))+x1951+((sj16*x1947))+((sj16*x1948))+((cj16*pz)));
evalcond[3]=((0.4)+(((-1.0)*x1947*x1949))+((pz*sj16))+x1950+(((0.1)*cj16))+(((-1.0)*x1948*x1949)));
evalcond[4]=((0.1)+(((-1.0)*sj16*x1951))+((cj16*x1950))+(((-1.0)*x1947))+(((-1.0)*x1948))+(((0.4)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1952=((1000.0)*cj16);
IkReal x1953=((1000.0)*sj16);
IkReal x1954=(py*sj15);
IkReal x1955=(cj15*px);
CheckValue<IkReal> x1956 = IKatan2WithCheck((gconst47*(((((100.0)*sj16))+(((-1.0)*pz*x1952))+(((-1.0)*x1953*x1955))+(((-1.0)*x1953*x1954))))),(gconst47*((((x1952*x1955))+((x1952*x1954))+(((-100.0)*cj16))+(((-400.0)*(sj16*sj16)))+(((-400.0)*(cj16*cj16)))+(((-1.0)*pz*x1953))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1956.valid){
continue;
}
j18array[0]=x1956.value;
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1957=IKcos(j18);
IkReal x1958=IKsin(j18);
IkReal x1959=(py*sj15);
IkReal x1960=(cj15*px);
IkReal x1961=((1.0)*cj16);
IkReal x1962=((0.321)*x1957);
IkReal x1963=((0.321)*x1958);
evalcond[0]=((((0.4)*sj16))+((cj16*x1963))+pz+((sj16*x1962)));
evalcond[1]=((0.253041)+(((0.2568)*x1957))+(((0.2)*x1960))+(((0.2)*x1959))+(((-1.0)*pp)));
evalcond[2]=((((-0.1)*sj16))+x1963+((cj16*pz))+((sj16*x1959))+((sj16*x1960)));
evalcond[3]=((0.4)+(((-1.0)*x1959*x1961))+((pz*sj16))+x1962+(((-1.0)*x1960*x1961))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1960))+((cj16*x1962))+(((0.4)*cj16))+(((-1.0)*x1959))+(((-1.0)*sj16*x1963)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1964=(py*sj15);
IkReal x1965=(cj15*py);
IkReal x1966=((0.8)*cj16);
IkReal x1967=(cj15*px);
IkReal x1968=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x1965))+x1968);
evalcond[2]=((-0.066959)+((x1964*x1966))+(((0.2)*x1967))+(((0.2)*x1964))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1966*x1967)));
evalcond[3]=((((-1.0)*x1968))+x1965);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst48;
gconst48=IKsign(((((321.0)*(cj16*cj16)))+(((321.0)*(sj16*sj16)))));
dummyeval[0]=((sj16*sj16)+(cj16*cj16));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1969=IKcos(j18);
IkReal x1970=(cj15*px);
IkReal x1971=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x1969))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1971))+(((-1.0)*x1970))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1969))+(((0.2)*x1971))+(((0.2)*x1970))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j16), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1972=IKcos(j18);
IkReal x1973=(cj15*px);
IkReal x1974=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x1972))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1974))+(((-1.0)*x1973))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1972))+(((0.2)*x1973))+(((0.2)*x1974))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j16), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1975=IKcos(j18);
IkReal x1976=(cj15*px);
IkReal x1977=(py*sj15);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1975)));
evalcond[1]=((0.1)+(((-1.0)*x1976))+(((-1.0)*x1977))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1975))+(((0.2)*x1976))+(((0.2)*x1977))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1978=(cj16*sj16);
IkReal x1979=(py*sj15);
IkReal x1980=((3.11526479750779)*cj16);
IkReal x1981=((1000.0)*pz);
IkReal x1982=(cj15*px);
CheckValue<IkReal> x1983=IKPowWithIntegerCheck(cj16,-1);
if(!x1983.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1983.value)*(((((-1.0)*x1981*(sj16*sj16)))+(((1000.0)*x1978*x1979))+(((-100.0)*x1978))+x1981+(((1000.0)*x1978*x1982)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1980*x1982))+((x1979*x1980))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1983.value)*(((((-1.0)*x1981*(sj16*sj16)))+(((1000.0)*x1978*x1979))+(((-100.0)*x1978))+x1981+(((1000.0)*x1978*x1982))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1980*x1982))+((x1979*x1980))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1983.value)*(((((-1.0)*x1981*(sj16*sj16)))+(((1000.0)*x1978*x1979))+(((-100.0)*x1978))+x1981+(((1000.0)*x1978*x1982))))), ((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1980*x1982))+((x1979*x1980))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1984=IKcos(j18);
IkReal x1985=IKsin(j18);
IkReal x1986=((1.0)*cj16);
IkReal x1987=(py*sj15);
IkReal x1988=(cj15*px);
IkReal x1989=((0.321)*x1984);
IkReal x1990=((1.0)*x1988);
IkReal x1991=((0.321)*x1985);
evalcond[0]=((((-1.0)*cj16*x1991))+(((0.4)*sj16))+pz+((sj16*x1989)));
evalcond[1]=((0.253041)+(((0.2568)*x1984))+(((0.2)*x1987))+(((0.2)*x1988))+(((-1.0)*pp)));
evalcond[2]=((0.4)+(((-1.0)*x1986*x1987))+(((-1.0)*x1986*x1988))+((pz*sj16))+x1989+(((0.1)*cj16)));
evalcond[3]=((((-1.0)*sj16*x1990))+x1991+(((0.1)*sj16))+(((-1.0)*sj16*x1987))+(((-1.0)*pz*x1986)));
evalcond[4]=((0.1)+(((-1.0)*x1990))+(((0.4)*cj16))+((cj16*x1989))+((sj16*x1991))+(((-1.0)*x1987)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1992=((250.0)*sj16);
IkReal x1993=(py*sj15);
IkReal x1994=(cj15*px);
CheckValue<IkReal> x1995=IKPowWithIntegerCheck(cj16,-1);
if(!x1995.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1995.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((-1.0)*x1992*x1993))+(((-1.0)*x1992*x1994))+(((1000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1993))+(((-0.778816199376947)*x1994)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1995.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((-1.0)*x1992*x1993))+(((-1.0)*x1992*x1994))+(((1000.0)*pz))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1993))+(((-0.778816199376947)*x1994))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1995.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((-1.0)*x1992*x1993))+(((-1.0)*x1992*x1994))+(((1000.0)*pz))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1993))+(((-0.778816199376947)*x1994))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1996=IKcos(j18);
IkReal x1997=IKsin(j18);
IkReal x1998=((1.0)*cj16);
IkReal x1999=(py*sj15);
IkReal x2000=(cj15*px);
IkReal x2001=((0.321)*x1996);
IkReal x2002=((1.0)*x2000);
IkReal x2003=((0.321)*x1997);
evalcond[0]=((((-1.0)*cj16*x2003))+(((0.4)*sj16))+pz+((sj16*x2001)));
evalcond[1]=((0.253041)+(((0.2)*x1999))+(((-1.0)*pp))+(((0.2568)*x1996))+(((0.2)*x2000)));
evalcond[2]=((0.4)+(((-1.0)*x1998*x1999))+(((-1.0)*x1998*x2000))+x2001+((pz*sj16))+(((0.1)*cj16)));
evalcond[3]=(x2003+(((-1.0)*pz*x1998))+(((0.1)*sj16))+(((-1.0)*sj16*x1999))+(((-1.0)*sj16*x2002)));
evalcond[4]=((0.1)+((cj16*x2001))+(((-1.0)*x2002))+(((0.4)*cj16))+((sj16*x2003))+(((-1.0)*x1999)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2004=((1000.0)*cj16);
IkReal x2005=((1000.0)*sj16);
IkReal x2006=(py*sj15);
IkReal x2007=(cj15*px);
CheckValue<IkReal> x2008 = IKatan2WithCheck((gconst48*((((pz*x2004))+((x2005*x2007))+((x2005*x2006))+(((-100.0)*sj16))))),(gconst48*(((((-100.0)*cj16))+(((-1.0)*pz*x2005))+(((-400.0)*(sj16*sj16)))+(((-400.0)*(cj16*cj16)))+((x2004*x2006))+((x2004*x2007))))),IKFAST_ATAN2_MAGTHRESH);
if(!x2008.valid){
continue;
}
j18array[0]=x2008.value;
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2009=IKcos(j18);
IkReal x2010=IKsin(j18);
IkReal x2011=((1.0)*cj16);
IkReal x2012=(py*sj15);
IkReal x2013=(cj15*px);
IkReal x2014=((0.321)*x2009);
IkReal x2015=((1.0)*x2013);
IkReal x2016=((0.321)*x2010);
evalcond[0]=(((sj16*x2014))+(((0.4)*sj16))+pz+(((-1.0)*cj16*x2016)));
evalcond[1]=((0.253041)+(((0.2568)*x2009))+(((-1.0)*pp))+(((0.2)*x2012))+(((0.2)*x2013)));
evalcond[2]=((0.4)+x2014+((pz*sj16))+(((-1.0)*x2011*x2012))+(((-1.0)*x2011*x2013))+(((0.1)*cj16)));
evalcond[3]=((((-1.0)*sj16*x2015))+(((-1.0)*pz*x2011))+x2016+(((-1.0)*sj16*x2012))+(((0.1)*sj16)));
evalcond[4]=((0.1)+(((-1.0)*x2015))+((cj16*x2014))+((sj16*x2016))+(((0.4)*cj16))+(((-1.0)*x2012)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2017=((1.0)*py);
IkReal x2018=(cj15*px);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j16), 6.28318530717959))))));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2)*x2018)));
evalcond[2]=((((-1.0)*cj15*cj17*x2017))+((cj17*px*sj15))+(((0.1)*sj17))+(((-1.0)*sj17*x2018))+(((-1.0)*sj15*sj17*x2017)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2019=((3.11526479750779)*cj15);
IkReal x2020=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*cj17*py*x2020))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x2020))+(((-1.0)*cj17*px*x2019))+((py*sj17*x2019)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj17*py*x2020))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x2020))+(((-1.0)*cj17*px*x2019))+((py*sj17*x2019))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*cj17*py*x2020))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x2020))+(((-1.0)*cj17*px*x2019))+((py*sj17*x2019))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2021=IKsin(j18);
IkReal x2022=IKcos(j18);
IkReal x2023=(py*sj15);
IkReal x2024=(px*sj15);
IkReal x2025=(cj15*px);
IkReal x2026=((0.321)*x2021);
IkReal x2027=((1.0)*cj15*py);
evalcond[0]=((0.4)+pz+(((0.321)*x2022)));
evalcond[1]=(x2024+((sj17*x2026))+(((-1.0)*x2027)));
evalcond[2]=((0.1)+(((-1.0)*x2023))+(((-1.0)*x2025))+(((-1.0)*cj17*x2026)));
evalcond[3]=((0.253041)+(((0.2568)*x2022))+(((-1.0)*pp))+(((0.2)*x2025))+(((0.2)*x2023)));
evalcond[4]=(x2026+(((-0.1)*cj17))+((cj17*x2023))+((cj17*x2025))+((sj17*x2024))+(((-1.0)*sj17*x2027)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2028=(cj15*px);
IkReal x2029=(py*sj15);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j16), 6.28318530717959))))));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x2028))+(((0.2)*x2029)));
evalcond[2]=((((-1.0)*cj15*cj17*py))+(((-0.1)*sj17))+((sj17*x2028))+((sj17*x2029))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2030=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x2030))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x2030))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2031=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x2031))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x2031))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2032=IKcos(j18);
IkReal x2033=(cj15*px);
IkReal x2034=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x2032))+pz);
evalcond[1]=((0.1)+(((-1.0)*x2033))+(((-1.0)*x2034))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x2032))+(((-1.0)*pp))+(((0.2)*x2034))+(((0.2)*x2033)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2035=IKcos(j18);
IkReal x2036=(cj15*px);
IkReal x2037=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x2035))+pz);
evalcond[1]=((0.1)+(((-0.321)*(IKsin(j18))))+(((-1.0)*x2037))+(((-1.0)*x2036)));
evalcond[2]=((0.253041)+(((0.2568)*x2035))+(((-1.0)*pp))+(((0.2)*x2036))+(((0.2)*x2037)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j17), 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2038=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x2038))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x2038))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j17), 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2039=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x2039))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x2039))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x2040=IKPowWithIntegerCheck(sj17,-1);
if(!x2040.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2040.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2040.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2040.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2041=IKsin(j18);
IkReal x2042=IKcos(j18);
IkReal x2043=(py*sj15);
IkReal x2044=((1.0)*cj15);
IkReal x2045=(px*sj15);
IkReal x2046=((0.321)*x2041);
evalcond[0]=((-0.4)+pz+(((-0.321)*x2042)));
evalcond[1]=(x2045+(((-1.0)*py*x2044))+((sj17*x2046)));
evalcond[2]=((0.1)+(((-1.0)*x2043))+(((-1.0)*px*x2044))+((cj17*x2046)));
evalcond[3]=((0.253041)+(((0.2)*x2043))+(((0.2568)*x2042))+(((0.2)*cj15*px))+(((-1.0)*pp)));
evalcond[4]=((((-1.0)*cj17*x2043))+(((-1.0)*py*sj17*x2044))+x2046+(((-1.0)*cj17*px*x2044))+((sj17*x2045))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x2047=IKPowWithIntegerCheck(cj17,-1);
if(!x2047.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2047.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2047.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2047.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2048=IKsin(j18);
IkReal x2049=IKcos(j18);
IkReal x2050=(py*sj15);
IkReal x2051=((1.0)*cj15);
IkReal x2052=(px*sj15);
IkReal x2053=((0.321)*x2048);
evalcond[0]=((-0.4)+pz+(((-0.321)*x2049)));
evalcond[1]=(x2052+(((-1.0)*py*x2051))+((sj17*x2053)));
evalcond[2]=((0.1)+(((-1.0)*px*x2051))+((cj17*x2053))+(((-1.0)*x2050)));
evalcond[3]=((0.253041)+(((0.2568)*x2049))+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x2050)));
evalcond[4]=((((-1.0)*cj17*x2050))+x2053+(((-1.0)*cj17*px*x2051))+((sj17*x2052))+(((-1.0)*py*sj17*x2051))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x2054=IKPowWithIntegerCheck(sj17,-1);
if(!x2054.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2054.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2054.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2054.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2055=IKsin(j18);
IkReal x2056=IKcos(j18);
IkReal x2057=(py*sj15);
IkReal x2058=((1.0)*cj15);
IkReal x2059=(px*sj15);
IkReal x2060=((0.321)*x2055);
evalcond[0]=((-0.4)+(((-0.321)*x2056))+pz);
evalcond[1]=(x2059+(((-1.0)*py*x2058))+((sj17*x2060)));
evalcond[2]=((0.1)+(((-1.0)*px*x2058))+(((-1.0)*x2057))+((cj17*x2060)));
evalcond[3]=((0.253041)+(((0.2568)*x2056))+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x2057)));
evalcond[4]=((((-1.0)*cj17*x2057))+x2060+(((-1.0)*cj17*px*x2058))+((sj17*x2059))+(((-1.0)*py*sj17*x2058))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2061=((1.0)*sj16);
IkReal x2062=(cj15*px);
IkReal x2063=(py*sj15);
IkReal x2064=((0.8)*cj16);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j17), 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x2062*x2064))+((x2063*x2064))+(((0.2)*x2062))+(((0.2)*x2063)));
evalcond[2]=((((-1.0)*x2061*x2062))+(((-1.0)*x2061*x2063))+(((-1.0)*cj16*pz))+(((0.1)*sj16)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2065=IKcos(j18);
IkReal x2066=(py*sj15);
IkReal x2067=((1.0)*cj16);
IkReal x2068=((1.0)*cj15);
IkReal x2069=(cj15*px);
IkReal x2070=((0.321)*x2065);
evalcond[0]=(((sj16*x2070))+(((0.4)*sj16))+pz);
evalcond[1]=(((px*sj15))+(((-1.0)*py*x2068))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x2065))+(((-1.0)*pp))+(((0.2)*x2066))+(((0.2)*x2069)));
evalcond[3]=((0.1)+(((-1.0)*px*x2068))+(((-1.0)*x2066))+(((0.4)*cj16))+((cj16*x2070)));
evalcond[4]=((0.4)+x2070+((pz*sj16))+(((-1.0)*x2066*x2067))+(((-1.0)*x2067*x2069))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2071=(cj15*px);
IkReal x2072=((0.8)*cj16);
IkReal x2073=(py*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j17), 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((-0.066959)+((x2071*x2072))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x2072*x2073))+(((0.2)*x2071))+(((0.2)*x2073)));
evalcond[2]=(((sj16*x2073))+((sj16*x2071))+(((-0.1)*sj16))+((cj16*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2074=IKcos(j18);
IkReal x2075=(py*sj15);
IkReal x2076=((1.0)*cj16);
IkReal x2077=((1.0)*cj15);
IkReal x2078=(cj15*px);
IkReal x2079=((0.321)*x2074);
evalcond[0]=(((sj16*x2079))+(((0.4)*sj16))+pz);
evalcond[1]=(((px*sj15))+(((-0.321)*(IKsin(j18))))+(((-1.0)*py*x2077)));
evalcond[2]=((0.253041)+(((0.2568)*x2074))+(((-1.0)*pp))+(((0.2)*x2075))+(((0.2)*x2078)));
evalcond[3]=((0.1)+(((-1.0)*px*x2077))+(((-1.0)*x2075))+(((0.4)*cj16))+((cj16*x2079)));
evalcond[4]=((0.4)+x2079+(((-1.0)*x2076*x2078))+((pz*sj16))+(((-1.0)*x2075*x2076))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2080=(py*sj15);
IkReal x2081=((0.8)*cj16);
IkReal x2082=(cj15*px);
IkReal x2083=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x2083;
evalcond[2]=((-0.066959)+((x2081*x2082))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((0.2)*x2080))+(((0.2)*x2082))+(((-0.08)*cj16))+((x2080*x2081)));
evalcond[3]=x2083;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst49;
gconst49=IKsign(((((321.0)*(cj16*cj16)))+(((321.0)*(sj16*sj16)))));
dummyeval[0]=((sj16*sj16)+(cj16*cj16));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2084=IKcos(j18);
IkReal x2085=(cj15*px);
IkReal x2086=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x2084))+pz);
evalcond[1]=((0.1)+(((-1.0)*x2085))+(((-1.0)*x2086))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x2086))+(((0.2)*x2085))+(((0.2568)*x2084)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j16), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2087=IKcos(j18);
IkReal x2088=(cj15*px);
IkReal x2089=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x2087))+pz);
evalcond[1]=((0.1)+(((-1.0)*x2088))+(((-1.0)*x2089))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x2089))+(((0.2)*x2088))+(((0.2568)*x2087)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2090=(cj16*sj16);
IkReal x2091=(py*sj15);
IkReal x2092=((3.11526479750779)*cj16);
IkReal x2093=((1000.0)*pz);
IkReal x2094=(cj15*px);
CheckValue<IkReal> x2095=IKPowWithIntegerCheck(cj16,-1);
if(!x2095.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2095.value)*(((((-1.0)*x2093))+(((100.0)*x2090))+((x2093*(sj16*sj16)))+(((-1000.0)*x2090*x2094))+(((-1000.0)*x2090*x2091)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x2091*x2092))+((x2092*x2094))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2095.value)*(((((-1.0)*x2093))+(((100.0)*x2090))+((x2093*(sj16*sj16)))+(((-1000.0)*x2090*x2094))+(((-1000.0)*x2090*x2091))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x2091*x2092))+((x2092*x2094))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2095.value)*(((((-1.0)*x2093))+(((100.0)*x2090))+((x2093*(sj16*sj16)))+(((-1000.0)*x2090*x2094))+(((-1000.0)*x2090*x2091))))), ((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x2091*x2092))+((x2092*x2094))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2096=IKcos(j18);
IkReal x2097=IKsin(j18);
IkReal x2098=(py*sj15);
IkReal x2099=(cj15*px);
IkReal x2100=((1.0)*cj16);
IkReal x2101=((0.321)*x2096);
IkReal x2102=((0.321)*x2097);
evalcond[0]=((((0.4)*sj16))+((cj16*x2102))+pz+((sj16*x2101)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x2098))+(((0.2)*x2099))+(((0.2568)*x2096)));
evalcond[2]=((((-0.1)*sj16))+x2102+((sj16*x2098))+((sj16*x2099))+((cj16*pz)));
evalcond[3]=((0.4)+x2101+((pz*sj16))+(((-1.0)*x2099*x2100))+(((-1.0)*x2098*x2100))+(((0.1)*cj16)));
evalcond[4]=((0.1)+((cj16*x2101))+(((0.4)*cj16))+(((-1.0)*x2098))+(((-1.0)*x2099))+(((-1.0)*sj16*x2102)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2103=((250.0)*sj16);
IkReal x2104=(py*sj15);
IkReal x2105=(cj15*px);
CheckValue<IkReal> x2106=IKPowWithIntegerCheck(cj16,-1);
if(!x2106.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2106.value)*(((((-1000.0)*pz))+((x2103*x2105))+((x2103*x2104))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2104))+(((-0.778816199376947)*x2105)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2106.value)*(((((-1000.0)*pz))+((x2103*x2105))+((x2103*x2104))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2104))+(((-0.778816199376947)*x2105))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2106.value)*(((((-1000.0)*pz))+((x2103*x2105))+((x2103*x2104))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2104))+(((-0.778816199376947)*x2105))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2107=IKcos(j18);
IkReal x2108=IKsin(j18);
IkReal x2109=(py*sj15);
IkReal x2110=(cj15*px);
IkReal x2111=((1.0)*cj16);
IkReal x2112=((0.321)*x2107);
IkReal x2113=((0.321)*x2108);
evalcond[0]=((((0.4)*sj16))+((sj16*x2112))+pz+((cj16*x2113)));
evalcond[1]=((0.253041)+(((0.2)*x2109))+(((-1.0)*pp))+(((0.2)*x2110))+(((0.2568)*x2107)));
evalcond[2]=((((-0.1)*sj16))+x2113+((sj16*x2110))+((cj16*pz))+((sj16*x2109)));
evalcond[3]=((0.4)+x2112+((pz*sj16))+(((-1.0)*x2109*x2111))+(((-1.0)*x2110*x2111))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((0.4)*cj16))+((cj16*x2112))+(((-1.0)*x2109))+(((-1.0)*x2110))+(((-1.0)*sj16*x2113)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2114=((1000.0)*cj16);
IkReal x2115=((1000.0)*sj16);
IkReal x2116=(py*sj15);
IkReal x2117=(cj15*px);
CheckValue<IkReal> x2118 = IKatan2WithCheck((gconst49*(((((100.0)*sj16))+(((-1.0)*pz*x2114))+(((-1.0)*x2115*x2117))+(((-1.0)*x2115*x2116))))),(gconst49*(((((-100.0)*cj16))+(((-400.0)*(sj16*sj16)))+(((-1.0)*pz*x2115))+(((-400.0)*(cj16*cj16)))+((x2114*x2116))+((x2114*x2117))))),IKFAST_ATAN2_MAGTHRESH);
if(!x2118.valid){
continue;
}
j18array[0]=x2118.value;
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2119=IKcos(j18);
IkReal x2120=IKsin(j18);
IkReal x2121=(py*sj15);
IkReal x2122=(cj15*px);
IkReal x2123=((1.0)*cj16);
IkReal x2124=((0.321)*x2119);
IkReal x2125=((0.321)*x2120);
evalcond[0]=(((sj16*x2124))+(((0.4)*sj16))+pz+((cj16*x2125)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x2121))+(((0.2)*x2122))+(((0.2568)*x2119)));
evalcond[2]=(((sj16*x2122))+((sj16*x2121))+(((-0.1)*sj16))+x2125+((cj16*pz)));
evalcond[3]=((0.4)+(((-1.0)*x2122*x2123))+x2124+((pz*sj16))+(((-1.0)*x2121*x2123))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x2122))+(((-1.0)*x2121))+(((-1.0)*sj16*x2125))+(((0.4)*cj16))+((cj16*x2124)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2126=(py*sj15);
IkReal x2127=(cj15*py);
IkReal x2128=((0.8)*cj16);
IkReal x2129=(cj15*px);
IkReal x2130=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=(x2130+(((-1.0)*x2127)));
evalcond[2]=((-0.066959)+((x2128*x2129))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+(((0.2)*x2129))+(((0.2)*x2126))+((x2126*x2128)));
evalcond[3]=(x2127+(((-1.0)*x2130)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst50;
gconst50=IKsign(((((321.0)*(cj16*cj16)))+(((321.0)*(sj16*sj16)))));
dummyeval[0]=((sj16*sj16)+(cj16*cj16));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2131=IKcos(j18);
IkReal x2132=(cj15*px);
IkReal x2133=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x2131))+pz);
evalcond[1]=((0.1)+(((-1.0)*x2132))+(((-1.0)*x2133))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x2133))+(((0.2)*x2132))+(((-1.0)*pp))+(((0.2568)*x2131)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j16), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x2134=IKcos(j18);
IkReal x2135=(cj15*px);
IkReal x2136=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x2134))+pz);
evalcond[1]=((0.1)+(((-1.0)*x2135))+(((-1.0)*x2136))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x2135))+(((0.2)*x2136))+(((-1.0)*pp))+(((0.2568)*x2134)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2137=(cj16*sj16);
IkReal x2138=(py*sj15);
IkReal x2139=((3.11526479750779)*cj16);
IkReal x2140=((1000.0)*pz);
IkReal x2141=(cj15*px);
CheckValue<IkReal> x2142=IKPowWithIntegerCheck(cj16,-1);
if(!x2142.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2142.value)*(((((1000.0)*x2137*x2138))+(((-100.0)*x2137))+(((-1.0)*x2140*(sj16*sj16)))+x2140+(((1000.0)*x2137*x2141)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x2138*x2139))+(((-0.311526479750779)*cj16))+((x2139*x2141)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2142.value)*(((((1000.0)*x2137*x2138))+(((-100.0)*x2137))+(((-1.0)*x2140*(sj16*sj16)))+x2140+(((1000.0)*x2137*x2141))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x2138*x2139))+(((-0.311526479750779)*cj16))+((x2139*x2141))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2142.value)*(((((1000.0)*x2137*x2138))+(((-100.0)*x2137))+(((-1.0)*x2140*(sj16*sj16)))+x2140+(((1000.0)*x2137*x2141))))), ((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x2138*x2139))+(((-0.311526479750779)*cj16))+((x2139*x2141))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2143=IKcos(j18);
IkReal x2144=IKsin(j18);
IkReal x2145=((1.0)*cj16);
IkReal x2146=(py*sj15);
IkReal x2147=(cj15*px);
IkReal x2148=((0.321)*x2143);
IkReal x2149=((1.0)*x2147);
IkReal x2150=((0.321)*x2144);
evalcond[0]=((((0.4)*sj16))+pz+((sj16*x2148))+(((-1.0)*cj16*x2150)));
evalcond[1]=((0.253041)+(((0.2568)*x2143))+(((-1.0)*pp))+(((0.2)*x2147))+(((0.2)*x2146)));
evalcond[2]=((0.4)+x2148+((pz*sj16))+(((-1.0)*x2145*x2146))+(((-1.0)*x2145*x2147))+(((0.1)*cj16)));
evalcond[3]=((((-1.0)*sj16*x2146))+(((-1.0)*sj16*x2149))+x2150+(((-1.0)*pz*x2145))+(((0.1)*sj16)));
evalcond[4]=((0.1)+(((-1.0)*x2146))+((cj16*x2148))+(((-1.0)*x2149))+((sj16*x2150))+(((0.4)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2151=((250.0)*sj16);
IkReal x2152=(py*sj15);
IkReal x2153=(cj15*px);
CheckValue<IkReal> x2154=IKPowWithIntegerCheck(cj16,-1);
if(!x2154.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2154.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((1000.0)*pz))+(((-1.0)*x2151*x2153))+(((-1.0)*x2151*x2152)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2152))+(((-0.778816199376947)*x2153)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2154.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((1000.0)*pz))+(((-1.0)*x2151*x2153))+(((-1.0)*x2151*x2152))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2152))+(((-0.778816199376947)*x2153))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2154.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((1000.0)*pz))+(((-1.0)*x2151*x2153))+(((-1.0)*x2151*x2152))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2152))+(((-0.778816199376947)*x2153))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2155=IKcos(j18);
IkReal x2156=IKsin(j18);
IkReal x2157=((1.0)*cj16);
IkReal x2158=(py*sj15);
IkReal x2159=(cj15*px);
IkReal x2160=((0.321)*x2155);
IkReal x2161=((1.0)*x2159);
IkReal x2162=((0.321)*x2156);
evalcond[0]=((((0.4)*sj16))+((sj16*x2160))+(((-1.0)*cj16*x2162))+pz);
evalcond[1]=((0.253041)+(((0.2)*x2159))+(((0.2)*x2158))+(((0.2568)*x2155))+(((-1.0)*pp)));
evalcond[2]=((0.4)+x2160+(((-1.0)*x2157*x2158))+(((-1.0)*x2157*x2159))+((pz*sj16))+(((0.1)*cj16)));
evalcond[3]=(x2162+(((-1.0)*pz*x2157))+(((0.1)*sj16))+(((-1.0)*sj16*x2161))+(((-1.0)*sj16*x2158)));
evalcond[4]=((0.1)+((sj16*x2162))+(((0.4)*cj16))+((cj16*x2160))+(((-1.0)*x2161))+(((-1.0)*x2158)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2163=((1000.0)*cj16);
IkReal x2164=((1000.0)*sj16);
IkReal x2165=(py*sj15);
IkReal x2166=(cj15*px);
CheckValue<IkReal> x2167 = IKatan2WithCheck((gconst50*((((x2164*x2166))+((x2164*x2165))+((pz*x2163))+(((-100.0)*sj16))))),(gconst50*(((((-100.0)*cj16))+(((-400.0)*(sj16*sj16)))+(((-1.0)*pz*x2164))+(((-400.0)*(cj16*cj16)))+((x2163*x2166))+((x2163*x2165))))),IKFAST_ATAN2_MAGTHRESH);
if(!x2167.valid){
continue;
}
j18array[0]=x2167.value;
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x2168=IKcos(j18);
IkReal x2169=IKsin(j18);
IkReal x2170=((1.0)*cj16);
IkReal x2171=(py*sj15);
IkReal x2172=(cj15*px);
IkReal x2173=((0.321)*x2168);
IkReal x2174=((1.0)*x2172);
IkReal x2175=((0.321)*x2169);
evalcond[0]=((((-1.0)*cj16*x2175))+(((0.4)*sj16))+pz+((sj16*x2173)));
evalcond[1]=((0.253041)+(((0.2)*x2171))+(((0.2)*x2172))+(((-1.0)*pp))+(((0.2568)*x2168)));
evalcond[2]=((0.4)+(((-1.0)*x2170*x2171))+(((-1.0)*x2170*x2172))+x2173+((pz*sj16))+(((0.1)*cj16)));
evalcond[3]=(x2175+(((-1.0)*pz*x2170))+(((-1.0)*sj16*x2171))+(((0.1)*sj16))+(((-1.0)*sj16*x2174)));
evalcond[4]=((0.1)+((cj16*x2173))+(((0.4)*cj16))+(((-1.0)*x2171))+((sj16*x2175))+(((-1.0)*x2174)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2176=((250.0)*sj16);
IkReal x2177=(py*sj15);
IkReal x2178=(cj15*px);
CheckValue<IkReal> x2179=IKPowWithIntegerCheck(cj16,-1);
if(!x2179.valid){
continue;
}
CheckValue<IkReal> x2180=IKPowWithIntegerCheck(cj17,-1);
if(!x2180.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2179.value)*(x2180.value)*(((((-1000.0)*pz))+((x2176*x2177))+((x2176*x2178))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x2178))+(((-0.778816199376947)*x2177))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2179.value)*(x2180.value)*(((((-1000.0)*pz))+((x2176*x2177))+((x2176*x2178))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x2178))+(((-0.778816199376947)*x2177))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2179.value)*(x2180.value)*(((((-1000.0)*pz))+((x2176*x2177))+((x2176*x2178))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((-0.778816199376947)*x2178))+(((-0.778816199376947)*x2177))+(((3.89408099688474)*pp))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x2181=IKcos(j18);
IkReal x2182=IKsin(j18);
IkReal x2183=(cj17*sj16);
IkReal x2184=(cj16*cj17);
IkReal x2185=(cj15*px);
IkReal x2186=((1.0)*cj16);
IkReal x2187=(py*sj15);
IkReal x2188=(px*sj15);
IkReal x2189=((0.321)*x2182);
IkReal x2190=((0.321)*x2181);
IkReal x2191=((1.0)*cj15*py);
evalcond[0]=(((sj17*x2189))+x2188+(((-1.0)*x2191)));
evalcond[1]=((0.253041)+(((0.2568)*x2181))+(((-1.0)*pp))+(((0.2)*x2187))+(((0.2)*x2185)));
evalcond[2]=(((sj16*x2190))+(((0.4)*sj16))+pz+((x2184*x2189)));
evalcond[3]=((0.4)+x2190+((pz*sj16))+(((-1.0)*x2186*x2187))+(((-1.0)*x2185*x2186))+(((0.1)*cj16)));
evalcond[4]=((0.1)+((cj16*x2190))+(((-1.0)*x2185))+(((-1.0)*x2187))+(((0.4)*cj16))+(((-1.0)*x2183*x2189)));
evalcond[5]=((((-0.1)*x2183))+((pz*x2184))+((sj17*x2188))+x2189+(((-1.0)*sj17*x2191))+((x2183*x2187))+((x2183*x2185)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x2192=((3.11526479750779)*cj16);
CheckValue<IkReal> x2193=IKPowWithIntegerCheck(sj17,-1);
if(!x2193.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2193.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((py*sj15*x2192))+((cj15*px*x2192))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2193.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((py*sj15*x2192))+((cj15*px*x2192))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2193.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((py*sj15*x2192))+((cj15*px*x2192))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x2194=IKcos(j18);
IkReal x2195=IKsin(j18);
IkReal x2196=(cj17*sj16);
IkReal x2197=(cj16*cj17);
IkReal x2198=(cj15*px);
IkReal x2199=((1.0)*cj16);
IkReal x2200=(py*sj15);
IkReal x2201=(px*sj15);
IkReal x2202=((0.321)*x2195);
IkReal x2203=((0.321)*x2194);
IkReal x2204=((1.0)*cj15*py);
evalcond[0]=(x2201+(((-1.0)*x2204))+((sj17*x2202)));
evalcond[1]=((0.253041)+(((0.2568)*x2194))+(((-1.0)*pp))+(((0.2)*x2198))+(((0.2)*x2200)));
evalcond[2]=(((sj16*x2203))+(((0.4)*sj16))+pz+((x2197*x2202)));
evalcond[3]=((0.4)+x2203+((pz*sj16))+(((-1.0)*x2199*x2200))+(((-1.0)*x2198*x2199))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x2200))+((cj16*x2203))+(((-1.0)*x2198))+(((-1.0)*x2196*x2202))+(((0.4)*cj16)));
evalcond[5]=(((x2196*x2198))+(((-0.1)*x2196))+x2202+((sj17*x2201))+(((-1.0)*sj17*x2204))+((x2196*x2200))+((pz*x2197)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x2205=IKPowWithIntegerCheck(sj17,-1);
if(!x2205.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2205.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2205.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x2205.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x2206=IKcos(j18);
IkReal x2207=IKsin(j18);
IkReal x2208=(cj17*sj16);
IkReal x2209=(cj16*cj17);
IkReal x2210=(cj15*px);
IkReal x2211=((1.0)*cj16);
IkReal x2212=(py*sj15);
IkReal x2213=(px*sj15);
IkReal x2214=((0.321)*x2207);
IkReal x2215=((0.321)*x2206);
IkReal x2216=((1.0)*cj15*py);
evalcond[0]=(x2213+(((-1.0)*x2216))+((sj17*x2214)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x2206))+(((0.2)*x2212))+(((0.2)*x2210)));
evalcond[2]=((((0.4)*sj16))+((sj16*x2215))+pz+((x2209*x2214)));
evalcond[3]=((0.4)+(((-1.0)*x2210*x2211))+x2215+((pz*sj16))+(((-1.0)*x2211*x2212))+(((0.1)*cj16)));
evalcond[4]=((0.1)+((cj16*x2215))+(((-1.0)*x2212))+(((-1.0)*x2210))+(((-1.0)*x2208*x2214))+(((0.4)*cj16)));
evalcond[5]=(x2214+((sj17*x2213))+(((-0.1)*x2208))+(((-1.0)*sj17*x2216))+((pz*x2209))+((x2208*x2210))+((x2208*x2212)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x146=((1.0)*cj17);
IkReal x147=(cj18*sj16);
IkReal x148=(cj16*sj17);
IkReal x149=(sj16*sj18);
IkReal x150=(sj16*sj17);
IkReal x151=(cj16*cj18);
IkReal x152=(sj17*sj18);
IkReal x153=(cj16*sj18);
IkReal x154=(cj18*sj15*sj17);
IkReal x155=(x149+(((-1.0)*x146*x151)));
IkReal x156=(((sj15*x150))+((cj15*cj17)));
IkReal x157=((((-1.0)*sj15*x146))+((cj15*x150)));
IkReal x158=(x151+(((-1.0)*x146*x149)));
IkReal x159=(cj15*x158);
IkReal x160=((((-1.0)*x153))+(((-1.0)*x146*x147)));
IkReal x161=((((-1.0)*x147))+(((-1.0)*x146*x153)));
IkReal x162=(cj15*x160);
IkReal x163=(((sj15*x158))+((cj15*x152)));
IkReal x164=(x159+(((-1.0)*sj15*x152)));
IkReal x165=(((cj15*cj18*sj17))+((sj15*x160)));
IkReal x166=(x162+(((-1.0)*x154)));
new_r00=(((r00*x166))+((r20*x155))+((r10*x165)));
new_r01=(((r01*x166))+((r21*x155))+((r11*x165)));
new_r02=(((r02*((x162+(((-1.0)*x154))))))+((r12*x165))+((r22*x155)));
new_r10=(((r20*x148))+((r00*x157))+((r10*x156)));
new_r11=(((r01*x157))+((r21*x148))+((r11*x156)));
new_r12=(((r02*x157))+((r22*x148))+((r12*x156)));
new_r20=(((r20*x161))+((r00*((x159+(((-1.0)*sj15*x152))))))+((r10*x163)));
new_r21=(((r01*x164))+((r21*x161))+((r11*x163)));
new_r22=(((r22*x161))+((r12*x163))+((r02*x164)));
{
IkReal j20array[2], cj20array[2], sj20array[2];
bool j20valid[2]={false};
_nj20 = 2;
cj20array[0]=new_r22;
if( cj20array[0] >= -1-IKFAST_SINCOS_THRESH && cj20array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j20valid[0] = j20valid[1] = true;
    j20array[0] = IKacos(cj20array[0]);
    sj20array[0] = IKsin(j20array[0]);
    cj20array[1] = cj20array[0];
    j20array[1] = -j20array[0];
    sj20array[1] = -sj20array[0];
}
else if( isnan(cj20array[0]) )
{
    // probably any value will work
    j20valid[0] = true;
    cj20array[0] = 1; sj20array[0] = 0; j20array[0] = 0;
}
for(int ij20 = 0; ij20 < 2; ++ij20)
{
if( !j20valid[ij20] )
{
    continue;
}
_ij20[0] = ij20; _ij20[1] = -1;
for(int iij20 = ij20+1; iij20 < 2; ++iij20)
{
if( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )
{
    j20valid[iij20]=false; _ij20[1] = iij20; break; 
}
}
j20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];

{
IkReal dummyeval[1];
IkReal gconst109;
gconst109=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst110;
gconst110=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst111;
gconst111=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x167=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x167;
evalcond[2]=x167;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x167;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
IkReal j21mul = 1;
j21=0;
j19mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j19=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].fmul = j19mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].fmul = j21mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x168=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x168;
evalcond[2]=x168;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
CheckValue<IkReal> x170 = IKatan2WithCheck(new_r02,new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x170.valid){
continue;
}
IkReal x169=x170.value;
j19array[0]=((-1.0)*x169);
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
j19array[1]=((3.14159265358979)+(((-1.0)*x169)));
sj19array[1]=IKsin(j19array[1]);
cj19array[1]=IKcos(j19array[1]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
if( j19array[1] > IKPI )
{
    j19array[1]-=IK2PI;
}
else if( j19array[1] < -IKPI )
{    j19array[1]+=IK2PI;
}
j19valid[1] = true;
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst173;
gconst173=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst174;
gconst174=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x171=((1.0)*sj19);
CheckValue<IkReal> x172 = IKatan2WithCheck((gconst174*((((cj19*new_r10))+(((-1.0)*new_r00*x171))))),(gconst174*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x171))))),IKFAST_ATAN2_MAGTHRESH);
if(!x172.valid){
continue;
}
j21array[0]=x172.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x173=IKsin(j21);
IkReal x174=IKcos(j21);
IkReal x175=((1.0)*cj19);
IkReal x176=((1.0)*sj19);
IkReal x177=((1.0)*x173);
IkReal x178=(sj19*x174);
IkReal x179=(sj19*x173);
IkReal x180=(x173*x175);
evalcond[0]=(x174+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x177))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x174))+x179+new_r00);
evalcond[3]=((((-1.0)*x177))+((cj19*new_r10))+(((-1.0)*new_r00*x176)));
evalcond[4]=((((-1.0)*x174))+((cj19*new_r11))+(((-1.0)*new_r01*x176)));
evalcond[5]=((((-1.0)*x180))+x178+new_r01);
evalcond[6]=((((-1.0)*x180))+x178+new_r10);
evalcond[7]=((((-1.0)*x174*x175))+new_r11+(((-1.0)*x173*x176)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x181=((1.0)*sj19);
CheckValue<IkReal> x182 = IKatan2WithCheck((gconst173*(((((-1.0)*new_r00*x181))+((cj19*new_r01))))),(gconst173*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x181))))),IKFAST_ATAN2_MAGTHRESH);
if(!x182.valid){
continue;
}
j21array[0]=x182.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x183=IKsin(j21);
IkReal x184=IKcos(j21);
IkReal x185=((1.0)*cj19);
IkReal x186=((1.0)*sj19);
IkReal x187=((1.0)*x183);
IkReal x188=(sj19*x184);
IkReal x189=(sj19*x183);
IkReal x190=(x183*x185);
evalcond[0]=(x184+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x187))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x184))+x189+new_r00);
evalcond[3]=((((-1.0)*x187))+((cj19*new_r10))+(((-1.0)*new_r00*x186)));
evalcond[4]=((((-1.0)*x184))+(((-1.0)*new_r01*x186))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x190))+x188+new_r01);
evalcond[6]=((((-1.0)*x190))+x188+new_r10);
evalcond[7]=((((-1.0)*x184*x185))+new_r11+(((-1.0)*x183*x186)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x191=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))));
evalcond[1]=x191;
evalcond[2]=x191;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x191;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
IkReal j21mul = 1;
j21=0;
j19mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j19=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].fmul = j19mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].fmul = j21mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x192=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959))))));
evalcond[1]=x192;
evalcond[2]=x192;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
CheckValue<IkReal> x194 = IKatan2WithCheck(new_r02,new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x194.valid){
continue;
}
IkReal x193=x194.value;
j19array[0]=((-1.0)*x193);
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
j19array[1]=((3.14159265358979)+(((-1.0)*x193)));
sj19array[1]=IKsin(j19array[1]);
cj19array[1]=IKcos(j19array[1]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
if( j19array[1] > IKPI )
{
    j19array[1]-=IK2PI;
}
else if( j19array[1] < -IKPI )
{    j19array[1]+=IK2PI;
}
j19valid[1] = true;
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst175;
gconst175=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst176;
gconst176=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x195=((1.0)*sj19);
CheckValue<IkReal> x196 = IKatan2WithCheck((gconst176*(((((-1.0)*new_r00*x195))+((cj19*new_r10))))),(gconst176*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x195))))),IKFAST_ATAN2_MAGTHRESH);
if(!x196.valid){
continue;
}
j21array[0]=x196.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x197=IKsin(j21);
IkReal x198=IKcos(j21);
IkReal x199=((1.0)*cj19);
IkReal x200=((1.0)*sj19);
IkReal x201=((1.0)*x197);
IkReal x202=(sj19*x198);
IkReal x203=(sj19*x197);
IkReal x204=(x197*x199);
evalcond[0]=(x198+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x201))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x198))+x203+new_r00);
evalcond[3]=((((-1.0)*new_r00*x200))+(((-1.0)*x201))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x198))+((cj19*new_r11))+(((-1.0)*new_r01*x200)));
evalcond[5]=((((-1.0)*x204))+x202+new_r01);
evalcond[6]=((((-1.0)*x204))+x202+new_r10);
evalcond[7]=((((-1.0)*x197*x200))+(((-1.0)*x198*x199))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x205=((1.0)*sj19);
CheckValue<IkReal> x206 = IKatan2WithCheck((gconst175*(((((-1.0)*new_r00*x205))+((cj19*new_r01))))),(gconst175*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x205))))),IKFAST_ATAN2_MAGTHRESH);
if(!x206.valid){
continue;
}
j21array[0]=x206.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x207=IKsin(j21);
IkReal x208=IKcos(j21);
IkReal x209=((1.0)*cj19);
IkReal x210=((1.0)*sj19);
IkReal x211=((1.0)*x207);
IkReal x212=(sj19*x208);
IkReal x213=(sj19*x207);
IkReal x214=(x207*x209);
evalcond[0]=(x208+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x211))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x208))+x213+new_r00);
evalcond[3]=(((cj19*new_r10))+(((-1.0)*x211))+(((-1.0)*new_r00*x210)));
evalcond[4]=((((-1.0)*new_r01*x210))+((cj19*new_r11))+(((-1.0)*x208)));
evalcond[5]=(x212+new_r01+(((-1.0)*x214)));
evalcond[6]=(x212+new_r10+(((-1.0)*x214)));
evalcond[7]=((((-1.0)*x207*x210))+(((-1.0)*x208*x209))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x215 = IKatan2WithCheck((gconst111*new_r21),((-1.0)*gconst111*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x215.valid){
continue;
}
j21array[0]=x215.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[2];
evalcond[0]=(((sj20*(IKcos(j21))))+new_r20);
evalcond[1]=((((-1.0)*sj20*(IKsin(j21))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst112;
gconst112=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst113;
gconst113=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x216=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x216;
evalcond[2]=x216;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x216;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst114;
gconst114=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst115;
gconst115=IKsign(((((-1.0)*cj21*new_r02))+((new_r12*sj21))));
dummyeval[0]=((((-1.0)*cj21*new_r02))+((new_r12*sj21)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst116;
CheckValue<IkReal> x217 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x217.valid){
continue;
}
gconst116=((-1.0)*(x217.value));
IkReal gconst117;
gconst117=IKsin(gconst116);
IkReal gconst118;
gconst118=IKcos(gconst116);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst116)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst122;
gconst122=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst123;
gconst123=IKsign(((((-1.0)*gconst118*new_r02))+((gconst117*new_r12))));
dummyeval[0]=((((-1.0)*gconst118*new_r02))+((gconst117*new_r12)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x218=(gconst123*new_r01);
CheckValue<IkReal> x219 = IKatan2WithCheck((new_r02*x218),((-1.0)*new_r12*x218),IKFAST_ATAN2_MAGTHRESH);
if(!x219.valid){
continue;
}
j19array[0]=x219.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x220=IKcos(j19);
IkReal x221=IKsin(j19);
IkReal x222=((1.0)*gconst118);
IkReal x223=((1.0)*gconst117);
IkReal x224=(gconst117*x221);
IkReal x225=((1.0)*x221);
IkReal x226=(x220*x222);
evalcond[0]=(((new_r02*x220))+((new_r12*x221)));
evalcond[1]=(((new_r12*x220))+(((-1.0)*new_r02*x225)));
evalcond[2]=(((new_r01*x220))+((new_r11*x221))+gconst117);
evalcond[3]=(new_r01+((gconst117*x220))+((gconst118*x221)));
evalcond[4]=(x224+new_r00+(((-1.0)*x226)));
evalcond[5]=(x224+new_r11+(((-1.0)*x226)));
evalcond[6]=(((new_r00*x220))+((new_r10*x221))+(((-1.0)*x222)));
evalcond[7]=((((-1.0)*x220*x223))+(((-1.0)*x221*x222))+new_r10);
evalcond[8]=(((new_r10*x220))+(((-1.0)*x223))+(((-1.0)*new_r00*x225)));
evalcond[9]=((((-1.0)*new_r01*x225))+((new_r11*x220))+(((-1.0)*x222)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x227=(gconst117*gconst122);
CheckValue<IkReal> x228 = IKatan2WithCheck((new_r02*x227),((-1.0)*new_r12*x227),IKFAST_ATAN2_MAGTHRESH);
if(!x228.valid){
continue;
}
j19array[0]=x228.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x229=IKcos(j19);
IkReal x230=IKsin(j19);
IkReal x231=((1.0)*gconst118);
IkReal x232=((1.0)*gconst117);
IkReal x233=(gconst117*x230);
IkReal x234=((1.0)*x230);
IkReal x235=(x229*x231);
evalcond[0]=(((new_r02*x229))+((new_r12*x230)));
evalcond[1]=((((-1.0)*new_r02*x234))+((new_r12*x229)));
evalcond[2]=(((new_r01*x229))+((new_r11*x230))+gconst117);
evalcond[3]=(((gconst118*x230))+new_r01+((gconst117*x229)));
evalcond[4]=((((-1.0)*x235))+x233+new_r00);
evalcond[5]=((((-1.0)*x235))+x233+new_r11);
evalcond[6]=(((new_r00*x229))+((new_r10*x230))+(((-1.0)*x231)));
evalcond[7]=((((-1.0)*x230*x231))+new_r10+(((-1.0)*x229*x232)));
evalcond[8]=((((-1.0)*x232))+((new_r10*x229))+(((-1.0)*new_r00*x234)));
evalcond[9]=((((-1.0)*x231))+((new_r11*x229))+(((-1.0)*new_r01*x234)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst119;
CheckValue<IkReal> x236 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x236.valid){
continue;
}
gconst119=((3.14159265358979)+(((-1.0)*(x236.value))));
IkReal gconst120;
gconst120=IKsin(gconst119);
IkReal gconst121;
gconst121=IKcos(gconst119);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst119)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst124;
gconst124=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst125;
gconst125=IKsign((((gconst120*new_r12))+(((-1.0)*gconst121*new_r02))));
dummyeval[0]=(((gconst120*new_r12))+(((-1.0)*gconst121*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x237=(gconst125*new_r01);
CheckValue<IkReal> x238 = IKatan2WithCheck((new_r02*x237),((-1.0)*new_r12*x237),IKFAST_ATAN2_MAGTHRESH);
if(!x238.valid){
continue;
}
j19array[0]=x238.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x239=IKcos(j19);
IkReal x240=IKsin(j19);
IkReal x241=((1.0)*gconst121);
IkReal x242=((1.0)*gconst120);
IkReal x243=(gconst120*x240);
IkReal x244=((1.0)*x240);
IkReal x245=(x239*x241);
evalcond[0]=(((new_r12*x240))+((new_r02*x239)));
evalcond[1]=(((new_r12*x239))+(((-1.0)*new_r02*x244)));
evalcond[2]=(((new_r01*x239))+gconst120+((new_r11*x240)));
evalcond[3]=(((gconst121*x240))+new_r01+((gconst120*x239)));
evalcond[4]=(x243+(((-1.0)*x245))+new_r00);
evalcond[5]=(x243+(((-1.0)*x245))+new_r11);
evalcond[6]=(((new_r00*x239))+(((-1.0)*x241))+((new_r10*x240)));
evalcond[7]=((((-1.0)*x240*x241))+new_r10+(((-1.0)*x239*x242)));
evalcond[8]=(((new_r10*x239))+(((-1.0)*new_r00*x244))+(((-1.0)*x242)));
evalcond[9]=((((-1.0)*new_r01*x244))+((new_r11*x239))+(((-1.0)*x241)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x246=(gconst120*gconst124);
CheckValue<IkReal> x247 = IKatan2WithCheck((new_r02*x246),((-1.0)*new_r12*x246),IKFAST_ATAN2_MAGTHRESH);
if(!x247.valid){
continue;
}
j19array[0]=x247.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x248=IKcos(j19);
IkReal x249=IKsin(j19);
IkReal x250=((1.0)*gconst121);
IkReal x251=((1.0)*gconst120);
IkReal x252=(gconst120*x249);
IkReal x253=((1.0)*x249);
IkReal x254=(x248*x250);
evalcond[0]=(((new_r12*x249))+((new_r02*x248)));
evalcond[1]=(((new_r12*x248))+(((-1.0)*new_r02*x253)));
evalcond[2]=(((new_r01*x248))+gconst120+((new_r11*x249)));
evalcond[3]=(((gconst121*x249))+((gconst120*x248))+new_r01);
evalcond[4]=(x252+new_r00+(((-1.0)*x254)));
evalcond[5]=(x252+new_r11+(((-1.0)*x254)));
evalcond[6]=(((new_r00*x248))+((new_r10*x249))+(((-1.0)*x250)));
evalcond[7]=((((-1.0)*x248*x251))+(((-1.0)*x249*x250))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x253))+((new_r10*x248))+(((-1.0)*x251)));
evalcond[9]=((((-1.0)*new_r01*x253))+((new_r11*x248))+(((-1.0)*x250)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x255=(gconst115*new_r01);
CheckValue<IkReal> x256 = IKatan2WithCheck((new_r02*x255),((-1.0)*new_r12*x255),IKFAST_ATAN2_MAGTHRESH);
if(!x256.valid){
continue;
}
j19array[0]=x256.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x257=IKcos(j19);
IkReal x258=IKsin(j19);
IkReal x259=((1.0)*cj21);
IkReal x260=(sj21*x258);
IkReal x261=((1.0)*x257);
IkReal x262=((1.0)*x258);
IkReal x263=(x257*x259);
evalcond[0]=(((new_r02*x257))+((new_r12*x258)));
evalcond[1]=(((new_r12*x257))+(((-1.0)*new_r02*x262)));
evalcond[2]=(((new_r01*x257))+sj21+((new_r11*x258)));
evalcond[3]=(((cj21*x258))+((sj21*x257))+new_r01);
evalcond[4]=(x260+new_r00+(((-1.0)*x263)));
evalcond[5]=(x260+new_r11+(((-1.0)*x263)));
evalcond[6]=(((new_r00*x257))+((new_r10*x258))+(((-1.0)*x259)));
evalcond[7]=(new_r10+(((-1.0)*sj21*x261))+(((-1.0)*x258*x259)));
evalcond[8]=((((-1.0)*new_r00*x262))+(((-1.0)*sj21))+((new_r10*x257)));
evalcond[9]=((((-1.0)*new_r01*x262))+((new_r11*x257))+(((-1.0)*x259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x264=(gconst114*sj21);
CheckValue<IkReal> x265 = IKatan2WithCheck((new_r02*x264),((-1.0)*new_r12*x264),IKFAST_ATAN2_MAGTHRESH);
if(!x265.valid){
continue;
}
j19array[0]=x265.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x266=IKcos(j19);
IkReal x267=IKsin(j19);
IkReal x268=((1.0)*cj21);
IkReal x269=(sj21*x267);
IkReal x270=((1.0)*x266);
IkReal x271=((1.0)*x267);
IkReal x272=(x266*x268);
evalcond[0]=(((new_r12*x267))+((new_r02*x266)));
evalcond[1]=(((new_r12*x266))+(((-1.0)*new_r02*x271)));
evalcond[2]=(sj21+((new_r01*x266))+((new_r11*x267)));
evalcond[3]=(((cj21*x267))+new_r01+((sj21*x266)));
evalcond[4]=(x269+(((-1.0)*x272))+new_r00);
evalcond[5]=(x269+(((-1.0)*x272))+new_r11);
evalcond[6]=(((new_r00*x266))+(((-1.0)*x268))+((new_r10*x267)));
evalcond[7]=((((-1.0)*x267*x268))+new_r10+(((-1.0)*sj21*x270)));
evalcond[8]=((((-1.0)*new_r00*x271))+(((-1.0)*sj21))+((new_r10*x266)));
evalcond[9]=((((-1.0)*new_r01*x271))+(((-1.0)*x268))+((new_r11*x266)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x273=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x273;
evalcond[2]=x273;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst126;
gconst126=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst127;
gconst127=IKsign((((cj21*new_r12))+(((-1.0)*new_r02*sj21))));
dummyeval[0]=(((cj21*new_r12))+(((-1.0)*new_r02*sj21)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst128;
CheckValue<IkReal> x274 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x274.valid){
continue;
}
gconst128=((-1.0)*(x274.value));
IkReal gconst129;
gconst129=IKsin(gconst128);
IkReal gconst130;
gconst130=IKcos(gconst128);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst128)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst134;
gconst134=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst135;
gconst135=IKsign((((gconst130*new_r12))+(((-1.0)*gconst129*new_r02))));
dummyeval[0]=(((gconst130*new_r12))+(((-1.0)*gconst129*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x275=(gconst135*new_r00);
CheckValue<IkReal> x276 = IKatan2WithCheck((new_r02*x275),((-1.0)*new_r12*x275),IKFAST_ATAN2_MAGTHRESH);
if(!x276.valid){
continue;
}
j19array[0]=x276.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x277=IKcos(j19);
IkReal x278=IKsin(j19);
IkReal x279=((1.0)*gconst129);
IkReal x280=((1.0)*gconst130);
IkReal x281=(gconst130*x278);
IkReal x282=(gconst129*x278);
IkReal x283=((1.0)*x278);
IkReal x284=(x277*x279);
evalcond[0]=(((new_r02*x277))+((new_r12*x278)));
evalcond[1]=((((-1.0)*new_r02*x283))+((new_r12*x277)));
evalcond[2]=(((new_r00*x277))+gconst130+((new_r10*x278)));
evalcond[3]=(((gconst130*x277))+x282+new_r00);
evalcond[4]=(x281+(((-1.0)*x284))+new_r01);
evalcond[5]=(x281+(((-1.0)*x284))+new_r10);
evalcond[6]=(((new_r01*x277))+(((-1.0)*x279))+((new_r11*x278)));
evalcond[7]=((((-1.0)*x277*x280))+(((-1.0)*x278*x279))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x283))+(((-1.0)*x279))+((new_r10*x277)));
evalcond[9]=((((-1.0)*new_r01*x283))+(((-1.0)*x280))+((new_r11*x277)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x285=(gconst130*gconst134);
CheckValue<IkReal> x286 = IKatan2WithCheck((new_r02*x285),((-1.0)*new_r12*x285),IKFAST_ATAN2_MAGTHRESH);
if(!x286.valid){
continue;
}
j19array[0]=x286.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x287=IKcos(j19);
IkReal x288=IKsin(j19);
IkReal x289=((1.0)*gconst129);
IkReal x290=((1.0)*gconst130);
IkReal x291=(gconst130*x288);
IkReal x292=(gconst129*x288);
IkReal x293=((1.0)*x288);
IkReal x294=(x287*x289);
evalcond[0]=(((new_r02*x287))+((new_r12*x288)));
evalcond[1]=(((new_r12*x287))+(((-1.0)*new_r02*x293)));
evalcond[2]=(gconst130+((new_r00*x287))+((new_r10*x288)));
evalcond[3]=(((gconst130*x287))+x292+new_r00);
evalcond[4]=((((-1.0)*x294))+x291+new_r01);
evalcond[5]=((((-1.0)*x294))+x291+new_r10);
evalcond[6]=((((-1.0)*x289))+((new_r11*x288))+((new_r01*x287)));
evalcond[7]=((((-1.0)*x288*x289))+(((-1.0)*x287*x290))+new_r11);
evalcond[8]=((((-1.0)*x289))+(((-1.0)*new_r00*x293))+((new_r10*x287)));
evalcond[9]=((((-1.0)*new_r01*x293))+(((-1.0)*x290))+((new_r11*x287)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst131;
CheckValue<IkReal> x295 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x295.valid){
continue;
}
gconst131=((3.14159265358979)+(((-1.0)*(x295.value))));
IkReal gconst132;
gconst132=IKsin(gconst131);
IkReal gconst133;
gconst133=IKcos(gconst131);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst131)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst136;
gconst136=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst137;
gconst137=IKsign((((gconst133*new_r12))+(((-1.0)*gconst132*new_r02))));
dummyeval[0]=(((gconst133*new_r12))+(((-1.0)*gconst132*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x296=(gconst137*new_r00);
CheckValue<IkReal> x297 = IKatan2WithCheck((new_r02*x296),((-1.0)*new_r12*x296),IKFAST_ATAN2_MAGTHRESH);
if(!x297.valid){
continue;
}
j19array[0]=x297.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x298=IKcos(j19);
IkReal x299=IKsin(j19);
IkReal x300=((1.0)*gconst132);
IkReal x301=((1.0)*gconst133);
IkReal x302=(gconst133*x299);
IkReal x303=((1.0)*x299);
IkReal x304=(x298*x300);
evalcond[0]=(((new_r02*x298))+((new_r12*x299)));
evalcond[1]=((((-1.0)*new_r02*x303))+((new_r12*x298)));
evalcond[2]=(((new_r10*x299))+((new_r00*x298))+gconst133);
evalcond[3]=(((gconst133*x298))+((gconst132*x299))+new_r00);
evalcond[4]=(x302+new_r01+(((-1.0)*x304)));
evalcond[5]=(x302+new_r10+(((-1.0)*x304)));
evalcond[6]=(((new_r11*x299))+((new_r01*x298))+(((-1.0)*x300)));
evalcond[7]=((((-1.0)*x298*x301))+(((-1.0)*x299*x300))+new_r11);
evalcond[8]=(((new_r10*x298))+(((-1.0)*new_r00*x303))+(((-1.0)*x300)));
evalcond[9]=(((new_r11*x298))+(((-1.0)*new_r01*x303))+(((-1.0)*x301)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x305=(gconst133*gconst136);
CheckValue<IkReal> x306 = IKatan2WithCheck((new_r02*x305),((-1.0)*new_r12*x305),IKFAST_ATAN2_MAGTHRESH);
if(!x306.valid){
continue;
}
j19array[0]=x306.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x307=IKcos(j19);
IkReal x308=IKsin(j19);
IkReal x309=((1.0)*gconst132);
IkReal x310=((1.0)*gconst133);
IkReal x311=(gconst133*x308);
IkReal x312=((1.0)*x308);
IkReal x313=(x307*x309);
evalcond[0]=(((new_r12*x308))+((new_r02*x307)));
evalcond[1]=((((-1.0)*new_r02*x312))+((new_r12*x307)));
evalcond[2]=(((new_r00*x307))+((new_r10*x308))+gconst133);
evalcond[3]=(((gconst133*x307))+new_r00+((gconst132*x308)));
evalcond[4]=(x311+(((-1.0)*x313))+new_r01);
evalcond[5]=(x311+(((-1.0)*x313))+new_r10);
evalcond[6]=(((new_r01*x307))+((new_r11*x308))+(((-1.0)*x309)));
evalcond[7]=((((-1.0)*x308*x309))+(((-1.0)*x307*x310))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x312))+((new_r10*x307))+(((-1.0)*x309)));
evalcond[9]=(((new_r11*x307))+(((-1.0)*x310))+(((-1.0)*new_r01*x312)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x314=(gconst127*new_r00);
CheckValue<IkReal> x315 = IKatan2WithCheck((new_r02*x314),((-1.0)*new_r12*x314),IKFAST_ATAN2_MAGTHRESH);
if(!x315.valid){
continue;
}
j19array[0]=x315.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x316=IKcos(j19);
IkReal x317=IKsin(j19);
IkReal x318=((1.0)*sj21);
IkReal x319=(cj21*x317);
IkReal x320=((1.0)*x316);
IkReal x321=((1.0)*x317);
IkReal x322=(x316*x318);
evalcond[0]=(((new_r02*x316))+((new_r12*x317)));
evalcond[1]=((((-1.0)*new_r02*x321))+((new_r12*x316)));
evalcond[2]=(((new_r00*x316))+cj21+((new_r10*x317)));
evalcond[3]=(((cj21*x316))+new_r00+((sj21*x317)));
evalcond[4]=((((-1.0)*x322))+x319+new_r01);
evalcond[5]=((((-1.0)*x322))+x319+new_r10);
evalcond[6]=(((new_r01*x316))+(((-1.0)*x318))+((new_r11*x317)));
evalcond[7]=((((-1.0)*cj21*x320))+new_r11+(((-1.0)*x317*x318)));
evalcond[8]=((((-1.0)*x318))+((new_r10*x316))+(((-1.0)*new_r00*x321)));
evalcond[9]=((((-1.0)*new_r01*x321))+(((-1.0)*cj21))+((new_r11*x316)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x323=(cj21*gconst126);
CheckValue<IkReal> x324 = IKatan2WithCheck((new_r02*x323),((-1.0)*new_r12*x323),IKFAST_ATAN2_MAGTHRESH);
if(!x324.valid){
continue;
}
j19array[0]=x324.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x325=IKcos(j19);
IkReal x326=IKsin(j19);
IkReal x327=((1.0)*sj21);
IkReal x328=(cj21*x326);
IkReal x329=((1.0)*x325);
IkReal x330=((1.0)*x326);
IkReal x331=(x325*x327);
evalcond[0]=(((new_r12*x326))+((new_r02*x325)));
evalcond[1]=(((new_r12*x325))+(((-1.0)*new_r02*x330)));
evalcond[2]=(((new_r00*x325))+cj21+((new_r10*x326)));
evalcond[3]=(((sj21*x326))+new_r00+((cj21*x325)));
evalcond[4]=(x328+(((-1.0)*x331))+new_r01);
evalcond[5]=(x328+(((-1.0)*x331))+new_r10);
evalcond[6]=(((new_r01*x325))+(((-1.0)*x327))+((new_r11*x326)));
evalcond[7]=((((-1.0)*cj21*x329))+(((-1.0)*x326*x327))+new_r11);
evalcond[8]=((((-1.0)*x327))+(((-1.0)*new_r00*x330))+((new_r10*x325)));
evalcond[9]=((((-1.0)*cj21))+(((-1.0)*new_r01*x330))+((new_r11*x325)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x332=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))));
evalcond[1]=x332;
evalcond[2]=x332;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x332;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst138;
gconst138=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst139;
gconst139=IKsign(((((-1.0)*cj21*new_r02))+((new_r12*sj21))));
dummyeval[0]=((((-1.0)*cj21*new_r02))+((new_r12*sj21)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst140;
CheckValue<IkReal> x333 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x333.valid){
continue;
}
gconst140=((-1.0)*(x333.value));
IkReal gconst141;
gconst141=IKsin(gconst140);
IkReal gconst142;
gconst142=IKcos(gconst140);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst140)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst146;
gconst146=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst147;
gconst147=IKsign((((gconst141*new_r12))+(((-1.0)*gconst142*new_r02))));
dummyeval[0]=(((gconst141*new_r12))+(((-1.0)*gconst142*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x334=(gconst147*new_r01);
CheckValue<IkReal> x335 = IKatan2WithCheck((new_r02*x334),((-1.0)*new_r12*x334),IKFAST_ATAN2_MAGTHRESH);
if(!x335.valid){
continue;
}
j19array[0]=x335.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x336=IKcos(j19);
IkReal x337=IKsin(j19);
IkReal x338=((1.0)*gconst142);
IkReal x339=(gconst141*x337);
IkReal x340=((1.0)*x337);
IkReal x341=(gconst141*x336);
IkReal x342=(x336*x338);
evalcond[0]=(((new_r12*x337))+((new_r02*x336)));
evalcond[1]=((((-1.0)*new_r02*x340))+((new_r12*x336)));
evalcond[2]=(((new_r01*x336))+((new_r11*x337))+gconst141);
evalcond[3]=(x341+((gconst142*x337))+new_r01);
evalcond[4]=(x339+new_r00+(((-1.0)*x342)));
evalcond[5]=(x339+new_r11+(((-1.0)*x342)));
evalcond[6]=(((new_r00*x336))+((new_r10*x337))+(((-1.0)*x338)));
evalcond[7]=((((-1.0)*x337*x338))+new_r10+(((-1.0)*x341)));
evalcond[8]=(((new_r10*x336))+(((-1.0)*new_r00*x340))+(((-1.0)*gconst141)));
evalcond[9]=(((new_r11*x336))+(((-1.0)*x338))+(((-1.0)*new_r01*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x343=(gconst141*gconst146);
CheckValue<IkReal> x344 = IKatan2WithCheck((new_r02*x343),((-1.0)*new_r12*x343),IKFAST_ATAN2_MAGTHRESH);
if(!x344.valid){
continue;
}
j19array[0]=x344.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x345=IKcos(j19);
IkReal x346=IKsin(j19);
IkReal x347=((1.0)*gconst142);
IkReal x348=(gconst141*x346);
IkReal x349=((1.0)*x346);
IkReal x350=(gconst141*x345);
IkReal x351=(x345*x347);
evalcond[0]=(((new_r02*x345))+((new_r12*x346)));
evalcond[1]=((((-1.0)*new_r02*x349))+((new_r12*x345)));
evalcond[2]=(((new_r11*x346))+((new_r01*x345))+gconst141);
evalcond[3]=(x350+((gconst142*x346))+new_r01);
evalcond[4]=((((-1.0)*x351))+x348+new_r00);
evalcond[5]=((((-1.0)*x351))+x348+new_r11);
evalcond[6]=(((new_r00*x345))+((new_r10*x346))+(((-1.0)*x347)));
evalcond[7]=((((-1.0)*x350))+(((-1.0)*x346*x347))+new_r10);
evalcond[8]=(((new_r10*x345))+(((-1.0)*new_r00*x349))+(((-1.0)*gconst141)));
evalcond[9]=(((new_r11*x345))+(((-1.0)*new_r01*x349))+(((-1.0)*x347)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst143;
CheckValue<IkReal> x352 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x352.valid){
continue;
}
gconst143=((3.14159265358979)+(((-1.0)*(x352.value))));
IkReal gconst144;
gconst144=IKsin(gconst143);
IkReal gconst145;
gconst145=IKcos(gconst143);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst143)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst148;
gconst148=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst149;
gconst149=IKsign(((((-1.0)*gconst145*new_r02))+((gconst144*new_r12))));
dummyeval[0]=((((-1.0)*gconst145*new_r02))+((gconst144*new_r12)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x353=(gconst149*new_r01);
CheckValue<IkReal> x354 = IKatan2WithCheck((new_r02*x353),((-1.0)*new_r12*x353),IKFAST_ATAN2_MAGTHRESH);
if(!x354.valid){
continue;
}
j19array[0]=x354.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x355=IKcos(j19);
IkReal x356=IKsin(j19);
IkReal x357=((1.0)*gconst145);
IkReal x358=((1.0)*gconst144);
IkReal x359=(gconst144*x356);
IkReal x360=((1.0)*x356);
IkReal x361=(x355*x357);
evalcond[0]=(((new_r02*x355))+((new_r12*x356)));
evalcond[1]=((((-1.0)*new_r02*x360))+((new_r12*x355)));
evalcond[2]=(((new_r01*x355))+gconst144+((new_r11*x356)));
evalcond[3]=(((gconst144*x355))+new_r01+((gconst145*x356)));
evalcond[4]=((((-1.0)*x361))+x359+new_r00);
evalcond[5]=((((-1.0)*x361))+x359+new_r11);
evalcond[6]=((((-1.0)*x357))+((new_r10*x356))+((new_r00*x355)));
evalcond[7]=((((-1.0)*x356*x357))+new_r10+(((-1.0)*x355*x358)));
evalcond[8]=((((-1.0)*new_r00*x360))+(((-1.0)*x358))+((new_r10*x355)));
evalcond[9]=((((-1.0)*x357))+((new_r11*x355))+(((-1.0)*new_r01*x360)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x362=(gconst144*gconst148);
CheckValue<IkReal> x363 = IKatan2WithCheck((new_r02*x362),((-1.0)*new_r12*x362),IKFAST_ATAN2_MAGTHRESH);
if(!x363.valid){
continue;
}
j19array[0]=x363.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x364=IKcos(j19);
IkReal x365=IKsin(j19);
IkReal x366=((1.0)*gconst145);
IkReal x367=((1.0)*gconst144);
IkReal x368=(gconst144*x365);
IkReal x369=((1.0)*x365);
IkReal x370=(x364*x366);
evalcond[0]=(((new_r02*x364))+((new_r12*x365)));
evalcond[1]=((((-1.0)*new_r02*x369))+((new_r12*x364)));
evalcond[2]=(((new_r01*x364))+gconst144+((new_r11*x365)));
evalcond[3]=(((gconst144*x364))+new_r01+((gconst145*x365)));
evalcond[4]=((((-1.0)*x370))+x368+new_r00);
evalcond[5]=((((-1.0)*x370))+x368+new_r11);
evalcond[6]=((((-1.0)*x366))+((new_r00*x364))+((new_r10*x365)));
evalcond[7]=((((-1.0)*x364*x367))+new_r10+(((-1.0)*x365*x366)));
evalcond[8]=((((-1.0)*new_r00*x369))+(((-1.0)*x367))+((new_r10*x364)));
evalcond[9]=((((-1.0)*x366))+(((-1.0)*new_r01*x369))+((new_r11*x364)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x371=(gconst139*new_r01);
CheckValue<IkReal> x372 = IKatan2WithCheck((new_r02*x371),((-1.0)*new_r12*x371),IKFAST_ATAN2_MAGTHRESH);
if(!x372.valid){
continue;
}
j19array[0]=x372.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x373=IKcos(j19);
IkReal x374=IKsin(j19);
IkReal x375=((1.0)*cj21);
IkReal x376=(sj21*x374);
IkReal x377=((1.0)*x373);
IkReal x378=((1.0)*x374);
IkReal x379=(x373*x375);
evalcond[0]=(((new_r12*x374))+((new_r02*x373)));
evalcond[1]=(((new_r12*x373))+(((-1.0)*new_r02*x378)));
evalcond[2]=(((new_r01*x373))+sj21+((new_r11*x374)));
evalcond[3]=(((cj21*x374))+new_r01+((sj21*x373)));
evalcond[4]=((((-1.0)*x379))+x376+new_r00);
evalcond[5]=((((-1.0)*x379))+x376+new_r11);
evalcond[6]=((((-1.0)*x375))+((new_r00*x373))+((new_r10*x374)));
evalcond[7]=((((-1.0)*x374*x375))+(((-1.0)*sj21*x377))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x378))+(((-1.0)*sj21))+((new_r10*x373)));
evalcond[9]=((((-1.0)*x375))+(((-1.0)*new_r01*x378))+((new_r11*x373)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x380=(gconst138*sj21);
CheckValue<IkReal> x381 = IKatan2WithCheck((new_r02*x380),((-1.0)*new_r12*x380),IKFAST_ATAN2_MAGTHRESH);
if(!x381.valid){
continue;
}
j19array[0]=x381.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x382=IKcos(j19);
IkReal x383=IKsin(j19);
IkReal x384=((1.0)*cj21);
IkReal x385=(sj21*x383);
IkReal x386=((1.0)*x382);
IkReal x387=((1.0)*x383);
IkReal x388=(x382*x384);
evalcond[0]=(((new_r02*x382))+((new_r12*x383)));
evalcond[1]=(((new_r12*x382))+(((-1.0)*new_r02*x387)));
evalcond[2]=(((new_r01*x382))+((new_r11*x383))+sj21);
evalcond[3]=(((sj21*x382))+new_r01+((cj21*x383)));
evalcond[4]=(x385+(((-1.0)*x388))+new_r00);
evalcond[5]=(x385+(((-1.0)*x388))+new_r11);
evalcond[6]=(((new_r00*x382))+((new_r10*x383))+(((-1.0)*x384)));
evalcond[7]=(new_r10+(((-1.0)*sj21*x386))+(((-1.0)*x383*x384)));
evalcond[8]=((((-1.0)*new_r00*x387))+(((-1.0)*sj21))+((new_r10*x382)));
evalcond[9]=((((-1.0)*new_r01*x387))+((new_r11*x382))+(((-1.0)*x384)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x389=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959))))));
evalcond[1]=x389;
evalcond[2]=x389;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst150;
gconst150=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst151;
gconst151=IKsign((((cj21*new_r12))+(((-1.0)*new_r02*sj21))));
dummyeval[0]=(((cj21*new_r12))+(((-1.0)*new_r02*sj21)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst152;
CheckValue<IkReal> x390 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x390.valid){
continue;
}
gconst152=((-1.0)*(x390.value));
IkReal gconst153;
gconst153=IKsin(gconst152);
IkReal gconst154;
gconst154=IKcos(gconst152);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst152))+j21)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst158;
gconst158=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst159;
gconst159=IKsign((((gconst154*new_r12))+(((-1.0)*gconst153*new_r02))));
dummyeval[0]=(((gconst154*new_r12))+(((-1.0)*gconst153*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x391=(gconst159*new_r00);
CheckValue<IkReal> x392 = IKatan2WithCheck((new_r02*x391),((-1.0)*new_r12*x391),IKFAST_ATAN2_MAGTHRESH);
if(!x392.valid){
continue;
}
j19array[0]=x392.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x393=IKcos(j19);
IkReal x394=IKsin(j19);
IkReal x395=((1.0)*gconst153);
IkReal x396=(gconst154*x394);
IkReal x397=((1.0)*x393);
IkReal x398=((1.0)*x394);
IkReal x399=(x393*x395);
evalcond[0]=(((new_r02*x393))+((new_r12*x394)));
evalcond[1]=((((-1.0)*new_r02*x398))+((new_r12*x393)));
evalcond[2]=(((new_r00*x393))+gconst154+((new_r10*x394)));
evalcond[3]=(new_r00+((gconst154*x393))+((gconst153*x394)));
evalcond[4]=((((-1.0)*x399))+x396+new_r01);
evalcond[5]=((((-1.0)*x399))+x396+new_r10);
evalcond[6]=(((new_r11*x394))+(((-1.0)*x395))+((new_r01*x393)));
evalcond[7]=((((-1.0)*gconst154*x397))+(((-1.0)*x394*x395))+new_r11);
evalcond[8]=((((-1.0)*x395))+(((-1.0)*new_r00*x398))+((new_r10*x393)));
evalcond[9]=((((-1.0)*new_r01*x398))+((new_r11*x393))+(((-1.0)*gconst154)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x400=(gconst154*gconst158);
CheckValue<IkReal> x401 = IKatan2WithCheck((new_r02*x400),((-1.0)*new_r12*x400),IKFAST_ATAN2_MAGTHRESH);
if(!x401.valid){
continue;
}
j19array[0]=x401.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x402=IKcos(j19);
IkReal x403=IKsin(j19);
IkReal x404=((1.0)*gconst153);
IkReal x405=(gconst154*x403);
IkReal x406=((1.0)*x402);
IkReal x407=((1.0)*x403);
IkReal x408=(x402*x404);
evalcond[0]=(((new_r12*x403))+((new_r02*x402)));
evalcond[1]=(((new_r12*x402))+(((-1.0)*new_r02*x407)));
evalcond[2]=(((new_r10*x403))+gconst154+((new_r00*x402)));
evalcond[3]=(((gconst154*x402))+((gconst153*x403))+new_r00);
evalcond[4]=(x405+new_r01+(((-1.0)*x408)));
evalcond[5]=(x405+new_r10+(((-1.0)*x408)));
evalcond[6]=(((new_r11*x403))+((new_r01*x402))+(((-1.0)*x404)));
evalcond[7]=((((-1.0)*gconst154*x406))+(((-1.0)*x403*x404))+new_r11);
evalcond[8]=(((new_r10*x402))+(((-1.0)*new_r00*x407))+(((-1.0)*x404)));
evalcond[9]=((((-1.0)*gconst154))+((new_r11*x402))+(((-1.0)*new_r01*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst155;
CheckValue<IkReal> x409 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x409.valid){
continue;
}
gconst155=((3.14159265358979)+(((-1.0)*(x409.value))));
IkReal gconst156;
gconst156=IKsin(gconst155);
IkReal gconst157;
gconst157=IKcos(gconst155);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst155))+j21)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst160;
gconst160=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst161;
gconst161=IKsign((((gconst157*new_r12))+(((-1.0)*gconst156*new_r02))));
dummyeval[0]=(((gconst157*new_r12))+(((-1.0)*gconst156*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x410=(gconst161*new_r00);
CheckValue<IkReal> x411 = IKatan2WithCheck((new_r02*x410),((-1.0)*new_r12*x410),IKFAST_ATAN2_MAGTHRESH);
if(!x411.valid){
continue;
}
j19array[0]=x411.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x412=IKcos(j19);
IkReal x413=IKsin(j19);
IkReal x414=((1.0)*gconst156);
IkReal x415=(gconst157*x413);
IkReal x416=((1.0)*x413);
IkReal x417=(gconst157*x412);
IkReal x418=(x412*x414);
evalcond[0]=(((new_r12*x413))+((new_r02*x412)));
evalcond[1]=(((new_r12*x412))+(((-1.0)*new_r02*x416)));
evalcond[2]=(gconst157+((new_r10*x413))+((new_r00*x412)));
evalcond[3]=(((gconst156*x413))+x417+new_r00);
evalcond[4]=(x415+new_r01+(((-1.0)*x418)));
evalcond[5]=(x415+new_r10+(((-1.0)*x418)));
evalcond[6]=(((new_r11*x413))+(((-1.0)*x414))+((new_r01*x412)));
evalcond[7]=((((-1.0)*x413*x414))+new_r11+(((-1.0)*x417)));
evalcond[8]=(((new_r10*x412))+(((-1.0)*new_r00*x416))+(((-1.0)*x414)));
evalcond[9]=((((-1.0)*gconst157))+((new_r11*x412))+(((-1.0)*new_r01*x416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x419=(gconst157*gconst160);
CheckValue<IkReal> x420 = IKatan2WithCheck((new_r02*x419),((-1.0)*new_r12*x419),IKFAST_ATAN2_MAGTHRESH);
if(!x420.valid){
continue;
}
j19array[0]=x420.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x421=IKcos(j19);
IkReal x422=IKsin(j19);
IkReal x423=((1.0)*gconst156);
IkReal x424=(gconst157*x422);
IkReal x425=((1.0)*x422);
IkReal x426=(gconst157*x421);
IkReal x427=(x421*x423);
evalcond[0]=(((new_r12*x422))+((new_r02*x421)));
evalcond[1]=(((new_r12*x421))+(((-1.0)*new_r02*x425)));
evalcond[2]=(((new_r10*x422))+gconst157+((new_r00*x421)));
evalcond[3]=(((gconst156*x422))+x426+new_r00);
evalcond[4]=((((-1.0)*x427))+x424+new_r01);
evalcond[5]=((((-1.0)*x427))+x424+new_r10);
evalcond[6]=((((-1.0)*x423))+((new_r11*x422))+((new_r01*x421)));
evalcond[7]=((((-1.0)*x422*x423))+(((-1.0)*x426))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x425))+(((-1.0)*x423))+((new_r10*x421)));
evalcond[9]=((((-1.0)*gconst157))+((new_r11*x421))+(((-1.0)*new_r01*x425)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x428=(gconst151*new_r00);
CheckValue<IkReal> x429 = IKatan2WithCheck((new_r02*x428),((-1.0)*new_r12*x428),IKFAST_ATAN2_MAGTHRESH);
if(!x429.valid){
continue;
}
j19array[0]=x429.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x430=IKcos(j19);
IkReal x431=IKsin(j19);
IkReal x432=((1.0)*sj21);
IkReal x433=(cj21*x431);
IkReal x434=((1.0)*x430);
IkReal x435=((1.0)*x431);
IkReal x436=(x430*x432);
evalcond[0]=(((new_r12*x431))+((new_r02*x430)));
evalcond[1]=(((new_r12*x430))+(((-1.0)*new_r02*x435)));
evalcond[2]=(((new_r00*x430))+cj21+((new_r10*x431)));
evalcond[3]=(((cj21*x430))+((sj21*x431))+new_r00);
evalcond[4]=((((-1.0)*x436))+x433+new_r01);
evalcond[5]=((((-1.0)*x436))+x433+new_r10);
evalcond[6]=(((new_r01*x430))+(((-1.0)*x432))+((new_r11*x431)));
evalcond[7]=((((-1.0)*x431*x432))+(((-1.0)*cj21*x434))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x435))+(((-1.0)*x432))+((new_r10*x430)));
evalcond[9]=((((-1.0)*new_r01*x435))+(((-1.0)*cj21))+((new_r11*x430)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x437=(cj21*gconst150);
CheckValue<IkReal> x438 = IKatan2WithCheck((new_r02*x437),((-1.0)*new_r12*x437),IKFAST_ATAN2_MAGTHRESH);
if(!x438.valid){
continue;
}
j19array[0]=x438.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x439=IKcos(j19);
IkReal x440=IKsin(j19);
IkReal x441=((1.0)*sj21);
IkReal x442=(cj21*x440);
IkReal x443=((1.0)*x439);
IkReal x444=((1.0)*x440);
IkReal x445=(x439*x441);
evalcond[0]=(((new_r12*x440))+((new_r02*x439)));
evalcond[1]=(((new_r12*x439))+(((-1.0)*new_r02*x444)));
evalcond[2]=(((new_r00*x439))+cj21+((new_r10*x440)));
evalcond[3]=(((cj21*x439))+((sj21*x440))+new_r00);
evalcond[4]=((((-1.0)*x445))+x442+new_r01);
evalcond[5]=((((-1.0)*x445))+x442+new_r10);
evalcond[6]=((((-1.0)*x441))+((new_r01*x439))+((new_r11*x440)));
evalcond[7]=((((-1.0)*cj21*x443))+new_r11+(((-1.0)*x440*x441)));
evalcond[8]=((((-1.0)*x441))+(((-1.0)*new_r00*x444))+((new_r10*x439)));
evalcond[9]=((((-1.0)*new_r01*x444))+(((-1.0)*cj21))+((new_r11*x439)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x446 = IKatan2WithCheck((gconst113*new_r12),(gconst113*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x446.valid){
continue;
}
j19array[0]=x446.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[18];
IkReal x447=IKcos(j19);
IkReal x448=IKsin(j19);
IkReal x449=((1.0)*cj21);
IkReal x450=((1.0)*sj21);
IkReal x451=((1.0)*sj20);
IkReal x452=(new_r11*x448);
IkReal x453=(new_r00*x447);
IkReal x454=(cj20*x448);
IkReal x455=(sj20*x448);
IkReal x456=(new_r01*x447);
IkReal x457=((1.0)*x448);
IkReal x458=(new_r02*x447);
IkReal x459=(cj20*x447);
evalcond[0]=((((-1.0)*x447*x451))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x448*x451)));
evalcond[2]=(((new_r12*x447))+(((-1.0)*new_r02*x457)));
evalcond[3]=(((cj21*x448))+new_r01+((sj21*x459)));
evalcond[4]=(((new_r12*x448))+(((-1.0)*x451))+x458);
evalcond[5]=(x456+x452+((cj20*sj21)));
evalcond[6]=(((sj21*x448))+new_r00+(((-1.0)*x449*x459)));
evalcond[7]=((((-1.0)*x447*x449))+new_r11+((sj21*x454)));
evalcond[8]=((((-1.0)*new_r00*x457))+(((-1.0)*x450))+((new_r10*x447)));
evalcond[9]=((((-1.0)*x449))+(((-1.0)*new_r01*x457))+((new_r11*x447)));
evalcond[10]=((((-1.0)*cj20*x449))+x453+((new_r10*x448)));
evalcond[11]=((((-1.0)*x447*x450))+new_r10+(((-1.0)*x449*x454)));
evalcond[12]=(((new_r10*x455))+((sj20*x453))+((cj20*new_r20)));
evalcond[13]=(((sj20*x452))+((sj20*x456))+((cj20*new_r21)));
evalcond[14]=((-1.0)+((new_r12*x455))+((sj20*x458))+((cj20*new_r22)));
evalcond[15]=(((cj20*x458))+((new_r12*x454))+(((-1.0)*new_r22*x451)));
evalcond[16]=((((-1.0)*new_r21*x451))+((cj20*x452))+((cj20*x456))+sj21);
evalcond[17]=((((-1.0)*x449))+((new_r10*x454))+(((-1.0)*new_r20*x451))+((cj20*x453)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x460 = IKatan2WithCheck((gconst112*new_r12),(gconst112*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x460.valid){
continue;
}
j19array[0]=x460.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[18];
IkReal x461=IKcos(j19);
IkReal x462=IKsin(j19);
IkReal x463=((1.0)*cj21);
IkReal x464=((1.0)*sj21);
IkReal x465=((1.0)*sj20);
IkReal x466=(new_r11*x462);
IkReal x467=(new_r00*x461);
IkReal x468=(cj20*x462);
IkReal x469=(sj20*x462);
IkReal x470=(new_r01*x461);
IkReal x471=((1.0)*x462);
IkReal x472=(new_r02*x461);
IkReal x473=(cj20*x461);
evalcond[0]=((((-1.0)*x461*x465))+new_r02);
evalcond[1]=((((-1.0)*x462*x465))+new_r12);
evalcond[2]=(((new_r12*x461))+(((-1.0)*new_r02*x471)));
evalcond[3]=(new_r01+((cj21*x462))+((sj21*x473)));
evalcond[4]=(((new_r12*x462))+(((-1.0)*x465))+x472);
evalcond[5]=(x466+x470+((cj20*sj21)));
evalcond[6]=(((sj21*x462))+new_r00+(((-1.0)*x463*x473)));
evalcond[7]=(((sj21*x468))+(((-1.0)*x461*x463))+new_r11);
evalcond[8]=(((new_r10*x461))+(((-1.0)*new_r00*x471))+(((-1.0)*x464)));
evalcond[9]=(((new_r11*x461))+(((-1.0)*x463))+(((-1.0)*new_r01*x471)));
evalcond[10]=(((new_r10*x462))+x467+(((-1.0)*cj20*x463)));
evalcond[11]=((((-1.0)*x463*x468))+(((-1.0)*x461*x464))+new_r10);
evalcond[12]=(((new_r10*x469))+((sj20*x467))+((cj20*new_r20)));
evalcond[13]=(((sj20*x466))+((cj20*new_r21))+((sj20*x470)));
evalcond[14]=((-1.0)+((new_r12*x469))+((cj20*new_r22))+((sj20*x472)));
evalcond[15]=(((cj20*x472))+((new_r12*x468))+(((-1.0)*new_r22*x465)));
evalcond[16]=((((-1.0)*new_r21*x465))+((cj20*x470))+((cj20*x466))+sj21);
evalcond[17]=(((new_r10*x468))+((cj20*x467))+(((-1.0)*new_r20*x465))+(((-1.0)*x463)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x474 = IKatan2WithCheck((gconst110*new_r12),(gconst110*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x474.valid){
continue;
}
j19array[0]=x474.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x475=IKcos(j19);
IkReal x476=IKsin(j19);
IkReal x477=((1.0)*sj20);
IkReal x478=(new_r02*x475);
IkReal x479=(new_r12*x476);
IkReal x480=(sj20*x475);
IkReal x481=(sj20*x476);
evalcond[0]=((((-1.0)*x475*x477))+new_r02);
evalcond[1]=((((-1.0)*x476*x477))+new_r12);
evalcond[2]=(((new_r12*x475))+(((-1.0)*new_r02*x476)));
evalcond[3]=((((-1.0)*x477))+x478+x479);
evalcond[4]=(((new_r10*x481))+((new_r00*x480))+((cj20*new_r20)));
evalcond[5]=(((new_r11*x481))+((cj20*new_r21))+((new_r01*x480)));
evalcond[6]=((-1.0)+((cj20*new_r22))+((sj20*x478))+((sj20*x479)));
evalcond[7]=(((cj20*x479))+((cj20*x478))+(((-1.0)*new_r22*x477)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst162;
gconst162=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj20;
dummyeval[1]=sj19;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj19;
dummyeval[1]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x482=((((-1.0)*cj20))+new_r22);
IkReal x483=((((-1.0)*sj20))+new_r02);
IkReal x484=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x482;
evalcond[2]=x482;
evalcond[3]=x483;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x483;
evalcond[8]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[9]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[10]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[11]=(((cj20*new_r02))+(((-1.0)*new_r22*x484)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x485=IKcos(j21);
IkReal x486=IKsin(j21);
IkReal x487=((1.0)*new_r02);
IkReal x488=((1.0)*x485);
evalcond[0]=(((new_r02*x485))+new_r20);
evalcond[1]=((((-1.0)*x486))+new_r10);
evalcond[2]=((((-1.0)*x488))+new_r11);
evalcond[3]=(new_r01+((new_r22*x486)));
evalcond[4]=((((-1.0)*x486*x487))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*new_r22*x488)));
evalcond[6]=((((-1.0)*new_r21*x487))+((new_r01*new_r22))+x486);
evalcond[7]=((((-1.0)*x488))+((new_r00*new_r22))+(((-1.0)*new_r20*x487)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x489=((((-1.0)*cj20))+new_r22);
IkReal x490=((1.0)*sj20);
IkReal x491=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x489;
evalcond[2]=x489;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x490))+(((-1.0)*new_r02)));
evalcond[7]=((((-1.0)*new_r00*x490))+((cj20*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x490))+((cj20*new_r21)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x490))+((cj20*new_r22)));
evalcond[10]=((((-1.0)*new_r02*x491))+(((-1.0)*new_r22*x490)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x492=IKsin(j21);
IkReal x493=IKcos(j21);
IkReal x494=((1.0)*new_r22);
IkReal x495=((1.0)*x493);
evalcond[0]=(((new_r02*x492))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x495))+new_r20);
evalcond[2]=((((-1.0)*x492))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x495))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x492))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x493*x494))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x494))+x492+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x494))+(((-1.0)*x495))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x496=((-1.0)+new_r22);
IkReal x497=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x498=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x496;
evalcond[2]=x496;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x497;
evalcond[10]=x497;
evalcond[11]=x498;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x496;
evalcond[15]=x498;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst164;
gconst164=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst165;
gconst165=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x499 = IKatan2WithCheck((gconst165*((((cj19*new_r01))+((new_r11*sj19))))),(gconst165*(((((-1.0)*cj19*new_r11))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x499.valid){
continue;
}
j21array[0]=x499.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x500=IKsin(j21);
IkReal x501=IKcos(j21);
IkReal x502=((1.0)*sj19);
IkReal x503=((1.0)*x501);
IkReal x504=(sj19*x500);
IkReal x505=((1.0)*x500);
IkReal x506=(cj19*x503);
evalcond[0]=(x500+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x501))+((cj19*x500))+new_r01);
evalcond[2]=((((-1.0)*x503))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x502))+(((-1.0)*x505))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x502))+(((-1.0)*x503))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x506))+x504+new_r00);
evalcond[6]=((((-1.0)*x506))+x504+new_r11);
evalcond[7]=((((-1.0)*x501*x502))+(((-1.0)*cj19*x505))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x507 = IKatan2WithCheck((gconst164*((((new_r00*sj19))+((cj19*new_r01))))),(gconst164*(((((-1.0)*cj19*new_r00))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x507.valid){
continue;
}
j21array[0]=x507.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x508=IKsin(j21);
IkReal x509=IKcos(j21);
IkReal x510=((1.0)*sj19);
IkReal x511=((1.0)*x509);
IkReal x512=(sj19*x508);
IkReal x513=((1.0)*x508);
IkReal x514=(cj19*x511);
evalcond[0]=(x508+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x509))+((cj19*x508))+new_r01);
evalcond[2]=((((-1.0)*x511))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x510))+((cj19*new_r10))+(((-1.0)*x513)));
evalcond[4]=((((-1.0)*new_r01*x510))+((cj19*new_r11))+(((-1.0)*x511)));
evalcond[5]=(x512+new_r00+(((-1.0)*x514)));
evalcond[6]=(x512+new_r11+(((-1.0)*x514)));
evalcond[7]=((((-1.0)*cj19*x513))+new_r10+(((-1.0)*x509*x510)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x515=((1.0)+new_r22);
IkReal x516=(new_r12*sj19);
IkReal x517=((1.0)*new_r02);
IkReal x518=((((-1.0)*sj19*x517))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x515;
evalcond[2]=x515;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x518;
evalcond[10]=x518;
evalcond[11]=(x516+((cj19*new_r02)));
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*cj19*x517))+(((-1.0)*x516)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst166;
gconst166=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst167;
gconst167=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x519=((1.0)*sj19);
CheckValue<IkReal> x520 = IKatan2WithCheck((gconst167*(((((-1.0)*new_r00*x519))+((cj19*new_r10))))),(gconst167*(((((-1.0)*new_r10*x519))+(((-1.0)*cj19*new_r00))))),IKFAST_ATAN2_MAGTHRESH);
if(!x520.valid){
continue;
}
j21array[0]=x520.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x521=IKsin(j21);
IkReal x522=IKcos(j21);
IkReal x523=((1.0)*cj19);
IkReal x524=((1.0)*sj19);
IkReal x525=((1.0)*x521);
IkReal x526=(sj19*x522);
IkReal x527=(sj19*x521);
IkReal x528=(x521*x523);
evalcond[0]=(x522+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x525))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x522))+x527+new_r00);
evalcond[3]=((((-1.0)*new_r00*x524))+(((-1.0)*x525))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x522))+(((-1.0)*new_r01*x524))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x528))+x526+new_r01);
evalcond[6]=((((-1.0)*x528))+x526+new_r10);
evalcond[7]=((((-1.0)*x521*x524))+(((-1.0)*x522*x523))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x529=((1.0)*sj19);
CheckValue<IkReal> x530 = IKatan2WithCheck((gconst166*(((((-1.0)*new_r00*x529))+((cj19*new_r01))))),(gconst166*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x529))))),IKFAST_ATAN2_MAGTHRESH);
if(!x530.valid){
continue;
}
j21array[0]=x530.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x531=IKsin(j21);
IkReal x532=IKcos(j21);
IkReal x533=((1.0)*cj19);
IkReal x534=((1.0)*sj19);
IkReal x535=((1.0)*x531);
IkReal x536=(sj19*x532);
IkReal x537=(sj19*x531);
IkReal x538=(x531*x533);
evalcond[0]=(x532+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x535))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x532))+x537+new_r00);
evalcond[3]=((((-1.0)*new_r00*x534))+(((-1.0)*x535))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x532))+(((-1.0)*new_r01*x534))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x538))+x536+new_r01);
evalcond[6]=((((-1.0)*x538))+x536+new_r10);
evalcond[7]=((((-1.0)*x532*x533))+(((-1.0)*x531*x534))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x539=((((-1.0)*cj20))+new_r22);
IkReal x540=((((-1.0)*sj20))+new_r02);
IkReal x541=((1.0)*sj20);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j19), 6.28318530717959))))));
evalcond[1]=x539;
evalcond[2]=x539;
evalcond[3]=x540;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x540;
evalcond[8]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[9]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[10]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[11]=((((-1.0)*new_r22*x541))+((cj20*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x542=IKcos(j21);
IkReal x543=IKsin(j21);
IkReal x544=((1.0)*new_r02);
IkReal x545=((1.0)*x542);
evalcond[0]=(((new_r02*x542))+new_r20);
evalcond[1]=((((-1.0)*x543))+new_r10);
evalcond[2]=((((-1.0)*x545))+new_r11);
evalcond[3]=(((new_r22*x543))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x543*x544)));
evalcond[5]=((((-1.0)*new_r22*x545))+new_r00);
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x544))+x543);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x544))+(((-1.0)*x545)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x546=((((-1.0)*cj20))+new_r22);
IkReal x547=((1.0)*sj20);
IkReal x548=((1.0)*cj20);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j19, 6.28318530717959))))));
evalcond[1]=x546;
evalcond[2]=x546;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x547))+(((-1.0)*new_r02)));
evalcond[7]=((((-1.0)*new_r00*x547))+((cj20*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x547))+((cj20*new_r21)));
evalcond[9]=((-1.0)+((cj20*new_r22))+(((-1.0)*new_r02*x547)));
evalcond[10]=((((-1.0)*new_r22*x547))+(((-1.0)*new_r02*x548)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x549=IKsin(j21);
IkReal x550=IKcos(j21);
IkReal x551=((1.0)*new_r22);
IkReal x552=((1.0)*x550);
evalcond[0]=(((new_r02*x549))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*new_r02*x552)));
evalcond[2]=((((-1.0)*x549))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x552))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x549))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x550*x551))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x551))+x549+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x551))+(((-1.0)*x552))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x553=((-1.0)+new_r22);
IkReal x554=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x555=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))));
evalcond[1]=x553;
evalcond[2]=x553;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x554;
evalcond[10]=x554;
evalcond[11]=x555;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x553;
evalcond[15]=x555;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst169;
gconst169=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst170;
gconst170=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x556 = IKatan2WithCheck((gconst170*((((cj19*new_r01))+((new_r11*sj19))))),(gconst170*(((((-1.0)*cj19*new_r11))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x556.valid){
continue;
}
j21array[0]=x556.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x557=IKsin(j21);
IkReal x558=IKcos(j21);
IkReal x559=((1.0)*sj19);
IkReal x560=((1.0)*x558);
IkReal x561=(sj19*x557);
IkReal x562=((1.0)*x557);
IkReal x563=(cj19*x560);
evalcond[0]=(x557+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((cj19*x557))+new_r01+((sj19*x558)));
evalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x560)));
evalcond[3]=((((-1.0)*new_r00*x559))+((cj19*new_r10))+(((-1.0)*x562)));
evalcond[4]=((((-1.0)*new_r01*x559))+((cj19*new_r11))+(((-1.0)*x560)));
evalcond[5]=(x561+new_r00+(((-1.0)*x563)));
evalcond[6]=(x561+new_r11+(((-1.0)*x563)));
evalcond[7]=((((-1.0)*x558*x559))+(((-1.0)*cj19*x562))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x564 = IKatan2WithCheck((gconst169*((((new_r00*sj19))+((cj19*new_r01))))),(gconst169*(((((-1.0)*cj19*new_r00))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x564.valid){
continue;
}
j21array[0]=x564.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x565=IKsin(j21);
IkReal x566=IKcos(j21);
IkReal x567=((1.0)*sj19);
IkReal x568=((1.0)*x566);
IkReal x569=(sj19*x565);
IkReal x570=((1.0)*x565);
IkReal x571=(cj19*x568);
evalcond[0]=(x565+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x566))+((cj19*x565))+new_r01);
evalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x568)));
evalcond[3]=((((-1.0)*new_r00*x567))+(((-1.0)*x570))+((cj19*new_r10)));
evalcond[4]=(((cj19*new_r11))+(((-1.0)*x568))+(((-1.0)*new_r01*x567)));
evalcond[5]=((((-1.0)*x571))+x569+new_r00);
evalcond[6]=((((-1.0)*x571))+x569+new_r11);
evalcond[7]=((((-1.0)*x566*x567))+new_r10+(((-1.0)*cj19*x570)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x572=((1.0)+new_r22);
IkReal x573=(new_r12*sj19);
IkReal x574=((1.0)*new_r02);
IkReal x575=((((-1.0)*sj19*x574))+((cj19*new_r12)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959))))));
evalcond[1]=x572;
evalcond[2]=x572;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x575;
evalcond[10]=x575;
evalcond[11]=(x573+((cj19*new_r02)));
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x573))+(((-1.0)*cj19*x574)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst171;
gconst171=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst172;
gconst172=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x576=((1.0)*sj19);
CheckValue<IkReal> x577 = IKatan2WithCheck((gconst172*(((((-1.0)*new_r00*x576))+((cj19*new_r10))))),(gconst172*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x576))))),IKFAST_ATAN2_MAGTHRESH);
if(!x577.valid){
continue;
}
j21array[0]=x577.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x578=IKsin(j21);
IkReal x579=IKcos(j21);
IkReal x580=((1.0)*cj19);
IkReal x581=((1.0)*sj19);
IkReal x582=((1.0)*x578);
IkReal x583=(sj19*x579);
IkReal x584=(sj19*x578);
IkReal x585=(x578*x580);
evalcond[0]=(x579+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=(((cj19*new_r01))+(((-1.0)*x582))+((new_r11*sj19)));
evalcond[2]=(((cj19*x579))+x584+new_r00);
evalcond[3]=(((cj19*new_r10))+(((-1.0)*x582))+(((-1.0)*new_r00*x581)));
evalcond[4]=((((-1.0)*new_r01*x581))+(((-1.0)*x579))+((cj19*new_r11)));
evalcond[5]=(x583+new_r01+(((-1.0)*x585)));
evalcond[6]=(x583+new_r10+(((-1.0)*x585)));
evalcond[7]=((((-1.0)*x578*x581))+(((-1.0)*x579*x580))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x586=((1.0)*sj19);
CheckValue<IkReal> x587 = IKatan2WithCheck((gconst171*((((cj19*new_r01))+(((-1.0)*new_r00*x586))))),(gconst171*(((((-1.0)*new_r01*x586))+(((-1.0)*cj19*new_r00))))),IKFAST_ATAN2_MAGTHRESH);
if(!x587.valid){
continue;
}
j21array[0]=x587.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x588=IKsin(j21);
IkReal x589=IKcos(j21);
IkReal x590=((1.0)*cj19);
IkReal x591=((1.0)*sj19);
IkReal x592=((1.0)*x588);
IkReal x593=(sj19*x589);
IkReal x594=(sj19*x588);
IkReal x595=(x588*x590);
evalcond[0]=(x589+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x592))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(x594+((cj19*x589))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x591))+(((-1.0)*x592))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x589))+(((-1.0)*new_r01*x591))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x595))+x593+new_r01);
evalcond[6]=((((-1.0)*x595))+x593+new_r10);
evalcond[7]=((((-1.0)*x588*x591))+(((-1.0)*x589*x590))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x596=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x596;
evalcond[2]=x596;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x596;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x597=IKsin(j21);
IkReal x598=((1.0)*(IKcos(j21)));
evalcond[0]=(x597+new_r01);
evalcond[1]=((((-1.0)*x597))+new_r10);
evalcond[2]=((((-1.0)*x598))+new_r11);
evalcond[3]=((((-1.0)*x598))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x599=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x599;
evalcond[2]=x599;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x600=IKcos(j21);
IkReal x601=((1.0)*(IKsin(j21)));
evalcond[0]=(x600+new_r00);
evalcond[1]=((((-1.0)*x601))+new_r10);
evalcond[2]=((((-1.0)*x600))+new_r11);
evalcond[3]=((((-1.0)*x601))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x602=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x602;
evalcond[2]=x602;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x602;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x603=IKsin(j21);
IkReal x604=((1.0)*(IKcos(j21)));
evalcond[0]=(x603+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x603))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x604)));
evalcond[3]=((((-1.0)*x604))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x605=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x605;
evalcond[2]=x605;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x606=IKcos(j21);
IkReal x607=((1.0)*(IKsin(j21)));
evalcond[0]=(x606+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x607)));
evalcond[2]=((((-1.0)*x606))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x607))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x608=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j19), 6.28318530717959)))))))));
evalcond[1]=x608;
evalcond[2]=x608;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x608;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x609=IKsin(j21);
IkReal x610=((1.0)*(IKcos(j21)));
evalcond[0]=(x609+new_r01);
evalcond[1]=((((-1.0)*x609))+new_r10);
evalcond[2]=((((-1.0)*x610))+new_r11);
evalcond[3]=((((-1.0)*x610))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x611=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j19, 6.28318530717959))))));
evalcond[1]=x611;
evalcond[2]=x611;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x611;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x612=IKsin(j21);
IkReal x613=((1.0)*(IKcos(j21)));
evalcond[0]=(x612+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x612))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x613))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x613))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x614=((1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j19), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959))))));
evalcond[1]=x614;
evalcond[2]=x614;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x615=IKcos(j21);
IkReal x616=((1.0)*(IKsin(j21)));
evalcond[0]=(x615+new_r00);
evalcond[1]=((((-1.0)*x616))+new_r10);
evalcond[2]=((((-1.0)*x615))+new_r11);
evalcond[3]=((((-1.0)*x616))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x617=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j19, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959))))));
evalcond[1]=x617;
evalcond[2]=x617;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x618=IKcos(j21);
IkReal x619=((1.0)*(IKsin(j21)));
evalcond[0]=(x618+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x619))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x618))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x619))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x621=IKPowWithIntegerCheck(sj20,-1);
if(!x621.valid){
continue;
}
IkReal x620=x621.value;
CheckValue<IkReal> x622=IKPowWithIntegerCheck(sj19,-1);
if(!x622.valid){
continue;
}
if( IKabs((x620*(x622.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x620)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x620*(x622.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x620))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x620*(x622.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x620));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x623=IKsin(j21);
IkReal x624=IKcos(j21);
IkReal x625=(cj20*sj19);
IkReal x626=(cj19*new_r01);
IkReal x627=((1.0)*sj20);
IkReal x628=(cj19*new_r00);
IkReal x629=((1.0)*sj19);
IkReal x630=((1.0)*x624);
IkReal x631=(cj20*x623);
IkReal x632=((1.0)*x623);
IkReal x633=(cj19*x630);
evalcond[0]=(new_r20+((sj20*x624)));
evalcond[1]=((((-1.0)*x623*x627))+new_r21);
evalcond[2]=(x626+x631+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x629))+(((-1.0)*x632))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x629))+(((-1.0)*x630))+((cj19*new_r11)));
evalcond[5]=(((cj19*x631))+((sj19*x624))+new_r01);
evalcond[6]=((((-1.0)*cj20*x630))+x628+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x633))+((sj19*x623))+new_r00);
evalcond[8]=((((-1.0)*x633))+new_r11+((x623*x625)));
evalcond[9]=((((-1.0)*x625*x630))+new_r10+(((-1.0)*cj19*x632)));
evalcond[10]=(((cj20*x626))+(((-1.0)*new_r21*x627))+((new_r11*x625))+x623);
evalcond[11]=(((cj20*x628))+(((-1.0)*x630))+((new_r10*x625))+(((-1.0)*new_r20*x627)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x635=IKPowWithIntegerCheck(sj20,-1);
if(!x635.valid){
continue;
}
IkReal x634=x635.value;
CheckValue<IkReal> x636=IKPowWithIntegerCheck(sj19,-1);
if(!x636.valid){
continue;
}
if( IKabs((new_r21*x634)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x634*(x636.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x634))+IKsqr((x634*(x636.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((new_r21*x634), (x634*(x636.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x637=IKsin(j21);
IkReal x638=IKcos(j21);
IkReal x639=(cj20*sj19);
IkReal x640=(cj19*new_r01);
IkReal x641=((1.0)*sj20);
IkReal x642=(cj19*new_r00);
IkReal x643=((1.0)*sj19);
IkReal x644=((1.0)*x638);
IkReal x645=(cj20*x637);
IkReal x646=((1.0)*x637);
IkReal x647=(cj19*x644);
evalcond[0]=(new_r20+((sj20*x638)));
evalcond[1]=((((-1.0)*x637*x641))+new_r21);
evalcond[2]=(x645+x640+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x646))+(((-1.0)*new_r00*x643))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x644))+(((-1.0)*new_r01*x643))+((cj19*new_r11)));
evalcond[5]=(((cj19*x645))+((sj19*x638))+new_r01);
evalcond[6]=((((-1.0)*cj20*x644))+x642+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x647))+((sj19*x637))+new_r00);
evalcond[8]=((((-1.0)*x647))+new_r11+((x637*x639)));
evalcond[9]=((((-1.0)*x639*x644))+(((-1.0)*cj19*x646))+new_r10);
evalcond[10]=(((cj20*x640))+(((-1.0)*new_r21*x641))+((new_r11*x639))+x637);
evalcond[11]=(((cj20*x642))+(((-1.0)*x644))+((new_r10*x639))+(((-1.0)*new_r20*x641)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x648 = IKatan2WithCheck((gconst162*new_r21),((-1.0)*gconst162*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x648.valid){
continue;
}
j21array[0]=x648.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x649=IKsin(j21);
IkReal x650=IKcos(j21);
IkReal x651=(cj20*sj19);
IkReal x652=(cj19*new_r01);
IkReal x653=((1.0)*sj20);
IkReal x654=(cj19*new_r00);
IkReal x655=((1.0)*sj19);
IkReal x656=((1.0)*x650);
IkReal x657=(cj20*x649);
IkReal x658=((1.0)*x649);
IkReal x659=(cj19*x656);
evalcond[0]=(((sj20*x650))+new_r20);
evalcond[1]=((((-1.0)*x649*x653))+new_r21);
evalcond[2]=(x652+x657+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x655))+(((-1.0)*x658))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x656))+(((-1.0)*new_r01*x655))+((cj19*new_r11)));
evalcond[5]=(((cj19*x657))+new_r01+((sj19*x650)));
evalcond[6]=((((-1.0)*cj20*x656))+x654+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x659))+new_r00+((sj19*x649)));
evalcond[8]=(((x649*x651))+(((-1.0)*x659))+new_r11);
evalcond[9]=((((-1.0)*x651*x656))+(((-1.0)*cj19*x658))+new_r10);
evalcond[10]=(((cj20*x652))+x649+((new_r11*x651))+(((-1.0)*new_r21*x653)));
evalcond[11]=(((cj20*x654))+(((-1.0)*x656))+(((-1.0)*new_r20*x653))+((new_r10*x651)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x660 = IKatan2WithCheck((gconst109*new_r12),(gconst109*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x660.valid){
continue;
}
j19array[0]=x660.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x661=IKcos(j19);
IkReal x662=IKsin(j19);
IkReal x663=((1.0)*sj20);
IkReal x664=(new_r02*x661);
IkReal x665=(new_r12*x662);
IkReal x666=(sj20*x661);
IkReal x667=(sj20*x662);
evalcond[0]=((((-1.0)*x661*x663))+new_r02);
evalcond[1]=((((-1.0)*x662*x663))+new_r12);
evalcond[2]=(((new_r12*x661))+(((-1.0)*new_r02*x662)));
evalcond[3]=((((-1.0)*x663))+x665+x664);
evalcond[4]=(((new_r10*x667))+((cj20*new_r20))+((new_r00*x666)));
evalcond[5]=(((new_r11*x667))+((cj20*new_r21))+((new_r01*x666)));
evalcond[6]=((-1.0)+((cj20*new_r22))+((sj20*x665))+((sj20*x664)));
evalcond[7]=(((cj20*x664))+((cj20*x665))+(((-1.0)*new_r22*x663)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst162;
gconst162=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj20;
dummyeval[1]=sj19;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj19;
dummyeval[1]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x668=((((-1.0)*cj20))+new_r22);
IkReal x669=((((-1.0)*sj20))+new_r02);
IkReal x670=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x668;
evalcond[2]=x668;
evalcond[3]=x669;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x669;
evalcond[8]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[9]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[10]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[11]=(((cj20*new_r02))+(((-1.0)*new_r22*x670)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x671=IKcos(j21);
IkReal x672=IKsin(j21);
IkReal x673=((1.0)*new_r02);
IkReal x674=((1.0)*x671);
evalcond[0]=(((new_r02*x671))+new_r20);
evalcond[1]=((((-1.0)*x672))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x674)));
evalcond[3]=(new_r01+((new_r22*x672)));
evalcond[4]=((((-1.0)*x672*x673))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x674))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x673))+((new_r01*new_r22))+x672);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x673))+(((-1.0)*x674)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x675=((((-1.0)*cj20))+new_r22);
IkReal x676=((1.0)*sj20);
IkReal x677=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x675;
evalcond[2]=x675;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*new_r02))+(((-1.0)*x676)));
evalcond[7]=((((-1.0)*new_r00*x676))+((cj20*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x676))+((cj20*new_r21)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x676))+((cj20*new_r22)));
evalcond[10]=((((-1.0)*new_r02*x677))+(((-1.0)*new_r22*x676)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x678=IKsin(j21);
IkReal x679=IKcos(j21);
IkReal x680=((1.0)*new_r22);
IkReal x681=((1.0)*x679);
evalcond[0]=(((new_r02*x678))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x681))+new_r20);
evalcond[2]=((((-1.0)*x678))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x681))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((new_r22*x678)));
evalcond[5]=((((-1.0)*x679*x680))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x680))+x678+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x681))+((new_r02*new_r20))+(((-1.0)*new_r00*x680)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x682=((-1.0)+new_r22);
IkReal x683=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x684=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x682;
evalcond[2]=x682;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x683;
evalcond[10]=x683;
evalcond[11]=x684;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x682;
evalcond[15]=x684;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst164;
gconst164=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst165;
gconst165=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x685 = IKatan2WithCheck((gconst165*((((cj19*new_r01))+((new_r11*sj19))))),(gconst165*(((((-1.0)*cj19*new_r11))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x685.valid){
continue;
}
j21array[0]=x685.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x686=IKsin(j21);
IkReal x687=IKcos(j21);
IkReal x688=((1.0)*sj19);
IkReal x689=((1.0)*x687);
IkReal x690=(sj19*x686);
IkReal x691=((1.0)*x686);
IkReal x692=(cj19*x689);
evalcond[0]=(x686+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((cj19*x686))+new_r01+((sj19*x687)));
evalcond[2]=((((-1.0)*x689))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*x691))+((cj19*new_r10))+(((-1.0)*new_r00*x688)));
evalcond[4]=((((-1.0)*new_r01*x688))+(((-1.0)*x689))+((cj19*new_r11)));
evalcond[5]=(x690+(((-1.0)*x692))+new_r00);
evalcond[6]=(x690+(((-1.0)*x692))+new_r11);
evalcond[7]=((((-1.0)*x687*x688))+(((-1.0)*cj19*x691))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x693 = IKatan2WithCheck((gconst164*((((new_r00*sj19))+((cj19*new_r01))))),(gconst164*(((((-1.0)*cj19*new_r00))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x693.valid){
continue;
}
j21array[0]=x693.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x694=IKsin(j21);
IkReal x695=IKcos(j21);
IkReal x696=((1.0)*sj19);
IkReal x697=((1.0)*x695);
IkReal x698=(sj19*x694);
IkReal x699=((1.0)*x694);
IkReal x700=(cj19*x697);
evalcond[0]=(x694+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x695))+((cj19*x694))+new_r01);
evalcond[2]=((((-1.0)*x697))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x696))+(((-1.0)*x699))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x696))+(((-1.0)*x697))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x700))+x698+new_r00);
evalcond[6]=((((-1.0)*x700))+x698+new_r11);
evalcond[7]=((((-1.0)*cj19*x699))+(((-1.0)*x695*x696))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x701=((1.0)+new_r22);
IkReal x702=(new_r12*sj19);
IkReal x703=((1.0)*new_r02);
IkReal x704=((((-1.0)*sj19*x703))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x701;
evalcond[2]=x701;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x704;
evalcond[10]=x704;
evalcond[11]=(x702+((cj19*new_r02)));
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*cj19*x703))+(((-1.0)*x702)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst166;
gconst166=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst167;
gconst167=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x705=((1.0)*sj19);
CheckValue<IkReal> x706 = IKatan2WithCheck((gconst167*((((cj19*new_r10))+(((-1.0)*new_r00*x705))))),(gconst167*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x705))))),IKFAST_ATAN2_MAGTHRESH);
if(!x706.valid){
continue;
}
j21array[0]=x706.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x707=IKsin(j21);
IkReal x708=IKcos(j21);
IkReal x709=((1.0)*cj19);
IkReal x710=((1.0)*sj19);
IkReal x711=((1.0)*x707);
IkReal x712=(sj19*x708);
IkReal x713=(sj19*x707);
IkReal x714=(x707*x709);
evalcond[0]=(x708+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x711))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x708))+x713+new_r00);
evalcond[3]=((((-1.0)*x711))+((cj19*new_r10))+(((-1.0)*new_r00*x710)));
evalcond[4]=((((-1.0)*x708))+((cj19*new_r11))+(((-1.0)*new_r01*x710)));
evalcond[5]=((((-1.0)*x714))+x712+new_r01);
evalcond[6]=((((-1.0)*x714))+x712+new_r10);
evalcond[7]=((((-1.0)*x707*x710))+new_r11+(((-1.0)*x708*x709)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x715=((1.0)*sj19);
CheckValue<IkReal> x716 = IKatan2WithCheck((gconst166*((((cj19*new_r01))+(((-1.0)*new_r00*x715))))),(gconst166*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x715))))),IKFAST_ATAN2_MAGTHRESH);
if(!x716.valid){
continue;
}
j21array[0]=x716.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x717=IKsin(j21);
IkReal x718=IKcos(j21);
IkReal x719=((1.0)*cj19);
IkReal x720=((1.0)*sj19);
IkReal x721=((1.0)*x717);
IkReal x722=(sj19*x718);
IkReal x723=(sj19*x717);
IkReal x724=(x717*x719);
evalcond[0]=(x718+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x721))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x718))+x723+new_r00);
evalcond[3]=((((-1.0)*x721))+((cj19*new_r10))+(((-1.0)*new_r00*x720)));
evalcond[4]=((((-1.0)*x718))+((cj19*new_r11))+(((-1.0)*new_r01*x720)));
evalcond[5]=((((-1.0)*x724))+x722+new_r01);
evalcond[6]=((((-1.0)*x724))+x722+new_r10);
evalcond[7]=((((-1.0)*x717*x720))+(((-1.0)*x718*x719))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x725=((((-1.0)*cj20))+new_r22);
IkReal x726=((((-1.0)*sj20))+new_r02);
IkReal x727=((1.0)*sj20);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j19), 6.28318530717959))))));
evalcond[1]=x725;
evalcond[2]=x725;
evalcond[3]=x726;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x726;
evalcond[8]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[9]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[10]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[11]=(((cj20*new_r02))+(((-1.0)*new_r22*x727)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x728=IKcos(j21);
IkReal x729=IKsin(j21);
IkReal x730=((1.0)*new_r02);
IkReal x731=((1.0)*x728);
evalcond[0]=(((new_r02*x728))+new_r20);
evalcond[1]=((((-1.0)*x729))+new_r10);
evalcond[2]=((((-1.0)*x731))+new_r11);
evalcond[3]=(new_r01+((new_r22*x729)));
evalcond[4]=(new_r21+(((-1.0)*x729*x730)));
evalcond[5]=((((-1.0)*new_r22*x731))+new_r00);
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x730))+x729);
evalcond[7]=((((-1.0)*new_r20*x730))+((new_r00*new_r22))+(((-1.0)*x731)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x732=((((-1.0)*cj20))+new_r22);
IkReal x733=((1.0)*sj20);
IkReal x734=((1.0)*cj20);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j19, 6.28318530717959))))));
evalcond[1]=x732;
evalcond[2]=x732;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x733))+(((-1.0)*new_r02)));
evalcond[7]=((((-1.0)*new_r00*x733))+((cj20*new_r20)));
evalcond[8]=(((cj20*new_r21))+(((-1.0)*new_r01*x733)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x733))+((cj20*new_r22)));
evalcond[10]=((((-1.0)*new_r22*x733))+(((-1.0)*new_r02*x734)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x735=IKsin(j21);
IkReal x736=IKcos(j21);
IkReal x737=((1.0)*new_r22);
IkReal x738=((1.0)*x736);
evalcond[0]=(((new_r02*x735))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x738))+new_r20);
evalcond[2]=((((-1.0)*x735))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x738))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x735))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x736*x737))+(((-1.0)*new_r00)));
evalcond[6]=(x735+((new_r02*new_r21))+(((-1.0)*new_r01*x737)));
evalcond[7]=((((-1.0)*x738))+(((-1.0)*new_r00*x737))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x739=((-1.0)+new_r22);
IkReal x740=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x741=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))));
evalcond[1]=x739;
evalcond[2]=x739;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x740;
evalcond[10]=x740;
evalcond[11]=x741;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x739;
evalcond[15]=x741;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst169;
gconst169=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst170;
gconst170=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x742 = IKatan2WithCheck((gconst170*((((cj19*new_r01))+((new_r11*sj19))))),(gconst170*(((((-1.0)*cj19*new_r11))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x742.valid){
continue;
}
j21array[0]=x742.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x743=IKsin(j21);
IkReal x744=IKcos(j21);
IkReal x745=((1.0)*sj19);
IkReal x746=((1.0)*x744);
IkReal x747=(sj19*x743);
IkReal x748=((1.0)*x743);
IkReal x749=(cj19*x746);
evalcond[0]=(x743+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x744))+((cj19*x743))+new_r01);
evalcond[2]=(((new_r10*sj19))+(((-1.0)*x746))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x745))+((cj19*new_r10))+(((-1.0)*x748)));
evalcond[4]=((((-1.0)*new_r01*x745))+((cj19*new_r11))+(((-1.0)*x746)));
evalcond[5]=(x747+new_r00+(((-1.0)*x749)));
evalcond[6]=(x747+new_r11+(((-1.0)*x749)));
evalcond[7]=((((-1.0)*x744*x745))+(((-1.0)*cj19*x748))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x750 = IKatan2WithCheck((gconst169*((((new_r00*sj19))+((cj19*new_r01))))),(gconst169*(((((-1.0)*cj19*new_r00))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x750.valid){
continue;
}
j21array[0]=x750.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x751=IKsin(j21);
IkReal x752=IKcos(j21);
IkReal x753=((1.0)*sj19);
IkReal x754=((1.0)*x752);
IkReal x755=(sj19*x751);
IkReal x756=((1.0)*x751);
IkReal x757=(cj19*x754);
evalcond[0]=(x751+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x752))+((cj19*x751))+new_r01);
evalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x754)));
evalcond[3]=((((-1.0)*new_r00*x753))+((cj19*new_r10))+(((-1.0)*x756)));
evalcond[4]=((((-1.0)*new_r01*x753))+((cj19*new_r11))+(((-1.0)*x754)));
evalcond[5]=(x755+new_r00+(((-1.0)*x757)));
evalcond[6]=(x755+new_r11+(((-1.0)*x757)));
evalcond[7]=((((-1.0)*x752*x753))+new_r10+(((-1.0)*cj19*x756)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x758=((1.0)+new_r22);
IkReal x759=(new_r12*sj19);
IkReal x760=((1.0)*new_r02);
IkReal x761=((((-1.0)*sj19*x760))+((cj19*new_r12)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959))))));
evalcond[1]=x758;
evalcond[2]=x758;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x761;
evalcond[10]=x761;
evalcond[11]=(x759+((cj19*new_r02)));
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x759))+(((-1.0)*cj19*x760)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst171;
gconst171=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst172;
gconst172=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x762=((1.0)*sj19);
CheckValue<IkReal> x763 = IKatan2WithCheck((gconst172*(((((-1.0)*new_r00*x762))+((cj19*new_r10))))),(gconst172*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x762))))),IKFAST_ATAN2_MAGTHRESH);
if(!x763.valid){
continue;
}
j21array[0]=x763.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x764=IKsin(j21);
IkReal x765=IKcos(j21);
IkReal x766=((1.0)*cj19);
IkReal x767=((1.0)*sj19);
IkReal x768=((1.0)*x764);
IkReal x769=(sj19*x765);
IkReal x770=(sj19*x764);
IkReal x771=(x764*x766);
evalcond[0]=(x765+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x768))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x765))+x770+new_r00);
evalcond[3]=((((-1.0)*new_r00*x767))+(((-1.0)*x768))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x765))+((cj19*new_r11))+(((-1.0)*new_r01*x767)));
evalcond[5]=(x769+(((-1.0)*x771))+new_r01);
evalcond[6]=(x769+(((-1.0)*x771))+new_r10);
evalcond[7]=((((-1.0)*x765*x766))+(((-1.0)*x764*x767))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x772=((1.0)*sj19);
CheckValue<IkReal> x773 = IKatan2WithCheck((gconst171*(((((-1.0)*new_r00*x772))+((cj19*new_r01))))),(gconst171*(((((-1.0)*new_r01*x772))+(((-1.0)*cj19*new_r00))))),IKFAST_ATAN2_MAGTHRESH);
if(!x773.valid){
continue;
}
j21array[0]=x773.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x774=IKsin(j21);
IkReal x775=IKcos(j21);
IkReal x776=((1.0)*cj19);
IkReal x777=((1.0)*sj19);
IkReal x778=((1.0)*x774);
IkReal x779=(sj19*x775);
IkReal x780=(sj19*x774);
IkReal x781=(x774*x776);
evalcond[0]=(x775+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x778))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(x780+new_r00+((cj19*x775)));
evalcond[3]=((((-1.0)*new_r00*x777))+(((-1.0)*x778))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x777))+((cj19*new_r11))+(((-1.0)*x775)));
evalcond[5]=((((-1.0)*x781))+x779+new_r01);
evalcond[6]=((((-1.0)*x781))+x779+new_r10);
evalcond[7]=((((-1.0)*x774*x777))+(((-1.0)*x775*x776))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x782=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x782;
evalcond[2]=x782;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x782;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x783=IKsin(j21);
IkReal x784=((1.0)*(IKcos(j21)));
evalcond[0]=(x783+new_r01);
evalcond[1]=((((-1.0)*x783))+new_r10);
evalcond[2]=((((-1.0)*x784))+new_r11);
evalcond[3]=((((-1.0)*x784))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x785=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x785;
evalcond[2]=x785;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x786=IKcos(j21);
IkReal x787=((1.0)*(IKsin(j21)));
evalcond[0]=(x786+new_r00);
evalcond[1]=((((-1.0)*x787))+new_r10);
evalcond[2]=((((-1.0)*x786))+new_r11);
evalcond[3]=((((-1.0)*x787))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x788=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j20), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x788;
evalcond[2]=x788;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x788;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x789=IKsin(j21);
IkReal x790=((1.0)*(IKcos(j21)));
evalcond[0]=((((-1.0)*new_r01))+x789);
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x789)));
evalcond[2]=((((-1.0)*x790))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x790))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x791=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j20, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x791;
evalcond[2]=x791;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x792=IKcos(j21);
IkReal x793=((1.0)*(IKsin(j21)));
evalcond[0]=((((-1.0)*new_r00))+x792);
evalcond[1]=((((-1.0)*x793))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x792)));
evalcond[3]=((((-1.0)*x793))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x794=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j19), 6.28318530717959)))))))));
evalcond[1]=x794;
evalcond[2]=x794;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x794;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x795=IKsin(j21);
IkReal x796=((1.0)*(IKcos(j21)));
evalcond[0]=(x795+new_r01);
evalcond[1]=((((-1.0)*x795))+new_r10);
evalcond[2]=((((-1.0)*x796))+new_r11);
evalcond[3]=((((-1.0)*x796))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x797=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j19, 6.28318530717959))))));
evalcond[1]=x797;
evalcond[2]=x797;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x797;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x798=IKsin(j21);
IkReal x799=((1.0)*(IKcos(j21)));
evalcond[0]=((((-1.0)*new_r01))+x798);
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x798)));
evalcond[2]=((((-1.0)*x799))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x799))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x800=((1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j19), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959))))));
evalcond[1]=x800;
evalcond[2]=x800;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x801=IKcos(j21);
IkReal x802=((1.0)*(IKsin(j21)));
evalcond[0]=(new_r00+x801);
evalcond[1]=(new_r10+(((-1.0)*x802)));
evalcond[2]=((((-1.0)*x801))+new_r11);
evalcond[3]=(new_r01+(((-1.0)*x802)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x803=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j19, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959))))));
evalcond[1]=x803;
evalcond[2]=x803;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x804=IKcos(j21);
IkReal x805=((1.0)*(IKsin(j21)));
evalcond[0]=((((-1.0)*new_r00))+x804);
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x805)));
evalcond[2]=((((-1.0)*x804))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x805)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x807=IKPowWithIntegerCheck(sj20,-1);
if(!x807.valid){
continue;
}
IkReal x806=x807.value;
CheckValue<IkReal> x808=IKPowWithIntegerCheck(sj19,-1);
if(!x808.valid){
continue;
}
if( IKabs((x806*(x808.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x806)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x806*(x808.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x806))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x806*(x808.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x806));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x809=IKsin(j21);
IkReal x810=IKcos(j21);
IkReal x811=(cj20*sj19);
IkReal x812=(cj19*new_r01);
IkReal x813=((1.0)*sj20);
IkReal x814=(cj19*new_r00);
IkReal x815=((1.0)*sj19);
IkReal x816=((1.0)*x810);
IkReal x817=(cj20*x809);
IkReal x818=((1.0)*x809);
IkReal x819=(cj19*x816);
evalcond[0]=(((sj20*x810))+new_r20);
evalcond[1]=((((-1.0)*x809*x813))+new_r21);
evalcond[2]=(x817+x812+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x818))+(((-1.0)*new_r00*x815))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x816))+(((-1.0)*new_r01*x815))+((cj19*new_r11)));
evalcond[5]=(((sj19*x810))+((cj19*x817))+new_r01);
evalcond[6]=((((-1.0)*cj20*x816))+x814+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x819))+((sj19*x809))+new_r00);
evalcond[8]=(((x809*x811))+(((-1.0)*x819))+new_r11);
evalcond[9]=((((-1.0)*cj19*x818))+(((-1.0)*x811*x816))+new_r10);
evalcond[10]=(((new_r11*x811))+(((-1.0)*new_r21*x813))+((cj20*x812))+x809);
evalcond[11]=(((new_r10*x811))+(((-1.0)*x816))+(((-1.0)*new_r20*x813))+((cj20*x814)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x821=IKPowWithIntegerCheck(sj20,-1);
if(!x821.valid){
continue;
}
IkReal x820=x821.value;
CheckValue<IkReal> x822=IKPowWithIntegerCheck(sj19,-1);
if(!x822.valid){
continue;
}
if( IKabs((new_r21*x820)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x820*(x822.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x820))+IKsqr((x820*(x822.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((new_r21*x820), (x820*(x822.value)*(((((-1.0)*new_r01*sj20))+(((-1.0)*cj19*cj20*new_r21))))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x823=IKsin(j21);
IkReal x824=IKcos(j21);
IkReal x825=(cj20*sj19);
IkReal x826=(cj19*new_r01);
IkReal x827=((1.0)*sj20);
IkReal x828=(cj19*new_r00);
IkReal x829=((1.0)*sj19);
IkReal x830=((1.0)*x824);
IkReal x831=(cj20*x823);
IkReal x832=((1.0)*x823);
IkReal x833=(cj19*x830);
evalcond[0]=(((sj20*x824))+new_r20);
evalcond[1]=((((-1.0)*x823*x827))+new_r21);
evalcond[2]=(x826+x831+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x829))+(((-1.0)*x832))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x829))+(((-1.0)*x830))+((cj19*new_r11)));
evalcond[5]=(((sj19*x824))+new_r01+((cj19*x831)));
evalcond[6]=(x828+((new_r10*sj19))+(((-1.0)*cj20*x830)));
evalcond[7]=(((sj19*x823))+new_r00+(((-1.0)*cj20*x833)));
evalcond[8]=((((-1.0)*x833))+((x823*x825))+new_r11);
evalcond[9]=((((-1.0)*cj19*x832))+new_r10+(((-1.0)*x825*x830)));
evalcond[10]=(((new_r11*x825))+(((-1.0)*new_r21*x827))+((cj20*x826))+x823);
evalcond[11]=((((-1.0)*new_r20*x827))+((new_r10*x825))+(((-1.0)*x830))+((cj20*x828)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x834 = IKatan2WithCheck((gconst162*new_r21),((-1.0)*gconst162*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x834.valid){
continue;
}
j21array[0]=x834.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x835=IKsin(j21);
IkReal x836=IKcos(j21);
IkReal x837=(cj20*sj19);
IkReal x838=(cj19*new_r01);
IkReal x839=((1.0)*sj20);
IkReal x840=(cj19*new_r00);
IkReal x841=((1.0)*sj19);
IkReal x842=((1.0)*x836);
IkReal x843=(cj20*x835);
IkReal x844=((1.0)*x835);
IkReal x845=(cj19*x842);
evalcond[0]=(((sj20*x836))+new_r20);
evalcond[1]=((((-1.0)*x835*x839))+new_r21);
evalcond[2]=(x838+x843+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x844))+((cj19*new_r10))+(((-1.0)*new_r00*x841)));
evalcond[4]=((((-1.0)*x842))+((cj19*new_r11))+(((-1.0)*new_r01*x841)));
evalcond[5]=(((sj19*x836))+new_r01+((cj19*x843)));
evalcond[6]=(x840+((new_r10*sj19))+(((-1.0)*cj20*x842)));
evalcond[7]=(((sj19*x835))+new_r00+(((-1.0)*cj20*x845)));
evalcond[8]=(((x835*x837))+(((-1.0)*x845))+new_r11);
evalcond[9]=((((-1.0)*x837*x842))+new_r10+(((-1.0)*cj19*x844)));
evalcond[10]=(((new_r11*x837))+((cj20*x838))+(((-1.0)*new_r21*x839))+x835);
evalcond[11]=(((cj20*x840))+(((-1.0)*x842))+(((-1.0)*new_r20*x839))+((new_r10*x837)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j15;
vinfos[1].indices[0] = _ij15[0];
vinfos[1].indices[1] = _ij15[1];
vinfos[1].maxsolutions = _nj15;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j16;
vinfos[2].indices[0] = _ij16[0];
vinfos[2].indices[1] = _ij16[1];
vinfos[2].maxsolutions = _nj16;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j17;
vinfos[3].indices[0] = _ij17[0];
vinfos[3].indices[1] = _ij17[1];
vinfos[3].maxsolutions = _nj17;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j18;
vinfos[4].indices[0] = _ij18[0];
vinfos[4].indices[1] = _ij18[1];
vinfos[4].maxsolutions = _nj18;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j19;
vinfos[5].indices[0] = _ij19[0];
vinfos[5].indices[1] = _ij19[1];
vinfos[5].maxsolutions = _nj19;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j20;
vinfos[6].indices[0] = _ij20[0];
vinfos[6].indices[1] = _ij20[1];
vinfos[6].maxsolutions = _nj20;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j21;
vinfos[7].indices[0] = _ij21[0];
vinfos[7].indices[1] = _ij21[1];
vinfos[7].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "12ceb0aaa06143fe305efa6e48faae0b"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
