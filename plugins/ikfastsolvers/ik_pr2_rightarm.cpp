#define IKFAST_NAMESPACE ik_pr2_rightarm
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 66 generated on 2013-07-25 00:01:37.083223
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==66);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
#ifndef isfinite
#define isfinite _isfinite
#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62;
x0=IKcos(j[0]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[4]);
x6=IKcos(j[4]);
x7=IKcos(j[3]);
x8=IKcos(j[1]);
x9=IKsin(j[3]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKsin(j[5]);
x13=IKcos(j[5]);
x14=((1.0)*x12);
x15=((0.18)*x7);
x16=((0.18)*x5);
x17=((0.321)*x3);
x18=((1.0)*x1);
x19=((0.18)*x9);
x20=((1.0)*x13);
x21=((1.0)*x9);
x22=((0.18)*x6);
x23=((1.0)*x3);
x24=(x8*x9);
x25=(x0*x8);
x26=(x0*x3);
x27=(x0*x2);
x28=(x4*x7);
x29=((-1.0)*x7);
x30=(x1*x4);
x31=(x1*x8);
x32=(x2*x8);
x33=(x31*x7);
x34=(x21*x25);
x35=(x18*x24);
x36=(x23*x7*x8);
x37=(((x27*x4))+(((-1.0)*x18*x3)));
x38=(x27+(((-1.0)*x18*x3*x4)));
x39=(((x2*x30))+x26);
x40=((((-1.0)*x36))+((x4*x9)));
x41=((((-1.0)*x18*x2))+(((-1.0)*x0*x23*x4)));
x42=(x37*x5);
x43=(x38*x7);
x44=(x39*x5);
x45=(((x21*x3*x8))+(((1.0)*x28)));
x46=(x38*x9);
x47=(x41*x7);
x48=(x41*x9);
x49=(((x32*x5))+((x40*x6)));
x50=((((-1.0)*x1*x24))+x43);
x51=(((x32*x6))+((x5*(((((-1.0)*x21*x4))+x36)))));
x52=((((-1.0)*x18*x7*x8))+(((-1.0)*x21*x38)));
x53=(x13*x49);
x54=((((-1.0)*x0*x24))+x47);
x55=(x50*x6);
x56=((((-1.0)*x48))+((x25*x29)));
x57=(x54*x6);
x58=(x44+x55);
x59=(((x6*(((((-1.0)*x34))+x47))))+x42);
x60=(((x5*((((x29*x38))+x35))))+((x39*x6)));
x61=(((x5*((((x29*x41))+x34))))+((x37*x6)));
x62=(x13*x59);
eerot[0]=(((x11*x61))+((x10*((((x12*x56))+x62)))));
eerot[1]=(((x11*(((((-1.0)*x20*x59))+(((-1.0)*x14*x56))))))+((x10*x61)));
eerot[2]=(((x13*((x48+((x25*x7))))))+((x12*((x42+x57)))));
eetrans[0]=(((x9*(((((-1.0)*x0*x17*x4))+(((-0.321)*x1*x2))))))+(((0.1)*x0))+(((0.321)*x25*x7))+(((0.4)*x25))+((x12*((((x16*x37))+((x22*x54))))))+((x13*((((x19*x41))+((x15*x25)))))));
eerot[3]=(((x11*x60))+((x10*((((x13*x58))+((x12*x52)))))));
eerot[4]=(((x11*(((((-1.0)*x20*x58))+(((-1.0)*x14*x52))))))+((x10*x60)));
eerot[5]=(((x13*((x33+x46))))+((x12*((((x6*(((((-1.0)*x35))+x43))))+x44)))));
eetrans[1]=((-0.188)+(((0.1)*x1))+((x13*((((x19*x38))+((x15*x31))))))+(((0.321)*x33))+(((0.4)*x31))+((x9*(((((-1.0)*x17*x30))+(((0.321)*x27))))))+((x12*((((x16*x39))+((x22*x50)))))));
eerot[6]=(((x11*x51))+((x10*((x53+((x12*x45)))))));
eerot[7]=(((x10*x51))+((x11*(((((-1.0)*x20*x49))+(((-1.0)*x14*x45)))))));
eerot[8]=(((x12*x49))+(((-1.0)*x13*x45)));
eetrans[2]=(((x13*(((((-1.0)*x19*x3*x8))+(((-1.0)*x15*x4))))))+((x12*((((x16*x32))+((x22*x40))))))+(((-1.0)*x17*x24))+(((-0.4)*x4))+(((-0.321)*x28)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j27,cj27,sj27,htj27,j28,cj28,sj28,htj28,j30,cj30,sj30,htj30,j31,cj31,sj31,htj31,j32,cj32,sj32,htj32,j33,cj33,sj33,htj33,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij29[2], _nj29;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j29=pfree[0]; cj29=cos(pfree[0]); sj29=sin(pfree[0]);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((((-0.18)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((0.188)+(((-0.18)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=(pz+(((-0.18)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*py*r20))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*pz*r00)));
rxp0_2=((((-1.0)*px*r10))+((py*r00)));
rxp1_0=((((-1.0)*py*r21))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*pz*r01)));
rxp1_2=((((-1.0)*px*r11))+((py*r01)));
rxp2_0=((((-1.0)*py*r22))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*pz*r02)));
rxp2_2=((((-1.0)*px*r12))+((py*r02)));
{
IkReal dummyeval[1];
IkReal gconst0;
gconst0=((-1.0)*py);
IkReal gconst1;
gconst1=((0.642)*sj29);
IkReal gconst2;
gconst2=((-1.0)*py);
IkReal gconst3;
gconst3=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst4;
gconst4=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst5;
gconst5=((-1.0)*py);
IkReal gconst6;
gconst6=((0.642)*sj29);
IkReal gconst7;
gconst7=((-1.0)*py);
IkReal gconst8;
gconst8=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst9;
gconst9=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst10;
gconst10=((2.0)*px);
IkReal gconst11;
gconst11=((2.0)*px);
IkReal gconst12;
gconst12=((0.4)*py);
IkReal gconst13;
gconst13=((0.4)*py);
IkReal gconst14;
gconst14=((2.0)*px);
IkReal gconst15;
gconst15=((2.0)*px);
IkReal gconst16;
gconst16=((0.4)*py);
IkReal gconst17;
gconst17=((0.4)*py);
IkReal gconst18;
gconst18=py;
IkReal gconst19;
gconst19=((0.642)*sj29);
IkReal gconst20;
gconst20=py;
IkReal gconst21;
gconst21=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst22;
gconst22=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst23;
gconst23=py;
IkReal gconst24;
gconst24=((0.642)*sj29);
IkReal gconst25;
gconst25=py;
IkReal gconst26;
gconst26=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst27;
gconst27=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal x63=(gconst20*gconst21);
IkReal x64=(gconst23*gconst27);
IkReal x65=(gconst25*gconst26);
IkReal x66=(gconst18*gconst22);
dummyeval[0]=((((-1.0)*x64*x66))+(((-1.0)*x63*x65))+(((-1.0)*gconst19*gconst22*gconst24*gconst26))+((x63*x64))+((x65*x66)));
if( IKabs(dummyeval[0]) < 0.0000001000000000  )
{
continue;

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x67=((1.0)*gconst8);
IkReal x68=(gconst3*gconst7);
IkReal x69=(gconst0*gconst8);
IkReal x70=(gconst13*gconst15);
IkReal x71=((1.0)*gconst22);
IkReal x72=(gconst19*gconst24);
IkReal x73=(gconst0*gconst9);
IkReal x74=(gconst1*gconst6);
IkReal x75=(gconst27*gconst5);
IkReal x76=(gconst2*gconst3);
IkReal x77=((1.0)*gconst4);
IkReal x78=(gconst17*gconst5);
IkReal x79=(gconst12*gconst14);
IkReal x80=(gconst2*gconst9);
IkReal x81=((1.0)*gconst16);
IkReal x82=(gconst18*gconst25);
IkReal x83=(gconst12*gconst7);
IkReal x84=(gconst18*gconst9);
IkReal x85=(gconst20*gconst27);
IkReal x86=(gconst26*gconst4);
IkReal x87=(gconst1*gconst24);
IkReal x88=(gconst11*gconst3);
IkReal x89=((1.0)*gconst26);
IkReal x90=(gconst20*gconst21);
IkReal x91=(gconst13*gconst16);
IkReal x92=(gconst18*gconst23);
IkReal x93=(gconst21*gconst25);
IkReal x94=(gconst2*gconst21);
IkReal x95=(gconst12*gconst2);
IkReal x96=(gconst5*gconst9);
IkReal x97=(gconst20*gconst3);
IkReal x98=(gconst4*gconst7);
IkReal x99=(gconst11*gconst12);
IkReal x100=(gconst14*gconst17);
IkReal x101=(gconst15*gconst4);
IkReal x102=((1.0)*gconst13);
IkReal x103=(gconst10*gconst8);
IkReal x104=(gconst0*gconst16);
IkReal x105=(gconst23*gconst27);
IkReal x106=(gconst22*gconst25);
IkReal x107=(gconst10*gconst16);
IkReal x108=(gconst19*gconst6);
IkReal x109=(gconst22*gconst7);
IkReal x110=(gconst0*gconst7);
IkReal x111=(gconst17*gconst23);
IkReal x112=(gconst10*gconst14);
IkReal x113=(gconst11*gconst21);
IkReal x114=(gconst12*gconst20);
IkReal x115=(gconst18*gconst26);
IkReal x116=(gconst14*gconst9);
IkReal x117=(gconst13*gconst7);
IkReal x118=(gconst16*gconst22);
IkReal x119=(gconst23*x90);
IkReal x120=(gconst10*gconst25*gconst26);
IkReal x121=(gconst15*gconst22*gconst26);
IkReal x122=(gconst14*gconst18*gconst27);
op[0]=((((-1.0)*gconst26*x71*x72))+(((-1.0)*gconst25*x89*x90))+((gconst22*gconst26*x82))+(((-1.0)*gconst27*x71*x92))+((gconst21*gconst23*x85)));
op[1]=((((-1.0)*x122*x71))+(((-1.0)*gconst25*x81*x90))+((gconst13*gconst26*x82))+((gconst10*gconst26*x106))+(((-1.0)*gconst11*x89*x93))+((gconst14*gconst21*x85))+(((-1.0)*gconst17*x71*x92))+(((-1.0)*gconst27*x102*x92))+(((-1.0)*gconst25*x114*x89))+(((-1.0)*gconst16*x71*x72))+(((-1.0)*gconst13*x72*x89))+((x111*x90))+((gconst15*gconst22*x115))+((x118*x82))+((x105*x113))+(((-1.0)*gconst10*x105*x71))+(((-1.0)*gconst15*x89*x90))+((gconst12*gconst23*x85)));
op[2]=((((-1.0)*gconst15*x81*x90))+(((-1.0)*gconst27*x112*x71))+((gconst15*gconst18*x118))+((x79*x85))+((x100*x90))+((x82*x91))+((x106*x107))+((x111*x114))+((x111*x113))+((x82*x86))+((gconst23*gconst3*x85))+((gconst14*gconst27*x113))+(((-1.0)*gconst22*x67*x72))+(((-1.0)*gconst17*x102*x92))+((x115*x70))+(((-1.0)*gconst25*x89*x99))+(((-1.0)*gconst25*x89*x97))+(((-1.0)*gconst25*x67*x90))+((x109*x115))+((gconst9*x119))+(((-1.0)*gconst25*x114*x81))+(((-1.0)*gconst26*x71*x87))+(((-1.0)*gconst11*x81*x93))+((gconst22*gconst8*x82))+((x75*x90))+((gconst13*x120))+((gconst0*gconst26*x106))+(((-1.0)*gconst18*x71*x75))+(((-1.0)*gconst13*x72*x81))+(((-1.0)*gconst10*x102*x105))+(((-1.0)*gconst23*x71*x84))+((gconst10*x121))+(((-1.0)*gconst7*x89*x90))+(((-1.0)*gconst2*x89*x93))+(((-1.0)*gconst0*x105*x71))+(((-1.0)*gconst15*x113*x89))+(((-1.0)*gconst10*x111*x71))+(((-1.0)*x102*x122))+((x105*x99))+((x105*x94))+(((-1.0)*gconst26*x72*x77))+(((-1.0)*gconst26*x108*x71))+(((-1.0)*gconst27*x77*x92))+(((-1.0)*gconst18*x100*x71))+(((-1.0)*gconst15*x114*x89)));
op[3]=((((-1.0)*gconst17*gconst18*gconst23*gconst4))+((gconst16*gconst18*gconst25*gconst4))+((gconst15*gconst18*gconst22*gconst8))+(((-1.0)*gconst16*gconst19*gconst22*gconst6))+((gconst11*gconst12*gconst14*gconst27))+(((-1.0)*gconst16*gconst20*gconst21*gconst7))+(((-1.0)*gconst10*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst13*gconst14*gconst27))+((gconst0*gconst16*gconst22*gconst25))+((gconst0*gconst15*gconst22*gconst26))+((gconst14*gconst2*gconst21*gconst27))+((gconst10*gconst13*gconst15*gconst26))+(((-1.0)*gconst16*gconst2*gconst21*gconst25))+((gconst11*gconst23*gconst27*gconst3))+(((-1.0)*gconst10*gconst13*gconst17*gconst23))+((gconst11*gconst14*gconst17*gconst21))+(((-1.0)*gconst15*gconst20*gconst26*gconst3))+((gconst12*gconst14*gconst17*gconst20))+(((-1.0)*gconst14*gconst18*gconst22*gconst9))+(((-1.0)*gconst13*gconst18*gconst27*gconst5))+(((-1.0)*gconst16*gconst20*gconst25*gconst3))+((gconst11*gconst21*gconst23*gconst9))+(((-1.0)*gconst11*gconst12*gconst15*gconst26))+(((-1.0)*gconst11*gconst21*gconst26*gconst7))+((gconst14*gconst20*gconst21*gconst9))+((gconst16*gconst18*gconst22*gconst7))+(((-1.0)*gconst17*gconst18*gconst22*gconst5))+(((-1.0)*gconst15*gconst2*gconst21*gconst26))+((gconst12*gconst20*gconst23*gconst9))+((gconst13*gconst18*gconst25*gconst8))+(((-1.0)*gconst13*gconst18*gconst23*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst20))+((gconst10*gconst25*gconst26*gconst4))+(((-1.0)*gconst10*gconst22*gconst27*gconst5))+((gconst14*gconst20*gconst27*gconst3))+((gconst15*gconst18*gconst26*gconst4))+((gconst13*gconst15*gconst16*gconst18))+((gconst10*gconst22*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst23))+(((-1.0)*gconst15*gconst20*gconst21*gconst8))+(((-1.0)*gconst11*gconst15*gconst16*gconst21))+(((-1.0)*gconst10*gconst14*gconst17*gconst22))+(((-1.0)*gconst11*gconst12*gconst16*gconst25))+(((-1.0)*gconst13*gconst19*gconst24*gconst8))+((gconst11*gconst12*gconst17*gconst23))+((gconst12*gconst2*gconst23*gconst27))+(((-1.0)*gconst13*gconst14*gconst17*gconst18))+((gconst17*gconst20*gconst23*gconst3))+(((-1.0)*gconst13*gconst19*gconst26*gconst6))+((gconst17*gconst20*gconst21*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst26))+((gconst10*gconst15*gconst16*gconst22))+(((-1.0)*gconst1*gconst16*gconst22*gconst24))+(((-1.0)*gconst0*gconst13*gconst23*gconst27))+((gconst11*gconst21*gconst27*gconst5))+((gconst13*gconst18*gconst26*gconst7))+((gconst17*gconst2*gconst21*gconst23))+(((-1.0)*gconst10*gconst23*gconst27*gconst4))+(((-1.0)*gconst0*gconst14*gconst22*gconst27))+((gconst0*gconst13*gconst25*gconst26))+(((-1.0)*gconst11*gconst25*gconst26*gconst3))+(((-1.0)*gconst1*gconst13*gconst24*gconst26))+((gconst10*gconst22*gconst26*gconst7))+((gconst12*gconst20*gconst27*gconst5))+(((-1.0)*gconst14*gconst18*gconst27*gconst4))+(((-1.0)*gconst12*gconst20*gconst26*gconst7))+(((-1.0)*gconst11*gconst21*gconst25*gconst8))+(((-1.0)*gconst16*gconst19*gconst24*gconst4))+((gconst10*gconst13*gconst16*gconst25))+(((-1.0)*gconst12*gconst20*gconst25*gconst8)));
op[4]=(((gconst12*gconst14*gconst2*gconst27))+(((-1.0)*gconst11*gconst15*gconst26*gconst3))+(((-1.0)*gconst10*gconst17*gconst23*gconst4))+((gconst10*gconst15*gconst22*gconst8))+(((-1.0)*gconst13*gconst17*gconst18*gconst5))+((gconst2*gconst23*gconst27*gconst3))+((gconst18*gconst22*gconst7*gconst8))+((gconst14*gconst17*gconst2*gconst21))+((gconst20*gconst27*gconst3*gconst5))+(((-1.0)*gconst2*gconst21*gconst25*gconst8))+((gconst11*gconst12*gconst14*gconst17))+(((-1.0)*gconst18*gconst27*gconst4*gconst5))+(((-1.0)*gconst10*gconst13*gconst14*gconst17))+(((-1.0)*gconst2*gconst21*gconst26*gconst7))+(((-1.0)*gconst12*gconst15*gconst2*gconst26))+((gconst10*gconst16*gconst22*gconst7))+((gconst13*gconst15*gconst18*gconst8))+((gconst12*gconst17*gconst2*gconst23))+((gconst10*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst13*gconst16*gconst24))+((gconst11*gconst14*gconst27*gconst3))+(((-1.0)*gconst0*gconst13*gconst14*gconst27))+(((-1.0)*gconst1*gconst22*gconst24*gconst8))+((gconst18*gconst25*gconst4*gconst8))+(((-1.0)*gconst12*gconst16*gconst20*gconst7))+(((-1.0)*gconst13*gconst14*gconst18*gconst9))+((gconst0*gconst13*gconst16*gconst25))+((gconst13*gconst16*gconst18*gconst7))+(((-1.0)*gconst20*gconst26*gconst3*gconst7))+((gconst11*gconst12*gconst27*gconst5))+(((-1.0)*gconst0*gconst14*gconst17*gconst22))+(((-1.0)*gconst20*gconst25*gconst3*gconst8))+(((-1.0)*gconst12*gconst15*gconst20*gconst8))+(((-1.0)*gconst19*gconst26*gconst4*gconst6))+(((-1.0)*gconst15*gconst16*gconst2*gconst21))+(((-1.0)*gconst10*gconst14*gconst22*gconst9))+((gconst10*gconst13*gconst25*gconst8))+(((-1.0)*gconst18*gconst22*gconst5*gconst9))+((gconst10*gconst13*gconst26*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst16))+((gconst0*gconst13*gconst15*gconst26))+(((-1.0)*gconst12*gconst16*gconst2*gconst25))+(((-1.0)*gconst20*gconst21*gconst7*gconst8))+(((-1.0)*gconst11*gconst12*gconst26*gconst7))+(((-1.0)*gconst2*gconst25*gconst26*gconst3))+((gconst2*gconst21*gconst27*gconst5))+(((-1.0)*gconst14*gconst17*gconst18*gconst4))+((gconst2*gconst21*gconst23*gconst9))+(((-1.0)*gconst13*gconst16*gconst19*gconst6))+(((-1.0)*gconst0*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst14*gconst27*gconst4))+(((-1.0)*gconst11*gconst12*gconst25*gconst8))+((gconst12*gconst14*gconst20*gconst9))+((gconst18*gconst26*gconst4*gconst7))+(((-1.0)*gconst0*gconst23*gconst27*gconst4))+((gconst20*gconst21*gconst5*gconst9))+((gconst11*gconst12*gconst23*gconst9))+(((-1.0)*gconst0*gconst22*gconst27*gconst5))+(((-1.0)*gconst10*gconst13*gconst27*gconst5))+(((-1.0)*gconst1*gconst22*gconst26*gconst6))+((gconst10*gconst15*gconst26*gconst4))+(((-1.0)*gconst10*gconst13*gconst23*gconst9))+((gconst11*gconst17*gconst23*gconst3))+(((-1.0)*gconst10*gconst17*gconst22*gconst5))+((gconst0*gconst15*gconst16*gconst22))+(((-1.0)*gconst11*gconst16*gconst21*gconst7))+((gconst0*gconst25*gconst26*gconst4))+(((-1.0)*gconst19*gconst24*gconst4*gconst8))+((gconst0*gconst22*gconst25*gconst8))+(((-1.0)*gconst18*gconst23*gconst4*gconst9))+((gconst11*gconst14*gconst21*gconst9))+(((-1.0)*gconst11*gconst16*gconst25*gconst3))+(((-1.0)*gconst11*gconst15*gconst21*gconst8))+((gconst14*gconst17*gconst20*gconst3))+((gconst12*gconst17*gconst20*gconst5))+((gconst11*gconst17*gconst21*gconst5))+(((-1.0)*gconst19*gconst22*gconst6*gconst8))+((gconst15*gconst16*gconst18*gconst4))+((gconst0*gconst22*gconst26*gconst7))+((gconst20*gconst23*gconst3*gconst9))+(((-1.0)*gconst1*gconst24*gconst26*gconst4))+((gconst10*gconst16*gconst25*gconst4))+(((-1.0)*gconst0*gconst13*gconst17*gconst23))+(((-1.0)*gconst15*gconst16*gconst20*gconst3)));
op[5]=(((gconst0*gconst13*gconst26*gconst7))+(((-1.0)*gconst16*gconst2*gconst25*gconst3))+(((-1.0)*gconst13*gconst18*gconst5*gconst9))+(((-1.0)*gconst16*gconst19*gconst4*gconst6))+((gconst17*gconst20*gconst3*gconst5))+(((-1.0)*gconst0*gconst14*gconst27*gconst4))+((gconst10*gconst15*gconst16*gconst4))+(((-1.0)*gconst0*gconst17*gconst23*gconst4))+(((-1.0)*gconst10*gconst13*gconst14*gconst9))+(((-1.0)*gconst16*gconst20*gconst3*gconst7))+((gconst12*gconst20*gconst5*gconst9))+(((-1.0)*gconst0*gconst14*gconst22*gconst9))+((gconst11*gconst14*gconst17*gconst3))+((gconst0*gconst15*gconst22*gconst8))+(((-1.0)*gconst0*gconst13*gconst14*gconst17))+(((-1.0)*gconst15*gconst2*gconst21*gconst8))+((gconst10*gconst25*gconst4*gconst8))+(((-1.0)*gconst11*gconst25*gconst3*gconst8))+(((-1.0)*gconst1*gconst16*gconst22*gconst6))+(((-1.0)*gconst15*gconst2*gconst26*gconst3))+(((-1.0)*gconst11*gconst26*gconst3*gconst7))+((gconst17*gconst2*gconst23*gconst3))+((gconst0*gconst16*gconst25*gconst4))+((gconst10*gconst26*gconst4*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst8))+((gconst14*gconst2*gconst21*gconst9))+(((-1.0)*gconst0*gconst13*gconst27*gconst5))+((gconst17*gconst2*gconst21*gconst5))+((gconst12*gconst14*gconst17*gconst2))+(((-1.0)*gconst16*gconst2*gconst21*gconst7))+((gconst11*gconst23*gconst3*gconst9))+((gconst10*gconst13*gconst16*gconst7))+((gconst11*gconst12*gconst17*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst8))+((gconst12*gconst2*gconst27*gconst5))+((gconst11*gconst21*gconst5*gconst9))+(((-1.0)*gconst13*gconst19*gconst6*gconst8))+(((-1.0)*gconst10*gconst23*gconst4*gconst9))+((gconst0*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst16*gconst24*gconst4))+((gconst14*gconst20*gconst3*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst2))+(((-1.0)*gconst0*gconst13*gconst23*gconst9))+(((-1.0)*gconst11*gconst15*gconst16*gconst3))+((gconst16*gconst18*gconst4*gconst7))+((gconst12*gconst2*gconst23*gconst9))+(((-1.0)*gconst12*gconst2*gconst26*gconst7))+((gconst10*gconst22*gconst7*gconst8))+(((-1.0)*gconst1*gconst13*gconst24*gconst8))+(((-1.0)*gconst15*gconst20*gconst3*gconst8))+(((-1.0)*gconst12*gconst20*gconst7*gconst8))+((gconst11*gconst12*gconst14*gconst9))+(((-1.0)*gconst10*gconst14*gconst17*gconst4))+((gconst13*gconst18*gconst7*gconst8))+((gconst10*gconst13*gconst15*gconst8))+(((-1.0)*gconst17*gconst18*gconst4*gconst5))+(((-1.0)*gconst10*gconst22*gconst5*gconst9))+(((-1.0)*gconst11*gconst21*gconst7*gconst8))+((gconst14*gconst2*gconst27*gconst3))+(((-1.0)*gconst1*gconst13*gconst26*gconst6))+(((-1.0)*gconst10*gconst27*gconst4*gconst5))+(((-1.0)*gconst14*gconst18*gconst4*gconst9))+((gconst0*gconst15*gconst26*gconst4))+((gconst15*gconst18*gconst4*gconst8))+(((-1.0)*gconst10*gconst13*gconst17*gconst5))+((gconst0*gconst13*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst5))+(((-1.0)*gconst11*gconst12*gconst16*gconst7))+((gconst11*gconst27*gconst3*gconst5))+((gconst0*gconst16*gconst22*gconst7)));
op[6]=((((-1.0)*gconst26*x74*x77))+((x110*x86))+((x96*x97))+((x96*x99))+((x79*x80))+(((-1.0)*gconst2*x81*x83))+(((-1.0)*gconst13*x74*x81))+((x107*x98))+((x78*x88))+((gconst23*gconst9*x76))+((x100*x76))+(((-1.0)*gconst23*x73*x77))+(((-1.0)*gconst25*x67*x76))+(((-1.0)*gconst22*x67*x74))+(((-1.0)*gconst15*x76*x81))+((x78*x95))+(((-1.0)*gconst9*x112*x77))+(((-1.0)*gconst14*x102*x73))+(((-1.0)*gconst4*x108*x67))+((gconst18*gconst8*x98))+((x103*x117))+((x69*x70))+(((-1.0)*gconst5*x71*x73))+(((-1.0)*gconst10*x102*x96))+(((-1.0)*gconst20*x67*x68))+((x75*x76))+(((-1.0)*gconst2*x68*x89))+(((-1.0)*gconst10*x77*x78))+(((-1.0)*gconst0*x102*x78))+((gconst21*gconst5*x80))+((x109*x69))+(((-1.0)*gconst11*x68*x81))+((x116*x88))+(((-1.0)*gconst4*x67*x87))+(((-1.0)*gconst11*x67*x83))+(((-1.0)*gconst5*x77*x84))+(((-1.0)*gconst0*x75*x77))+(((-1.0)*gconst0*x100*x77))+((gconst25*gconst4*x69))+((x101*x103))+((x101*x104))+(((-1.0)*gconst15*x67*x88))+(((-1.0)*gconst7*x67*x94))+((x110*x91))+(((-1.0)*gconst15*x67*x95)));
op[7]=(((x101*x69))+(((-1.0)*gconst0*x77*x78))+((x103*x98))+((x116*x76))+(((-1.0)*gconst13*x67*x74))+((gconst12*gconst5*x80))+(((-1.0)*gconst2*x68*x81))+(((-1.0)*gconst11*x67*x68))+((x88*x96))+(((-1.0)*gconst16*x74*x77))+(((-1.0)*gconst14*x73*x77))+(((-1.0)*gconst2*x67*x83))+((x76*x78))+(((-1.0)*gconst15*x67*x76))+(((-1.0)*gconst10*x77*x96))+((x117*x69))+((x104*x98))+(((-1.0)*gconst5*x102*x73)));
op[8]=((((-1.0)*gconst5*x73*x77))+(((-1.0)*gconst2*x67*x68))+((x69*x98))+((x76*x96))+(((-1.0)*gconst4*x67*x74)));
polyroots8(op,zeror,numroots);
IkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];
int numsolutions = 0;
for(int ij27 = 0; ij27 < numroots; ++ij27)
{
IkReal htj27 = zeror[ij27];
tempj27array[0]=((2.0)*(atan(htj27)));
for(int kj27 = 0; kj27 < 1; ++kj27)
{
j27array[numsolutions] = tempj27array[kj27];
if( j27array[numsolutions] > IKPI )
{
    j27array[numsolutions]-=IK2PI;
}
else if( j27array[numsolutions] < -IKPI )
{
    j27array[numsolutions]+=IK2PI;
}
sj27array[numsolutions] = IKsin(j27array[numsolutions]);
cj27array[numsolutions] = IKcos(j27array[numsolutions]);
numsolutions++;
}
}
bool j27valid[8]={true,true,true,true,true,true,true,true};
_nj27 = 8;
for(int ij27 = 0; ij27 < numsolutions; ++ij27)
    {
if( !j27valid[ij27] )
{
    continue;
}
    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];
htj27 = IKtan(j27/2);

_ij27[0] = ij27; _ij27[1] = -1;
for(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)
{
if( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )
{
    j27valid[iij27]=false; _ij27[1] = iij27; break; 
}
}
{
IkReal dummyeval[1];
IkReal gconst44;
IkReal x123=((0.8)*sj29);
IkReal x124=(cj27*px);
IkReal x125=(py*sj27);
IkReal x126=((4.0)*sj29);
gconst44=IKsign(((((-1.0)*x126*(pz*pz)))+((x123*x125))+((x123*x124))+(((-0.04)*sj29))+(((-1.0)*x126*(x124*x124)))+(((-1.0)*x126*(x125*x125)))+(((-8.0)*sj29*x124*x125))));
IkReal x127=(py*sj27);
IkReal x128=((100.0)*sj29);
IkReal x129=(cj27*px*sj29);
dummyeval[0]=((((20.0)*sj29*x127))+(((-1.0)*x128*(cj27*cj27)*(px*px)))+(((-1.0)*sj29))+(((-1.0)*x128*(x127*x127)))+(((20.0)*x129))+(((-200.0)*x127*x129))+(((-1.0)*x128*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x130=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x130;
evalcond[2]=x130;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst49;
IkReal x131=(py*sj27);
IkReal x132=((321.0)*cj30);
IkReal x133=(cj27*px);
gconst49=IKsign(((40.0)+(((-321.0)*pz*sj30))+(((-400.0)*x133))+(((-400.0)*x131))+(((-1.0)*x132*x133))+(((32.1)*cj30))+(((-1.0)*x131*x132))));
IkReal x134=(py*sj27);
IkReal x135=((10.0)*cj30);
IkReal x136=(cj27*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x135*x136))+(((-12.4610591900312)*x136))+(((-12.4610591900312)*x134))+(((-1.0)*x134*x135))+(((-10.0)*pz*sj30))+cj30);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x137=((10.0)*sj30);
dummyeval[0]=((((-1.0)*cj27*px*x137))+(((-1.0)*py*sj27*x137))+sj30+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x138=x130;
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=x138;
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=x138;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x139=IKsin(j28);
IkReal x140=IKcos(j28);
IkReal x141=(cj27*px);
IkReal x142=(py*sj27);
IkReal x143=(x140*x142);
evalcond[0]=((0.721)*x139);
evalcond[1]=((((-0.1)*x139))+((x139*x142))+((x139*x141)));
evalcond[2]=((0.721)+(((0.1)*x140))+(((-1.0)*x143))+(((-1.0)*x140*x141)));
evalcond[3]=((-0.066959)+(((-0.08)*x140))+(((0.2)*x142))+(((0.2)*x141))+(((0.8)*x140*x141))+(((-1.0)*pp))+(((0.8)*x143)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x729=x130;
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=x729;
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=x729;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x730=IKsin(j28);
IkReal x731=IKcos(j28);
IkReal x732=(cj27*px);
IkReal x733=(py*sj27);
IkReal x734=(x731*x733);
evalcond[0]=((0.079)*x730);
evalcond[1]=((((-0.1)*x730))+((x730*x732))+((x730*x733)));
evalcond[2]=((0.079)+(((-1.0)*x734))+(((-1.0)*x731*x732))+(((0.1)*x731)));
evalcond[3]=((-0.066959)+(((-0.08)*x731))+(((0.8)*x731*x732))+(((-1.0)*pp))+(((0.2)*x733))+(((0.2)*x732))+(((0.8)*x734)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x735=(cj30*pz);
IkReal x736=((1000.0)*pz);
IkReal x737=(py*sj27*sj30);
IkReal x738=(cj27*px*sj30);
CheckValue<IkReal> x739=IKPowWithIntegerCheck(((((-321000.0)*x738))+(((-321000.0)*x737))+(((32100.0)*sj30))+(((321000.0)*x735))+(((400000.0)*pz))),-1);
if(!x739.valid){
continue;
}
CheckValue<IkReal> x740=IKPowWithIntegerCheck(((((321.0)*x735))+(((400.0)*pz))+(((-321.0)*x738))+(((-321.0)*x737))+(((32.1)*sj30))),-1);
if(!x740.valid){
continue;
}
if( IKabs(((x739.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x740.value)*(((((-100.0)*pz))+((cj27*px*x736))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+((py*sj27*x736)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x739.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x740.value)*(((((-100.0)*pz))+((cj27*px*x736))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+((py*sj27*x736))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x739.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x740.value)*(((((-100.0)*pz))+((cj27*px*x736))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+((py*sj27*x736))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x741=IKsin(j28);
IkReal x742=IKcos(j28);
IkReal x743=((0.321)*cj30);
IkReal x744=((0.321)*sj30);
IkReal x745=(cj27*px);
IkReal x746=(py*sj27);
IkReal x747=((1.0)*x746);
IkReal x748=(pz*x741);
IkReal x749=((0.8)*x742);
evalcond[0]=(((x742*x744))+((x741*x743))+pz+(((0.4)*x741)));
evalcond[1]=(((x741*x746))+((x741*x745))+x744+(((-0.1)*x741))+((pz*x742)));
evalcond[2]=((0.1)+((x742*x743))+(((-1.0)*x745))+(((0.4)*x742))+(((-1.0)*x741*x744))+(((-1.0)*x747)));
evalcond[3]=((0.4)+(((-1.0)*x742*x747))+(((-1.0)*x742*x745))+(((0.1)*x742))+x743+x748);
evalcond[4]=((-0.066959)+((x745*x749))+(((-0.08)*x742))+((x746*x749))+(((-1.0)*pp))+(((0.2)*x746))+(((0.2)*x745))+(((-0.8)*x748)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x750=((1000.0)*pz);
CheckValue<IkReal> x751 = IKatan2WithCheck((gconst49*(((((-100.0)*pz))+(((128.4)*sj30))+((cj27*px*x750))+((py*sj27*x750))+(((103.041)*cj30*sj30))))),(gconst49*(((-160.0)+((pz*x750))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x751.valid){
continue;
}
j28array[0]=x751.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x752=IKsin(j28);
IkReal x753=IKcos(j28);
IkReal x754=((0.321)*cj30);
IkReal x755=((0.321)*sj30);
IkReal x756=(cj27*px);
IkReal x757=(py*sj27);
IkReal x758=((1.0)*x757);
IkReal x759=(pz*x752);
IkReal x760=((0.8)*x753);
evalcond[0]=(((x752*x754))+pz+((x753*x755))+(((0.4)*x752)));
evalcond[1]=(((pz*x753))+((x752*x756))+((x752*x757))+(((-0.1)*x752))+x755);
evalcond[2]=((0.1)+(((-1.0)*x756))+(((-1.0)*x752*x755))+((x753*x754))+(((0.4)*x753))+(((-1.0)*x758)));
evalcond[3]=((0.4)+(((0.1)*x753))+(((-1.0)*x753*x758))+(((-1.0)*x753*x756))+x754+x759);
evalcond[4]=((-0.066959)+((x757*x760))+(((-0.08)*x753))+(((0.2)*x756))+(((0.2)*x757))+(((-1.0)*pp))+((x756*x760))+(((-0.8)*x759)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x761=(px*sj27);
IkReal x762=(cj27*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x762))+x761);
evalcond[2]=((((-1.0)*x761))+x762);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst50;
IkReal x763=(py*sj27);
IkReal x764=((321.0)*cj30);
IkReal x765=(cj27*px);
gconst50=IKsign(((-40.0)+(((400.0)*x765))+(((400.0)*x763))+(((-321.0)*pz*sj30))+((x763*x764))+((x764*x765))+(((-32.1)*cj30))));
IkReal x766=(cj27*px);
IkReal x767=(py*sj27);
IkReal x768=((10.0)*cj30);
dummyeval[0]=((-1.24610591900312)+(((12.4610591900312)*x767))+(((12.4610591900312)*x766))+(((-10.0)*pz*sj30))+(((-1.0)*cj30))+((x766*x768))+((x767*x768)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x769=((10.0)*sj30);
dummyeval[0]=(((py*sj27*x769))+(((-1.0)*sj30))+((cj27*px*x769))+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x770=(cj27*py);
IkReal x771=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=(x771+(((-1.0)*x770)));
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=(x770+(((-1.0)*x771)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x772=IKsin(j28);
IkReal x773=IKcos(j28);
IkReal x774=(cj27*px);
IkReal x775=(py*sj27);
IkReal x776=((1.0)*x772);
IkReal x777=(x773*x775);
evalcond[0]=((0.721)*x772);
evalcond[1]=((((-1.0)*x774*x776))+(((0.1)*x772))+(((-1.0)*x775*x776)));
evalcond[2]=((0.721)+(((0.1)*x773))+(((-1.0)*x777))+(((-1.0)*x773*x774)));
evalcond[3]=((-0.066959)+(((0.8)*x773*x774))+(((0.8)*x777))+(((-0.08)*x773))+(((-1.0)*pp))+(((0.2)*x774))+(((0.2)*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x778=(cj27*py);
IkReal x779=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=(x779+(((-1.0)*x778)));
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=(x778+(((-1.0)*x779)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x780=IKsin(j28);
IkReal x781=IKcos(j28);
IkReal x782=(cj27*px);
IkReal x783=(py*sj27);
IkReal x784=((1.0)*x780);
IkReal x785=(x781*x783);
evalcond[0]=((0.079)*x780);
evalcond[1]=((((0.1)*x780))+(((-1.0)*x782*x784))+(((-1.0)*x783*x784)));
evalcond[2]=((0.079)+(((-1.0)*x781*x782))+(((0.1)*x781))+(((-1.0)*x785)));
evalcond[3]=((-0.066959)+(((0.8)*x781*x782))+(((-0.08)*x781))+(((0.2)*x783))+(((0.2)*x782))+(((-1.0)*pp))+(((0.8)*x785)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x786=(cj30*pz);
IkReal x787=(py*sj27);
IkReal x788=((321000.0)*sj30);
IkReal x789=((1000.0)*pz);
IkReal x790=((321.0)*sj30);
IkReal x791=(cj27*px);
CheckValue<IkReal> x792=IKPowWithIntegerCheck(((((321000.0)*x786))+((x787*x788))+((x788*x791))+(((400000.0)*pz))+(((-32100.0)*sj30))),-1);
if(!x792.valid){
continue;
}
CheckValue<IkReal> x793=IKPowWithIntegerCheck((((x790*x791))+(((400.0)*pz))+(((321.0)*x786))+((x787*x790))+(((-32.1)*sj30))),-1);
if(!x793.valid){
continue;
}
if( IKabs(((x792.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x793.value)*(((((-100.0)*pz))+((x787*x789))+(((128.4)*sj30))+(((103.041)*cj30*sj30))+((x789*x791)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x792.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x793.value)*(((((-100.0)*pz))+((x787*x789))+(((128.4)*sj30))+(((103.041)*cj30*sj30))+((x789*x791))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x792.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x793.value)*(((((-100.0)*pz))+((x787*x789))+(((128.4)*sj30))+(((103.041)*cj30*sj30))+((x789*x791))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x794=IKsin(j28);
IkReal x795=IKcos(j28);
IkReal x796=((0.321)*cj30);
IkReal x797=((0.321)*sj30);
IkReal x798=(py*sj27);
IkReal x799=(cj27*px);
IkReal x800=((1.0)*x798);
IkReal x801=(pz*x794);
IkReal x802=((1.0)*x795);
IkReal x803=((0.8)*x795);
evalcond[0]=((((-1.0)*x795*x797))+pz+((x794*x796))+(((0.4)*x794)));
evalcond[1]=((0.1)+(((-1.0)*x799))+((x794*x797))+(((0.4)*x795))+(((-1.0)*x800))+((x795*x796)));
evalcond[2]=((0.4)+(((-1.0)*x799*x802))+(((0.1)*x795))+(((-1.0)*x795*x800))+x796+x801);
evalcond[3]=((((0.1)*x794))+(((-1.0)*x794*x799))+x797+(((-1.0)*x794*x800))+(((-1.0)*pz*x802)));
evalcond[4]=((-0.066959)+(((-0.08)*x795))+(((-1.0)*pp))+(((0.2)*x799))+(((0.2)*x798))+((x798*x803))+((x799*x803))+(((-0.8)*x801)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x804=((1000.0)*pz);
CheckValue<IkReal> x805 = IKatan2WithCheck((gconst50*(((((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))+(((-1.0)*py*sj27*x804))+(((-1.0)*cj27*px*x804))))),(gconst50*(((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x804))))),IKFAST_ATAN2_MAGTHRESH);
if(!x805.valid){
continue;
}
j28array[0]=x805.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x806=IKsin(j28);
IkReal x807=IKcos(j28);
IkReal x808=((0.321)*cj30);
IkReal x809=((0.321)*sj30);
IkReal x810=(py*sj27);
IkReal x811=(cj27*px);
IkReal x812=((1.0)*x810);
IkReal x813=(pz*x806);
IkReal x814=((1.0)*x807);
IkReal x815=((0.8)*x807);
evalcond[0]=((((-1.0)*x807*x809))+((x806*x808))+pz+(((0.4)*x806)));
evalcond[1]=((0.1)+((x806*x809))+(((-1.0)*x812))+(((-1.0)*x811))+(((0.4)*x807))+((x807*x808)));
evalcond[2]=((0.4)+(((0.1)*x807))+(((-1.0)*x811*x814))+(((-1.0)*x807*x812))+x813+x808);
evalcond[3]=((((0.1)*x806))+(((-1.0)*pz*x814))+x809+(((-1.0)*x806*x812))+(((-1.0)*x806*x811)));
evalcond[4]=((-0.066959)+(((-0.8)*x813))+((x810*x815))+(((-0.08)*x807))+(((-1.0)*pp))+((x811*x815))+(((0.2)*x811))+(((0.2)*x810)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x816=((-1.0)*cj27*py);
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x816;
evalcond[2]=x816;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst51;
IkReal x817=(py*sj27);
gconst51=IKsign(((40.0)+(((-400.0)*x817))+(((-321.0)*pz*sj30))+(((-321.0)*cj30*x817))+(((32.1)*cj30))));
IkReal x818=(py*sj27);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x818))+(((-10.0)*pz*sj30))+cj30+(((-10.0)*cj30*x818)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((((-10.0)*py*sj27*sj30))+sj30+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x819=x816;
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=x819;
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27)));
evalcond[3]=x819;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x820=IKsin(j28);
IkReal x821=IKcos(j28);
IkReal x822=(py*sj27);
IkReal x823=(x821*x822);
evalcond[0]=((0.721)*x820);
evalcond[1]=((((-0.1)*x820))+((x820*x822)));
evalcond[2]=((0.721)+(((0.1)*x821))+(((-1.0)*x823)));
evalcond[3]=((-0.066959)+(((0.8)*x823))+(((-0.08)*x821))+(((-1.0)*pp))+(((0.2)*x822)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x824=x816;
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=x824;
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27)));
evalcond[3]=x824;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x825=IKsin(j28);
IkReal x826=IKcos(j28);
IkReal x827=(py*sj27);
IkReal x828=(x826*x827);
evalcond[0]=((0.079)*x825);
evalcond[1]=((((-0.1)*x825))+((x825*x827)));
evalcond[2]=((0.079)+(((0.1)*x826))+(((-1.0)*x828)));
evalcond[3]=((-0.066959)+(((0.8)*x828))+(((-0.08)*x826))+(((-1.0)*pp))+(((0.2)*x827)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x829=(cj30*pz);
IkReal x830=(py*sj27*sj30);
CheckValue<IkReal> x831=IKPowWithIntegerCheck(((((32100.0)*sj30))+(((400000.0)*pz))+(((321000.0)*x829))+(((-321000.0)*x830))),-1);
if(!x831.valid){
continue;
}
CheckValue<IkReal> x832=IKPowWithIntegerCheck(((((-321.0)*x830))+(((400.0)*pz))+(((32.1)*sj30))+(((321.0)*x829))),-1);
if(!x832.valid){
continue;
}
if( IKabs(((x831.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x832.value)*(((((-100.0)*pz))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+(((1000.0)*py*pz*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x831.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x832.value)*(((((-100.0)*pz))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+(((1000.0)*py*pz*sj27))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x831.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x832.value)*(((((-100.0)*pz))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+(((1000.0)*py*pz*sj27))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x833=IKsin(j28);
IkReal x834=IKcos(j28);
IkReal x835=(py*sj27);
IkReal x836=((0.321)*x833);
IkReal x837=(pz*x833);
IkReal x838=((0.321)*x834);
evalcond[0]=((((0.4)*x833))+pz+((sj30*x838))+((cj30*x836)));
evalcond[1]=((((0.321)*sj30))+((x833*x835))+((pz*x834))+(((-0.1)*x833)));
evalcond[2]=((0.4)+(((-1.0)*x834*x835))+(((0.321)*cj30))+(((0.1)*x834))+x837);
evalcond[3]=((0.1)+(((0.4)*x834))+(((-1.0)*x835))+(((-1.0)*sj30*x836))+((cj30*x838)));
evalcond[4]=((-0.066959)+(((0.8)*x834*x835))+(((-0.08)*x834))+(((-0.8)*x837))+(((-1.0)*pp))+(((0.2)*x835)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
CheckValue<IkReal> x839 = IKatan2WithCheck((gconst51*(((((-100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))+(((1000.0)*py*pz*sj27))))),(gconst51*(((-160.0)+(((1000.0)*(pz*pz)))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x839.valid){
continue;
}
j28array[0]=x839.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x840=IKsin(j28);
IkReal x841=IKcos(j28);
IkReal x842=(py*sj27);
IkReal x843=((0.321)*x840);
IkReal x844=(pz*x840);
IkReal x845=((0.321)*x841);
evalcond[0]=((((0.4)*x840))+pz+((sj30*x845))+((cj30*x843)));
evalcond[1]=((((0.321)*sj30))+((x840*x842))+((pz*x841))+(((-0.1)*x840)));
evalcond[2]=((0.4)+(((0.321)*cj30))+(((0.1)*x841))+(((-1.0)*x841*x842))+x844);
evalcond[3]=((0.1)+(((0.4)*x841))+(((-1.0)*x842))+(((-1.0)*sj30*x843))+((cj30*x845)));
evalcond[4]=((-0.066959)+(((-0.08)*x841))+(((-1.0)*pp))+(((-0.8)*x844))+(((0.2)*x842))+(((0.8)*x841*x842)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x846=(cj27*py);
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((-1.0)*x846);
evalcond[2]=x846;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst52;
IkReal x847=(py*sj27);
gconst52=IKsign(((-40.0)+(((-321.0)*pz*sj30))+(((400.0)*x847))+(((321.0)*cj30*x847))+(((-32.1)*cj30))));
IkReal x848=(py*sj27);
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj30))+(((-1.0)*cj30))+(((12.4610591900312)*x848))+(((10.0)*cj30*x848)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((((-1.0)*sj30))+(((10.0)*py*sj27*sj30))+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x849=(cj27*py);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((-1.0)*x849);
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27)));
evalcond[3]=x849;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x850=IKsin(j28);
IkReal x851=IKcos(j28);
IkReal x852=(py*sj27);
IkReal x853=(x851*x852);
evalcond[0]=((0.721)*x850);
evalcond[1]=((((-1.0)*x850*x852))+(((0.1)*x850)));
evalcond[2]=((0.721)+(((0.1)*x851))+(((-1.0)*x853)));
evalcond[3]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x851))+(((0.8)*x853))+(((0.2)*x852)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x854=(cj27*py);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((-1.0)*x854);
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27)));
evalcond[3]=x854;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x855=IKsin(j28);
IkReal x856=IKcos(j28);
IkReal x857=(py*sj27);
IkReal x858=(x856*x857);
evalcond[0]=((0.079)*x855);
evalcond[1]=((((0.1)*x855))+(((-1.0)*x855*x857)));
evalcond[2]=((0.079)+(((0.1)*x856))+(((-1.0)*x858)));
evalcond[3]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x856))+(((0.8)*x858))+(((0.2)*x857)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x859=(cj30*pz);
IkReal x860=(py*sj27);
CheckValue<IkReal> x861=IKPowWithIntegerCheck(((((400000.0)*pz))+(((-32100.0)*sj30))+(((321000.0)*x859))+(((321000.0)*sj30*x860))),-1);
if(!x861.valid){
continue;
}
CheckValue<IkReal> x862=IKPowWithIntegerCheck(((((321.0)*x859))+(((400.0)*pz))+(((321.0)*sj30*x860))+(((-32.1)*sj30))),-1);
if(!x862.valid){
continue;
}
if( IKabs(((x861.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x862.value)*(((((-100.0)*pz))+(((1000.0)*pz*x860))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x861.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x862.value)*(((((-100.0)*pz))+(((1000.0)*pz*x860))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x861.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x862.value)*(((((-100.0)*pz))+(((1000.0)*pz*x860))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x863=IKsin(j28);
IkReal x864=IKcos(j28);
IkReal x865=(py*sj27);
IkReal x866=((0.321)*cj30);
IkReal x867=((0.321)*sj30);
IkReal x868=((1.0)*x864);
IkReal x869=((0.321)*x863);
IkReal x870=(pz*x863);
evalcond[0]=(((x863*x866))+(((-1.0)*x864*x867))+pz+(((0.4)*x863)));
evalcond[1]=((0.4)+(((-1.0)*x865*x868))+(((0.1)*x864))+x866+x870);
evalcond[2]=((((0.1)*x863))+(((-1.0)*pz*x868))+x867+(((-1.0)*x863*x865)));
evalcond[3]=((0.1)+((x863*x867))+(((-1.0)*x865))+(((0.4)*x864))+((x864*x866)));
evalcond[4]=((-0.066959)+(((0.2)*x865))+(((-0.8)*x870))+(((0.8)*x864*x865))+(((-1.0)*pp))+(((-0.08)*x864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
CheckValue<IkReal> x871 = IKatan2WithCheck((gconst52*(((((100.0)*pz))+(((128.4)*sj30))+(((-1000.0)*py*pz*sj27))+(((103.041)*cj30*sj30))))),(gconst52*(((160.0)+(((-1000.0)*(pz*pz)))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x871.valid){
continue;
}
j28array[0]=x871.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x872=IKsin(j28);
IkReal x873=IKcos(j28);
IkReal x874=(py*sj27);
IkReal x875=((0.321)*cj30);
IkReal x876=((0.321)*sj30);
IkReal x877=((1.0)*x873);
IkReal x878=((0.321)*x872);
IkReal x879=(pz*x872);
evalcond[0]=(((x872*x875))+(((-1.0)*x873*x876))+pz+(((0.4)*x872)));
evalcond[1]=((0.4)+(((0.1)*x873))+(((-1.0)*x874*x877))+x879+x875);
evalcond[2]=((((0.1)*x872))+(((-1.0)*x872*x874))+(((-1.0)*pz*x877))+x876);
evalcond[3]=((0.1)+((x872*x876))+(((-1.0)*x874))+((x873*x875))+(((0.4)*x873)));
evalcond[4]=((-0.066959)+(((0.2)*x874))+(((-0.8)*x879))+(((0.8)*x873*x874))+(((-1.0)*pp))+(((-0.08)*x873)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x880=(px*sj27);
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x880;
evalcond[2]=x880;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst53;
IkReal x881=(cj27*px);
gconst53=IKsign(((40.0)+(((-400.0)*x881))+(((-321.0)*pz*sj30))+(((-321.0)*cj30*x881))+(((32.1)*cj30))));
IkReal x882=(cj27*px);
dummyeval[0]=((1.24610591900312)+(((-10.0)*pz*sj30))+cj30+(((-10.0)*cj30*x882))+(((-12.4610591900312)*x882)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((((-10.0)*cj27*px*sj30))+sj30+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x883=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=x883;
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*cj27*px)));
evalcond[3]=x883;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x884=IKsin(j28);
IkReal x885=IKcos(j28);
IkReal x886=(cj27*px);
evalcond[0]=((0.721)*x884);
evalcond[1]=((((-0.1)*x884))+((x884*x886)));
evalcond[2]=((0.721)+(((-1.0)*x885*x886))+(((0.1)*x885)));
evalcond[3]=((-0.066959)+(((0.8)*x885*x886))+(((-1.0)*pp))+(((0.2)*x886))+(((-0.08)*x885)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x887=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=x887;
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*cj27*px)));
evalcond[3]=x887;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x888=IKsin(j28);
IkReal x889=IKcos(j28);
IkReal x890=(cj27*px);
evalcond[0]=((0.079)*x888);
evalcond[1]=(((x888*x890))+(((-0.1)*x888)));
evalcond[2]=((0.079)+(((-1.0)*x889*x890))+(((0.1)*x889)));
evalcond[3]=((-0.066959)+(((-1.0)*pp))+(((0.2)*x890))+(((0.8)*x889*x890))+(((-0.08)*x889)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x891=(cj30*pz);
IkReal x892=(cj27*px*sj30);
CheckValue<IkReal> x893=IKPowWithIntegerCheck(((((32100.0)*sj30))+(((400000.0)*pz))+(((321000.0)*x891))+(((-321000.0)*x892))),-1);
if(!x893.valid){
continue;
}
CheckValue<IkReal> x894=IKPowWithIntegerCheck(((((400.0)*pz))+(((32.1)*sj30))+(((321.0)*x891))+(((-321.0)*x892))),-1);
if(!x894.valid){
continue;
}
if( IKabs(((x893.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x894.value)*(((((-100.0)*pz))+(((1000.0)*cj27*px*pz))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x893.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x894.value)*(((((-100.0)*pz))+(((1000.0)*cj27*px*pz))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x893.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x894.value)*(((((-100.0)*pz))+(((1000.0)*cj27*px*pz))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x895=IKsin(j28);
IkReal x896=IKcos(j28);
IkReal x897=((0.321)*cj30);
IkReal x898=((0.321)*sj30);
IkReal x899=(cj27*px);
IkReal x900=((1.0)*x899);
IkReal x901=(pz*x895);
evalcond[0]=(((x896*x898))+((x895*x897))+(((0.4)*x895))+pz);
evalcond[1]=((((-0.1)*x895))+((pz*x896))+((x895*x899))+x898);
evalcond[2]=((0.4)+(((-1.0)*x896*x900))+x897+x901+(((0.1)*x896)));
evalcond[3]=((0.1)+((x896*x897))+(((-1.0)*x895*x898))+(((-1.0)*x900))+(((0.4)*x896)));
evalcond[4]=((-0.066959)+(((0.8)*x896*x899))+(((-1.0)*pp))+(((-0.8)*x901))+(((0.2)*x899))+(((-0.08)*x896)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
CheckValue<IkReal> x902 = IKatan2WithCheck((gconst53*(((((-100.0)*pz))+(((1000.0)*cj27*px*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))),(gconst53*(((-160.0)+(((1000.0)*(pz*pz)))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x902.valid){
continue;
}
j28array[0]=x902.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x903=IKsin(j28);
IkReal x904=IKcos(j28);
IkReal x905=((0.321)*cj30);
IkReal x906=((0.321)*sj30);
IkReal x907=(cj27*px);
IkReal x908=((1.0)*x907);
IkReal x909=(pz*x903);
evalcond[0]=(((x903*x905))+(((0.4)*x903))+pz+((x904*x906)));
evalcond[1]=(((x903*x907))+(((-0.1)*x903))+((pz*x904))+x906);
evalcond[2]=((0.4)+(((-1.0)*x904*x908))+x905+x909+(((0.1)*x904)));
evalcond[3]=((0.1)+(((-1.0)*x903*x906))+(((-1.0)*x908))+(((0.4)*x904))+((x904*x905)));
evalcond[4]=((-0.066959)+(((0.2)*x907))+(((-0.08)*x904))+(((-1.0)*pp))+(((0.8)*x904*x907))+(((-0.8)*x909)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x910=(px*sj27);
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=x910;
evalcond[2]=((-1.0)*x910);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst54;
IkReal x911=(cj27*px);
gconst54=IKsign(((-40.0)+(((321.0)*cj30*x911))+(((-321.0)*pz*sj30))+(((400.0)*x911))+(((-32.1)*cj30))));
IkReal x912=(cj27*px);
dummyeval[0]=((-1.24610591900312)+(((12.4610591900312)*x912))+(((10.0)*cj30*x912))+(((-10.0)*pz*sj30))+(((-1.0)*cj30)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((((-1.0)*sj30))+(((10.0)*cj27*px*sj30))+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x913=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=x913;
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*cj27*px)));
evalcond[3]=((-1.0)*x913);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x914=IKsin(j28);
IkReal x915=IKcos(j28);
IkReal x916=(cj27*px);
evalcond[0]=((0.721)*x914);
evalcond[1]=((((0.1)*x914))+(((-1.0)*x914*x916)));
evalcond[2]=((0.721)+(((-1.0)*x915*x916))+(((0.1)*x915)));
evalcond[3]=((-0.066959)+(((0.2)*x916))+(((-0.08)*x915))+(((-1.0)*pp))+(((0.8)*x915*x916)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x917=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=x917;
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*cj27*px)));
evalcond[3]=((-1.0)*x917);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x918=IKsin(j28);
IkReal x919=IKcos(j28);
IkReal x920=(cj27*px);
evalcond[0]=((0.079)*x918);
evalcond[1]=((((-1.0)*x918*x920))+(((0.1)*x918)));
evalcond[2]=((0.079)+(((-1.0)*x919*x920))+(((0.1)*x919)));
evalcond[3]=((-0.066959)+(((-0.08)*x919))+(((0.2)*x920))+(((-1.0)*pp))+(((0.8)*x919*x920)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x921=(cj30*pz);
IkReal x922=(cj27*px*sj30);
CheckValue<IkReal> x923=IKPowWithIntegerCheck(((((400000.0)*pz))+(((-32100.0)*sj30))+(((321000.0)*x921))+(((321000.0)*x922))),-1);
if(!x923.valid){
continue;
}
CheckValue<IkReal> x924=IKPowWithIntegerCheck(((((321.0)*x922))+(((321.0)*x921))+(((400.0)*pz))+(((-32.1)*sj30))),-1);
if(!x924.valid){
continue;
}
if( IKabs(((x923.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x924.value)*(((((-100.0)*pz))+(((1000.0)*cj27*px*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x923.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x924.value)*(((((-100.0)*pz))+(((1000.0)*cj27*px*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x923.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x924.value)*(((((-100.0)*pz))+(((1000.0)*cj27*px*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x925=IKsin(j28);
IkReal x926=IKcos(j28);
IkReal x927=(cj27*px);
IkReal x928=((0.321)*cj30);
IkReal x929=((0.321)*sj30);
IkReal x930=(pz*x925);
IkReal x931=((0.321)*x925);
IkReal x932=((1.0)*x926);
evalcond[0]=((((-1.0)*x926*x929))+pz+(((0.4)*x925))+((x925*x928)));
evalcond[1]=((0.4)+(((0.1)*x926))+(((-1.0)*x927*x932))+x930+x928);
evalcond[2]=((((0.1)*x925))+(((-1.0)*x925*x927))+(((-1.0)*pz*x932))+x929);
evalcond[3]=((0.1)+(((-1.0)*x927))+(((0.4)*x926))+((x925*x929))+((x926*x928)));
evalcond[4]=((-0.066959)+(((-0.08)*x926))+(((0.2)*x927))+(((-0.8)*x930))+(((-1.0)*pp))+(((0.8)*x926*x927)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
CheckValue<IkReal> x933 = IKatan2WithCheck((gconst54*(((((100.0)*pz))+(((128.4)*sj30))+(((-1000.0)*cj27*px*pz))+(((103.041)*cj30*sj30))))),(gconst54*(((160.0)+(((-1000.0)*(pz*pz)))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x933.valid){
continue;
}
j28array[0]=x933.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x934=IKsin(j28);
IkReal x935=IKcos(j28);
IkReal x936=(cj27*px);
IkReal x937=((0.321)*cj30);
IkReal x938=((0.321)*sj30);
IkReal x939=(pz*x934);
IkReal x940=((0.321)*x934);
IkReal x941=((1.0)*x935);
evalcond[0]=((((-1.0)*x935*x938))+pz+(((0.4)*x934))+((x934*x937)));
evalcond[1]=((0.4)+(((0.1)*x935))+(((-1.0)*x936*x941))+x939+x937);
evalcond[2]=((((0.1)*x934))+(((-1.0)*pz*x941))+(((-1.0)*x934*x936))+x938);
evalcond[3]=((0.1)+((x935*x937))+(((-1.0)*x936))+(((0.4)*x935))+((x934*x938)));
evalcond[4]=((-0.066959)+(((-0.08)*x935))+(((0.2)*x936))+(((-0.8)*x939))+(((-1.0)*pp))+(((0.8)*x935*x936)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x942=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x942;
evalcond[2]=x942;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst55;
gconst55=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(sj30*sj30)))+(((103041.0)*(cj30*cj30)))));
dummyeval[0]=((1.5527799613746)+(sj30*sj30)+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*cj27*px))+(((10.0)*py*sj27)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*cj27*px))+(((10.0)*py*sj27)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal gconst56;
CheckValue<IkReal> x943 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x943.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x944=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x944.valid){
continue;
}
if( (x944.value) < -1-IKFAST_SINCOS_THRESH || (x944.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst56=((((-1.0)*(x943.value)))+(IKasin(x944.value)));
IkReal gconst57;
gconst57=IKsin(gconst56);
IkReal gconst58;
gconst58=IKcos(gconst56);
IkReal x945=(((gconst57*px))+(((-1.0)*gconst58*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst56))+j27)))), 6.28318530717959)));
evalcond[1]=x945;
evalcond[2]=((0.253041)+(((0.2)*gconst58*px))+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst57*py)));
evalcond[3]=x945;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst68;
gconst68=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(sj30*sj30)))+(((103041.0)*(cj30*cj30)))));
dummyeval[0]=((1.5527799613746)+(sj30*sj30)+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst58*px))+(((10.0)*gconst57*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst58*px))+(((10.0)*gconst57*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x946=(gconst58*px);
IkReal x947=(gconst57*py);
CheckValue<IkReal> x948=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x947))+(((1000.0)*x946))),-1);
if(!x948.valid){
continue;
}
CheckValue<IkReal> x949=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x946))+(((-1.0)*x947))),-1);
if(!x949.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x948.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x949.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x948.value)))+IKsqr(((x949.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x948.value)), ((x949.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x950=IKsin(j28);
IkReal x951=IKcos(j28);
IkReal x952=(gconst58*px);
IkReal x953=((0.321)*cj30);
IkReal x954=(gconst57*py);
IkReal x955=((0.321)*sj30);
IkReal x956=((1.0)*x951);
IkReal x957=((0.8)*x951);
evalcond[0]=(((x951*x955))+(((0.4)*x950))+((x950*x953)));
evalcond[1]=((((-0.1)*x950))+x955+((x950*x952))+((x950*x954)));
evalcond[2]=((0.4)+(((0.1)*x951))+(((-1.0)*x954*x956))+(((-1.0)*x952*x956))+x953);
evalcond[3]=((0.1)+((x951*x953))+(((-1.0)*x952))+(((-1.0)*x954))+(((-1.0)*x950*x955))+(((0.4)*x951)));
evalcond[4]=((-0.066959)+((x952*x957))+(((-1.0)*pp))+(((0.2)*x954))+(((0.2)*x952))+(((-0.08)*x951))+((x954*x957)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x958=(gconst57*py);
IkReal x959=(gconst58*px);
CheckValue<IkReal> x960=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x958))+(((1000.0)*x959))),-1);
if(!x960.valid){
continue;
}
CheckValue<IkReal> x961=IKPowWithIntegerCheck(((-0.1)+x959+x958),-1);
if(!x961.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x960.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x961.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x960.value)))+IKsqr(((x961.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x960.value)), ((x961.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x962=IKsin(j28);
IkReal x963=IKcos(j28);
IkReal x964=(gconst58*px);
IkReal x965=((0.321)*cj30);
IkReal x966=(gconst57*py);
IkReal x967=((0.321)*sj30);
IkReal x968=((1.0)*x963);
IkReal x969=((0.8)*x963);
evalcond[0]=(((x962*x965))+((x963*x967))+(((0.4)*x962)));
evalcond[1]=((((-0.1)*x962))+((x962*x966))+((x962*x964))+x967);
evalcond[2]=((0.4)+(((0.1)*x963))+(((-1.0)*x964*x968))+(((-1.0)*x966*x968))+x965);
evalcond[3]=((0.1)+(((-1.0)*x962*x967))+(((-1.0)*x966))+(((-1.0)*x964))+((x963*x965))+(((0.4)*x963)));
evalcond[4]=((-0.066959)+(((-1.0)*pp))+((x964*x969))+(((0.2)*x966))+(((0.2)*x964))+((x966*x969))+(((-0.08)*x963)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x970=(gconst57*py);
IkReal x971=((321000.0)*cj30);
IkReal x972=(gconst58*px);
IkReal x973=((321000.0)*sj30);
CheckValue<IkReal> x974 = IKatan2WithCheck((gconst68*(((((32100.0)*sj30))+(((-1.0)*x970*x973))+(((-1.0)*x972*x973))))),(gconst68*(((-40000.0)+(((-32100.0)*cj30))+(((400000.0)*x970))+(((400000.0)*x972))+((x971*x972))+((x970*x971))))),IKFAST_ATAN2_MAGTHRESH);
if(!x974.valid){
continue;
}
j28array[0]=x974.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x975=IKsin(j28);
IkReal x976=IKcos(j28);
IkReal x977=(gconst58*px);
IkReal x978=((0.321)*cj30);
IkReal x979=(gconst57*py);
IkReal x980=((0.321)*sj30);
IkReal x981=((1.0)*x976);
IkReal x982=((0.8)*x976);
evalcond[0]=(((x975*x978))+((x976*x980))+(((0.4)*x975)));
evalcond[1]=(((x975*x979))+((x975*x977))+(((-0.1)*x975))+x980);
evalcond[2]=((0.4)+(((0.1)*x976))+(((-1.0)*x977*x981))+(((-1.0)*x979*x981))+x978);
evalcond[3]=((0.1)+(((-1.0)*x977))+(((-1.0)*x979))+((x976*x978))+(((-1.0)*x975*x980))+(((0.4)*x976)));
evalcond[4]=((-0.066959)+((x977*x982))+((x979*x982))+(((-1.0)*pp))+(((0.2)*x977))+(((0.2)*x979))+(((-0.08)*x976)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst59;
CheckValue<IkReal> x983 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x983.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x984=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x984.valid){
continue;
}
if( (x984.value) < -1-IKFAST_SINCOS_THRESH || (x984.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst59=((3.14159265358979)+(((-1.0)*(x983.value)))+(((-1.0)*(IKasin(x984.value)))));
IkReal gconst60;
gconst60=IKsin(gconst59);
IkReal gconst61;
gconst61=IKcos(gconst59);
IkReal x985=(((gconst60*px))+(((-1.0)*gconst61*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst59))+j27)))), 6.28318530717959)));
evalcond[1]=x985;
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst61*px))+(((0.2)*gconst60*py)));
evalcond[3]=x985;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst69;
gconst69=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(sj30*sj30)))+(((103041.0)*(cj30*cj30)))));
dummyeval[0]=((1.5527799613746)+(sj30*sj30)+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst60*py))+(((10.0)*gconst61*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst60*py))+(((10.0)*gconst61*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x986=(gconst61*px);
IkReal x987=(gconst60*py);
CheckValue<IkReal> x988=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x986))+(((1000.0)*x987))),-1);
if(!x988.valid){
continue;
}
CheckValue<IkReal> x989=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x987))+(((-1.0)*x986))),-1);
if(!x989.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x988.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x989.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x988.value)))+IKsqr(((x989.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x988.value)), ((x989.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x990=IKsin(j28);
IkReal x991=IKcos(j28);
IkReal x992=((0.321)*cj30);
IkReal x993=(gconst60*py);
IkReal x994=(gconst61*px);
IkReal x995=((0.321)*sj30);
IkReal x996=((1.0)*x991);
IkReal x997=((0.8)*x991);
evalcond[0]=((((0.4)*x990))+((x991*x995))+((x990*x992)));
evalcond[1]=(((x990*x994))+((x990*x993))+(((-0.1)*x990))+x995);
evalcond[2]=((0.4)+(((-1.0)*x994*x996))+(((0.1)*x991))+(((-1.0)*x993*x996))+x992);
evalcond[3]=((0.1)+(((-1.0)*x993))+(((-1.0)*x994))+(((0.4)*x991))+((x991*x992))+(((-1.0)*x990*x995)));
evalcond[4]=((-0.066959)+((x993*x997))+((x994*x997))+(((-1.0)*pp))+(((-0.08)*x991))+(((0.2)*x993))+(((0.2)*x994)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x998=(gconst61*px);
IkReal x999=(gconst60*py);
CheckValue<IkReal> x1000=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x998))+(((1000.0)*x999))),-1);
if(!x1000.valid){
continue;
}
CheckValue<IkReal> x1001=IKPowWithIntegerCheck(((-0.1)+x999+x998),-1);
if(!x1001.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1000.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1001.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1000.value)))+IKsqr(((x1001.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1000.value)), ((x1001.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1002=IKsin(j28);
IkReal x1003=IKcos(j28);
IkReal x1004=((0.321)*cj30);
IkReal x1005=(gconst60*py);
IkReal x1006=(gconst61*px);
IkReal x1007=((0.321)*sj30);
IkReal x1008=((1.0)*x1003);
IkReal x1009=((0.8)*x1003);
evalcond[0]=((((0.4)*x1002))+((x1002*x1004))+((x1003*x1007)));
evalcond[1]=(x1007+((x1002*x1006))+((x1002*x1005))+(((-0.1)*x1002)));
evalcond[2]=((0.4)+(((0.1)*x1003))+x1004+(((-1.0)*x1006*x1008))+(((-1.0)*x1005*x1008)));
evalcond[3]=((0.1)+(((-1.0)*x1006))+(((-1.0)*x1005))+(((0.4)*x1003))+(((-1.0)*x1002*x1007))+((x1003*x1004)));
evalcond[4]=((-0.066959)+(((0.2)*x1006))+(((0.2)*x1005))+(((-0.08)*x1003))+(((-1.0)*pp))+((x1006*x1009))+((x1005*x1009)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1010=((321000.0)*gconst60*py);
IkReal x1011=((321000.0)*gconst61*px);
CheckValue<IkReal> x1012 = IKatan2WithCheck((gconst69*(((((32100.0)*sj30))+(((-1.0)*sj30*x1011))+(((-1.0)*sj30*x1010))))),(gconst69*(((-40000.0)+((cj30*x1011))+((cj30*x1010))+(((400000.0)*gconst61*px))+(((-32100.0)*cj30))+(((400000.0)*gconst60*py))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1012.valid){
continue;
}
j28array[0]=x1012.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1013=IKsin(j28);
IkReal x1014=IKcos(j28);
IkReal x1015=((0.321)*cj30);
IkReal x1016=(gconst60*py);
IkReal x1017=(gconst61*px);
IkReal x1018=((0.321)*sj30);
IkReal x1019=((1.0)*x1014);
IkReal x1020=((0.8)*x1014);
evalcond[0]=(((x1014*x1018))+(((0.4)*x1013))+((x1013*x1015)));
evalcond[1]=(x1018+((x1013*x1016))+((x1013*x1017))+(((-0.1)*x1013)));
evalcond[2]=((0.4)+x1015+(((-1.0)*x1017*x1019))+(((-1.0)*x1016*x1019))+(((0.1)*x1014)));
evalcond[3]=((0.1)+((x1014*x1015))+(((0.4)*x1014))+(((-1.0)*x1013*x1018))+(((-1.0)*x1016))+(((-1.0)*x1017)));
evalcond[4]=((-0.066959)+((x1017*x1020))+(((-0.08)*x1014))+(((-1.0)*pp))+(((0.2)*x1017))+(((0.2)*x1016))+((x1016*x1020)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst62;
CheckValue<IkReal> x1021 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1021.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1022=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1022.valid){
continue;
}
if( (x1022.value) < -1-IKFAST_SINCOS_THRESH || (x1022.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst62=((((-1.0)*(x1021.value)))+(IKasin(x1022.value)));
IkReal gconst63;
gconst63=IKsin(gconst62);
IkReal gconst64;
gconst64=IKcos(gconst62);
IkReal x1023=((((-1.0)*gconst64*py))+((gconst63*px)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst62))+j27)))), 6.28318530717959)));
evalcond[1]=x1023;
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst63*py))+(((0.2)*gconst64*px))+(((-1.0)*pp)));
evalcond[3]=x1023;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst70;
gconst70=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(sj30*sj30)))+(((103041.0)*(cj30*cj30)))));
dummyeval[0]=((1.5527799613746)+(sj30*sj30)+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst64*px))+(((10.0)*gconst63*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst64*px))+(((10.0)*gconst63*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1024=(gconst63*py);
IkReal x1025=(gconst64*px);
CheckValue<IkReal> x1026=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1024))+(((1000.0)*x1025))),-1);
if(!x1026.valid){
continue;
}
CheckValue<IkReal> x1027=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1025))+(((-1.0)*x1024))),-1);
if(!x1027.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1026.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1027.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1026.value)))+IKsqr(((x1027.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1026.value)), ((x1027.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1028=IKsin(j28);
IkReal x1029=IKcos(j28);
IkReal x1030=(gconst64*px);
IkReal x1031=((0.321)*cj30);
IkReal x1032=((0.321)*sj30);
IkReal x1033=(gconst63*py);
IkReal x1034=((0.8)*x1029);
IkReal x1035=((1.0)*x1033);
evalcond[0]=((((0.4)*x1028))+((x1028*x1031))+((x1029*x1032)));
evalcond[1]=(x1032+((x1028*x1033))+((x1028*x1030))+(((-0.1)*x1028)));
evalcond[2]=((0.4)+(((-1.0)*x1029*x1030))+x1031+(((-1.0)*x1029*x1035))+(((0.1)*x1029)));
evalcond[3]=((0.1)+(((0.4)*x1029))+(((-1.0)*x1035))+(((-1.0)*x1028*x1032))+(((-1.0)*x1030))+((x1029*x1031)));
evalcond[4]=((-0.066959)+((x1030*x1034))+(((-1.0)*pp))+(((-0.08)*x1029))+((x1033*x1034))+(((0.2)*x1030))+(((0.2)*x1033)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1036=(gconst64*px);
IkReal x1037=(gconst63*py);
CheckValue<IkReal> x1038=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1037))+(((1000.0)*x1036))),-1);
if(!x1038.valid){
continue;
}
CheckValue<IkReal> x1039=IKPowWithIntegerCheck(((-0.1)+x1036+x1037),-1);
if(!x1039.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1038.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1039.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1038.value)))+IKsqr(((x1039.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1038.value)), ((x1039.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1040=IKsin(j28);
IkReal x1041=IKcos(j28);
IkReal x1042=(gconst64*px);
IkReal x1043=((0.321)*cj30);
IkReal x1044=((0.321)*sj30);
IkReal x1045=(gconst63*py);
IkReal x1046=((0.8)*x1041);
IkReal x1047=((1.0)*x1045);
evalcond[0]=(((x1040*x1043))+((x1041*x1044))+(((0.4)*x1040)));
evalcond[1]=(x1044+(((-0.1)*x1040))+((x1040*x1045))+((x1040*x1042)));
evalcond[2]=((0.4)+x1043+(((0.1)*x1041))+(((-1.0)*x1041*x1042))+(((-1.0)*x1041*x1047)));
evalcond[3]=((0.1)+((x1041*x1043))+(((0.4)*x1041))+(((-1.0)*x1042))+(((-1.0)*x1040*x1044))+(((-1.0)*x1047)));
evalcond[4]=((-0.066959)+(((0.2)*x1045))+(((0.2)*x1042))+((x1042*x1046))+(((-1.0)*pp))+((x1045*x1046))+(((-0.08)*x1041)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1048=(gconst64*px);
IkReal x1049=((321000.0)*cj30);
IkReal x1050=((321000.0)*sj30);
IkReal x1051=(gconst63*py);
CheckValue<IkReal> x1052 = IKatan2WithCheck((gconst70*(((((32100.0)*sj30))+(((-1.0)*x1048*x1050))+(((-1.0)*x1050*x1051))))),(gconst70*(((-40000.0)+(((-32100.0)*cj30))+((x1048*x1049))+((x1049*x1051))+(((400000.0)*x1051))+(((400000.0)*x1048))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1052.valid){
continue;
}
j28array[0]=x1052.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1053=IKsin(j28);
IkReal x1054=IKcos(j28);
IkReal x1055=(gconst64*px);
IkReal x1056=((0.321)*cj30);
IkReal x1057=((0.321)*sj30);
IkReal x1058=(gconst63*py);
IkReal x1059=((0.8)*x1054);
IkReal x1060=((1.0)*x1058);
evalcond[0]=(((x1054*x1057))+((x1053*x1056))+(((0.4)*x1053)));
evalcond[1]=(x1057+(((-0.1)*x1053))+((x1053*x1058))+((x1053*x1055)));
evalcond[2]=((0.4)+(((-1.0)*x1054*x1055))+x1056+(((0.1)*x1054))+(((-1.0)*x1054*x1060)));
evalcond[3]=((0.1)+((x1054*x1056))+(((0.4)*x1054))+(((-1.0)*x1055))+(((-1.0)*x1053*x1057))+(((-1.0)*x1060)));
evalcond[4]=((-0.066959)+(((-0.08)*x1054))+((x1055*x1059))+(((0.2)*x1055))+(((0.2)*x1058))+(((-1.0)*pp))+((x1058*x1059)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst65;
CheckValue<IkReal> x1061 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1061.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1062=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1062.valid){
continue;
}
if( (x1062.value) < -1-IKFAST_SINCOS_THRESH || (x1062.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst65=((3.14159265358979)+(((-1.0)*(x1061.value)))+(((-1.0)*(IKasin(x1062.value)))));
IkReal gconst66;
gconst66=IKsin(gconst65);
IkReal gconst67;
gconst67=IKcos(gconst65);
IkReal x1063=((((-1.0)*gconst67*py))+((gconst66*px)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst65))+j27)))), 6.28318530717959)));
evalcond[1]=x1063;
evalcond[2]=((0.253041)+(((0.2)*gconst67*px))+(((0.2568)*cj30))+(((0.2)*gconst66*py))+(((-1.0)*pp)));
evalcond[3]=x1063;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst71;
gconst71=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(sj30*sj30)))+(((103041.0)*(cj30*cj30)))));
dummyeval[0]=((1.5527799613746)+(sj30*sj30)+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst66*py))+(((10.0)*gconst67*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst66*py))+(((10.0)*gconst67*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1064=(gconst67*px);
IkReal x1065=(gconst66*py);
CheckValue<IkReal> x1066=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1064))+(((1000.0)*x1065))),-1);
if(!x1066.valid){
continue;
}
CheckValue<IkReal> x1067=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1065))+(((-1.0)*x1064))),-1);
if(!x1067.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1066.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1067.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1066.value)))+IKsqr(((x1067.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1066.value)), ((x1067.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1068=IKsin(j28);
IkReal x1069=IKcos(j28);
IkReal x1070=((0.321)*cj30);
IkReal x1071=(gconst67*px);
IkReal x1072=(gconst66*py);
IkReal x1073=((0.321)*sj30);
IkReal x1074=((0.8)*x1069);
IkReal x1075=((1.0)*x1069);
evalcond[0]=(((x1068*x1070))+((x1069*x1073))+(((0.4)*x1068)));
evalcond[1]=(((x1068*x1071))+((x1068*x1072))+x1073+(((-0.1)*x1068)));
evalcond[2]=((0.4)+x1070+(((-1.0)*x1071*x1075))+(((0.1)*x1069))+(((-1.0)*x1072*x1075)));
evalcond[3]=((0.1)+((x1069*x1070))+(((0.4)*x1069))+(((-1.0)*x1068*x1073))+(((-1.0)*x1071))+(((-1.0)*x1072)));
evalcond[4]=((-0.066959)+(((-0.08)*x1069))+((x1071*x1074))+(((0.2)*x1072))+(((0.2)*x1071))+(((-1.0)*pp))+((x1072*x1074)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1076=(gconst66*py);
IkReal x1077=(gconst67*px);
CheckValue<IkReal> x1078=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1077))+(((1000.0)*x1076))),-1);
if(!x1078.valid){
continue;
}
CheckValue<IkReal> x1079=IKPowWithIntegerCheck(((-0.1)+x1076+x1077),-1);
if(!x1079.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1078.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1079.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1078.value)))+IKsqr(((x1079.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1078.value)), ((x1079.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1080=IKsin(j28);
IkReal x1081=IKcos(j28);
IkReal x1082=((0.321)*cj30);
IkReal x1083=(gconst67*px);
IkReal x1084=(gconst66*py);
IkReal x1085=((0.321)*sj30);
IkReal x1086=((0.8)*x1081);
IkReal x1087=((1.0)*x1081);
evalcond[0]=(((x1081*x1085))+((x1080*x1082))+(((0.4)*x1080)));
evalcond[1]=(x1085+(((-0.1)*x1080))+((x1080*x1083))+((x1080*x1084)));
evalcond[2]=((0.4)+x1082+(((0.1)*x1081))+(((-1.0)*x1084*x1087))+(((-1.0)*x1083*x1087)));
evalcond[3]=((0.1)+((x1081*x1082))+(((-1.0)*x1084))+(((-1.0)*x1083))+(((-1.0)*x1080*x1085))+(((0.4)*x1081)));
evalcond[4]=((-0.066959)+(((0.2)*x1083))+(((0.2)*x1084))+(((-1.0)*pp))+(((-0.08)*x1081))+((x1084*x1086))+((x1083*x1086)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1088=(gconst67*px);
IkReal x1089=((321000.0)*sj30);
IkReal x1090=(gconst66*py);
IkReal x1091=((321000.0)*cj30);
CheckValue<IkReal> x1092 = IKatan2WithCheck((gconst71*(((((32100.0)*sj30))+(((-1.0)*x1089*x1090))+(((-1.0)*x1088*x1089))))),(gconst71*(((-40000.0)+(((-32100.0)*cj30))+((x1088*x1091))+(((400000.0)*x1090))+(((400000.0)*x1088))+((x1090*x1091))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1092.valid){
continue;
}
j28array[0]=x1092.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1093=IKsin(j28);
IkReal x1094=IKcos(j28);
IkReal x1095=((0.321)*cj30);
IkReal x1096=(gconst67*px);
IkReal x1097=(gconst66*py);
IkReal x1098=((0.321)*sj30);
IkReal x1099=((0.8)*x1094);
IkReal x1100=((1.0)*x1094);
evalcond[0]=(((x1094*x1098))+((x1093*x1095))+(((0.4)*x1093)));
evalcond[1]=(x1098+((x1093*x1096))+((x1093*x1097))+(((-0.1)*x1093)));
evalcond[2]=((0.4)+x1095+(((0.1)*x1094))+(((-1.0)*x1097*x1100))+(((-1.0)*x1096*x1100)));
evalcond[3]=((0.1)+((x1094*x1095))+(((-1.0)*x1096))+(((-1.0)*x1097))+(((-1.0)*x1093*x1098))+(((0.4)*x1094)));
evalcond[4]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x1094))+(((0.2)*x1097))+(((0.2)*x1096))+((x1096*x1099))+((x1097*x1099)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1101=(py*sj27);
IkReal x1102=(cj27*px);
CheckValue<IkReal> x1103=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1102))+(((1000.0)*x1101))),-1);
if(!x1103.valid){
continue;
}
CheckValue<IkReal> x1104=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1101))+(((-1.0)*x1102))),-1);
if(!x1104.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1103.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1104.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1103.value)))+IKsqr(((x1104.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1103.value)), ((x1104.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1105=IKsin(j28);
IkReal x1106=IKcos(j28);
IkReal x1107=((0.321)*cj30);
IkReal x1108=((0.321)*sj30);
IkReal x1109=(cj27*px);
IkReal x1110=(py*sj27);
IkReal x1111=((1.0)*x1110);
IkReal x1112=((0.8)*x1106);
evalcond[0]=(((x1105*x1107))+(((0.4)*x1105))+((x1106*x1108)));
evalcond[1]=(x1108+((x1105*x1109))+((x1105*x1110))+(((-0.1)*x1105)));
evalcond[2]=((0.4)+x1107+(((-1.0)*x1106*x1111))+(((0.1)*x1106))+(((-1.0)*x1106*x1109)));
evalcond[3]=((0.1)+(((-1.0)*x1109))+(((0.4)*x1106))+(((-1.0)*x1111))+((x1106*x1107))+(((-1.0)*x1105*x1108)));
evalcond[4]=((-0.066959)+((x1109*x1112))+((x1110*x1112))+(((-0.08)*x1106))+(((-1.0)*pp))+(((0.2)*x1110))+(((0.2)*x1109)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1113=(py*sj27);
IkReal x1114=(cj27*px);
CheckValue<IkReal> x1115=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1114))+(((1000.0)*x1113))),-1);
if(!x1115.valid){
continue;
}
CheckValue<IkReal> x1116=IKPowWithIntegerCheck(((-0.1)+x1113+x1114),-1);
if(!x1116.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1115.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1116.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1115.value)))+IKsqr(((x1116.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1115.value)), ((x1116.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1117=IKsin(j28);
IkReal x1118=IKcos(j28);
IkReal x1119=((0.321)*cj30);
IkReal x1120=((0.321)*sj30);
IkReal x1121=(cj27*px);
IkReal x1122=(py*sj27);
IkReal x1123=((1.0)*x1122);
IkReal x1124=((0.8)*x1118);
evalcond[0]=(((x1117*x1119))+(((0.4)*x1117))+((x1118*x1120)));
evalcond[1]=(x1120+((x1117*x1122))+((x1117*x1121))+(((-0.1)*x1117)));
evalcond[2]=((0.4)+x1119+(((-1.0)*x1118*x1121))+(((0.1)*x1118))+(((-1.0)*x1118*x1123)));
evalcond[3]=((0.1)+(((-1.0)*x1117*x1120))+(((-1.0)*x1121))+(((-1.0)*x1123))+(((0.4)*x1118))+((x1118*x1119)));
evalcond[4]=((-0.066959)+((x1121*x1124))+(((-1.0)*pp))+(((-0.08)*x1118))+(((0.2)*x1121))+(((0.2)*x1122))+((x1122*x1124)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1125=(cj27*px);
IkReal x1126=((321000.0)*py*sj27);
CheckValue<IkReal> x1127 = IKatan2WithCheck((gconst55*(((((-321000.0)*sj30*x1125))+(((32100.0)*sj30))+(((-1.0)*sj30*x1126))))),(gconst55*(((-40000.0)+(((400000.0)*x1125))+(((-32100.0)*cj30))+(((321000.0)*cj30*x1125))+((cj30*x1126))+(((400000.0)*py*sj27))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1127.valid){
continue;
}
j28array[0]=x1127.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1128=IKsin(j28);
IkReal x1129=IKcos(j28);
IkReal x1130=((0.321)*cj30);
IkReal x1131=((0.321)*sj30);
IkReal x1132=(cj27*px);
IkReal x1133=(py*sj27);
IkReal x1134=((1.0)*x1133);
IkReal x1135=((0.8)*x1129);
evalcond[0]=(((x1129*x1131))+(((0.4)*x1128))+((x1128*x1130)));
evalcond[1]=(x1131+(((-0.1)*x1128))+((x1128*x1133))+((x1128*x1132)));
evalcond[2]=((0.4)+(((-1.0)*x1129*x1132))+x1130+(((0.1)*x1129))+(((-1.0)*x1129*x1134)));
evalcond[3]=((0.1)+((x1129*x1130))+(((-1.0)*x1134))+(((0.4)*x1129))+(((-1.0)*x1132))+(((-1.0)*x1128*x1131)));
evalcond[4]=((-0.066959)+(((-1.0)*pp))+(((0.2)*x1133))+(((0.2)*x1132))+(((-0.08)*x1129))+((x1133*x1135))+((x1132*x1135)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1136=(px*sj27);
IkReal x1137=(cj27*py);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=(x1136+(((-1.0)*x1137)));
evalcond[2]=(x1137+(((-1.0)*x1136)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst72;
gconst72=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1138=(cj27*px);
IkReal x1139=(py*sj27);
IkReal x1140=((10.0)*cj30);
dummyeval[0]=((1.24610591900312)+cj30+(((-12.4610591900312)*x1138))+(((-12.4610591900312)*x1139))+(((-1.0)*x1139*x1140))+(((-1.0)*x1138*x1140)));
dummyeval[1]=((1.0)+(((-10.0)*x1139))+(((-10.0)*x1138)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal gconst73;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1141=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1141.valid){
continue;
}
if( (x1141.value) < -1-IKFAST_SINCOS_THRESH || (x1141.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1142 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1142.valid){
continue;
}
gconst73=((((-1.0)*(IKasin(x1141.value))))+(((-1.0)*(x1142.value))));
IkReal gconst74;
gconst74=IKsin(gconst73);
IkReal gconst75;
gconst75=IKcos(gconst73);
IkReal x1143=(gconst74*px);
IkReal x1144=(gconst75*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst73))+j27)))), 6.28318530717959)));
evalcond[1]=(x1143+(((-1.0)*x1144)));
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst75*px))+(((0.2)*gconst74*py)));
evalcond[3]=(x1144+(((-1.0)*x1143)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst85;
gconst85=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst74*py))+(((-10.0)*gconst75*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1145=(gconst75*px);
IkReal x1146=((10.0)*cj30);
IkReal x1147=(gconst74*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1145*x1146))+(((-12.4610591900312)*x1145))+(((-12.4610591900312)*x1147))+(((-1.0)*x1146*x1147))+cj30);
dummyeval[1]=((1.0)+(((-10.0)*x1147))+(((-10.0)*x1145)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1148=(gconst75*px);
IkReal x1149=(gconst74*py);
IkReal x1150=((321.0)*cj30);
CheckValue<IkReal> x1151=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1149*x1150))+(((-400.0)*x1149))+(((-400.0)*x1148))+(((-1.0)*x1148*x1150))+(((32.1)*cj30))),-1);
if(!x1151.valid){
continue;
}
CheckValue<IkReal> x1152=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1148))+(((-1.0)*x1149))),-1);
if(!x1152.valid){
continue;
}
if( IKabs(((x1151.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1152.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1151.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1152.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1151.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1152.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1153=IKsin(j28);
IkReal x1154=IKcos(j28);
IkReal x1155=((0.321)*cj30);
IkReal x1156=(gconst74*py);
IkReal x1157=((0.321)*sj30);
IkReal x1158=(gconst75*px);
IkReal x1159=((0.8)*x1154);
IkReal x1160=((1.0)*x1153);
IkReal x1161=((1.0)*x1154);
evalcond[0]=((((-1.0)*x1154*x1157))+((x1153*x1155))+(((0.4)*x1153)));
evalcond[1]=((((-1.0)*x1156*x1160))+(((0.1)*x1153))+x1157+(((-1.0)*x1158*x1160)));
evalcond[2]=((0.4)+(((-1.0)*x1156*x1161))+(((0.1)*x1154))+x1155+(((-1.0)*x1158*x1161)));
evalcond[3]=((0.1)+((x1153*x1157))+(((-1.0)*x1156))+(((-1.0)*x1158))+(((0.4)*x1154))+((x1154*x1155)));
evalcond[4]=((-0.066959)+(((0.2)*x1156))+(((0.2)*x1158))+((x1158*x1159))+(((-1.0)*pp))+(((-0.08)*x1154))+((x1156*x1159)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1162=(gconst75*px);
IkReal x1163=(gconst74*py);
CheckValue<IkReal> x1164=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1163))+(((-1000.0)*x1162))),-1);
if(!x1164.valid){
continue;
}
CheckValue<IkReal> x1165=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1162))+(((-1.0)*x1163))),-1);
if(!x1165.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1164.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1165.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1164.value)))+IKsqr(((x1165.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1164.value)), ((x1165.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1166=IKsin(j28);
IkReal x1167=IKcos(j28);
IkReal x1168=((0.321)*cj30);
IkReal x1169=(gconst74*py);
IkReal x1170=((0.321)*sj30);
IkReal x1171=(gconst75*px);
IkReal x1172=((0.8)*x1167);
IkReal x1173=((1.0)*x1166);
IkReal x1174=((1.0)*x1167);
evalcond[0]=(((x1166*x1168))+(((0.4)*x1166))+(((-1.0)*x1167*x1170)));
evalcond[1]=(x1170+(((0.1)*x1166))+(((-1.0)*x1171*x1173))+(((-1.0)*x1169*x1173)));
evalcond[2]=((0.4)+x1168+(((0.1)*x1167))+(((-1.0)*x1171*x1174))+(((-1.0)*x1169*x1174)));
evalcond[3]=((0.1)+((x1166*x1170))+(((0.4)*x1167))+((x1167*x1168))+(((-1.0)*x1169))+(((-1.0)*x1171)));
evalcond[4]=((-0.066959)+(((-0.08)*x1167))+(((0.2)*x1171))+(((-1.0)*pp))+(((0.2)*x1169))+((x1169*x1172))+((x1171*x1172)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1175=(gconst74*py);
IkReal x1176=((321000.0)*cj30);
IkReal x1177=((321000.0)*sj30);
IkReal x1178=(gconst75*px);
CheckValue<IkReal> x1179 = IKatan2WithCheck((gconst85*(((((32100.0)*sj30))+(((-1.0)*x1175*x1177))+(((-1.0)*x1177*x1178))))),(gconst85*(((40000.0)+(((-400000.0)*x1178))+(((-400000.0)*x1175))+(((32100.0)*cj30))+(((-1.0)*x1176*x1178))+(((-1.0)*x1175*x1176))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1179.valid){
continue;
}
j28array[0]=x1179.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1180=IKsin(j28);
IkReal x1181=IKcos(j28);
IkReal x1182=((0.321)*cj30);
IkReal x1183=(gconst74*py);
IkReal x1184=((0.321)*sj30);
IkReal x1185=(gconst75*px);
IkReal x1186=((0.8)*x1181);
IkReal x1187=((1.0)*x1180);
IkReal x1188=((1.0)*x1181);
evalcond[0]=((((-1.0)*x1181*x1184))+((x1180*x1182))+(((0.4)*x1180)));
evalcond[1]=(x1184+(((-1.0)*x1185*x1187))+(((-1.0)*x1183*x1187))+(((0.1)*x1180)));
evalcond[2]=((0.4)+x1182+(((-1.0)*x1185*x1188))+(((-1.0)*x1183*x1188))+(((0.1)*x1181)));
evalcond[3]=((0.1)+((x1180*x1184))+(((0.4)*x1181))+((x1181*x1182))+(((-1.0)*x1185))+(((-1.0)*x1183)));
evalcond[4]=((-0.066959)+((x1183*x1186))+((x1185*x1186))+(((-1.0)*pp))+(((0.2)*x1185))+(((0.2)*x1183))+(((-0.08)*x1181)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst76;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1189=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1189.valid){
continue;
}
if( (x1189.value) < -1-IKFAST_SINCOS_THRESH || (x1189.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1190 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1190.valid){
continue;
}
gconst76=((3.14159265358979)+(IKasin(x1189.value))+(((-1.0)*(x1190.value))));
IkReal gconst77;
gconst77=IKsin(gconst76);
IkReal gconst78;
gconst78=IKcos(gconst76);
IkReal x1191=(gconst78*py);
IkReal x1192=(gconst77*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst76))+j27)))), 6.28318530717959)));
evalcond[1]=(x1192+(((-1.0)*x1191)));
evalcond[2]=((0.253041)+(((0.2)*gconst77*py))+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst78*px)));
evalcond[3]=(x1191+(((-1.0)*x1192)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst86;
gconst86=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst77*py))+(((-10.0)*gconst78*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1193=(gconst77*py);
IkReal x1194=((10.0)*cj30);
IkReal x1195=(gconst78*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1193*x1194))+(((-1.0)*x1194*x1195))+cj30+(((-12.4610591900312)*x1195))+(((-12.4610591900312)*x1193)));
dummyeval[1]=((1.0)+(((-10.0)*x1193))+(((-10.0)*x1195)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1196=(gconst77*py);
IkReal x1197=((321.0)*cj30);
IkReal x1198=(gconst78*px);
CheckValue<IkReal> x1199=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1197*x1198))+(((-1.0)*x1196*x1197))+(((-400.0)*x1198))+(((-400.0)*x1196))+(((32.1)*cj30))),-1);
if(!x1199.valid){
continue;
}
CheckValue<IkReal> x1200=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1198))+(((-1.0)*x1196))),-1);
if(!x1200.valid){
continue;
}
if( IKabs(((x1199.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1200.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1199.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1200.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1199.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1200.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1201=IKsin(j28);
IkReal x1202=IKcos(j28);
IkReal x1203=((0.321)*cj30);
IkReal x1204=((0.321)*sj30);
IkReal x1205=(gconst77*py);
IkReal x1206=(gconst78*px);
IkReal x1207=((1.0)*x1206);
IkReal x1208=((0.8)*x1202);
evalcond[0]=((((0.4)*x1201))+(((-1.0)*x1202*x1204))+((x1201*x1203)));
evalcond[1]=(x1204+(((0.1)*x1201))+(((-1.0)*x1201*x1205))+(((-1.0)*x1201*x1207)));
evalcond[2]=((0.4)+x1203+(((-1.0)*x1202*x1207))+(((-1.0)*x1202*x1205))+(((0.1)*x1202)));
evalcond[3]=((0.1)+(((0.4)*x1202))+((x1202*x1203))+(((-1.0)*x1205))+((x1201*x1204))+(((-1.0)*x1207)));
evalcond[4]=((-0.066959)+(((-0.08)*x1202))+(((-1.0)*pp))+((x1205*x1208))+((x1206*x1208))+(((0.2)*x1206))+(((0.2)*x1205)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1209=(gconst78*px);
IkReal x1210=(gconst77*py);
CheckValue<IkReal> x1211=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1210))+(((-1000.0)*x1209))),-1);
if(!x1211.valid){
continue;
}
CheckValue<IkReal> x1212=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1209))+(((-1.0)*x1210))),-1);
if(!x1212.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1211.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1212.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1211.value)))+IKsqr(((x1212.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1211.value)), ((x1212.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1213=IKsin(j28);
IkReal x1214=IKcos(j28);
IkReal x1215=((0.321)*cj30);
IkReal x1216=((0.321)*sj30);
IkReal x1217=(gconst77*py);
IkReal x1218=(gconst78*px);
IkReal x1219=((1.0)*x1218);
IkReal x1220=((0.8)*x1214);
evalcond[0]=(((x1213*x1215))+(((-1.0)*x1214*x1216))+(((0.4)*x1213)));
evalcond[1]=(x1216+(((0.1)*x1213))+(((-1.0)*x1213*x1217))+(((-1.0)*x1213*x1219)));
evalcond[2]=((0.4)+x1215+(((0.1)*x1214))+(((-1.0)*x1214*x1219))+(((-1.0)*x1214*x1217)));
evalcond[3]=((0.1)+((x1214*x1215))+((x1213*x1216))+(((-1.0)*x1219))+(((0.4)*x1214))+(((-1.0)*x1217)));
evalcond[4]=((-0.066959)+((x1217*x1220))+(((0.2)*x1218))+(((0.2)*x1217))+(((-1.0)*pp))+(((-0.08)*x1214))+((x1218*x1220)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1221=((321000.0)*cj30);
IkReal x1222=(gconst77*py);
IkReal x1223=(gconst78*px);
IkReal x1224=((321000.0)*sj30);
CheckValue<IkReal> x1225 = IKatan2WithCheck((gconst86*(((((32100.0)*sj30))+(((-1.0)*x1222*x1224))+(((-1.0)*x1223*x1224))))),(gconst86*(((40000.0)+(((-1.0)*x1221*x1222))+(((-1.0)*x1221*x1223))+(((-400000.0)*x1223))+(((-400000.0)*x1222))+(((32100.0)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1225.valid){
continue;
}
j28array[0]=x1225.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1226=IKsin(j28);
IkReal x1227=IKcos(j28);
IkReal x1228=((0.321)*cj30);
IkReal x1229=((0.321)*sj30);
IkReal x1230=(gconst77*py);
IkReal x1231=(gconst78*px);
IkReal x1232=((1.0)*x1231);
IkReal x1233=((0.8)*x1227);
evalcond[0]=((((-1.0)*x1227*x1229))+(((0.4)*x1226))+((x1226*x1228)));
evalcond[1]=((((0.1)*x1226))+x1229+(((-1.0)*x1226*x1230))+(((-1.0)*x1226*x1232)));
evalcond[2]=((0.4)+(((0.1)*x1227))+x1228+(((-1.0)*x1227*x1230))+(((-1.0)*x1227*x1232)));
evalcond[3]=((0.1)+(((-1.0)*x1230))+(((-1.0)*x1232))+(((0.4)*x1227))+((x1226*x1229))+((x1227*x1228)));
evalcond[4]=((-0.066959)+(((-1.0)*pp))+(((0.2)*x1231))+(((0.2)*x1230))+((x1231*x1233))+(((-0.08)*x1227))+((x1230*x1233)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst79;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1234=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1234.valid){
continue;
}
if( (x1234.value) < -1-IKFAST_SINCOS_THRESH || (x1234.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1235 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1235.valid){
continue;
}
gconst79=((((-1.0)*(IKasin(x1234.value))))+(((-1.0)*(x1235.value))));
IkReal gconst80;
gconst80=IKsin(gconst79);
IkReal gconst81;
gconst81=IKcos(gconst79);
IkReal x1236=(gconst80*px);
IkReal x1237=(gconst81*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst79))+j27)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x1237))+x1236);
evalcond[2]=((0.253041)+(((0.2)*gconst81*px))+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst80*py)));
evalcond[3]=((((-1.0)*x1236))+x1237);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst87;
gconst87=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst81*px))+(((-10.0)*gconst80*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1238=(gconst81*px);
IkReal x1239=((10.0)*gconst80*py);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*gconst80*py))+(((-12.4610591900312)*x1238))+(((-10.0)*cj30*x1238))+(((-1.0)*cj30*x1239))+cj30);
dummyeval[1]=((1.0)+(((-1.0)*x1239))+(((-10.0)*x1238)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1240=(gconst81*px);
IkReal x1241=(gconst80*py);
IkReal x1242=((321.0)*cj30);
CheckValue<IkReal> x1243=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1241))+(((-400.0)*x1240))+(((-1.0)*x1240*x1242))+(((-1.0)*x1241*x1242))+(((32.1)*cj30))),-1);
if(!x1243.valid){
continue;
}
CheckValue<IkReal> x1244=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1240))+(((-1.0)*x1241))),-1);
if(!x1244.valid){
continue;
}
if( IKabs(((x1243.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1244.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1243.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1244.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1243.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1244.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1245=IKsin(j28);
IkReal x1246=IKcos(j28);
IkReal x1247=(gconst80*py);
IkReal x1248=((0.321)*cj30);
IkReal x1249=(gconst81*px);
IkReal x1250=((0.321)*sj30);
IkReal x1251=((1.0)*x1246);
IkReal x1252=((0.8)*x1246);
IkReal x1253=((1.0)*x1245);
evalcond[0]=((((0.4)*x1245))+(((-1.0)*x1246*x1250))+((x1245*x1248)));
evalcond[1]=((((-1.0)*x1249*x1253))+x1250+(((-1.0)*x1247*x1253))+(((0.1)*x1245)));
evalcond[2]=((0.4)+(((-1.0)*x1249*x1251))+x1248+(((-1.0)*x1247*x1251))+(((0.1)*x1246)));
evalcond[3]=((0.1)+((x1245*x1250))+(((-1.0)*x1249))+(((-1.0)*x1247))+(((0.4)*x1246))+((x1246*x1248)));
evalcond[4]=((-0.066959)+((x1247*x1252))+(((0.2)*x1249))+(((0.2)*x1247))+(((-1.0)*pp))+((x1249*x1252))+(((-0.08)*x1246)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1254=(gconst81*px);
IkReal x1255=(gconst80*py);
CheckValue<IkReal> x1256=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1254))+(((-1000.0)*x1255))),-1);
if(!x1256.valid){
continue;
}
CheckValue<IkReal> x1257=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1255))+(((-1.0)*x1254))),-1);
if(!x1257.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1256.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1257.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1256.value)))+IKsqr(((x1257.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1256.value)), ((x1257.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1258=IKsin(j28);
IkReal x1259=IKcos(j28);
IkReal x1260=(gconst80*py);
IkReal x1261=((0.321)*cj30);
IkReal x1262=(gconst81*px);
IkReal x1263=((0.321)*sj30);
IkReal x1264=((1.0)*x1259);
IkReal x1265=((0.8)*x1259);
IkReal x1266=((1.0)*x1258);
evalcond[0]=(((x1258*x1261))+(((-1.0)*x1259*x1263))+(((0.4)*x1258)));
evalcond[1]=(x1263+(((-1.0)*x1260*x1266))+(((0.1)*x1258))+(((-1.0)*x1262*x1266)));
evalcond[2]=((0.4)+x1261+(((-1.0)*x1260*x1264))+(((0.1)*x1259))+(((-1.0)*x1262*x1264)));
evalcond[3]=((0.1)+((x1258*x1263))+((x1259*x1261))+(((-1.0)*x1260))+(((-1.0)*x1262))+(((0.4)*x1259)));
evalcond[4]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x1259))+((x1260*x1265))+((x1262*x1265))+(((0.2)*x1260))+(((0.2)*x1262)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1267=((321000.0)*cj30);
IkReal x1268=(gconst80*py);
IkReal x1269=(gconst81*px);
IkReal x1270=((321000.0)*sj30);
CheckValue<IkReal> x1271 = IKatan2WithCheck((gconst87*(((((-1.0)*x1268*x1270))+(((32100.0)*sj30))+(((-1.0)*x1269*x1270))))),(gconst87*(((40000.0)+(((-1.0)*x1267*x1268))+(((-1.0)*x1267*x1269))+(((32100.0)*cj30))+(((-400000.0)*x1269))+(((-400000.0)*x1268))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1271.valid){
continue;
}
j28array[0]=x1271.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1272=IKsin(j28);
IkReal x1273=IKcos(j28);
IkReal x1274=(gconst80*py);
IkReal x1275=((0.321)*cj30);
IkReal x1276=(gconst81*px);
IkReal x1277=((0.321)*sj30);
IkReal x1278=((1.0)*x1273);
IkReal x1279=((0.8)*x1273);
IkReal x1280=((1.0)*x1272);
evalcond[0]=((((0.4)*x1272))+((x1272*x1275))+(((-1.0)*x1273*x1277)));
evalcond[1]=(x1277+(((-1.0)*x1276*x1280))+(((0.1)*x1272))+(((-1.0)*x1274*x1280)));
evalcond[2]=((0.4)+x1275+(((0.1)*x1273))+(((-1.0)*x1276*x1278))+(((-1.0)*x1274*x1278)));
evalcond[3]=((0.1)+(((0.4)*x1273))+((x1272*x1277))+((x1273*x1275))+(((-1.0)*x1276))+(((-1.0)*x1274)));
evalcond[4]=((-0.066959)+((x1276*x1279))+((x1274*x1279))+(((-0.08)*x1273))+(((-1.0)*pp))+(((0.2)*x1276))+(((0.2)*x1274)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst82;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1281=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1281.valid){
continue;
}
if( (x1281.value) < -1-IKFAST_SINCOS_THRESH || (x1281.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1282 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1282.valid){
continue;
}
gconst82=((3.14159265358979)+(IKasin(x1281.value))+(((-1.0)*(x1282.value))));
IkReal gconst83;
gconst83=IKsin(gconst82);
IkReal gconst84;
gconst84=IKcos(gconst82);
IkReal x1283=(gconst83*px);
IkReal x1284=(gconst84*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst82))+j27)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x1284))+x1283);
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst83*py))+(((0.2)*gconst84*px))+(((-1.0)*pp)));
evalcond[3]=((((-1.0)*x1283))+x1284);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst88;
gconst88=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst83*py))+(((-10.0)*gconst84*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1285=(gconst84*px);
IkReal x1286=((10.0)*gconst83*py);
dummyeval[0]=((1.24610591900312)+(((-10.0)*cj30*x1285))+cj30+(((-1.0)*cj30*x1286))+(((-12.4610591900312)*x1285))+(((-12.4610591900312)*gconst83*py)));
dummyeval[1]=((1.0)+(((-1.0)*x1286))+(((-10.0)*x1285)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1287=(gconst84*px);
IkReal x1288=((321.0)*cj30);
IkReal x1289=(gconst83*py);
CheckValue<IkReal> x1290=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1287))+(((-400.0)*x1289))+(((-1.0)*x1288*x1289))+(((-1.0)*x1287*x1288))+(((32.1)*cj30))),-1);
if(!x1290.valid){
continue;
}
CheckValue<IkReal> x1291=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1289))+(((-1.0)*x1287))),-1);
if(!x1291.valid){
continue;
}
if( IKabs(((x1290.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1291.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1290.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1291.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1290.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1291.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1292=IKsin(j28);
IkReal x1293=IKcos(j28);
IkReal x1294=((0.321)*cj30);
IkReal x1295=(gconst84*px);
IkReal x1296=((0.321)*sj30);
IkReal x1297=(gconst83*py);
IkReal x1298=((1.0)*x1292);
IkReal x1299=(x1293*x1295);
evalcond[0]=((((0.4)*x1292))+(((-1.0)*x1293*x1296))+((x1292*x1294)));
evalcond[1]=(x1296+(((-1.0)*x1295*x1298))+(((0.1)*x1292))+(((-1.0)*x1297*x1298)));
evalcond[2]=((0.4)+x1294+(((0.1)*x1293))+(((-1.0)*x1293*x1297))+(((-1.0)*x1299)));
evalcond[3]=((0.1)+(((0.4)*x1293))+((x1293*x1294))+(((-1.0)*x1297))+(((-1.0)*x1295))+((x1292*x1296)));
evalcond[4]=((-0.066959)+(((-0.08)*x1293))+(((0.8)*x1299))+(((0.8)*x1293*x1297))+(((-1.0)*pp))+(((0.2)*x1297))+(((0.2)*x1295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1300=(gconst84*px);
IkReal x1301=(gconst83*py);
CheckValue<IkReal> x1302=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1300))+(((-1000.0)*x1301))),-1);
if(!x1302.valid){
continue;
}
CheckValue<IkReal> x1303=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1301))+(((-1.0)*x1300))),-1);
if(!x1303.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1302.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1303.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1302.value)))+IKsqr(((x1303.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1302.value)), ((x1303.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1304=IKsin(j28);
IkReal x1305=IKcos(j28);
IkReal x1306=((0.321)*cj30);
IkReal x1307=(gconst84*px);
IkReal x1308=((0.321)*sj30);
IkReal x1309=(gconst83*py);
IkReal x1310=((1.0)*x1304);
IkReal x1311=(x1305*x1307);
evalcond[0]=((((0.4)*x1304))+((x1304*x1306))+(((-1.0)*x1305*x1308)));
evalcond[1]=(x1308+(((-1.0)*x1307*x1310))+(((0.1)*x1304))+(((-1.0)*x1309*x1310)));
evalcond[2]=((0.4)+x1306+(((-1.0)*x1305*x1309))+(((-1.0)*x1311))+(((0.1)*x1305)));
evalcond[3]=((0.1)+(((0.4)*x1305))+((x1305*x1306))+(((-1.0)*x1309))+(((-1.0)*x1307))+((x1304*x1308)));
evalcond[4]=((-0.066959)+(((0.2)*x1307))+(((0.2)*x1309))+(((0.8)*x1305*x1309))+(((0.8)*x1311))+(((-0.08)*x1305))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1312=(gconst84*px);
IkReal x1313=((321000.0)*gconst83*py);
CheckValue<IkReal> x1314 = IKatan2WithCheck((gconst88*(((((32100.0)*sj30))+(((-1.0)*sj30*x1313))+(((-321000.0)*sj30*x1312))))),(gconst88*(((40000.0)+(((-400000.0)*x1312))+(((32100.0)*cj30))+(((-321000.0)*cj30*x1312))+(((-1.0)*cj30*x1313))+(((-400000.0)*gconst83*py))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1314.valid){
continue;
}
j28array[0]=x1314.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1315=IKsin(j28);
IkReal x1316=IKcos(j28);
IkReal x1317=((0.321)*cj30);
IkReal x1318=(gconst84*px);
IkReal x1319=((0.321)*sj30);
IkReal x1320=(gconst83*py);
IkReal x1321=((1.0)*x1315);
IkReal x1322=(x1316*x1318);
evalcond[0]=((((0.4)*x1315))+(((-1.0)*x1316*x1319))+((x1315*x1317)));
evalcond[1]=(x1319+(((0.1)*x1315))+(((-1.0)*x1320*x1321))+(((-1.0)*x1318*x1321)));
evalcond[2]=((0.4)+x1317+(((-1.0)*x1322))+(((0.1)*x1316))+(((-1.0)*x1316*x1320)));
evalcond[3]=((0.1)+((x1316*x1317))+(((0.4)*x1316))+(((-1.0)*x1318))+(((-1.0)*x1320))+((x1315*x1319)));
evalcond[4]=((-0.066959)+(((0.2)*x1320))+(((0.8)*x1322))+(((0.2)*x1318))+(((-0.08)*x1316))+(((-1.0)*pp))+(((0.8)*x1316*x1320)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1323=(py*sj27);
IkReal x1324=((321.0)*cj30);
IkReal x1325=(cj27*px);
CheckValue<IkReal> x1326=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1323*x1324))+(((-1.0)*x1324*x1325))+(((-400.0)*x1325))+(((-400.0)*x1323))+(((32.1)*cj30))),-1);
if(!x1326.valid){
continue;
}
CheckValue<IkReal> x1327=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1325))+(((-1.0)*x1323))),-1);
if(!x1327.valid){
continue;
}
if( IKabs(((x1326.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1327.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1326.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1327.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1326.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1327.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1328=IKsin(j28);
IkReal x1329=IKcos(j28);
IkReal x1330=((0.321)*cj30);
IkReal x1331=((0.321)*sj30);
IkReal x1332=(py*sj27);
IkReal x1333=(cj27*px);
IkReal x1334=((1.0)*x1332);
IkReal x1335=((0.8)*x1329);
evalcond[0]=((((0.4)*x1328))+((x1328*x1330))+(((-1.0)*x1329*x1331)));
evalcond[1]=(x1331+(((-1.0)*x1328*x1333))+(((-1.0)*x1328*x1334))+(((0.1)*x1328)));
evalcond[2]=((0.4)+x1330+(((-1.0)*x1329*x1333))+(((-1.0)*x1329*x1334))+(((0.1)*x1329)));
evalcond[3]=((0.1)+((x1329*x1330))+(((0.4)*x1329))+(((-1.0)*x1333))+((x1328*x1331))+(((-1.0)*x1334)));
evalcond[4]=((-0.066959)+(((-0.08)*x1329))+(((-1.0)*pp))+((x1333*x1335))+(((0.2)*x1332))+(((0.2)*x1333))+((x1332*x1335)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1336=(py*sj27);
IkReal x1337=(cj27*px);
CheckValue<IkReal> x1338=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1337))+(((-1000.0)*x1336))),-1);
if(!x1338.valid){
continue;
}
CheckValue<IkReal> x1339=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1337))+(((-1.0)*x1336))),-1);
if(!x1339.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1338.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1339.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1338.value)))+IKsqr(((x1339.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1338.value)), ((x1339.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1340=IKsin(j28);
IkReal x1341=IKcos(j28);
IkReal x1342=((0.321)*cj30);
IkReal x1343=((0.321)*sj30);
IkReal x1344=(py*sj27);
IkReal x1345=(cj27*px);
IkReal x1346=((1.0)*x1344);
IkReal x1347=((0.8)*x1341);
evalcond[0]=((((-1.0)*x1341*x1343))+((x1340*x1342))+(((0.4)*x1340)));
evalcond[1]=(x1343+(((-1.0)*x1340*x1346))+(((-1.0)*x1340*x1345))+(((0.1)*x1340)));
evalcond[2]=((0.4)+x1342+(((-1.0)*x1341*x1346))+(((-1.0)*x1341*x1345))+(((0.1)*x1341)));
evalcond[3]=((0.1)+(((-1.0)*x1346))+((x1340*x1343))+((x1341*x1342))+(((0.4)*x1341))+(((-1.0)*x1345)));
evalcond[4]=((-0.066959)+(((-0.08)*x1341))+((x1344*x1347))+((x1345*x1347))+(((0.2)*x1345))+(((0.2)*x1344))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1348=(cj27*px);
IkReal x1349=((321000.0)*py*sj27);
CheckValue<IkReal> x1350 = IKatan2WithCheck((gconst72*(((((32100.0)*sj30))+(((-1.0)*sj30*x1349))+(((-321000.0)*sj30*x1348))))),(gconst72*(((40000.0)+(((-400000.0)*py*sj27))+(((-321000.0)*cj30*x1348))+(((32100.0)*cj30))+(((-1.0)*cj30*x1349))+(((-400000.0)*x1348))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1350.valid){
continue;
}
j28array[0]=x1350.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1351=IKsin(j28);
IkReal x1352=IKcos(j28);
IkReal x1353=((0.321)*cj30);
IkReal x1354=((0.321)*sj30);
IkReal x1355=(py*sj27);
IkReal x1356=(cj27*px);
IkReal x1357=((1.0)*x1355);
IkReal x1358=((0.8)*x1352);
evalcond[0]=((((-1.0)*x1352*x1354))+(((0.4)*x1351))+((x1351*x1353)));
evalcond[1]=((((-1.0)*x1351*x1356))+x1354+(((0.1)*x1351))+(((-1.0)*x1351*x1357)));
evalcond[2]=((0.4)+x1353+(((-1.0)*x1352*x1357))+(((0.1)*x1352))+(((-1.0)*x1352*x1356)));
evalcond[3]=((0.1)+(((-1.0)*x1357))+(((-1.0)*x1356))+(((0.4)*x1352))+((x1351*x1354))+((x1352*x1353)));
evalcond[4]=((-0.066959)+((x1355*x1358))+(((-0.08)*x1352))+(((-1.0)*pp))+(((0.2)*x1356))+(((0.2)*x1355))+((x1356*x1358)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1359=IKPowWithIntegerCheck(sj29,-1);
if(!x1359.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1359.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1359.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1359.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[2];
evalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));
evalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst45;
IkReal x1360=(py*sj27);
IkReal x1361=((321.0)*cj30);
IkReal x1362=(cj27*px);
gconst45=IKsign(((-40.0)+(((400.0)*x1362))+(((400.0)*x1360))+((x1361*x1362))+((x1360*x1361))+(((321.0)*cj29*pz*sj30))+(((-32.1)*cj30))));
IkReal x1363=(cj27*px);
IkReal x1364=(py*sj27);
IkReal x1365=((10.0)*cj30);
dummyeval[0]=((-1.24610591900312)+((x1363*x1365))+(((12.4610591900312)*x1363))+(((12.4610591900312)*x1364))+(((-1.0)*cj30))+((x1364*x1365))+(((10.0)*cj29*pz*sj30)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst46;
gconst46=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(cj30*cj30)))+(((103041.0)*(cj29*cj29)*(sj30*sj30)))));
dummyeval[0]=((1.5527799613746)+(((cj29*cj29)*(sj30*sj30)))+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1366=(cj27*px);
IkReal x1367=((321000.0)*cj30);
IkReal x1368=(py*sj27);
IkReal x1369=((321000.0)*cj29*sj30);
CheckValue<IkReal> x1370 = IKatan2WithCheck((gconst46*(((((-1.0)*x1366*x1369))+(((-1.0)*pz*x1367))+(((32100.0)*cj29*sj30))+(((-1.0)*x1368*x1369))+(((-400000.0)*pz))))),(gconst46*(((-40000.0)+(((-1.0)*pz*x1369))+((x1367*x1368))+((x1366*x1367))+(((-32100.0)*cj30))+(((400000.0)*x1366))+(((400000.0)*x1368))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1370.valid){
continue;
}
j28array[0]=x1370.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x1371=IKsin(j28);
IkReal x1372=IKcos(j28);
IkReal x1373=((0.321)*cj30);
IkReal x1374=(py*sj27);
IkReal x1375=((0.321)*sj30);
IkReal x1376=((1.0)*sj29);
IkReal x1377=(px*sj27);
IkReal x1378=(cj27*px);
IkReal x1379=(cj27*py);
IkReal x1380=((1.0)*x1374);
IkReal x1381=(pz*x1371);
IkReal x1382=(cj29*x1371);
IkReal x1383=(pz*x1372);
IkReal x1384=((0.8)*x1372);
IkReal x1385=(sj29*x1371);
evalcond[0]=((((0.4)*x1371))+((x1371*x1373))+pz+((cj29*x1372*x1375)));
evalcond[1]=((0.1)+(((-1.0)*x1380))+((x1372*x1373))+(((-1.0)*x1375*x1382))+(((-1.0)*x1378))+(((0.4)*x1372)));
evalcond[2]=((0.4)+x1373+x1381+(((-1.0)*x1372*x1380))+(((-1.0)*x1372*x1378))+(((0.1)*x1372)));
evalcond[3]=((-0.066959)+(((0.2)*x1378))+(((0.2)*x1374))+(((-0.8)*x1381))+(((-0.08)*x1372))+(((-1.0)*pp))+((x1374*x1384))+((x1378*x1384)));
evalcond[4]=((((-1.0)*x1371*x1376*x1378))+(((-1.0)*x1371*x1374*x1376))+(((0.1)*x1385))+(((-1.0)*x1376*x1383))+((cj29*x1377))+(((-1.0)*cj29*x1379)));
evalcond[5]=((((-0.1)*x1382))+x1375+(((-1.0)*x1376*x1379))+((x1374*x1382))+((cj29*x1383))+((x1378*x1382))+((sj29*x1377)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1386=(cj29*sj30);
IkReal x1387=((1000.0)*pz);
CheckValue<IkReal> x1388 = IKatan2WithCheck((gconst45*(((((-1.0)*py*sj27*x1387))+(((100.0)*pz))+(((-1.0)*cj27*px*x1387))+(((-103.041)*cj30*x1386))+(((-128.4)*x1386))))),(gconst45*(((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x1387))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1388.valid){
continue;
}
j28array[0]=x1388.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x1389=IKsin(j28);
IkReal x1390=IKcos(j28);
IkReal x1391=((0.321)*cj30);
IkReal x1392=(py*sj27);
IkReal x1393=((0.321)*sj30);
IkReal x1394=((1.0)*sj29);
IkReal x1395=(px*sj27);
IkReal x1396=(cj27*px);
IkReal x1397=(cj27*py);
IkReal x1398=((1.0)*x1392);
IkReal x1399=(pz*x1389);
IkReal x1400=(cj29*x1389);
IkReal x1401=(pz*x1390);
IkReal x1402=((0.8)*x1390);
IkReal x1403=(sj29*x1389);
evalcond[0]=(((cj29*x1390*x1393))+(((0.4)*x1389))+pz+((x1389*x1391)));
evalcond[1]=((0.1)+((x1390*x1391))+(((0.4)*x1390))+(((-1.0)*x1393*x1400))+(((-1.0)*x1396))+(((-1.0)*x1398)));
evalcond[2]=((0.4)+x1399+x1391+(((-1.0)*x1390*x1396))+(((0.1)*x1390))+(((-1.0)*x1390*x1398)));
evalcond[3]=((-0.066959)+((x1392*x1402))+(((-0.8)*x1399))+((x1396*x1402))+(((-1.0)*pp))+(((0.2)*x1396))+(((0.2)*x1392))+(((-0.08)*x1390)));
evalcond[4]=((((-1.0)*x1389*x1392*x1394))+(((0.1)*x1403))+(((-1.0)*x1389*x1394*x1396))+((cj29*x1395))+(((-1.0)*x1394*x1401))+(((-1.0)*cj29*x1397)));
evalcond[5]=(x1393+((cj29*x1401))+(((-0.1)*x1400))+(((-1.0)*x1394*x1397))+((x1392*x1400))+((x1396*x1400))+((sj29*x1395)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1404=py*py;
IkReal x1405=sj27*sj27;
IkReal x1406=cj27*cj27;
IkReal x1407=px*px;
IkReal x1408=(pz*sj27);
IkReal x1409=(py*sj29);
IkReal x1410=((5.0)*pp);
IkReal x1411=(pz*sj29);
IkReal x1412=((0.4)*cj29);
IkReal x1413=(px*sj27);
IkReal x1414=((4.0)*cj29*px);
IkReal x1415=(cj27*px*sj29);
IkReal x1416=((4.0)*cj27*cj29);
CheckValue<IkReal> x1417 = IKatan2WithCheck((gconst44*(((((-1.0)*py*x1405*x1414))+(((-1.0)*x1408*x1409))+((x1412*x1413))+(((-1.0)*sj27*x1407*x1416))+(((-1.0)*cj27*py*x1412))+((sj27*x1404*x1416))+((py*x1406*x1414))+((x1410*x1411))+(((0.334795)*x1411))+(((-1.0)*cj27*px*x1411))))),(gconst44*(((((-0.434795)*sj27*x1409))+(((0.5)*pp*sj29))+((py*pz*x1416))+(((-0.434795)*x1415))+(((0.0334795)*sj29))+((sj29*x1404*x1405))+(((-1.0)*x1408*x1414))+(((2.0)*cj27*x1409*x1413))+(((-1.0)*x1410*x1415))+((sj29*x1406*x1407))+(((-1.0)*sj27*x1409*x1410))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1417.valid){
continue;
}
j28array[0]=x1417.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[2];
IkReal x1418=IKcos(j28);
IkReal x1419=IKsin(j28);
IkReal x1420=(py*sj27);
IkReal x1421=((1.0)*cj27);
IkReal x1422=(cj27*px);
IkReal x1423=((0.8)*x1418);
IkReal x1424=(sj29*x1419);
evalcond[0]=((-0.066959)+((x1420*x1423))+((x1422*x1423))+(((-0.08)*x1418))+(((-1.0)*pp))+(((-0.8)*pz*x1419))+(((0.2)*x1420))+(((0.2)*x1422)));
evalcond[1]=(((cj29*px*sj27))+(((0.1)*x1424))+(((-1.0)*x1420*x1424))+(((-1.0)*px*x1421*x1424))+(((-1.0)*pz*sj29*x1418))+(((-1.0)*cj29*py*x1421)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=cj28;
dummyeval[1]=cj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1425=(cj27*px);
IkReal x1426=((1.0)*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1425))+(((0.2)*py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*x1426))+(((0.1)*sj29))+(((-1.0)*sj27*sj29*x1426))+(((-1.0)*sj29*x1425)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1427=((3.11526479750779)*cj29);
IkReal x1428=((3.11526479750779)*sj29);
if( IKabs(((((-1.0)*px*sj27*x1428))+(((-1.0)*cj27*px*x1427))+(((-1.0)*py*sj27*x1427))+((cj27*py*x1428))+(((0.311526479750779)*cj29)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*px*sj27*x1428))+(((-1.0)*cj27*px*x1427))+(((-1.0)*py*sj27*x1427))+((cj27*py*x1428))+(((0.311526479750779)*cj29))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-1.0)*px*sj27*x1428))+(((-1.0)*cj27*px*x1427))+(((-1.0)*py*sj27*x1427))+((cj27*py*x1428))+(((0.311526479750779)*cj29))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1429=IKsin(j30);
IkReal x1430=IKcos(j30);
IkReal x1431=((1.0)*py);
IkReal x1432=(cj27*px);
IkReal x1433=(px*sj27);
IkReal x1434=(py*sj27);
IkReal x1435=((0.321)*x1429);
evalcond[0]=((0.4)+(((0.321)*x1430))+pz);
evalcond[1]=(((sj29*x1435))+x1433+(((-1.0)*cj27*x1431)));
evalcond[2]=((0.1)+(((-1.0)*x1432))+(((-1.0)*sj27*x1431))+(((-1.0)*cj29*x1435)));
evalcond[3]=((0.253041)+(((0.2)*x1434))+(((0.2)*x1432))+(((0.2568)*x1430))+(((-1.0)*pp)));
evalcond[4]=(((cj29*x1434))+((cj29*x1432))+(((-1.0)*cj27*sj29*x1431))+((sj29*x1433))+x1435+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1436=(py*sj27);
IkReal x1437=(cj27*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.2)*x1437))+(((0.2)*x1436))+(((0.8)*pz))+(((-1.0)*pp)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((sj29*x1437))+((sj29*x1436))+(((-0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1438=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x1438;
evalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=x1438;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1439=IKcos(j30);
IkReal x1440=(py*sj27);
IkReal x1441=(cj27*px);
evalcond[0]=((-0.4)+(((-0.321)*x1439))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1440))+(((-1.0)*x1441))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1439))+(((-1.0)*pp))+(((0.2)*x1441))+(((0.2)*x1440)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1442=(cj27*py);
IkReal x1443=(px*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x1442))+x1443);
evalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=((((-1.0)*x1443))+x1442);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1444=IKcos(j30);
IkReal x1445=(py*sj27);
IkReal x1446=(cj27*px);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1444)));
evalcond[1]=((0.1)+(((-1.0)*x1446))+(((-1.0)*x1445))+(((-0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1444))+(((-1.0)*pp))+(((0.2)*x1445))+(((0.2)*x1446)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1447=(py*sj27);
IkReal x1448=(cj27*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*x1448))+(((-1.0)*x1447)));
evalcond[2]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1447))+(((0.2)*x1448)));
evalcond[3]=((-0.1)+x1447+x1448);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1449=IKcos(j30);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1449)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1449))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1450=(py*sj27);
IkReal x1451=(cj27*px);
IkReal x1452=((0.1)+(((-1.0)*x1451))+(((-1.0)*x1450)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=x1452;
evalcond[2]=((-0.066959)+(((0.2)*x1450))+(((0.2)*x1451))+(((0.8)*pz))+(((-1.0)*pp)));
evalcond[3]=x1452;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1453=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1453))+pz);
evalcond[1]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1453))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1454=IKPowWithIntegerCheck(sj29,-1);
if(!x1454.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1454.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1454.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1454.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1455=IKsin(j30);
IkReal x1456=IKcos(j30);
IkReal x1457=((1.0)*py);
IkReal x1458=(px*sj27);
IkReal x1459=((1.0)*cj27*px);
IkReal x1460=((0.321)*x1455);
evalcond[0]=((-0.4)+(((-0.321)*x1456))+pz);
evalcond[1]=(((sj29*x1460))+x1458+(((-1.0)*cj27*x1457)));
evalcond[2]=((0.1)+(((-1.0)*x1459))+(((-1.0)*sj27*x1457))+((cj29*x1460)));
evalcond[3]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1456))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[4]=((((-1.0)*cj27*sj29*x1457))+(((-1.0)*cj29*sj27*x1457))+((sj29*x1458))+(((-1.0)*cj29*x1459))+x1460+(((0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1461=IKPowWithIntegerCheck(cj29,-1);
if(!x1461.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1461.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1461.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1461.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1462=IKsin(j30);
IkReal x1463=IKcos(j30);
IkReal x1464=((1.0)*py);
IkReal x1465=(px*sj27);
IkReal x1466=((1.0)*cj27*px);
IkReal x1467=((0.321)*x1462);
evalcond[0]=((-0.4)+(((-0.321)*x1463))+pz);
evalcond[1]=(((sj29*x1467))+(((-1.0)*cj27*x1464))+x1465);
evalcond[2]=((0.1)+(((-1.0)*x1466))+(((-1.0)*sj27*x1464))+((cj29*x1467)));
evalcond[3]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1463))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[4]=((((-1.0)*cj29*x1466))+(((-1.0)*cj29*sj27*x1464))+((sj29*x1465))+x1467+(((0.1)*cj29))+(((-1.0)*cj27*sj29*x1464)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1468=IKPowWithIntegerCheck(sj29,-1);
if(!x1468.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1468.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1468.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1468.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1469=IKsin(j30);
IkReal x1470=IKcos(j30);
IkReal x1471=((1.0)*py);
IkReal x1472=(px*sj27);
IkReal x1473=((1.0)*cj27*px);
IkReal x1474=((0.321)*x1469);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1470)));
evalcond[1]=(((sj29*x1474))+(((-1.0)*cj27*x1471))+x1472);
evalcond[2]=((0.1)+((cj29*x1474))+(((-1.0)*x1473))+(((-1.0)*sj27*x1471)));
evalcond[3]=((0.253041)+(((0.2568)*x1470))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[4]=(((sj29*x1472))+(((-1.0)*cj29*x1473))+(((-1.0)*cj27*sj29*x1471))+x1474+(((0.1)*cj29))+(((-1.0)*cj29*sj27*x1471)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1475=(cj27*px);
IkReal x1476=((0.8)*cj28);
IkReal x1477=(py*sj27);
IkReal x1478=((1.0)*sj28);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1476*x1477))+((x1475*x1476))+(((0.2)*x1475))+(((0.2)*x1477))+(((-0.8)*pz*sj28)));
evalcond[2]=((((-1.0)*x1477*x1478))+(((0.1)*sj28))+(((-1.0)*x1475*x1478))+(((-1.0)*cj28*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1479=IKcos(j30);
IkReal x1480=((1.0)*py);
IkReal x1481=(cj27*px);
IkReal x1482=((0.321)*x1479);
evalcond[0]=((((0.4)*sj28))+pz+((sj28*x1482)));
evalcond[1]=((((-1.0)*cj27*x1480))+((px*sj27))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1479))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*x1481)));
evalcond[3]=((0.1)+(((0.4)*cj28))+(((-1.0)*x1481))+(((-1.0)*sj27*x1480))+((cj28*x1482)));
evalcond[4]=((0.4)+(((-1.0)*cj28*x1481))+(((-1.0)*cj28*sj27*x1480))+x1482+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1483=(cj27*px);
IkReal x1484=((0.8)*cj28);
IkReal x1485=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1483*x1484))+((x1484*x1485))+(((0.2)*x1485))+(((0.2)*x1483))+(((-0.8)*pz*sj28)));
evalcond[2]=(((cj28*pz))+(((-0.1)*sj28))+((sj28*x1483))+((sj28*x1485)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1486=IKcos(j30);
IkReal x1487=((1.0)*py);
IkReal x1488=(cj27*px);
IkReal x1489=((0.321)*x1486);
evalcond[0]=((((0.4)*sj28))+pz+((sj28*x1489)));
evalcond[1]=((((-1.0)*cj27*x1487))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
evalcond[2]=((0.253041)+(((0.2568)*x1486))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*x1488)));
evalcond[3]=((0.1)+(((0.4)*cj28))+(((-1.0)*x1488))+(((-1.0)*sj27*x1487))+((cj28*x1489)));
evalcond[4]=((0.4)+(((-1.0)*cj28*x1488))+(((-1.0)*cj28*sj27*x1487))+x1489+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1490=(cj27*px);
IkReal x1491=((0.8)*cj28);
IkReal x1492=(py*sj27);
IkReal x1493=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x1493;
evalcond[2]=((-0.066959)+((x1491*x1492))+(((-0.08)*cj28))+(((-1.0)*pp))+((x1490*x1491))+(((0.2)*x1492))+(((0.2)*x1490))+(((-0.8)*pz*sj28)));
evalcond[3]=x1493;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst47;
gconst47=IKsign(((((321.0)*(cj28*cj28)))+(((321.0)*(sj28*sj28)))));
dummyeval[0]=((cj28*cj28)+(sj28*sj28));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1494=x1493;
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=x1494;
evalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=x1494;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1495=IKcos(j30);
IkReal x1496=(py*sj27);
IkReal x1497=(cj27*px);
evalcond[0]=((0.4)+pz+(((0.321)*x1495)));
evalcond[1]=((0.1)+(((-1.0)*x1496))+(((-1.0)*x1497))+(((-0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1495))+(((-1.0)*pp))+(((0.2)*x1497))+(((0.2)*x1496)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1498=(cj28*sj28);
IkReal x1499=((1000.0)*pz);
IkReal x1500=(cj27*px);
IkReal x1501=(cj28*py*sj27);
CheckValue<IkReal> x1502=IKPowWithIntegerCheck(cj28,-1);
if(!x1502.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1502.value)*(((((-1000.0)*x1498*x1500))+(((-1.0)*x1499))+(((100.0)*x1498))+((x1499*(sj28*sj28)))+(((-1000.0)*py*sj27*x1498)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((3.11526479750779)*x1501))+(((-3.11526479750779)*pz*sj28))+(((3.11526479750779)*cj28*x1500)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1502.value)*(((((-1000.0)*x1498*x1500))+(((-1.0)*x1499))+(((100.0)*x1498))+((x1499*(sj28*sj28)))+(((-1000.0)*py*sj27*x1498))))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((3.11526479750779)*x1501))+(((-3.11526479750779)*pz*sj28))+(((3.11526479750779)*cj28*x1500))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1502.value)*(((((-1000.0)*x1498*x1500))+(((-1.0)*x1499))+(((100.0)*x1498))+((x1499*(sj28*sj28)))+(((-1000.0)*py*sj27*x1498))))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((3.11526479750779)*x1501))+(((-3.11526479750779)*pz*sj28))+(((3.11526479750779)*cj28*x1500))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1503=IKcos(j30);
IkReal x1504=IKsin(j30);
IkReal x1505=(py*sj27);
IkReal x1506=(cj27*px);
IkReal x1507=((1.0)*cj28);
IkReal x1508=((0.321)*x1504);
IkReal x1509=((0.321)*x1503);
evalcond[0]=((((0.4)*sj28))+((cj28*x1508))+pz+((sj28*x1509)));
evalcond[1]=((0.253041)+(((0.2568)*x1503))+(((-1.0)*pp))+(((0.2)*x1505))+(((0.2)*x1506)));
evalcond[2]=(((cj28*pz))+x1508+(((-0.1)*sj28))+((sj28*x1506))+((sj28*x1505)));
evalcond[3]=((0.4)+(((-1.0)*x1506*x1507))+x1509+(((0.1)*cj28))+(((-1.0)*x1505*x1507))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*sj28*x1508))+(((-1.0)*x1505))+(((-1.0)*x1506))+(((0.4)*cj28))+((cj28*x1509)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1510=((250.0)*sj28);
IkReal x1511=(py*sj27);
IkReal x1512=(cj27*px);
CheckValue<IkReal> x1513=IKPowWithIntegerCheck(cj28,-1);
if(!x1513.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1513.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1510*x1512))+((x1510*x1511))+(((-1250.0)*pp*sj28)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x1512))+(((-0.778816199376947)*x1511))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1513.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1510*x1512))+((x1510*x1511))+(((-1250.0)*pp*sj28))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x1512))+(((-0.778816199376947)*x1511))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1513.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1510*x1512))+((x1510*x1511))+(((-1250.0)*pp*sj28))))), ((-0.98536214953271)+(((-0.778816199376947)*x1512))+(((-0.778816199376947)*x1511))+(((3.89408099688474)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1514=IKcos(j30);
IkReal x1515=IKsin(j30);
IkReal x1516=(py*sj27);
IkReal x1517=(cj27*px);
IkReal x1518=((1.0)*cj28);
IkReal x1519=((0.321)*x1515);
IkReal x1520=((0.321)*x1514);
evalcond[0]=((((0.4)*sj28))+((sj28*x1520))+((cj28*x1519))+pz);
evalcond[1]=((0.253041)+(((0.2568)*x1514))+(((-1.0)*pp))+(((0.2)*x1517))+(((0.2)*x1516)));
evalcond[2]=(((cj28*pz))+x1519+(((-0.1)*sj28))+((sj28*x1517))+((sj28*x1516)));
evalcond[3]=((0.4)+(((-1.0)*x1516*x1518))+x1520+(((-1.0)*x1517*x1518))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*sj28*x1519))+(((-1.0)*x1517))+(((-1.0)*x1516))+(((0.4)*cj28))+((cj28*x1520)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1521=((1000.0)*cj28);
IkReal x1522=(py*sj27);
IkReal x1523=((1000.0)*sj28);
IkReal x1524=(cj27*px);
CheckValue<IkReal> x1525 = IKatan2WithCheck((gconst47*(((((-1.0)*x1522*x1523))+(((-1.0)*x1523*x1524))+(((-1.0)*pz*x1521))+(((100.0)*sj28))))),(gconst47*(((((-400.0)*(sj28*sj28)))+(((-400.0)*(cj28*cj28)))+((x1521*x1524))+((x1521*x1522))+(((-100.0)*cj28))+(((-1.0)*pz*x1523))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1525.valid){
continue;
}
j30array[0]=x1525.value;
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1526=IKcos(j30);
IkReal x1527=IKsin(j30);
IkReal x1528=(py*sj27);
IkReal x1529=(cj27*px);
IkReal x1530=((1.0)*cj28);
IkReal x1531=((0.321)*x1527);
IkReal x1532=((0.321)*x1526);
evalcond[0]=((((0.4)*sj28))+((sj28*x1532))+pz+((cj28*x1531)));
evalcond[1]=((0.253041)+(((0.2568)*x1526))+(((-1.0)*pp))+(((0.2)*x1529))+(((0.2)*x1528)));
evalcond[2]=(((sj28*x1528))+((sj28*x1529))+((cj28*pz))+x1531+(((-0.1)*sj28)));
evalcond[3]=((0.4)+(((-1.0)*x1529*x1530))+x1532+(((-1.0)*x1528*x1530))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x1532))+(((-1.0)*sj28*x1531))+(((-1.0)*x1529))+(((-1.0)*x1528)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1533=(cj27*px);
IkReal x1534=((0.8)*cj28);
IkReal x1535=(cj27*py);
IkReal x1536=(px*sj27);
IkReal x1537=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x1535))+x1536);
evalcond[2]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1533))+(((0.2)*x1537))+((x1533*x1534))+((x1534*x1537))+(((-0.8)*pz*sj28)));
evalcond[3]=((((-1.0)*x1536))+x1535);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst48;
gconst48=IKsign(((((321.0)*(cj28*cj28)))+(((321.0)*(sj28*sj28)))));
dummyeval[0]=((cj28*cj28)+(sj28*sj28));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1538=(cj27*py);
IkReal x1539=(px*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x1538))+x1539);
evalcond[2]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=((((-1.0)*x1539))+x1538);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1540=IKcos(j30);
IkReal x1541=(py*sj27);
IkReal x1542=(cj27*px);
evalcond[0]=((0.4)+pz+(((0.321)*x1540)));
evalcond[1]=((0.1)+(((-1.0)*x1541))+(((-1.0)*x1542))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1540))+(((-1.0)*pp))+(((0.2)*x1542))+(((0.2)*x1541)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1543=((1000.0)*pz);
IkReal x1544=(cj28*sj28);
IkReal x1545=(cj27*px);
IkReal x1546=(cj28*py*sj27);
CheckValue<IkReal> x1547=IKPowWithIntegerCheck(cj28,-1);
if(!x1547.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1547.value)*(((((-1.0)*x1543*(sj28*sj28)))+x1543+(((-100.0)*x1544))+(((1000.0)*x1544*x1545))+(((1000.0)*py*sj27*x1544)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*x1546))+(((-0.311526479750779)*cj28))+(((-3.11526479750779)*pz*sj28))+(((3.11526479750779)*cj28*x1545)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1547.value)*(((((-1.0)*x1543*(sj28*sj28)))+x1543+(((-100.0)*x1544))+(((1000.0)*x1544*x1545))+(((1000.0)*py*sj27*x1544))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*x1546))+(((-0.311526479750779)*cj28))+(((-3.11526479750779)*pz*sj28))+(((3.11526479750779)*cj28*x1545))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1547.value)*(((((-1.0)*x1543*(sj28*sj28)))+x1543+(((-100.0)*x1544))+(((1000.0)*x1544*x1545))+(((1000.0)*py*sj27*x1544))))), ((-1.24610591900312)+(((3.11526479750779)*x1546))+(((-0.311526479750779)*cj28))+(((-3.11526479750779)*pz*sj28))+(((3.11526479750779)*cj28*x1545))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1548=IKcos(j30);
IkReal x1549=IKsin(j30);
IkReal x1550=(py*sj27);
IkReal x1551=((1.0)*cj28);
IkReal x1552=(cj27*px);
IkReal x1553=((1.0)*sj28);
IkReal x1554=((0.321)*x1549);
IkReal x1555=((0.321)*x1548);
evalcond[0]=((((0.4)*sj28))+((sj28*x1555))+(((-1.0)*cj28*x1554))+pz);
evalcond[1]=((0.253041)+(((0.2568)*x1548))+(((-1.0)*pp))+(((0.2)*x1550))+(((0.2)*x1552)));
evalcond[2]=((0.4)+x1555+(((-1.0)*x1550*x1551))+(((0.1)*cj28))+(((-1.0)*x1551*x1552))+((pz*sj28)));
evalcond[3]=((((-1.0)*pz*x1551))+(((-1.0)*x1552*x1553))+(((0.1)*sj28))+x1554+(((-1.0)*x1550*x1553)));
evalcond[4]=((0.1)+((cj28*x1555))+((sj28*x1554))+(((-1.0)*x1550))+(((-1.0)*x1552))+(((0.4)*cj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1556=((250.0)*sj28);
IkReal x1557=(py*sj27);
IkReal x1558=(cj27*px);
CheckValue<IkReal> x1559=IKPowWithIntegerCheck(cj28,-1);
if(!x1559.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1559.value)*(((((1250.0)*pp*sj28))+(((83.69875)*sj28))+(((-1.0)*x1556*x1558))+(((-1.0)*x1556*x1557))+(((1000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x1557))+(((-0.778816199376947)*x1558))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1559.value)*(((((1250.0)*pp*sj28))+(((83.69875)*sj28))+(((-1.0)*x1556*x1558))+(((-1.0)*x1556*x1557))+(((1000.0)*pz))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x1557))+(((-0.778816199376947)*x1558))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1559.value)*(((((1250.0)*pp*sj28))+(((83.69875)*sj28))+(((-1.0)*x1556*x1558))+(((-1.0)*x1556*x1557))+(((1000.0)*pz))))), ((-0.98536214953271)+(((-0.778816199376947)*x1557))+(((-0.778816199376947)*x1558))+(((3.89408099688474)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1560=IKcos(j30);
IkReal x1561=IKsin(j30);
IkReal x1562=(py*sj27);
IkReal x1563=((1.0)*cj28);
IkReal x1564=(cj27*px);
IkReal x1565=((1.0)*sj28);
IkReal x1566=((0.321)*x1561);
IkReal x1567=((0.321)*x1560);
evalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x1566))+((sj28*x1567))+pz);
evalcond[1]=((0.253041)+(((0.2568)*x1560))+(((-1.0)*pp))+(((0.2)*x1562))+(((0.2)*x1564)));
evalcond[2]=((0.4)+(((-1.0)*x1562*x1563))+(((-1.0)*x1563*x1564))+x1567+(((0.1)*cj28))+((pz*sj28)));
evalcond[3]=((((-1.0)*pz*x1563))+(((-1.0)*x1562*x1565))+(((0.1)*sj28))+x1566+(((-1.0)*x1564*x1565)));
evalcond[4]=((0.1)+((cj28*x1567))+((sj28*x1566))+(((0.4)*cj28))+(((-1.0)*x1562))+(((-1.0)*x1564)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1568=((1000.0)*cj28);
IkReal x1569=(py*sj27);
IkReal x1570=((1000.0)*sj28);
IkReal x1571=(cj27*px);
CheckValue<IkReal> x1572 = IKatan2WithCheck((gconst48*(((((-100.0)*sj28))+((x1569*x1570))+((x1570*x1571))+((pz*x1568))))),(gconst48*(((((-400.0)*(sj28*sj28)))+(((-400.0)*(cj28*cj28)))+(((-1.0)*pz*x1570))+((x1568*x1569))+((x1568*x1571))+(((-100.0)*cj28))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1572.valid){
continue;
}
j30array[0]=x1572.value;
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1573=IKcos(j30);
IkReal x1574=IKsin(j30);
IkReal x1575=(py*sj27);
IkReal x1576=((1.0)*cj28);
IkReal x1577=(cj27*px);
IkReal x1578=((1.0)*sj28);
IkReal x1579=((0.321)*x1574);
IkReal x1580=((0.321)*x1573);
evalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x1579))+((sj28*x1580))+pz);
evalcond[1]=((0.253041)+(((0.2568)*x1573))+(((-1.0)*pp))+(((0.2)*x1577))+(((0.2)*x1575)));
evalcond[2]=((0.4)+(((-1.0)*x1576*x1577))+(((-1.0)*x1575*x1576))+x1580+(((0.1)*cj28))+((pz*sj28)));
evalcond[3]=((((-1.0)*x1575*x1578))+(((-1.0)*pz*x1576))+(((0.1)*sj28))+x1579+(((-1.0)*x1577*x1578)));
evalcond[4]=((0.1)+(((0.4)*cj28))+((sj28*x1579))+((cj28*x1580))+(((-1.0)*x1577))+(((-1.0)*x1575)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1581=((250.0)*sj28);
IkReal x1582=(py*sj27);
IkReal x1583=(cj27*px);
CheckValue<IkReal> x1584=IKPowWithIntegerCheck(cj28,-1);
if(!x1584.valid){
continue;
}
CheckValue<IkReal> x1585=IKPowWithIntegerCheck(cj29,-1);
if(!x1585.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1584.value)*(x1585.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1581*x1583))+((x1581*x1582)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x1582))+(((-0.778816199376947)*x1583))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1584.value)*(x1585.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1581*x1583))+((x1581*x1582))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x1582))+(((-0.778816199376947)*x1583))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1584.value)*(x1585.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1581*x1583))+((x1581*x1582))))), ((-0.98536214953271)+(((-0.778816199376947)*x1582))+(((-0.778816199376947)*x1583))+(((3.89408099688474)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1586=IKsin(j30);
IkReal x1587=IKcos(j30);
IkReal x1588=((1.0)*py);
IkReal x1589=(cj29*sj28);
IkReal x1590=(cj27*px);
IkReal x1591=(cj28*cj29);
IkReal x1592=(py*sj27);
IkReal x1593=(px*sj27);
IkReal x1594=((0.321)*x1586);
IkReal x1595=((0.321)*x1587);
evalcond[0]=((((-1.0)*cj27*x1588))+((sj29*x1594))+x1593);
evalcond[1]=((0.253041)+(((0.2568)*x1587))+(((-1.0)*pp))+(((0.2)*x1590))+(((0.2)*x1592)));
evalcond[2]=((((0.4)*sj28))+((sj28*x1595))+((x1591*x1594))+pz);
evalcond[3]=((0.4)+(((-1.0)*cj28*x1590))+x1595+(((0.1)*cj28))+(((-1.0)*cj28*sj27*x1588))+((pz*sj28)));
evalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x1595))+(((-1.0)*x1589*x1594))+(((-1.0)*x1590))+(((-1.0)*sj27*x1588)));
evalcond[5]=(((x1589*x1592))+((x1589*x1590))+((sj29*x1593))+x1594+((pz*x1591))+(((-0.1)*x1589))+(((-1.0)*cj27*sj29*x1588)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1596=((3.11526479750779)*cj28);
CheckValue<IkReal> x1597=IKPowWithIntegerCheck(sj29,-1);
if(!x1597.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1597.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+((cj27*px*x1596))+(((-3.11526479750779)*pz*sj28))+((py*sj27*x1596)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1597.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+((cj27*px*x1596))+(((-3.11526479750779)*pz*sj28))+((py*sj27*x1596))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1597.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+((cj27*px*x1596))+(((-3.11526479750779)*pz*sj28))+((py*sj27*x1596))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1598=IKsin(j30);
IkReal x1599=IKcos(j30);
IkReal x1600=((1.0)*py);
IkReal x1601=(cj29*sj28);
IkReal x1602=(cj27*px);
IkReal x1603=(cj28*cj29);
IkReal x1604=(py*sj27);
IkReal x1605=(px*sj27);
IkReal x1606=((0.321)*x1598);
IkReal x1607=((0.321)*x1599);
evalcond[0]=(((sj29*x1606))+x1605+(((-1.0)*cj27*x1600)));
evalcond[1]=((0.253041)+(((0.2568)*x1599))+(((-1.0)*pp))+(((0.2)*x1602))+(((0.2)*x1604)));
evalcond[2]=((((0.4)*sj28))+((sj28*x1607))+pz+((x1603*x1606)));
evalcond[3]=((0.4)+(((-1.0)*cj28*sj27*x1600))+x1607+(((0.1)*cj28))+(((-1.0)*cj28*x1602))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*x1602))+(((0.4)*cj28))+(((-1.0)*x1601*x1606))+((cj28*x1607))+(((-1.0)*sj27*x1600)));
evalcond[5]=(((sj29*x1605))+x1606+(((-1.0)*cj27*sj29*x1600))+((x1601*x1602))+((x1601*x1604))+(((-0.1)*x1601))+((pz*x1603)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1608=IKPowWithIntegerCheck(sj29,-1);
if(!x1608.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1608.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1608.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1608.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1609=IKsin(j30);
IkReal x1610=IKcos(j30);
IkReal x1611=((1.0)*py);
IkReal x1612=(cj29*sj28);
IkReal x1613=(cj27*px);
IkReal x1614=(cj28*cj29);
IkReal x1615=(py*sj27);
IkReal x1616=(px*sj27);
IkReal x1617=((0.321)*x1609);
IkReal x1618=((0.321)*x1610);
evalcond[0]=((((-1.0)*cj27*x1611))+x1616+((sj29*x1617)));
evalcond[1]=((0.253041)+(((0.2568)*x1610))+(((-1.0)*pp))+(((0.2)*x1615))+(((0.2)*x1613)));
evalcond[2]=((((0.4)*sj28))+((sj28*x1618))+((x1614*x1617))+pz);
evalcond[3]=((0.4)+x1618+(((-1.0)*cj28*sj27*x1611))+(((-1.0)*cj28*x1613))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*x1613))+(((0.4)*cj28))+((cj28*x1618))+(((-1.0)*x1612*x1617))+(((-1.0)*sj27*x1611)));
evalcond[5]=(((pz*x1614))+x1617+((sj29*x1616))+(((-0.1)*x1612))+(((-1.0)*cj27*sj29*x1611))+((x1612*x1615))+((x1612*x1613)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x144=(sj27*sj29);
IkReal x145=(cj27*sj29);
IkReal x146=(cj28*sj29);
IkReal x147=(cj28*cj30);
IkReal x148=((1.0)*sj30);
IkReal x149=((1.0)*cj29);
IkReal x150=(cj29*x148);
IkReal x151=((1.0)*cj30*sj28);
IkReal x152=((((-1.0)*x147*x149))+((sj28*sj30)));
IkReal x153=((((-1.0)*sj27*x149))+((sj28*x145)));
IkReal x154=(((sj28*x144))+((cj27*cj29)));
IkReal x155=((((-1.0)*sj28*x150))+x147);
IkReal x156=(cj27*x155);
IkReal x157=((((-1.0)*cj30*sj28*x149))+(((-1.0)*cj28*x148)));
IkReal x158=((((-1.0)*x151))+(((-1.0)*cj28*x150)));
IkReal x159=(cj27*x157);
IkReal x160=(((sj27*x155))+((sj30*x145)));
IkReal x161=(x156+(((-1.0)*sj30*x144)));
IkReal x162=(((cj30*x145))+((sj27*x157)));
IkReal x163=((((-1.0)*cj30*x144))+x159);
new_r00=(((r00*(((((-1.0)*cj30*x144))+x159))))+((r20*x152))+((r10*x162)));
new_r01=(((r01*x163))+((r21*x152))+((r11*x162)));
new_r02=(((r12*x162))+((r22*x152))+((r02*x163)));
new_r10=(((r20*x146))+((r00*x153))+((r10*x154)));
new_r11=(((r01*x153))+((r21*x146))+((r11*x154)));
new_r12=(((r02*x153))+((r22*x146))+((r12*x154)));
new_r20=(((r00*x161))+((r20*x158))+((r10*x160)));
new_r21=(((r01*x161))+((r21*x158))+((r11*x160)));
new_r22=(((r02*(((((-1.0)*x144*x148))+x156))))+((r12*x160))+((r22*x158)));
{
IkReal j32array[2], cj32array[2], sj32array[2];
bool j32valid[2]={false};
_nj32 = 2;
cj32array[0]=new_r22;
if( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j32valid[0] = j32valid[1] = true;
    j32array[0] = IKacos(cj32array[0]);
    sj32array[0] = IKsin(j32array[0]);
    cj32array[1] = cj32array[0];
    j32array[1] = -j32array[0];
    sj32array[1] = -sj32array[0];
}
else if( isnan(cj32array[0]) )
{
    // probably any value will work
    j32valid[0] = true;
    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;
}
for(int ij32 = 0; ij32 < 2; ++ij32)
{
if( !j32valid[ij32] )
{
    continue;
}
_ij32[0] = ij32; _ij32[1] = -1;
for(int iij32 = ij32+1; iij32 < 2; ++iij32)
{
if( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )
{
    j32valid[iij32]=false; _ij32[1] = iij32; break; 
}
}
j32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];

{
IkReal dummyeval[1];
IkReal gconst89;
gconst89=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst90;
gconst90=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst91;
gconst91=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x164=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x164;
evalcond[2]=x164;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x164;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
IkReal j33mul = 1;
j33=0;
IkReal j31mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].fmul = j31mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].fmul = j33mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x165=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x165;
evalcond[2]=x165;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x167 = IKatan2WithCheck(new_r02,new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x167.valid){
continue;
}
IkReal x166=x167.value;
j31array[0]=((-1.0)*x166);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x166)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst125;
gconst125=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst126;
gconst126=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x168=((1.0)*sj31);
CheckValue<IkReal> x169 = IKatan2WithCheck((gconst126*(((((-1.0)*new_r00*x168))+((cj31*new_r10))))),(gconst126*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x168))))),IKFAST_ATAN2_MAGTHRESH);
if(!x169.valid){
continue;
}
j33array[0]=x169.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x170=IKsin(j33);
IkReal x171=IKcos(j33);
IkReal x172=((1.0)*sj31);
IkReal x173=((1.0)*x170);
IkReal x174=(sj31*x171);
IkReal x175=((1.0)*x171);
IkReal x176=(cj31*x173);
evalcond[0]=(((cj31*new_r00))+x171+((new_r10*sj31)));
evalcond[1]=((((-1.0)*x173))+((cj31*new_r01))+((new_r11*sj31)));
evalcond[2]=(new_r00+((cj31*x171))+((sj31*x170)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x173))+(((-1.0)*new_r00*x172)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x175))+(((-1.0)*new_r01*x172)));
evalcond[5]=((((-1.0)*x176))+x174+new_r01);
evalcond[6]=((((-1.0)*x176))+x174+new_r10);
evalcond[7]=((((-1.0)*cj31*x175))+(((-1.0)*x170*x172))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x177=((1.0)*new_r00);
CheckValue<IkReal> x178 = IKatan2WithCheck((gconst125*(((((-1.0)*sj31*x177))+((cj31*new_r01))))),(gconst125*(((((-1.0)*cj31*x177))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x178.valid){
continue;
}
j33array[0]=x178.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x179=IKsin(j33);
IkReal x180=IKcos(j33);
IkReal x181=((1.0)*sj31);
IkReal x182=((1.0)*x179);
IkReal x183=(sj31*x180);
IkReal x184=((1.0)*x180);
IkReal x185=(cj31*x182);
evalcond[0]=(((cj31*new_r00))+x180+((new_r10*sj31)));
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x182))+((new_r11*sj31)));
evalcond[2]=(((cj31*x180))+new_r00+((sj31*x179)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x182))+(((-1.0)*new_r00*x181)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x184))+(((-1.0)*new_r01*x181)));
evalcond[5]=((((-1.0)*x185))+x183+new_r01);
evalcond[6]=((((-1.0)*x185))+x183+new_r10);
evalcond[7]=((((-1.0)*cj31*x184))+new_r11+(((-1.0)*x179*x181)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x186 = IKatan2WithCheck((gconst91*new_r21),((-1.0)*gconst91*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x186.valid){
continue;
}
j33array[0]=x186.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[2];
evalcond[0]=(((sj32*(IKcos(j33))))+new_r20);
evalcond[1]=((((-1.0)*sj32*(IKsin(j33))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst92;
gconst92=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst93;
gconst93=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x187=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x187;
evalcond[2]=x187;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x187;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst94;
gconst94=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst95;
gconst95=IKsign((((new_r12*sj33))+(((-1.0)*cj33*new_r02))));
dummyeval[0]=(((new_r12*sj33))+(((-1.0)*cj33*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal gconst96;
CheckValue<IkReal> x188 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x188.valid){
continue;
}
gconst96=((-1.0)*(x188.value));
IkReal gconst97;
gconst97=IKsin(gconst96);
IkReal gconst98;
gconst98=IKcos(gconst96);
IkReal x189=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst96))+j33)))), 6.28318530717959)));
evalcond[1]=x189;
evalcond[2]=x189;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x189;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst102;
gconst102=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst103;
gconst103=IKsign(((((-1.0)*gconst98*new_r02))+((gconst97*new_r12))));
dummyeval[0]=((((-1.0)*gconst98*new_r02))+((gconst97*new_r12)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x190=(gconst103*new_r01);
CheckValue<IkReal> x191 = IKatan2WithCheck((new_r02*x190),((-1.0)*new_r12*x190),IKFAST_ATAN2_MAGTHRESH);
if(!x191.valid){
continue;
}
j31array[0]=x191.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x192=IKcos(j31);
IkReal x193=IKsin(j31);
IkReal x194=((1.0)*gconst98);
IkReal x195=((1.0)*gconst97);
IkReal x196=(gconst97*x193);
IkReal x197=((1.0)*x193);
IkReal x198=(x192*x194);
evalcond[0]=(((new_r02*x192))+((new_r12*x193)));
evalcond[1]=(((new_r12*x192))+(((-1.0)*new_r02*x197)));
evalcond[2]=(((new_r11*x193))+((new_r01*x192))+gconst97);
evalcond[3]=(((gconst98*x193))+new_r01+((gconst97*x192)));
evalcond[4]=((((-1.0)*x198))+x196+new_r00);
evalcond[5]=((((-1.0)*x198))+x196+new_r11);
evalcond[6]=(((new_r10*x193))+((new_r00*x192))+(((-1.0)*x194)));
evalcond[7]=((((-1.0)*x192*x195))+new_r10+(((-1.0)*x193*x194)));
evalcond[8]=(((new_r10*x192))+(((-1.0)*x195))+(((-1.0)*new_r00*x197)));
evalcond[9]=(((new_r11*x192))+(((-1.0)*x194))+(((-1.0)*new_r01*x197)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x199=(gconst102*gconst97);
CheckValue<IkReal> x200 = IKatan2WithCheck((new_r02*x199),((-1.0)*new_r12*x199),IKFAST_ATAN2_MAGTHRESH);
if(!x200.valid){
continue;
}
j31array[0]=x200.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x201=IKcos(j31);
IkReal x202=IKsin(j31);
IkReal x203=((1.0)*gconst98);
IkReal x204=((1.0)*gconst97);
IkReal x205=(gconst97*x202);
IkReal x206=((1.0)*x202);
IkReal x207=(x201*x203);
evalcond[0]=(((new_r02*x201))+((new_r12*x202)));
evalcond[1]=((((-1.0)*new_r02*x206))+((new_r12*x201)));
evalcond[2]=(((new_r11*x202))+gconst97+((new_r01*x201)));
evalcond[3]=(((gconst98*x202))+((gconst97*x201))+new_r01);
evalcond[4]=((((-1.0)*x207))+x205+new_r00);
evalcond[5]=((((-1.0)*x207))+x205+new_r11);
evalcond[6]=(((new_r10*x202))+((new_r00*x201))+(((-1.0)*x203)));
evalcond[7]=((((-1.0)*x201*x204))+(((-1.0)*x202*x203))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x206))+((new_r10*x201))+(((-1.0)*x204)));
evalcond[9]=(((new_r11*x201))+(((-1.0)*x203))+(((-1.0)*new_r01*x206)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst99;
CheckValue<IkReal> x208 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x208.valid){
continue;
}
gconst99=((3.14159265358979)+(((-1.0)*(x208.value))));
IkReal gconst100;
gconst100=IKsin(gconst99);
IkReal gconst101;
gconst101=IKcos(gconst99);
IkReal x209=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst99))+j33)))), 6.28318530717959)));
evalcond[1]=x209;
evalcond[2]=x209;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x209;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst104;
gconst104=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst105;
gconst105=IKsign((((gconst100*new_r12))+(((-1.0)*gconst101*new_r02))));
dummyeval[0]=(((gconst100*new_r12))+(((-1.0)*gconst101*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x210=(gconst105*new_r01);
CheckValue<IkReal> x211 = IKatan2WithCheck((new_r02*x210),((-1.0)*new_r12*x210),IKFAST_ATAN2_MAGTHRESH);
if(!x211.valid){
continue;
}
j31array[0]=x211.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x212=IKcos(j31);
IkReal x213=IKsin(j31);
IkReal x214=((1.0)*gconst101);
IkReal x215=(gconst100*x213);
IkReal x216=(gconst101*x213);
IkReal x217=((1.0)*x213);
IkReal x218=(gconst100*x212);
IkReal x219=(x212*x214);
evalcond[0]=(((new_r02*x212))+((new_r12*x213)));
evalcond[1]=((((-1.0)*new_r02*x217))+((new_r12*x212)));
evalcond[2]=(((new_r01*x212))+gconst100+((new_r11*x213)));
evalcond[3]=(x216+x218+new_r01);
evalcond[4]=(x215+new_r00+(((-1.0)*x219)));
evalcond[5]=(x215+new_r11+(((-1.0)*x219)));
evalcond[6]=(((new_r00*x212))+(((-1.0)*x214))+((new_r10*x213)));
evalcond[7]=((((-1.0)*x218))+(((-1.0)*x213*x214))+new_r10);
evalcond[8]=((((-1.0)*gconst100))+(((-1.0)*new_r00*x217))+((new_r10*x212)));
evalcond[9]=((((-1.0)*new_r01*x217))+(((-1.0)*x214))+((new_r11*x212)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x220=(gconst100*gconst104);
CheckValue<IkReal> x221 = IKatan2WithCheck((new_r02*x220),((-1.0)*new_r12*x220),IKFAST_ATAN2_MAGTHRESH);
if(!x221.valid){
continue;
}
j31array[0]=x221.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x222=IKcos(j31);
IkReal x223=IKsin(j31);
IkReal x224=((1.0)*gconst101);
IkReal x225=(gconst100*x223);
IkReal x226=(gconst101*x223);
IkReal x227=((1.0)*x223);
IkReal x228=(gconst100*x222);
IkReal x229=(x222*x224);
evalcond[0]=(((new_r02*x222))+((new_r12*x223)));
evalcond[1]=(((new_r12*x222))+(((-1.0)*new_r02*x227)));
evalcond[2]=(((new_r01*x222))+((new_r11*x223))+gconst100);
evalcond[3]=(x228+x226+new_r01);
evalcond[4]=(x225+new_r00+(((-1.0)*x229)));
evalcond[5]=(x225+new_r11+(((-1.0)*x229)));
evalcond[6]=(((new_r00*x222))+((new_r10*x223))+(((-1.0)*x224)));
evalcond[7]=((((-1.0)*x223*x224))+new_r10+(((-1.0)*x228)));
evalcond[8]=((((-1.0)*gconst100))+((new_r10*x222))+(((-1.0)*new_r00*x227)));
evalcond[9]=((((-1.0)*new_r01*x227))+((new_r11*x222))+(((-1.0)*x224)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x230=(gconst95*new_r01);
CheckValue<IkReal> x231 = IKatan2WithCheck((new_r02*x230),((-1.0)*new_r12*x230),IKFAST_ATAN2_MAGTHRESH);
if(!x231.valid){
continue;
}
j31array[0]=x231.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x232=IKcos(j31);
IkReal x233=IKsin(j31);
IkReal x234=((1.0)*cj33);
IkReal x235=((1.0)*sj33);
IkReal x236=(sj33*x233);
IkReal x237=((1.0)*x233);
IkReal x238=(x232*x234);
evalcond[0]=(((new_r02*x232))+((new_r12*x233)));
evalcond[1]=((((-1.0)*new_r02*x237))+((new_r12*x232)));
evalcond[2]=(((new_r11*x233))+((new_r01*x232))+sj33);
evalcond[3]=(((cj33*x233))+((sj33*x232))+new_r01);
evalcond[4]=((((-1.0)*x238))+x236+new_r00);
evalcond[5]=((((-1.0)*x238))+x236+new_r11);
evalcond[6]=(((new_r10*x233))+((new_r00*x232))+(((-1.0)*x234)));
evalcond[7]=((((-1.0)*x233*x234))+new_r10+(((-1.0)*x232*x235)));
evalcond[8]=(((new_r10*x232))+(((-1.0)*x235))+(((-1.0)*new_r00*x237)));
evalcond[9]=(((new_r11*x232))+(((-1.0)*x234))+(((-1.0)*new_r01*x237)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x239=(gconst94*sj33);
CheckValue<IkReal> x240 = IKatan2WithCheck((new_r02*x239),((-1.0)*new_r12*x239),IKFAST_ATAN2_MAGTHRESH);
if(!x240.valid){
continue;
}
j31array[0]=x240.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x241=IKcos(j31);
IkReal x242=IKsin(j31);
IkReal x243=((1.0)*cj33);
IkReal x244=((1.0)*sj33);
IkReal x245=(sj33*x242);
IkReal x246=((1.0)*x242);
IkReal x247=(x241*x243);
evalcond[0]=(((new_r12*x242))+((new_r02*x241)));
evalcond[1]=(((new_r12*x241))+(((-1.0)*new_r02*x246)));
evalcond[2]=(sj33+((new_r01*x241))+((new_r11*x242)));
evalcond[3]=(((cj33*x242))+new_r01+((sj33*x241)));
evalcond[4]=(x245+(((-1.0)*x247))+new_r00);
evalcond[5]=(x245+(((-1.0)*x247))+new_r11);
evalcond[6]=(((new_r00*x241))+(((-1.0)*x243))+((new_r10*x242)));
evalcond[7]=((((-1.0)*x242*x243))+(((-1.0)*x241*x244))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x246))+(((-1.0)*x244))+((new_r10*x241)));
evalcond[9]=((((-1.0)*new_r01*x246))+(((-1.0)*x243))+((new_r11*x241)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x248=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x248;
evalcond[2]=x248;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst106;
gconst106=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst107;
gconst107=IKsign((((cj33*new_r12))+(((-1.0)*new_r02*sj33))));
dummyeval[0]=(((cj33*new_r12))+(((-1.0)*new_r02*sj33)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal gconst108;
CheckValue<IkReal> x249 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x249.valid){
continue;
}
gconst108=((-1.0)*(x249.value));
IkReal gconst109;
gconst109=IKsin(gconst108);
IkReal gconst110;
gconst110=IKcos(gconst108);
IkReal x250=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst108)))))), 6.28318530717959)));
evalcond[1]=x250;
evalcond[2]=x250;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst114;
gconst114=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst115;
gconst115=IKsign((((gconst110*new_r12))+(((-1.0)*gconst109*new_r02))));
dummyeval[0]=(((gconst110*new_r12))+(((-1.0)*gconst109*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x251=(gconst115*new_r00);
CheckValue<IkReal> x252 = IKatan2WithCheck((new_r02*x251),((-1.0)*new_r12*x251),IKFAST_ATAN2_MAGTHRESH);
if(!x252.valid){
continue;
}
j31array[0]=x252.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x253=IKcos(j31);
IkReal x254=IKsin(j31);
IkReal x255=((1.0)*gconst109);
IkReal x256=((1.0)*gconst110);
IkReal x257=(gconst110*x254);
IkReal x258=((1.0)*x254);
IkReal x259=(x253*x255);
evalcond[0]=(((new_r02*x253))+((new_r12*x254)));
evalcond[1]=(((new_r12*x253))+(((-1.0)*new_r02*x258)));
evalcond[2]=(((new_r00*x253))+((new_r10*x254))+gconst110);
evalcond[3]=(((gconst110*x253))+new_r00+((gconst109*x254)));
evalcond[4]=(x257+new_r01+(((-1.0)*x259)));
evalcond[5]=(x257+new_r10+(((-1.0)*x259)));
evalcond[6]=(((new_r01*x253))+((new_r11*x254))+(((-1.0)*x255)));
evalcond[7]=((((-1.0)*x254*x255))+new_r11+(((-1.0)*x253*x256)));
evalcond[8]=(((new_r10*x253))+(((-1.0)*new_r00*x258))+(((-1.0)*x255)));
evalcond[9]=((((-1.0)*new_r01*x258))+((new_r11*x253))+(((-1.0)*x256)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x260=(gconst110*gconst114);
CheckValue<IkReal> x261 = IKatan2WithCheck((new_r02*x260),((-1.0)*new_r12*x260),IKFAST_ATAN2_MAGTHRESH);
if(!x261.valid){
continue;
}
j31array[0]=x261.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x262=IKcos(j31);
IkReal x263=IKsin(j31);
IkReal x264=((1.0)*gconst109);
IkReal x265=((1.0)*gconst110);
IkReal x266=(gconst110*x263);
IkReal x267=((1.0)*x263);
IkReal x268=(x262*x264);
evalcond[0]=(((new_r12*x263))+((new_r02*x262)));
evalcond[1]=(((new_r12*x262))+(((-1.0)*new_r02*x267)));
evalcond[2]=(((new_r00*x262))+gconst110+((new_r10*x263)));
evalcond[3]=(((gconst109*x263))+new_r00+((gconst110*x262)));
evalcond[4]=(x266+new_r01+(((-1.0)*x268)));
evalcond[5]=(x266+new_r10+(((-1.0)*x268)));
evalcond[6]=(((new_r01*x262))+(((-1.0)*x264))+((new_r11*x263)));
evalcond[7]=((((-1.0)*x262*x265))+(((-1.0)*x263*x264))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x267))+(((-1.0)*x264))+((new_r10*x262)));
evalcond[9]=((((-1.0)*new_r01*x267))+(((-1.0)*x265))+((new_r11*x262)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst111;
CheckValue<IkReal> x269 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x269.valid){
continue;
}
gconst111=((3.14159265358979)+(((-1.0)*(x269.value))));
IkReal gconst112;
gconst112=IKsin(gconst111);
IkReal gconst113;
gconst113=IKcos(gconst111);
IkReal x270=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst111)))))), 6.28318530717959)));
evalcond[1]=x270;
evalcond[2]=x270;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst116;
gconst116=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst117;
gconst117=IKsign((((gconst113*new_r12))+(((-1.0)*gconst112*new_r02))));
dummyeval[0]=(((gconst113*new_r12))+(((-1.0)*gconst112*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x271=(gconst117*new_r00);
CheckValue<IkReal> x272 = IKatan2WithCheck((new_r02*x271),((-1.0)*new_r12*x271),IKFAST_ATAN2_MAGTHRESH);
if(!x272.valid){
continue;
}
j31array[0]=x272.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x273=IKcos(j31);
IkReal x274=IKsin(j31);
IkReal x275=((1.0)*gconst112);
IkReal x276=(gconst113*x274);
IkReal x277=(gconst112*x274);
IkReal x278=((1.0)*x273);
IkReal x279=((1.0)*x274);
IkReal x280=(x273*x275);
evalcond[0]=(((new_r02*x273))+((new_r12*x274)));
evalcond[1]=((((-1.0)*new_r02*x279))+((new_r12*x273)));
evalcond[2]=(((new_r00*x273))+gconst113+((new_r10*x274)));
evalcond[3]=(((gconst113*x273))+x277+new_r00);
evalcond[4]=(x276+(((-1.0)*x280))+new_r01);
evalcond[5]=(x276+(((-1.0)*x280))+new_r10);
evalcond[6]=(((new_r01*x273))+(((-1.0)*x275))+((new_r11*x274)));
evalcond[7]=((((-1.0)*x274*x275))+(((-1.0)*gconst113*x278))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x279))+(((-1.0)*x275))+((new_r10*x273)));
evalcond[9]=((((-1.0)*new_r01*x279))+(((-1.0)*gconst113))+((new_r11*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x281=(gconst113*gconst116);
CheckValue<IkReal> x282 = IKatan2WithCheck((new_r02*x281),((-1.0)*new_r12*x281),IKFAST_ATAN2_MAGTHRESH);
if(!x282.valid){
continue;
}
j31array[0]=x282.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x283=IKcos(j31);
IkReal x284=IKsin(j31);
IkReal x285=((1.0)*gconst112);
IkReal x286=(gconst113*x284);
IkReal x287=(gconst112*x284);
IkReal x288=((1.0)*x283);
IkReal x289=((1.0)*x284);
IkReal x290=(x283*x285);
evalcond[0]=(((new_r02*x283))+((new_r12*x284)));
evalcond[1]=((((-1.0)*new_r02*x289))+((new_r12*x283)));
evalcond[2]=(gconst113+((new_r00*x283))+((new_r10*x284)));
evalcond[3]=(x287+new_r00+((gconst113*x283)));
evalcond[4]=((((-1.0)*x290))+x286+new_r01);
evalcond[5]=((((-1.0)*x290))+x286+new_r10);
evalcond[6]=((((-1.0)*x285))+((new_r11*x284))+((new_r01*x283)));
evalcond[7]=((((-1.0)*x284*x285))+(((-1.0)*gconst113*x288))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x289))+(((-1.0)*x285))+((new_r10*x283)));
evalcond[9]=((((-1.0)*new_r01*x289))+((new_r11*x283))+(((-1.0)*gconst113)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x291=(gconst107*new_r00);
CheckValue<IkReal> x292 = IKatan2WithCheck((new_r02*x291),((-1.0)*new_r12*x291),IKFAST_ATAN2_MAGTHRESH);
if(!x292.valid){
continue;
}
j31array[0]=x292.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x293=IKcos(j31);
IkReal x294=IKsin(j31);
IkReal x295=((1.0)*sj33);
IkReal x296=(cj33*x294);
IkReal x297=(cj33*x293);
IkReal x298=((1.0)*x294);
IkReal x299=(x293*x295);
evalcond[0]=(((new_r02*x293))+((new_r12*x294)));
evalcond[1]=(((new_r12*x293))+(((-1.0)*new_r02*x298)));
evalcond[2]=(((new_r10*x294))+((new_r00*x293))+cj33);
evalcond[3]=(x297+new_r00+((sj33*x294)));
evalcond[4]=((((-1.0)*x299))+x296+new_r01);
evalcond[5]=((((-1.0)*x299))+x296+new_r10);
evalcond[6]=(((new_r11*x294))+(((-1.0)*x295))+((new_r01*x293)));
evalcond[7]=((((-1.0)*x297))+new_r11+(((-1.0)*x294*x295)));
evalcond[8]=((((-1.0)*x295))+((new_r10*x293))+(((-1.0)*new_r00*x298)));
evalcond[9]=((((-1.0)*new_r01*x298))+((new_r11*x293))+(((-1.0)*cj33)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x300=(cj33*gconst106);
CheckValue<IkReal> x301 = IKatan2WithCheck((new_r02*x300),((-1.0)*new_r12*x300),IKFAST_ATAN2_MAGTHRESH);
if(!x301.valid){
continue;
}
j31array[0]=x301.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x302=IKcos(j31);
IkReal x303=IKsin(j31);
IkReal x304=((1.0)*sj33);
IkReal x305=(cj33*x303);
IkReal x306=(cj33*x302);
IkReal x307=((1.0)*x303);
IkReal x308=(x302*x304);
evalcond[0]=(((new_r12*x303))+((new_r02*x302)));
evalcond[1]=((((-1.0)*new_r02*x307))+((new_r12*x302)));
evalcond[2]=(((new_r00*x302))+((new_r10*x303))+cj33);
evalcond[3]=(((sj33*x303))+x306+new_r00);
evalcond[4]=(x305+new_r01+(((-1.0)*x308)));
evalcond[5]=(x305+new_r10+(((-1.0)*x308)));
evalcond[6]=(((new_r01*x302))+((new_r11*x303))+(((-1.0)*x304)));
evalcond[7]=((((-1.0)*x303*x304))+(((-1.0)*x306))+new_r11);
evalcond[8]=(((new_r10*x302))+(((-1.0)*new_r00*x307))+(((-1.0)*x304)));
evalcond[9]=(((new_r11*x302))+(((-1.0)*cj33))+(((-1.0)*new_r01*x307)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x309 = IKatan2WithCheck((gconst93*new_r12),(gconst93*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x309.valid){
continue;
}
j31array[0]=x309.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x310=IKcos(j31);
IkReal x311=IKsin(j31);
IkReal x312=((1.0)*cj33);
IkReal x313=((1.0)*sj33);
IkReal x314=(cj32*sj33);
IkReal x315=((1.0)*sj32);
IkReal x316=(new_r10*x311);
IkReal x317=(cj32*x310);
IkReal x318=(sj32*x310);
IkReal x319=(new_r11*x311);
IkReal x320=(new_r12*x311);
IkReal x321=((1.0)*x311);
evalcond[0]=((((-1.0)*x310*x315))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x311*x315)));
evalcond[2]=((((-1.0)*new_r02*x321))+((new_r12*x310)));
evalcond[3]=(((x310*x314))+((cj33*x311))+new_r01);
evalcond[4]=(x320+((new_r02*x310))+(((-1.0)*x315)));
evalcond[5]=(((new_r01*x310))+x319+x314);
evalcond[6]=(((sj33*x311))+(((-1.0)*x312*x317))+new_r00);
evalcond[7]=((((-1.0)*x310*x312))+((x311*x314))+new_r11);
evalcond[8]=((((-1.0)*x313))+((new_r10*x310))+(((-1.0)*new_r00*x321)));
evalcond[9]=((((-1.0)*new_r01*x321))+(((-1.0)*x312))+((new_r11*x310)));
evalcond[10]=(((new_r00*x310))+x316+(((-1.0)*cj32*x312)));
evalcond[11]=((((-1.0)*x310*x313))+(((-1.0)*cj32*x311*x312))+new_r10);
evalcond[12]=(((new_r00*x318))+((cj32*new_r20))+((sj32*x316)));
evalcond[13]=(((new_r01*x318))+((cj32*new_r21))+((sj32*x319)));
evalcond[14]=((-1.0)+((new_r02*x318))+((sj32*x320))+((cj32*new_r22)));
evalcond[15]=(((cj32*x320))+(((-1.0)*new_r22*x315))+((new_r02*x317)));
evalcond[16]=((((-1.0)*new_r21*x315))+((cj32*x319))+((new_r01*x317))+sj33);
evalcond[17]=((((-1.0)*new_r20*x315))+((new_r00*x317))+((cj32*x316))+(((-1.0)*x312)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x322 = IKatan2WithCheck((gconst92*new_r12),(gconst92*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x322.valid){
continue;
}
j31array[0]=x322.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x323=IKcos(j31);
IkReal x324=IKsin(j31);
IkReal x325=((1.0)*cj33);
IkReal x326=((1.0)*sj33);
IkReal x327=(cj32*sj33);
IkReal x328=((1.0)*sj32);
IkReal x329=(new_r10*x324);
IkReal x330=(cj32*x323);
IkReal x331=(sj32*x323);
IkReal x332=(new_r11*x324);
IkReal x333=(new_r12*x324);
IkReal x334=((1.0)*x324);
evalcond[0]=((((-1.0)*x323*x328))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x324*x328)));
evalcond[2]=(((new_r12*x323))+(((-1.0)*new_r02*x334)));
evalcond[3]=(((x323*x327))+new_r01+((cj33*x324)));
evalcond[4]=((((-1.0)*x328))+x333+((new_r02*x323)));
evalcond[5]=(((new_r01*x323))+x332+x327);
evalcond[6]=(((sj33*x324))+new_r00+(((-1.0)*x325*x330)));
evalcond[7]=((((-1.0)*x323*x325))+((x324*x327))+new_r11);
evalcond[8]=((((-1.0)*x326))+(((-1.0)*new_r00*x334))+((new_r10*x323)));
evalcond[9]=((((-1.0)*x325))+(((-1.0)*new_r01*x334))+((new_r11*x323)));
evalcond[10]=(((new_r00*x323))+x329+(((-1.0)*cj32*x325)));
evalcond[11]=((((-1.0)*cj32*x324*x325))+(((-1.0)*x323*x326))+new_r10);
evalcond[12]=(((new_r00*x331))+((sj32*x329))+((cj32*new_r20)));
evalcond[13]=(((new_r01*x331))+((cj32*new_r21))+((sj32*x332)));
evalcond[14]=((-1.0)+((new_r02*x331))+((cj32*new_r22))+((sj32*x333)));
evalcond[15]=((((-1.0)*new_r22*x328))+((new_r02*x330))+((cj32*x333)));
evalcond[16]=(((new_r01*x330))+sj33+((cj32*x332))+(((-1.0)*new_r21*x328)));
evalcond[17]=(((cj32*x329))+((new_r00*x330))+(((-1.0)*x325))+(((-1.0)*new_r20*x328)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x335 = IKatan2WithCheck((gconst90*new_r12),(gconst90*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x335.valid){
continue;
}
j31array[0]=x335.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x336=IKcos(j31);
IkReal x337=IKsin(j31);
IkReal x338=((1.0)*sj32);
IkReal x339=(new_r02*x336);
IkReal x340=(new_r12*x337);
IkReal x341=(sj32*x336);
IkReal x342=(sj32*x337);
evalcond[0]=(new_r02+(((-1.0)*x336*x338)));
evalcond[1]=((((-1.0)*x337*x338))+new_r12);
evalcond[2]=(((new_r12*x336))+(((-1.0)*new_r02*x337)));
evalcond[3]=(x339+x340+(((-1.0)*x338)));
evalcond[4]=(((new_r00*x341))+((new_r10*x342))+((cj32*new_r20)));
evalcond[5]=(((new_r11*x342))+((new_r01*x341))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((cj32*new_r22))+((sj32*x339))+((sj32*x340)));
evalcond[7]=((((-1.0)*new_r22*x338))+((cj32*x340))+((cj32*x339)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst118;
gconst118=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj31;
dummyeval[1]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[3];
dummyeval[0]=cj31;
dummyeval[1]=cj32;
dummyeval[2]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  || IKabs(dummyeval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x343=((((-1.0)*cj32))+new_r22);
IkReal x344=((((-1.0)*sj32))+new_r12);
IkReal x345=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x343;
evalcond[2]=x343;
evalcond[3]=new_r02;
evalcond[4]=x344;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x344;
evalcond[7]=(((new_r10*sj32))+((cj32*new_r20)));
evalcond[8]=(((new_r11*sj32))+((cj32*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));
evalcond[10]=(((cj32*new_r12))+(((-1.0)*new_r22*x345)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst119;
gconst119=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=cj32;
dummyeval[1]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[15];
bool bgotonextstatement = true;
do
{
IkReal x346=((-1.0)+new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=new_r02;
evalcond[4]=x346;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x346;
evalcond[7]=new_r11;
evalcond[8]=new_r10;
evalcond[9]=new_r11;
evalcond[10]=new_r10;
evalcond[11]=new_r10;
evalcond[12]=new_r11;
evalcond[13]=x346;
evalcond[14]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x347=IKcos(j33);
IkReal x348=((1.0)*(IKsin(j33)));
evalcond[0]=(x347+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x348)));
evalcond[2]=((((-1.0)*new_r00))+(((-1.0)*x348)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x347)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x349=((1.0)+new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=new_r02;
evalcond[4]=x349;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x349;
evalcond[7]=new_r11;
evalcond[8]=new_r10;
evalcond[9]=new_r11;
evalcond[10]=new_r10;
evalcond[11]=((-1.0)*new_r10);
evalcond[12]=((-1.0)*new_r11);
evalcond[13]=((-1.0)+(((-1.0)*new_r12)));
evalcond[14]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x350=IKsin(j33);
IkReal x351=((1.0)*(IKcos(j33)));
evalcond[0]=(x350+new_r21);
evalcond[1]=((((-1.0)*x351))+new_r20);
evalcond[2]=((((-1.0)*x350))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x351))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x352=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x352;
evalcond[2]=x352;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r02);
evalcond[10]=new_r12;
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x352;
evalcond[14]=new_r12;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x353=IKsin(j33);
IkReal x354=((1.0)*(IKcos(j33)));
evalcond[0]=(x353+new_r11);
evalcond[1]=((((-1.0)*x354))+new_r10);
evalcond[2]=((((-1.0)*x353))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x354))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x355=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x355;
evalcond[2]=x355;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r02);
evalcond[10]=new_r12;
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
evalcond[14]=((-1.0)*new_r12);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x356=IKcos(j33);
IkReal x357=((1.0)*(IKsin(j33)));
evalcond[0]=(x356+new_r10);
evalcond[1]=((((-1.0)*x357))+new_r11);
evalcond[2]=((((-1.0)*x357))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x356))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x358=IKPowWithIntegerCheck(cj32,-1);
if(!x358.valid){
continue;
}
CheckValue<IkReal> x359=IKPowWithIntegerCheck(sj32,-1);
if(!x359.valid){
continue;
}
if( IKabs(((-1.0)*new_r11*(x358.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x359.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11*(x358.value)))+IKsqr(((-1.0)*new_r20*(x359.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r11*(x358.value)), ((-1.0)*new_r20*(x359.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x360=IKsin(j33);
IkReal x361=IKcos(j33);
IkReal x362=((1.0)*sj32);
IkReal x363=((1.0)*x361);
evalcond[0]=(((sj32*x361))+new_r20);
evalcond[1]=(((cj32*x360))+new_r11);
evalcond[2]=((((-1.0)*x360*x362))+new_r21);
evalcond[3]=((((-1.0)*cj32*x363))+new_r10);
evalcond[4]=((((-1.0)*x360))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x363))+(((-1.0)*new_r01)));
evalcond[6]=(((cj32*new_r11))+x360+(((-1.0)*new_r21*x362)));
evalcond[7]=((((-1.0)*new_r20*x362))+((cj32*new_r10))+(((-1.0)*x363)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x364 = IKatan2WithCheck((gconst119*new_r21),((-1.0)*gconst119*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x364.valid){
continue;
}
j33array[0]=x364.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x365=IKsin(j33);
IkReal x366=IKcos(j33);
IkReal x367=((1.0)*sj32);
IkReal x368=((1.0)*x366);
evalcond[0]=(((sj32*x366))+new_r20);
evalcond[1]=(((cj32*x365))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x365*x367)));
evalcond[3]=((((-1.0)*cj32*x368))+new_r10);
evalcond[4]=((((-1.0)*x365))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x368))+(((-1.0)*new_r01)));
evalcond[6]=(((cj32*new_r11))+x365+(((-1.0)*new_r21*x367)));
evalcond[7]=((((-1.0)*new_r20*x367))+((cj32*new_r10))+(((-1.0)*x368)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x369=((((-1.0)*cj32))+new_r22);
IkReal x370=((1.0)*sj32);
IkReal x371=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x369;
evalcond[2]=x369;
evalcond[3]=new_r02;
evalcond[4]=(sj32+new_r12);
evalcond[5]=new_r02;
evalcond[6]=new_r02;
evalcond[7]=((((-1.0)*x370))+(((-1.0)*x371)));
evalcond[8]=((((-1.0)*new_r10*x370))+((cj32*new_r20)));
evalcond[9]=((((-1.0)*new_r11*x370))+((cj32*new_r21)));
evalcond[10]=((-1.0)+(((-1.0)*new_r12*x370))+((cj32*new_r22)));
evalcond[11]=((((-1.0)*new_r22*x370))+(((-1.0)*cj32*x371)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r00, new_r01);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x372=IKcos(j33);
IkReal x373=IKsin(j33);
IkReal x374=((1.0)*sj32);
IkReal x375=((1.0)*new_r11);
IkReal x376=((1.0)*new_r10);
IkReal x377=((1.0)*x372);
evalcond[0]=(new_r20+((sj32*x372)));
evalcond[1]=((((-1.0)*x373))+new_r00);
evalcond[2]=((((-1.0)*x377))+new_r01);
evalcond[3]=((((-1.0)*x373*x374))+new_r21);
evalcond[4]=((((-1.0)*x375))+((cj32*x373)));
evalcond[5]=((((-1.0)*x376))+(((-1.0)*cj32*x377)));
evalcond[6]=((((-1.0)*new_r21*x374))+x373+(((-1.0)*cj32*x375)));
evalcond[7]=((((-1.0)*new_r20*x374))+(((-1.0)*x377))+(((-1.0)*cj32*x376)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x378=((1.0)*sj31);
IkReal x379=(((cj31*new_r12))+(((-1.0)*new_r02*x378)));
IkReal x380=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x381=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x382=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((((-1.0)*cj31))+new_r02);
evalcond[4]=((((-1.0)*x378))+new_r12);
evalcond[5]=x379;
evalcond[6]=x379;
evalcond[7]=x382;
evalcond[8]=x381;
evalcond[9]=x380;
evalcond[10]=x380;
evalcond[11]=x381;
evalcond[12]=x382;
evalcond[13]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x383=IKcos(j33);
IkReal x384=IKsin(j33);
IkReal x385=((1.0)*sj31);
IkReal x386=((1.0)*x384);
IkReal x387=((1.0)*x383);
evalcond[0]=(x383+new_r20);
evalcond[1]=((((-1.0)*x386))+new_r21);
evalcond[2]=(((sj31*x383))+new_r01);
evalcond[3]=(((sj31*x384))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj31*x387)));
evalcond[5]=(new_r10+(((-1.0)*cj31*x386)));
evalcond[6]=(((cj31*new_r10))+(((-1.0)*new_r00*x385))+(((-1.0)*x386)));
evalcond[7]=(((cj31*new_r11))+(((-1.0)*new_r01*x385))+(((-1.0)*x387)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x388=(new_r10*sj31);
IkReal x389=(cj31*new_r00);
IkReal x390=(cj31*new_r02);
IkReal x391=(new_r11*sj31);
IkReal x392=(new_r12*sj31);
IkReal x393=(cj31*new_r01);
IkReal x394=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=(cj31+new_r02);
evalcond[4]=(sj31+new_r12);
evalcond[5]=x394;
evalcond[6]=x394;
evalcond[7]=((1.0)+x390+x392);
evalcond[8]=(x391+x393);
evalcond[9]=(x388+x389);
evalcond[10]=((((-1.0)*x388))+(((-1.0)*x389)));
evalcond[11]=((((-1.0)*x393))+(((-1.0)*x391)));
evalcond[12]=((-1.0)+(((-1.0)*x390))+(((-1.0)*x392)));
evalcond[13]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x395=IKcos(j33);
IkReal x396=IKsin(j33);
IkReal x397=((1.0)*sj31);
IkReal x398=((1.0)*x395);
IkReal x399=((1.0)*x396);
evalcond[0]=(x396+new_r21);
evalcond[1]=((((-1.0)*x398))+new_r20);
evalcond[2]=(((sj31*x395))+new_r01);
evalcond[3]=(((sj31*x396))+new_r00);
evalcond[4]=((((-1.0)*cj31*x398))+new_r11);
evalcond[5]=((((-1.0)*cj31*x399))+new_r10);
evalcond[6]=((((-1.0)*x399))+((cj31*new_r10))+(((-1.0)*new_r00*x397)));
evalcond[7]=((((-1.0)*new_r01*x397))+(((-1.0)*x398))+((cj31*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x400=((-1.0)+new_r22);
IkReal x401=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x402=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x400;
evalcond[2]=x400;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x401;
evalcond[10]=x401;
evalcond[11]=x402;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x400;
evalcond[15]=x402;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst120;
gconst120=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst121;
gconst121=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x403 = IKatan2WithCheck((gconst121*((((cj31*new_r01))+((new_r11*sj31))))),(gconst121*(((((-1.0)*cj31*new_r11))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x403.valid){
continue;
}
j33array[0]=x403.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x404=IKsin(j33);
IkReal x405=IKcos(j33);
IkReal x406=((1.0)*sj31);
IkReal x407=((1.0)*x405);
IkReal x408=(sj31*x404);
IkReal x409=((1.0)*x404);
IkReal x410=(cj31*x407);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x404);
evalcond[1]=(((sj31*x405))+((cj31*x404))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x407)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x406))+(((-1.0)*x409)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x406))+(((-1.0)*x407)));
evalcond[5]=(x408+new_r00+(((-1.0)*x410)));
evalcond[6]=(x408+new_r11+(((-1.0)*x410)));
evalcond[7]=((((-1.0)*cj31*x409))+new_r10+(((-1.0)*x405*x406)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x411 = IKatan2WithCheck((gconst120*((((new_r00*sj31))+((cj31*new_r01))))),(gconst120*(((((-1.0)*cj31*new_r00))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x411.valid){
continue;
}
j33array[0]=x411.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x412=IKsin(j33);
IkReal x413=IKcos(j33);
IkReal x414=((1.0)*sj31);
IkReal x415=((1.0)*x413);
IkReal x416=(sj31*x412);
IkReal x417=((1.0)*x412);
IkReal x418=(cj31*x415);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x412);
evalcond[1]=(((sj31*x413))+((cj31*x412))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x415)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x414))+(((-1.0)*x417)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x415))+(((-1.0)*new_r01*x414)));
evalcond[5]=(x416+new_r00+(((-1.0)*x418)));
evalcond[6]=(x416+new_r11+(((-1.0)*x418)));
evalcond[7]=((((-1.0)*cj31*x417))+(((-1.0)*x413*x414))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x419=((1.0)+new_r22);
IkReal x420=(cj31*new_r02);
IkReal x421=(new_r12*sj31);
IkReal x422=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x419;
evalcond[2]=x419;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x422;
evalcond[10]=x422;
evalcond[11]=(x421+x420);
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x421))+(((-1.0)*x420)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst122;
gconst122=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst123;
gconst123=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x423=((1.0)*sj31);
CheckValue<IkReal> x424 = IKatan2WithCheck((gconst123*((((cj31*new_r10))+(((-1.0)*new_r00*x423))))),(gconst123*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x423))))),IKFAST_ATAN2_MAGTHRESH);
if(!x424.valid){
continue;
}
j33array[0]=x424.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x425=IKsin(j33);
IkReal x426=IKcos(j33);
IkReal x427=((1.0)*sj31);
IkReal x428=((1.0)*x425);
IkReal x429=(sj31*x426);
IkReal x430=((1.0)*x426);
IkReal x431=(cj31*x428);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x426);
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x428))+((new_r11*sj31)));
evalcond[2]=(((cj31*x426))+((sj31*x425))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x427))+(((-1.0)*x428)));
evalcond[4]=((((-1.0)*x430))+((cj31*new_r11))+(((-1.0)*new_r01*x427)));
evalcond[5]=((((-1.0)*x431))+x429+new_r01);
evalcond[6]=((((-1.0)*x431))+x429+new_r10);
evalcond[7]=((((-1.0)*cj31*x430))+(((-1.0)*x425*x427))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x432=((1.0)*new_r00);
CheckValue<IkReal> x433 = IKatan2WithCheck((gconst122*((((cj31*new_r01))+(((-1.0)*sj31*x432))))),(gconst122*(((((-1.0)*cj31*x432))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x433.valid){
continue;
}
j33array[0]=x433.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x434=IKsin(j33);
IkReal x435=IKcos(j33);
IkReal x436=((1.0)*sj31);
IkReal x437=((1.0)*x434);
IkReal x438=(sj31*x435);
IkReal x439=((1.0)*x435);
IkReal x440=(cj31*x437);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x435);
evalcond[1]=((((-1.0)*x437))+((cj31*new_r01))+((new_r11*sj31)));
evalcond[2]=(((cj31*x435))+((sj31*x434))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x436))+(((-1.0)*x437))+((cj31*new_r10)));
evalcond[4]=((((-1.0)*x439))+(((-1.0)*new_r01*x436))+((cj31*new_r11)));
evalcond[5]=((((-1.0)*x440))+x438+new_r01);
evalcond[6]=((((-1.0)*x440))+x438+new_r10);
evalcond[7]=((((-1.0)*x434*x436))+(((-1.0)*cj31*x439))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x441=((((-1.0)*cj32))+new_r22);
IkReal x442=((((-1.0)*sj32))+new_r02);
IkReal x443=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x441;
evalcond[2]=x441;
evalcond[3]=x442;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x442;
evalcond[8]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[9]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[10]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[11]=(((cj32*new_r02))+(((-1.0)*new_r22*x443)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x444=IKcos(j33);
IkReal x445=IKsin(j33);
IkReal x446=((1.0)*sj32);
IkReal x447=((1.0)*x444);
evalcond[0]=(((sj32*x444))+new_r20);
evalcond[1]=((((-1.0)*x445))+new_r10);
evalcond[2]=((((-1.0)*x447))+new_r11);
evalcond[3]=(((cj32*x445))+new_r01);
evalcond[4]=((((-1.0)*x445*x446))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*cj32*x447)));
evalcond[6]=(((cj32*new_r01))+x445+(((-1.0)*new_r21*x446)));
evalcond[7]=((((-1.0)*x447))+((cj32*new_r00))+(((-1.0)*new_r20*x446)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x448=((((-1.0)*cj32))+new_r22);
IkReal x449=((1.0)*sj32);
IkReal x450=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x448;
evalcond[2]=x448;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x449))+(((-1.0)*x450)));
evalcond[7]=((((-1.0)*new_r00*x449))+((cj32*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x449))+((cj32*new_r21)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x449))+((cj32*new_r22)));
evalcond[10]=((((-1.0)*cj32*x450))+(((-1.0)*new_r22*x449)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst124;
gconst124=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[14];
bool bgotonextstatement = true;
do
{
IkReal x451=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x451;
evalcond[2]=x451;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x451;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x452=IKsin(j33);
IkReal x453=((1.0)*(IKcos(j33)));
evalcond[0]=(x452+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x452))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x453))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x453))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x454=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x454;
evalcond[2]=x454;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x455=IKcos(j33);
IkReal x456=((1.0)*(IKsin(j33)));
evalcond[0]=(x455+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x456))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x455))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x456))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x457=IKPowWithIntegerCheck(sj32,-1);
if(!x457.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x457.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r20*(x457.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r20*(x457.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x458=IKsin(j33);
IkReal x459=IKcos(j33);
IkReal x460=((1.0)*new_r00);
IkReal x461=((1.0)*sj32);
IkReal x462=((1.0)*new_r01);
IkReal x463=((1.0)*x459);
evalcond[0]=(((sj32*x459))+new_r20);
evalcond[1]=((((-1.0)*x458*x461))+new_r21);
evalcond[2]=((((-1.0)*x458))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x463))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x462))+((cj32*x458)));
evalcond[5]=((((-1.0)*cj32*x463))+(((-1.0)*x460)));
evalcond[6]=((((-1.0)*new_r21*x461))+(((-1.0)*cj32*x462))+x458);
evalcond[7]=((((-1.0)*new_r20*x461))+(((-1.0)*cj32*x460))+(((-1.0)*x463)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x464=IKPowWithIntegerCheck(sj32,-1);
if(!x464.valid){
continue;
}
if( IKabs((new_r21*(x464.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x464.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*(x464.value)), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x465=IKsin(j33);
IkReal x466=IKcos(j33);
IkReal x467=((1.0)*new_r00);
IkReal x468=((1.0)*sj32);
IkReal x469=((1.0)*new_r01);
IkReal x470=((1.0)*x466);
evalcond[0]=(((sj32*x466))+new_r20);
evalcond[1]=((((-1.0)*x465*x468))+new_r21);
evalcond[2]=((((-1.0)*x465))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x470))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x469))+((cj32*x465)));
evalcond[5]=((((-1.0)*cj32*x470))+(((-1.0)*x467)));
evalcond[6]=((((-1.0)*new_r21*x468))+(((-1.0)*cj32*x469))+x465);
evalcond[7]=((((-1.0)*new_r20*x468))+(((-1.0)*cj32*x467))+(((-1.0)*x470)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x471 = IKatan2WithCheck((gconst124*new_r21),((-1.0)*gconst124*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x471.valid){
continue;
}
j33array[0]=x471.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x472=IKsin(j33);
IkReal x473=IKcos(j33);
IkReal x474=((1.0)*new_r00);
IkReal x475=((1.0)*sj32);
IkReal x476=((1.0)*new_r01);
IkReal x477=((1.0)*x473);
evalcond[0]=(((sj32*x473))+new_r20);
evalcond[1]=((((-1.0)*x472*x475))+new_r21);
evalcond[2]=((((-1.0)*x472))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x477))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*x476))+((cj32*x472)));
evalcond[5]=((((-1.0)*cj32*x477))+(((-1.0)*x474)));
evalcond[6]=((((-1.0)*cj32*x476))+(((-1.0)*new_r21*x475))+x472);
evalcond[7]=((((-1.0)*cj32*x474))+(((-1.0)*x477))+(((-1.0)*new_r20*x475)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x478=((-1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x478;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x478;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=new_r00;
evalcond[13]=new_r01;
evalcond[14]=x478;
evalcond[15]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x479=IKcos(j33);
IkReal x480=((1.0)*(IKsin(j33)));
evalcond[0]=(x479+new_r20);
evalcond[1]=((((-1.0)*x480))+new_r21);
evalcond[2]=((((-1.0)*x480))+new_r10);
evalcond[3]=((((-1.0)*x479))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((-1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x481=IKcos(j33);
IkReal x482=((1.0)*(IKsin(j33)));
evalcond[0]=(x481+new_r20);
evalcond[1]=((((-1.0)*x482))+new_r21);
evalcond[2]=((((-1.0)*x482))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x481))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x483=((1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x483;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x483;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=((-1.0)*new_r00);
evalcond[13]=((-1.0)*new_r01);
evalcond[14]=((-1.0)+(((-1.0)*new_r02)));
evalcond[15]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x484=IKsin(j33);
IkReal x485=((1.0)*(IKcos(j33)));
evalcond[0]=(x484+new_r21);
evalcond[1]=((((-1.0)*x485))+new_r20);
evalcond[2]=((((-1.0)*x484))+new_r10);
evalcond[3]=((((-1.0)*x485))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((-1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x486=IKsin(j33);
IkReal x487=((1.0)*(IKcos(j33)));
evalcond[0]=(x486+new_r21);
evalcond[1]=((((-1.0)*x487))+new_r20);
evalcond[2]=((((-1.0)*x486))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x487))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x488=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959))))));
evalcond[1]=x488;
evalcond[2]=x488;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x488;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x489=IKsin(j33);
IkReal x490=((1.0)*(IKcos(j33)));
evalcond[0]=(x489+new_r01);
evalcond[1]=((((-1.0)*x489))+new_r10);
evalcond[2]=((((-1.0)*x490))+new_r11);
evalcond[3]=((((-1.0)*x490))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x491=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959))))));
evalcond[1]=x491;
evalcond[2]=x491;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x492=IKcos(j33);
IkReal x493=((1.0)*(IKsin(j33)));
evalcond[0]=(x492+new_r00);
evalcond[1]=((((-1.0)*x493))+new_r10);
evalcond[2]=((((-1.0)*x492))+new_r11);
evalcond[3]=((((-1.0)*x493))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x495=IKPowWithIntegerCheck(sj32,-1);
if(!x495.valid){
continue;
}
IkReal x494=x495.value;
CheckValue<IkReal> x496=IKPowWithIntegerCheck(cj31,-1);
if(!x496.valid){
continue;
}
CheckValue<IkReal> x497=IKPowWithIntegerCheck(cj32,-1);
if(!x497.valid){
continue;
}
if( IKabs((x494*(x496.value)*(x497.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x494)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x494*(x496.value)*(x497.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x494))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x494*(x496.value)*(x497.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x494));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x498=IKsin(j33);
IkReal x499=IKcos(j33);
IkReal x500=(cj31*cj32);
IkReal x501=((1.0)*sj31);
IkReal x502=(new_r11*sj31);
IkReal x503=(new_r10*sj31);
IkReal x504=((1.0)*sj32);
IkReal x505=((1.0)*x499);
IkReal x506=((1.0)*x498);
IkReal x507=(sj31*x498);
evalcond[0]=(((sj32*x499))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x498*x504)));
evalcond[2]=(((cj32*x498))+((cj31*new_r01))+x502);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x501))+(((-1.0)*x506)));
evalcond[4]=((((-1.0)*new_r01*x501))+((cj31*new_r11))+(((-1.0)*x505)));
evalcond[5]=(((sj31*x499))+((x498*x500))+new_r01);
evalcond[6]=((((-1.0)*cj32*x505))+((cj31*new_r00))+x503);
evalcond[7]=(x507+new_r00+(((-1.0)*x500*x505)));
evalcond[8]=((((-1.0)*cj31*x505))+new_r11+((cj32*x507)));
evalcond[9]=((((-1.0)*cj32*x499*x501))+(((-1.0)*cj31*x506))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x504))+x498+((new_r01*x500))+((cj32*x502)));
evalcond[11]=((((-1.0)*new_r20*x504))+(((-1.0)*x505))+((new_r00*x500))+((cj32*x503)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x509=IKPowWithIntegerCheck(sj32,-1);
if(!x509.valid){
continue;
}
IkReal x508=x509.value;
CheckValue<IkReal> x510=IKPowWithIntegerCheck(sj31,-1);
if(!x510.valid){
continue;
}
if( IKabs((x508*(x510.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x508)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x508*(x510.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x508))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x508*(x510.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x508));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x511=IKsin(j33);
IkReal x512=IKcos(j33);
IkReal x513=(cj31*cj32);
IkReal x514=((1.0)*sj31);
IkReal x515=(new_r11*sj31);
IkReal x516=(new_r10*sj31);
IkReal x517=((1.0)*sj32);
IkReal x518=((1.0)*x512);
IkReal x519=((1.0)*x511);
IkReal x520=(sj31*x511);
evalcond[0]=(((sj32*x512))+new_r20);
evalcond[1]=((((-1.0)*x511*x517))+new_r21);
evalcond[2]=(((cj31*new_r01))+x515+((cj32*x511)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x514))+(((-1.0)*x519)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x514))+(((-1.0)*x518)));
evalcond[5]=(((x511*x513))+new_r01+((sj31*x512)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x518))+x516);
evalcond[7]=((((-1.0)*x513*x518))+x520+new_r00);
evalcond[8]=((((-1.0)*cj31*x518))+((cj32*x520))+new_r11);
evalcond[9]=((((-1.0)*cj31*x519))+(((-1.0)*cj32*x512*x514))+new_r10);
evalcond[10]=(((new_r01*x513))+x511+((cj32*x515))+(((-1.0)*new_r21*x517)));
evalcond[11]=(((new_r00*x513))+((cj32*x516))+(((-1.0)*new_r20*x517))+(((-1.0)*x518)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x521 = IKatan2WithCheck((gconst118*new_r21),((-1.0)*gconst118*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x521.valid){
continue;
}
j33array[0]=x521.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x522=IKsin(j33);
IkReal x523=IKcos(j33);
IkReal x524=(cj31*cj32);
IkReal x525=((1.0)*sj31);
IkReal x526=(new_r11*sj31);
IkReal x527=(new_r10*sj31);
IkReal x528=((1.0)*sj32);
IkReal x529=((1.0)*x523);
IkReal x530=((1.0)*x522);
IkReal x531=(sj31*x522);
evalcond[0]=(((sj32*x523))+new_r20);
evalcond[1]=((((-1.0)*x522*x528))+new_r21);
evalcond[2]=(((cj32*x522))+((cj31*new_r01))+x526);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x525))+(((-1.0)*x530)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x529))+(((-1.0)*new_r01*x525)));
evalcond[5]=(((x522*x524))+((sj31*x523))+new_r01);
evalcond[6]=((((-1.0)*cj32*x529))+((cj31*new_r00))+x527);
evalcond[7]=((((-1.0)*x524*x529))+x531+new_r00);
evalcond[8]=(((cj32*x531))+(((-1.0)*cj31*x529))+new_r11);
evalcond[9]=((((-1.0)*cj31*x530))+(((-1.0)*cj32*x523*x525))+new_r10);
evalcond[10]=(((new_r01*x524))+((cj32*x526))+(((-1.0)*new_r21*x528))+x522);
evalcond[11]=(((cj32*x527))+(((-1.0)*new_r20*x528))+(((-1.0)*x529))+((new_r00*x524)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x532 = IKatan2WithCheck((gconst89*new_r12),(gconst89*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
j31array[0]=x532.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x533=IKcos(j31);
IkReal x534=IKsin(j31);
IkReal x535=((1.0)*sj32);
IkReal x536=(new_r02*x533);
IkReal x537=(new_r12*x534);
IkReal x538=(sj32*x533);
IkReal x539=(sj32*x534);
evalcond[0]=((((-1.0)*x533*x535))+new_r02);
evalcond[1]=((((-1.0)*x534*x535))+new_r12);
evalcond[2]=(((new_r12*x533))+(((-1.0)*new_r02*x534)));
evalcond[3]=((((-1.0)*x535))+x537+x536);
evalcond[4]=(((new_r10*x539))+((cj32*new_r20))+((new_r00*x538)));
evalcond[5]=(((new_r01*x538))+((new_r11*x539))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((sj32*x537))+((sj32*x536))+((cj32*new_r22)));
evalcond[7]=((((-1.0)*new_r22*x535))+((cj32*x536))+((cj32*x537)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst118;
gconst118=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj31;
dummyeval[1]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[3];
dummyeval[0]=cj31;
dummyeval[1]=cj32;
dummyeval[2]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  || IKabs(dummyeval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x540=((((-1.0)*cj32))+new_r22);
IkReal x541=((((-1.0)*sj32))+new_r12);
IkReal x542=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x540;
evalcond[2]=x540;
evalcond[3]=new_r02;
evalcond[4]=x541;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x541;
evalcond[7]=(((new_r10*sj32))+((cj32*new_r20)));
evalcond[8]=(((new_r11*sj32))+((cj32*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));
evalcond[10]=((((-1.0)*new_r22*x542))+((cj32*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst119;
gconst119=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=cj32;
dummyeval[1]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[15];
bool bgotonextstatement = true;
do
{
IkReal x543=((-1.0)+new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=new_r02;
evalcond[4]=x543;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x543;
evalcond[7]=new_r11;
evalcond[8]=new_r10;
evalcond[9]=new_r11;
evalcond[10]=new_r10;
evalcond[11]=new_r10;
evalcond[12]=new_r11;
evalcond[13]=x543;
evalcond[14]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x544=IKcos(j33);
IkReal x545=((1.0)*(IKsin(j33)));
evalcond[0]=(x544+new_r20);
evalcond[1]=((((-1.0)*x545))+new_r21);
evalcond[2]=((((-1.0)*x545))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x544))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x546=((1.0)+new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=new_r02;
evalcond[4]=x546;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x546;
evalcond[7]=new_r11;
evalcond[8]=new_r10;
evalcond[9]=new_r11;
evalcond[10]=new_r10;
evalcond[11]=((-1.0)*new_r10);
evalcond[12]=((-1.0)*new_r11);
evalcond[13]=((-1.0)+(((-1.0)*new_r12)));
evalcond[14]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x547=IKsin(j33);
IkReal x548=((1.0)*(IKcos(j33)));
evalcond[0]=(x547+new_r21);
evalcond[1]=((((-1.0)*x548))+new_r20);
evalcond[2]=((((-1.0)*x547))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x548))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x549=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x549;
evalcond[2]=x549;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r02);
evalcond[10]=new_r12;
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x549;
evalcond[14]=new_r12;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x550=IKsin(j33);
IkReal x551=((1.0)*(IKcos(j33)));
evalcond[0]=(x550+new_r11);
evalcond[1]=((((-1.0)*x551))+new_r10);
evalcond[2]=((((-1.0)*x550))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x551))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x552=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x552;
evalcond[2]=x552;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r02);
evalcond[10]=new_r12;
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
evalcond[14]=((-1.0)*new_r12);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x553=IKcos(j33);
IkReal x554=((1.0)*(IKsin(j33)));
evalcond[0]=(x553+new_r10);
evalcond[1]=((((-1.0)*x554))+new_r11);
evalcond[2]=((((-1.0)*x554))+(((-1.0)*new_r00)));
evalcond[3]=((((-1.0)*x553))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x555=IKPowWithIntegerCheck(cj32,-1);
if(!x555.valid){
continue;
}
CheckValue<IkReal> x556=IKPowWithIntegerCheck(sj32,-1);
if(!x556.valid){
continue;
}
if( IKabs(((-1.0)*new_r11*(x555.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x556.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11*(x555.value)))+IKsqr(((-1.0)*new_r20*(x556.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r11*(x555.value)), ((-1.0)*new_r20*(x556.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x557=IKsin(j33);
IkReal x558=IKcos(j33);
IkReal x559=((1.0)*sj32);
IkReal x560=((1.0)*x558);
evalcond[0]=(((sj32*x558))+new_r20);
evalcond[1]=(((cj32*x557))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x557*x559)));
evalcond[3]=(new_r10+(((-1.0)*cj32*x560)));
evalcond[4]=((((-1.0)*x557))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x560)));
evalcond[6]=(((cj32*new_r11))+(((-1.0)*new_r21*x559))+x557);
evalcond[7]=(((cj32*new_r10))+(((-1.0)*new_r20*x559))+(((-1.0)*x560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x561 = IKatan2WithCheck((gconst119*new_r21),((-1.0)*gconst119*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x561.valid){
continue;
}
j33array[0]=x561.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x562=IKsin(j33);
IkReal x563=IKcos(j33);
IkReal x564=((1.0)*sj32);
IkReal x565=((1.0)*x563);
evalcond[0]=(((sj32*x563))+new_r20);
evalcond[1]=(new_r11+((cj32*x562)));
evalcond[2]=((((-1.0)*x562*x564))+new_r21);
evalcond[3]=(new_r10+(((-1.0)*cj32*x565)));
evalcond[4]=((((-1.0)*x562))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*new_r01))+(((-1.0)*x565)));
evalcond[6]=(((cj32*new_r11))+x562+(((-1.0)*new_r21*x564)));
evalcond[7]=((((-1.0)*new_r20*x564))+((cj32*new_r10))+(((-1.0)*x565)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x566=((((-1.0)*cj32))+new_r22);
IkReal x567=((1.0)*sj32);
IkReal x568=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x566;
evalcond[2]=x566;
evalcond[3]=new_r02;
evalcond[4]=(sj32+new_r12);
evalcond[5]=new_r02;
evalcond[6]=new_r02;
evalcond[7]=((((-1.0)*x567))+(((-1.0)*x568)));
evalcond[8]=(((cj32*new_r20))+(((-1.0)*new_r10*x567)));
evalcond[9]=(((cj32*new_r21))+(((-1.0)*new_r11*x567)));
evalcond[10]=((-1.0)+(((-1.0)*new_r12*x567))+((cj32*new_r22)));
evalcond[11]=((((-1.0)*new_r22*x567))+(((-1.0)*cj32*x568)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r00, new_r01);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x569=IKcos(j33);
IkReal x570=IKsin(j33);
IkReal x571=((1.0)*sj32);
IkReal x572=((1.0)*new_r11);
IkReal x573=((1.0)*new_r10);
IkReal x574=((1.0)*x569);
evalcond[0]=(((sj32*x569))+new_r20);
evalcond[1]=((((-1.0)*x570))+new_r00);
evalcond[2]=((((-1.0)*x574))+new_r01);
evalcond[3]=((((-1.0)*x570*x571))+new_r21);
evalcond[4]=(((cj32*x570))+(((-1.0)*x572)));
evalcond[5]=((((-1.0)*cj32*x574))+(((-1.0)*x573)));
evalcond[6]=((((-1.0)*cj32*x572))+x570+(((-1.0)*new_r21*x571)));
evalcond[7]=((((-1.0)*cj32*x573))+(((-1.0)*x574))+(((-1.0)*new_r20*x571)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x575=((1.0)*sj31);
IkReal x576=(((cj31*new_r12))+(((-1.0)*new_r02*x575)));
IkReal x577=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x578=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x579=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((((-1.0)*cj31))+new_r02);
evalcond[4]=((((-1.0)*x575))+new_r12);
evalcond[5]=x576;
evalcond[6]=x576;
evalcond[7]=x579;
evalcond[8]=x578;
evalcond[9]=x577;
evalcond[10]=x577;
evalcond[11]=x578;
evalcond[12]=x579;
evalcond[13]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x580=IKcos(j33);
IkReal x581=IKsin(j33);
IkReal x582=((1.0)*sj31);
IkReal x583=((1.0)*x581);
IkReal x584=((1.0)*x580);
evalcond[0]=(x580+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x583)));
evalcond[2]=(((sj31*x580))+new_r01);
evalcond[3]=(((sj31*x581))+new_r00);
evalcond[4]=((((-1.0)*cj31*x584))+new_r11);
evalcond[5]=((((-1.0)*cj31*x583))+new_r10);
evalcond[6]=(((cj31*new_r10))+(((-1.0)*x583))+(((-1.0)*new_r00*x582)));
evalcond[7]=((((-1.0)*new_r01*x582))+((cj31*new_r11))+(((-1.0)*x584)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x585=(new_r10*sj31);
IkReal x586=(cj31*new_r00);
IkReal x587=(cj31*new_r02);
IkReal x588=(new_r11*sj31);
IkReal x589=(new_r12*sj31);
IkReal x590=(cj31*new_r01);
IkReal x591=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=(cj31+new_r02);
evalcond[4]=(sj31+new_r12);
evalcond[5]=x591;
evalcond[6]=x591;
evalcond[7]=((1.0)+x587+x589);
evalcond[8]=(x588+x590);
evalcond[9]=(x585+x586);
evalcond[10]=((((-1.0)*x585))+(((-1.0)*x586)));
evalcond[11]=((((-1.0)*x588))+(((-1.0)*x590)));
evalcond[12]=((-1.0)+(((-1.0)*x587))+(((-1.0)*x589)));
evalcond[13]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x592=IKcos(j33);
IkReal x593=IKsin(j33);
IkReal x594=((1.0)*sj31);
IkReal x595=((1.0)*x592);
IkReal x596=((1.0)*x593);
evalcond[0]=(x593+new_r21);
evalcond[1]=((((-1.0)*x595))+new_r20);
evalcond[2]=(((sj31*x592))+new_r01);
evalcond[3]=(((sj31*x593))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*cj31*x595)));
evalcond[5]=(new_r10+(((-1.0)*cj31*x596)));
evalcond[6]=((((-1.0)*new_r00*x594))+((cj31*new_r10))+(((-1.0)*x596)));
evalcond[7]=(((cj31*new_r11))+(((-1.0)*new_r01*x594))+(((-1.0)*x595)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x597=((-1.0)+new_r22);
IkReal x598=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x599=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x597;
evalcond[2]=x597;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x598;
evalcond[10]=x598;
evalcond[11]=x599;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x597;
evalcond[15]=x599;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst120;
gconst120=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst121;
gconst121=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x600 = IKatan2WithCheck((gconst121*((((cj31*new_r01))+((new_r11*sj31))))),(gconst121*(((((-1.0)*cj31*new_r11))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x600.valid){
continue;
}
j33array[0]=x600.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x601=IKsin(j33);
IkReal x602=IKcos(j33);
IkReal x603=((1.0)*sj31);
IkReal x604=((1.0)*x602);
IkReal x605=(sj31*x601);
IkReal x606=((1.0)*x601);
IkReal x607=(cj31*x604);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x601);
evalcond[1]=(((cj31*x601))+new_r01+((sj31*x602)));
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x604)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x606))+(((-1.0)*new_r00*x603)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x604))+(((-1.0)*new_r01*x603)));
evalcond[5]=(x605+(((-1.0)*x607))+new_r00);
evalcond[6]=(x605+(((-1.0)*x607))+new_r11);
evalcond[7]=((((-1.0)*x602*x603))+(((-1.0)*cj31*x606))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x608 = IKatan2WithCheck((gconst120*((((new_r00*sj31))+((cj31*new_r01))))),(gconst120*(((((-1.0)*cj31*new_r00))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x608.valid){
continue;
}
j33array[0]=x608.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x609=IKsin(j33);
IkReal x610=IKcos(j33);
IkReal x611=((1.0)*sj31);
IkReal x612=((1.0)*x610);
IkReal x613=(sj31*x609);
IkReal x614=((1.0)*x609);
IkReal x615=(cj31*x612);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x609);
evalcond[1]=(((cj31*x609))+((sj31*x610))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x612)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x614))+(((-1.0)*new_r00*x611)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x612))+(((-1.0)*new_r01*x611)));
evalcond[5]=((((-1.0)*x615))+x613+new_r00);
evalcond[6]=((((-1.0)*x615))+x613+new_r11);
evalcond[7]=((((-1.0)*x610*x611))+new_r10+(((-1.0)*cj31*x614)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x616=((1.0)+new_r22);
IkReal x617=(cj31*new_r02);
IkReal x618=(new_r12*sj31);
IkReal x619=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x616;
evalcond[2]=x616;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x619;
evalcond[10]=x619;
evalcond[11]=(x618+x617);
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x617))+(((-1.0)*x618)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst122;
gconst122=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst123;
gconst123=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x620=((1.0)*sj31);
CheckValue<IkReal> x621 = IKatan2WithCheck((gconst123*(((((-1.0)*new_r00*x620))+((cj31*new_r10))))),(gconst123*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x620))))),IKFAST_ATAN2_MAGTHRESH);
if(!x621.valid){
continue;
}
j33array[0]=x621.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x622=IKsin(j33);
IkReal x623=IKcos(j33);
IkReal x624=((1.0)*sj31);
IkReal x625=((1.0)*x622);
IkReal x626=(sj31*x623);
IkReal x627=((1.0)*x623);
IkReal x628=(cj31*x625);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x623);
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x625))+((new_r11*sj31)));
evalcond[2]=(((sj31*x622))+((cj31*x623))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x624))+((cj31*new_r10))+(((-1.0)*x625)));
evalcond[4]=((((-1.0)*new_r01*x624))+((cj31*new_r11))+(((-1.0)*x627)));
evalcond[5]=((((-1.0)*x628))+x626+new_r01);
evalcond[6]=((((-1.0)*x628))+x626+new_r10);
evalcond[7]=((((-1.0)*x622*x624))+new_r11+(((-1.0)*cj31*x627)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x629=((1.0)*new_r00);
CheckValue<IkReal> x630 = IKatan2WithCheck((gconst122*((((cj31*new_r01))+(((-1.0)*sj31*x629))))),(gconst122*(((((-1.0)*cj31*x629))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x630.valid){
continue;
}
j33array[0]=x630.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x631=IKsin(j33);
IkReal x632=IKcos(j33);
IkReal x633=((1.0)*sj31);
IkReal x634=((1.0)*x631);
IkReal x635=(sj31*x632);
IkReal x636=((1.0)*x632);
IkReal x637=(cj31*x634);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x632);
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x634))+((new_r11*sj31)));
evalcond[2]=(((sj31*x631))+((cj31*x632))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x633))+(((-1.0)*x634)));
evalcond[4]=((((-1.0)*new_r01*x633))+((cj31*new_r11))+(((-1.0)*x636)));
evalcond[5]=((((-1.0)*x637))+x635+new_r01);
evalcond[6]=((((-1.0)*x637))+x635+new_r10);
evalcond[7]=((((-1.0)*x631*x633))+(((-1.0)*cj31*x636))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x638=((((-1.0)*cj32))+new_r22);
IkReal x639=((((-1.0)*sj32))+new_r02);
IkReal x640=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x638;
evalcond[2]=x638;
evalcond[3]=x639;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x639;
evalcond[8]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[9]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[10]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[11]=(((cj32*new_r02))+(((-1.0)*new_r22*x640)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x641=IKcos(j33);
IkReal x642=IKsin(j33);
IkReal x643=((1.0)*sj32);
IkReal x644=((1.0)*x641);
evalcond[0]=(new_r20+((sj32*x641)));
evalcond[1]=((((-1.0)*x642))+new_r10);
evalcond[2]=((((-1.0)*x644))+new_r11);
evalcond[3]=(((cj32*x642))+new_r01);
evalcond[4]=((((-1.0)*x642*x643))+new_r21);
evalcond[5]=((((-1.0)*cj32*x644))+new_r00);
evalcond[6]=(((cj32*new_r01))+(((-1.0)*new_r21*x643))+x642);
evalcond[7]=(((cj32*new_r00))+(((-1.0)*x644))+(((-1.0)*new_r20*x643)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x645=((((-1.0)*cj32))+new_r22);
IkReal x646=((1.0)*sj32);
IkReal x647=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x645;
evalcond[2]=x645;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x646))+(((-1.0)*x647)));
evalcond[7]=((((-1.0)*new_r00*x646))+((cj32*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x646))+((cj32*new_r21)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x646))+((cj32*new_r22)));
evalcond[10]=((((-1.0)*cj32*x647))+(((-1.0)*new_r22*x646)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst124;
gconst124=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[14];
bool bgotonextstatement = true;
do
{
IkReal x648=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x648;
evalcond[2]=x648;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x648;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x649=IKsin(j33);
IkReal x650=((1.0)*(IKcos(j33)));
evalcond[0]=(x649+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x649))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x650))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x650))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x651=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x651;
evalcond[2]=x651;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x652=IKcos(j33);
IkReal x653=((1.0)*(IKsin(j33)));
evalcond[0]=(x652+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x653))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x652))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x653))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x654=IKPowWithIntegerCheck(sj32,-1);
if(!x654.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x654.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r20*(x654.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r20*(x654.value)));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x655=IKsin(j33);
IkReal x656=IKcos(j33);
IkReal x657=((1.0)*new_r00);
IkReal x658=((1.0)*sj32);
IkReal x659=((1.0)*new_r01);
IkReal x660=((1.0)*x656);
evalcond[0]=(new_r20+((sj32*x656)));
evalcond[1]=((((-1.0)*x655*x658))+new_r21);
evalcond[2]=((((-1.0)*x655))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x660))+(((-1.0)*new_r11)));
evalcond[4]=(((cj32*x655))+(((-1.0)*x659)));
evalcond[5]=((((-1.0)*cj32*x660))+(((-1.0)*x657)));
evalcond[6]=((((-1.0)*cj32*x659))+x655+(((-1.0)*new_r21*x658)));
evalcond[7]=((((-1.0)*cj32*x657))+(((-1.0)*new_r20*x658))+(((-1.0)*x660)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x661=IKPowWithIntegerCheck(sj32,-1);
if(!x661.valid){
continue;
}
if( IKabs((new_r21*(x661.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*(x661.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*(x661.value)), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x662=IKsin(j33);
IkReal x663=IKcos(j33);
IkReal x664=((1.0)*new_r00);
IkReal x665=((1.0)*sj32);
IkReal x666=((1.0)*new_r01);
IkReal x667=((1.0)*x663);
evalcond[0]=(((sj32*x663))+new_r20);
evalcond[1]=((((-1.0)*x662*x665))+new_r21);
evalcond[2]=((((-1.0)*x662))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x667))+(((-1.0)*new_r11)));
evalcond[4]=(((cj32*x662))+(((-1.0)*x666)));
evalcond[5]=((((-1.0)*cj32*x667))+(((-1.0)*x664)));
evalcond[6]=((((-1.0)*new_r21*x665))+(((-1.0)*cj32*x666))+x662);
evalcond[7]=((((-1.0)*cj32*x664))+(((-1.0)*x667))+(((-1.0)*new_r20*x665)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x668 = IKatan2WithCheck((gconst124*new_r21),((-1.0)*gconst124*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x668.valid){
continue;
}
j33array[0]=x668.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x669=IKsin(j33);
IkReal x670=IKcos(j33);
IkReal x671=((1.0)*new_r00);
IkReal x672=((1.0)*sj32);
IkReal x673=((1.0)*new_r01);
IkReal x674=((1.0)*x670);
evalcond[0]=(((sj32*x670))+new_r20);
evalcond[1]=((((-1.0)*x669*x672))+new_r21);
evalcond[2]=((((-1.0)*x669))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x674)));
evalcond[4]=(((cj32*x669))+(((-1.0)*x673)));
evalcond[5]=((((-1.0)*cj32*x674))+(((-1.0)*x671)));
evalcond[6]=((((-1.0)*new_r21*x672))+x669+(((-1.0)*cj32*x673)));
evalcond[7]=((((-1.0)*new_r20*x672))+(((-1.0)*cj32*x671))+(((-1.0)*x674)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x675=((-1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x675;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x675;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=new_r00;
evalcond[13]=new_r01;
evalcond[14]=x675;
evalcond[15]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x676=IKcos(j33);
IkReal x677=((1.0)*(IKsin(j33)));
evalcond[0]=(x676+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x677)));
evalcond[2]=(new_r10+(((-1.0)*x677)));
evalcond[3]=((((-1.0)*x676))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((-1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x678=IKcos(j33);
IkReal x679=((1.0)*(IKsin(j33)));
evalcond[0]=(x678+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x679)));
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x679)));
evalcond[3]=((((-1.0)*x678))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x680=((1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x680;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x680;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=((-1.0)*new_r00);
evalcond[13]=((-1.0)*new_r01);
evalcond[14]=((-1.0)+(((-1.0)*new_r02)));
evalcond[15]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x681=IKsin(j33);
IkReal x682=((1.0)*(IKcos(j33)));
evalcond[0]=(x681+new_r21);
evalcond[1]=((((-1.0)*x682))+new_r20);
evalcond[2]=(new_r10+(((-1.0)*x681)));
evalcond[3]=((((-1.0)*x682))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((-1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x683=IKsin(j33);
IkReal x684=((1.0)*(IKcos(j33)));
evalcond[0]=(x683+new_r21);
evalcond[1]=((((-1.0)*x684))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x683)));
evalcond[3]=((((-1.0)*x684))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x685=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959))))));
evalcond[1]=x685;
evalcond[2]=x685;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x685;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x686=IKsin(j33);
IkReal x687=((1.0)*(IKcos(j33)));
evalcond[0]=(x686+new_r01);
evalcond[1]=(new_r10+(((-1.0)*x686)));
evalcond[2]=((((-1.0)*x687))+new_r11);
evalcond[3]=((((-1.0)*x687))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x688=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959))))));
evalcond[1]=x688;
evalcond[2]=x688;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x689=IKcos(j33);
IkReal x690=((1.0)*(IKsin(j33)));
evalcond[0]=(x689+new_r00);
evalcond[1]=((((-1.0)*x690))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x689)));
evalcond[3]=((((-1.0)*x690))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x692=IKPowWithIntegerCheck(sj32,-1);
if(!x692.valid){
continue;
}
IkReal x691=x692.value;
CheckValue<IkReal> x693=IKPowWithIntegerCheck(cj31,-1);
if(!x693.valid){
continue;
}
CheckValue<IkReal> x694=IKPowWithIntegerCheck(cj32,-1);
if(!x694.valid){
continue;
}
if( IKabs((x691*(x693.value)*(x694.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x691)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x691*(x693.value)*(x694.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x691))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x691*(x693.value)*(x694.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x691));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x695=IKsin(j33);
IkReal x696=IKcos(j33);
IkReal x697=(cj31*cj32);
IkReal x698=((1.0)*sj31);
IkReal x699=(new_r11*sj31);
IkReal x700=(new_r10*sj31);
IkReal x701=((1.0)*sj32);
IkReal x702=((1.0)*x696);
IkReal x703=((1.0)*x695);
IkReal x704=(sj31*x695);
evalcond[0]=(new_r20+((sj32*x696)));
evalcond[1]=((((-1.0)*x695*x701))+new_r21);
evalcond[2]=(((cj32*x695))+((cj31*new_r01))+x699);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x698))+(((-1.0)*x703)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x698))+(((-1.0)*x702)));
evalcond[5]=(((x695*x697))+((sj31*x696))+new_r01);
evalcond[6]=((((-1.0)*cj32*x702))+((cj31*new_r00))+x700);
evalcond[7]=(x704+new_r00+(((-1.0)*x697*x702)));
evalcond[8]=(((cj32*x704))+(((-1.0)*cj31*x702))+new_r11);
evalcond[9]=((((-1.0)*cj32*x696*x698))+(((-1.0)*cj31*x703))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x701))+((cj32*x699))+x695+((new_r01*x697)));
evalcond[11]=(((cj32*x700))+(((-1.0)*new_r20*x701))+(((-1.0)*x702))+((new_r00*x697)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x706=IKPowWithIntegerCheck(sj32,-1);
if(!x706.valid){
continue;
}
IkReal x705=x706.value;
CheckValue<IkReal> x707=IKPowWithIntegerCheck(sj31,-1);
if(!x707.valid){
continue;
}
if( IKabs((x705*(x707.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x705)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x705*(x707.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x705))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x705*(x707.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x705));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x708=IKsin(j33);
IkReal x709=IKcos(j33);
IkReal x710=(cj31*cj32);
IkReal x711=((1.0)*sj31);
IkReal x712=(new_r11*sj31);
IkReal x713=(new_r10*sj31);
IkReal x714=((1.0)*sj32);
IkReal x715=((1.0)*x709);
IkReal x716=((1.0)*x708);
IkReal x717=(sj31*x708);
evalcond[0]=(((sj32*x709))+new_r20);
evalcond[1]=((((-1.0)*x708*x714))+new_r21);
evalcond[2]=(((cj32*x708))+((cj31*new_r01))+x712);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x716))+(((-1.0)*new_r00*x711)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x715))+(((-1.0)*new_r01*x711)));
evalcond[5]=(((sj31*x709))+new_r01+((x708*x710)));
evalcond[6]=((((-1.0)*cj32*x715))+((cj31*new_r00))+x713);
evalcond[7]=((((-1.0)*x710*x715))+x717+new_r00);
evalcond[8]=(((cj32*x717))+(((-1.0)*cj31*x715))+new_r11);
evalcond[9]=((((-1.0)*cj31*x716))+new_r10+(((-1.0)*cj32*x709*x711)));
evalcond[10]=((((-1.0)*new_r21*x714))+((cj32*x712))+((new_r01*x710))+x708);
evalcond[11]=(((cj32*x713))+((new_r00*x710))+(((-1.0)*new_r20*x714))+(((-1.0)*x715)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x718 = IKatan2WithCheck((gconst118*new_r21),((-1.0)*gconst118*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x718.valid){
continue;
}
j33array[0]=x718.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x719=IKsin(j33);
IkReal x720=IKcos(j33);
IkReal x721=(cj31*cj32);
IkReal x722=((1.0)*sj31);
IkReal x723=(new_r11*sj31);
IkReal x724=(new_r10*sj31);
IkReal x725=((1.0)*sj32);
IkReal x726=((1.0)*x720);
IkReal x727=((1.0)*x719);
IkReal x728=(sj31*x719);
evalcond[0]=(new_r20+((sj32*x720)));
evalcond[1]=(new_r21+(((-1.0)*x719*x725)));
evalcond[2]=(((cj32*x719))+((cj31*new_r01))+x723);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x727))+(((-1.0)*new_r00*x722)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x726))+(((-1.0)*new_r01*x722)));
evalcond[5]=(((sj31*x720))+((x719*x721))+new_r01);
evalcond[6]=((((-1.0)*cj32*x726))+((cj31*new_r00))+x724);
evalcond[7]=((((-1.0)*x721*x726))+x728+new_r00);
evalcond[8]=((((-1.0)*cj31*x726))+new_r11+((cj32*x728)));
evalcond[9]=((((-1.0)*cj32*x720*x722))+(((-1.0)*cj31*x727))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x725))+((new_r01*x721))+x719+((cj32*x723)));
evalcond[11]=((((-1.0)*new_r20*x725))+((new_r00*x721))+(((-1.0)*x726))+((cj32*x724)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "ad4f1590d2a9b2079648c64e9db33191"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
