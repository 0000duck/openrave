#define IKFAST_NAMESPACE ik_pr2_rightarm_torso
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 67 generated on 2013-07-25 16:13:36.714711
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==67);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
#ifndef isfinite
#define isfinite _isfinite
#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61;
x0=IKcos(j[1]);
x1=IKcos(j[3]);
x2=IKsin(j[2]);
x3=IKsin(j[1]);
x4=IKsin(j[3]);
x5=IKcos(j[5]);
x6=IKcos(j[4]);
x7=IKcos(j[2]);
x8=IKsin(j[4]);
x9=IKsin(j[5]);
x10=IKcos(j[7]);
x11=IKsin(j[7]);
x12=IKsin(j[6]);
x13=IKcos(j[6]);
x14=((1.0)*x8);
x15=((0.18)*x5);
x16=((1.0)*x1);
x17=((0.321)*x4);
x18=((0.18)*x9);
x19=((0.18)*x8);
x20=((1.0)*x6);
x21=((1.0)*x13);
x22=((0.18)*x6);
x23=((0.321)*x6);
x24=((1.0)*x12);
x25=((0.321)*x1);
x26=(x3*x7);
x27=((-1.0)*x8);
x28=(x0*x2);
x29=(x4*x7);
x30=(x2*x6);
x31=(x0*x7);
x32=((-1.0)*x6);
x33=(x3*x4);
x34=(x2*x3);
x35=(x1*x7*x8);
x36=(x14*x31);
x37=(x16*x6*x7);
x38=((((-1.0)*x16*x3))+((x28*x4)));
x39=(((x0*x4))+(((-1.0)*x16*x34)));
x40=(((x0*x1))+((x2*x33)));
x41=((((-1.0)*x37))+((x2*x8)));
x42=((((-1.0)*x33))+(((-1.0)*x16*x28)));
x43=(x38*x5);
x44=(x38*x9);
x45=(((x1*x14*x7))+((x2*x20)));
x46=(x40*x9);
x47=(x42*x6);
x48=(((x29*x9))+((x41*x5)));
x49=(((x39*x6))+((x26*x27)));
x50=(((x29*x5))+((x9*(((((-1.0)*x14*x2))+x37)))));
x51=(x13*x48);
x52=(((x27*x31))+x47);
x53=(((x27*x39))+((x26*x32)));
x54=(x49*x5);
x55=(x5*x52);
x56=(x12*x53);
x57=(x46+x54);
x58=(((x9*(((((-1.0)*x20*x39))+((x14*x26))))))+((x40*x5)));
x59=(x44+x55);
x60=(x13*x57);
x61=(x13*x59);
eerot[0]=(((x11*((x43+((x9*(((((-1.0)*x20*x42))+x36))))))))+((x10*((((x12*((((x27*x42))+((x31*x32))))))+x61)))));
eerot[1]=(((x10*((((x9*((x36+((x32*x42))))))+x43))))+(((-1.0)*x11*((((x24*(((((-1.0)*x20*x31))+(((-1.0)*x14*x42))))))+((x21*x59)))))));
eerot[2]=(((x12*((((x5*(((((-1.0)*x36))+x47))))+x44))))+((x13*((((x31*x6))+((x42*x8)))))));
eetrans[0]=((-0.05)+((x23*x31))+(((0.1)*x0))+((x8*(((((-1.0)*x25*x28))+(((-1.0)*x17*x3))))))+((x13*((((x19*x42))+((x22*x31))))))+(((0.4)*x31))+((x12*((((x15*x52))+((x18*x38)))))));
eerot[3]=(((x10*((x56+x60))))+((x11*x58)));
eerot[4]=(((x11*(((((-1.0)*x56))+(((-1.0)*x60))))))+((x10*x58)));
eerot[5]=(((x12*x57))+((x13*((((x39*x8))+((x26*x6)))))));
eetrans[1]=((-0.188)+((x8*((((x0*x17))+(((-1.0)*x25*x34))))))+(((0.1)*x3))+((x13*((((x22*x26))+((x19*x39))))))+((x23*x26))+(((0.4)*x26))+((x12*((((x18*x40))+((x15*x49)))))));
eerot[6]=(((x10*((x51+((x12*x45))))))+((x11*x50)));
eerot[7]=(((x11*(((((-1.0)*x24*x45))+(((-1.0)*x21*x48))))))+((x10*x50)));
eerot[8]=(((x12*x48))+(((-1.0)*x13*x45)));
IkReal x62=((1.0)*x2);
IkReal x63=((1.0)*x7);
eetrans[2]=((0.739675)+(((-1.0)*x25*x63*x8))+((x12*((((x18*x29))+((x15*x41))))))+(((-1.0)*x23*x62))+(((-0.4)*x2))+j[0]+((x13*(((((-1.0)*x1*x19*x63))+(((-1.0)*x22*x62)))))));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j27,cj27,sj27,htj27,j27mul,j28,cj28,sj28,htj28,j28mul,j30,cj30,sj30,htj30,j30mul,j31,cj31,sj31,htj31,j31mul,j32,cj32,sj32,htj32,j32mul,j33,cj33,sj33,htj33,j33mul,j12,cj12,sj12,htj12,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij12[2], _nj12,_ij29[2], _nj29;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]);
j29=pfree[1]; cj29=cos(pfree[1]); sj29=sin(pfree[1]);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((0.05)+(((-0.18)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((0.188)+(((-0.18)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.739675)+(((-1.0)*j12))+pz+(((-0.18)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*py*r20))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*pz*r00)));
rxp0_2=((((-1.0)*px*r10))+((py*r00)));
rxp1_0=((((-1.0)*py*r21))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*pz*r01)));
rxp1_2=((((-1.0)*px*r11))+((py*r01)));
rxp2_0=((((-1.0)*py*r22))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*pz*r02)));
rxp2_2=((((-1.0)*px*r12))+((py*r02)));
{
IkReal dummyeval[1];
IkReal gconst0;
gconst0=((-1.0)*py);
IkReal gconst1;
gconst1=((0.642)*sj29);
IkReal gconst2;
gconst2=((-1.0)*py);
IkReal gconst3;
gconst3=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst4;
gconst4=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst5;
gconst5=((-1.0)*py);
IkReal gconst6;
gconst6=((0.642)*sj29);
IkReal gconst7;
gconst7=((-1.0)*py);
IkReal gconst8;
gconst8=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst9;
gconst9=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst10;
gconst10=((2.0)*px);
IkReal gconst11;
gconst11=((2.0)*px);
IkReal gconst12;
gconst12=((0.4)*py);
IkReal gconst13;
gconst13=((0.4)*py);
IkReal gconst14;
gconst14=((2.0)*px);
IkReal gconst15;
gconst15=((2.0)*px);
IkReal gconst16;
gconst16=((0.4)*py);
IkReal gconst17;
gconst17=((0.4)*py);
IkReal gconst18;
gconst18=py;
IkReal gconst19;
gconst19=((0.642)*sj29);
IkReal gconst20;
gconst20=py;
IkReal gconst21;
gconst21=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst22;
gconst22=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst23;
gconst23=py;
IkReal gconst24;
gconst24=((0.642)*sj29);
IkReal gconst25;
gconst25=py;
IkReal gconst26;
gconst26=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst27;
gconst27=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal x64=(gconst20*gconst21);
IkReal x65=(gconst23*gconst27);
IkReal x66=(gconst25*gconst26);
IkReal x67=(gconst18*gconst22);
dummyeval[0]=((((-1.0)*x64*x66))+(((-1.0)*x65*x67))+(((-1.0)*gconst19*gconst22*gconst24*gconst26))+((x64*x65))+((x66*x67)));
if( IKabs(dummyeval[0]) < 0.0000001000000000  )
{
continue;

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x68=((1.0)*gconst8);
IkReal x69=(gconst3*gconst7);
IkReal x70=(gconst0*gconst8);
IkReal x71=(gconst13*gconst15);
IkReal x72=((1.0)*gconst22);
IkReal x73=(gconst19*gconst24);
IkReal x74=(gconst0*gconst9);
IkReal x75=(gconst1*gconst6);
IkReal x76=(gconst27*gconst5);
IkReal x77=(gconst2*gconst3);
IkReal x78=((1.0)*gconst4);
IkReal x79=(gconst17*gconst5);
IkReal x80=(gconst12*gconst14);
IkReal x81=(gconst2*gconst9);
IkReal x82=((1.0)*gconst16);
IkReal x83=(gconst18*gconst25);
IkReal x84=(gconst12*gconst7);
IkReal x85=(gconst18*gconst9);
IkReal x86=(gconst20*gconst27);
IkReal x87=(gconst26*gconst4);
IkReal x88=(gconst1*gconst24);
IkReal x89=(gconst11*gconst3);
IkReal x90=((1.0)*gconst26);
IkReal x91=(gconst20*gconst21);
IkReal x92=(gconst13*gconst16);
IkReal x93=(gconst18*gconst23);
IkReal x94=(gconst21*gconst25);
IkReal x95=(gconst2*gconst21);
IkReal x96=(gconst12*gconst2);
IkReal x97=(gconst5*gconst9);
IkReal x98=(gconst20*gconst3);
IkReal x99=(gconst4*gconst7);
IkReal x100=(gconst11*gconst12);
IkReal x101=(gconst14*gconst17);
IkReal x102=(gconst15*gconst4);
IkReal x103=((1.0)*gconst13);
IkReal x104=(gconst10*gconst8);
IkReal x105=(gconst0*gconst16);
IkReal x106=(gconst23*gconst27);
IkReal x107=(gconst22*gconst25);
IkReal x108=(gconst10*gconst16);
IkReal x109=(gconst19*gconst6);
IkReal x110=(gconst22*gconst7);
IkReal x111=(gconst0*gconst7);
IkReal x112=(gconst17*gconst23);
IkReal x113=(gconst10*gconst14);
IkReal x114=(gconst11*gconst21);
IkReal x115=(gconst12*gconst20);
IkReal x116=(gconst18*gconst26);
IkReal x117=(gconst14*gconst9);
IkReal x118=(gconst13*gconst7);
IkReal x119=(gconst16*gconst22);
IkReal x120=(gconst23*x91);
IkReal x121=(gconst10*gconst25*gconst26);
IkReal x122=(gconst15*gconst22*gconst26);
IkReal x123=(gconst14*gconst18*gconst27);
op[0]=((((-1.0)*gconst27*x72*x93))+((gconst22*gconst26*x83))+(((-1.0)*gconst25*x90*x91))+((gconst21*gconst23*x86))+(((-1.0)*gconst26*x72*x73)));
op[1]=((((-1.0)*gconst10*x106*x72))+(((-1.0)*gconst17*x72*x93))+((x106*x114))+(((-1.0)*gconst13*x73*x90))+((gconst13*gconst26*x83))+((gconst10*gconst26*x107))+(((-1.0)*x123*x72))+((gconst14*gconst21*x86))+(((-1.0)*gconst11*x90*x94))+(((-1.0)*gconst25*x82*x91))+((x112*x91))+((gconst15*gconst22*x116))+((x119*x83))+(((-1.0)*gconst25*x115*x90))+(((-1.0)*gconst16*x72*x73))+((gconst12*gconst23*x86))+(((-1.0)*gconst15*x90*x91))+(((-1.0)*gconst27*x103*x93)));
op[2]=((((-1.0)*gconst22*x68*x73))+(((-1.0)*gconst18*x101*x72))+(((-1.0)*gconst26*x109*x72))+((x107*x108))+((gconst15*gconst18*x119))+((x110*x116))+(((-1.0)*gconst15*x114*x90))+((x112*x115))+((x112*x114))+(((-1.0)*gconst2*x90*x94))+((gconst23*gconst3*x86))+((gconst9*x120))+(((-1.0)*gconst17*x103*x93))+((gconst14*gconst27*x114))+((x101*x91))+(((-1.0)*gconst13*x73*x82))+(((-1.0)*gconst27*x78*x93))+(((-1.0)*gconst7*x90*x91))+(((-1.0)*gconst25*x100*x90))+((x116*x71))+(((-1.0)*gconst27*x113*x72))+((x106*x95))+(((-1.0)*gconst25*x68*x91))+((gconst22*gconst8*x83))+((gconst13*x121))+(((-1.0)*gconst25*x90*x98))+(((-1.0)*gconst26*x72*x88))+((x76*x91))+((gconst0*gconst26*x107))+(((-1.0)*gconst15*x82*x91))+(((-1.0)*gconst10*x103*x106))+((x83*x87))+((gconst10*x122))+((x80*x86))+(((-1.0)*gconst15*x115*x90))+((x83*x92))+(((-1.0)*gconst25*x115*x82))+(((-1.0)*gconst26*x73*x78))+(((-1.0)*gconst10*x112*x72))+(((-1.0)*gconst23*x72*x85))+(((-1.0)*gconst18*x72*x76))+(((-1.0)*x103*x123))+(((-1.0)*gconst11*x82*x94))+(((-1.0)*gconst0*x106*x72))+((x100*x106)));
op[3]=((((-1.0)*gconst17*gconst18*gconst23*gconst4))+((gconst16*gconst18*gconst25*gconst4))+((gconst15*gconst18*gconst22*gconst8))+(((-1.0)*gconst16*gconst19*gconst22*gconst6))+((gconst11*gconst12*gconst14*gconst27))+(((-1.0)*gconst16*gconst20*gconst21*gconst7))+(((-1.0)*gconst10*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst13*gconst14*gconst27))+((gconst0*gconst16*gconst22*gconst25))+((gconst0*gconst15*gconst22*gconst26))+((gconst14*gconst2*gconst21*gconst27))+((gconst10*gconst13*gconst15*gconst26))+(((-1.0)*gconst16*gconst2*gconst21*gconst25))+((gconst11*gconst23*gconst27*gconst3))+(((-1.0)*gconst10*gconst13*gconst17*gconst23))+((gconst11*gconst14*gconst17*gconst21))+(((-1.0)*gconst15*gconst20*gconst26*gconst3))+((gconst12*gconst14*gconst17*gconst20))+(((-1.0)*gconst14*gconst18*gconst22*gconst9))+(((-1.0)*gconst13*gconst18*gconst27*gconst5))+(((-1.0)*gconst16*gconst20*gconst25*gconst3))+((gconst11*gconst21*gconst23*gconst9))+(((-1.0)*gconst11*gconst12*gconst15*gconst26))+(((-1.0)*gconst11*gconst21*gconst26*gconst7))+((gconst14*gconst20*gconst21*gconst9))+((gconst16*gconst18*gconst22*gconst7))+(((-1.0)*gconst17*gconst18*gconst22*gconst5))+(((-1.0)*gconst15*gconst2*gconst21*gconst26))+((gconst12*gconst20*gconst23*gconst9))+((gconst13*gconst18*gconst25*gconst8))+(((-1.0)*gconst13*gconst18*gconst23*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst20))+((gconst10*gconst25*gconst26*gconst4))+(((-1.0)*gconst10*gconst22*gconst27*gconst5))+((gconst14*gconst20*gconst27*gconst3))+((gconst15*gconst18*gconst26*gconst4))+((gconst13*gconst15*gconst16*gconst18))+((gconst10*gconst22*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst23))+(((-1.0)*gconst15*gconst20*gconst21*gconst8))+(((-1.0)*gconst11*gconst15*gconst16*gconst21))+(((-1.0)*gconst10*gconst14*gconst17*gconst22))+(((-1.0)*gconst11*gconst12*gconst16*gconst25))+(((-1.0)*gconst13*gconst19*gconst24*gconst8))+((gconst11*gconst12*gconst17*gconst23))+((gconst12*gconst2*gconst23*gconst27))+(((-1.0)*gconst13*gconst14*gconst17*gconst18))+((gconst17*gconst20*gconst23*gconst3))+(((-1.0)*gconst13*gconst19*gconst26*gconst6))+((gconst17*gconst20*gconst21*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst26))+((gconst10*gconst15*gconst16*gconst22))+(((-1.0)*gconst1*gconst16*gconst22*gconst24))+(((-1.0)*gconst0*gconst13*gconst23*gconst27))+((gconst11*gconst21*gconst27*gconst5))+((gconst13*gconst18*gconst26*gconst7))+((gconst17*gconst2*gconst21*gconst23))+(((-1.0)*gconst10*gconst23*gconst27*gconst4))+(((-1.0)*gconst0*gconst14*gconst22*gconst27))+((gconst0*gconst13*gconst25*gconst26))+(((-1.0)*gconst11*gconst25*gconst26*gconst3))+(((-1.0)*gconst1*gconst13*gconst24*gconst26))+((gconst10*gconst22*gconst26*gconst7))+((gconst12*gconst20*gconst27*gconst5))+(((-1.0)*gconst14*gconst18*gconst27*gconst4))+(((-1.0)*gconst12*gconst20*gconst26*gconst7))+(((-1.0)*gconst11*gconst21*gconst25*gconst8))+(((-1.0)*gconst16*gconst19*gconst24*gconst4))+((gconst10*gconst13*gconst16*gconst25))+(((-1.0)*gconst12*gconst20*gconst25*gconst8)));
op[4]=(((gconst12*gconst14*gconst2*gconst27))+(((-1.0)*gconst11*gconst15*gconst26*gconst3))+(((-1.0)*gconst10*gconst17*gconst23*gconst4))+((gconst10*gconst15*gconst22*gconst8))+(((-1.0)*gconst13*gconst17*gconst18*gconst5))+((gconst2*gconst23*gconst27*gconst3))+((gconst18*gconst22*gconst7*gconst8))+((gconst14*gconst17*gconst2*gconst21))+((gconst20*gconst27*gconst3*gconst5))+(((-1.0)*gconst2*gconst21*gconst25*gconst8))+((gconst11*gconst12*gconst14*gconst17))+(((-1.0)*gconst18*gconst27*gconst4*gconst5))+(((-1.0)*gconst10*gconst13*gconst14*gconst17))+(((-1.0)*gconst2*gconst21*gconst26*gconst7))+(((-1.0)*gconst12*gconst15*gconst2*gconst26))+((gconst10*gconst16*gconst22*gconst7))+((gconst13*gconst15*gconst18*gconst8))+((gconst12*gconst17*gconst2*gconst23))+((gconst10*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst13*gconst16*gconst24))+((gconst11*gconst14*gconst27*gconst3))+(((-1.0)*gconst0*gconst13*gconst14*gconst27))+(((-1.0)*gconst1*gconst22*gconst24*gconst8))+((gconst18*gconst25*gconst4*gconst8))+(((-1.0)*gconst12*gconst16*gconst20*gconst7))+(((-1.0)*gconst13*gconst14*gconst18*gconst9))+((gconst0*gconst13*gconst16*gconst25))+((gconst13*gconst16*gconst18*gconst7))+(((-1.0)*gconst20*gconst26*gconst3*gconst7))+((gconst11*gconst12*gconst27*gconst5))+(((-1.0)*gconst0*gconst14*gconst17*gconst22))+(((-1.0)*gconst20*gconst25*gconst3*gconst8))+(((-1.0)*gconst12*gconst15*gconst20*gconst8))+(((-1.0)*gconst19*gconst26*gconst4*gconst6))+(((-1.0)*gconst15*gconst16*gconst2*gconst21))+(((-1.0)*gconst10*gconst14*gconst22*gconst9))+((gconst10*gconst13*gconst25*gconst8))+(((-1.0)*gconst18*gconst22*gconst5*gconst9))+((gconst10*gconst13*gconst26*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst16))+((gconst0*gconst13*gconst15*gconst26))+(((-1.0)*gconst12*gconst16*gconst2*gconst25))+(((-1.0)*gconst20*gconst21*gconst7*gconst8))+(((-1.0)*gconst11*gconst12*gconst26*gconst7))+(((-1.0)*gconst2*gconst25*gconst26*gconst3))+((gconst2*gconst21*gconst27*gconst5))+(((-1.0)*gconst14*gconst17*gconst18*gconst4))+((gconst2*gconst21*gconst23*gconst9))+(((-1.0)*gconst13*gconst16*gconst19*gconst6))+(((-1.0)*gconst0*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst14*gconst27*gconst4))+(((-1.0)*gconst11*gconst12*gconst25*gconst8))+((gconst12*gconst14*gconst20*gconst9))+((gconst18*gconst26*gconst4*gconst7))+(((-1.0)*gconst0*gconst23*gconst27*gconst4))+((gconst20*gconst21*gconst5*gconst9))+((gconst11*gconst12*gconst23*gconst9))+(((-1.0)*gconst0*gconst22*gconst27*gconst5))+(((-1.0)*gconst10*gconst13*gconst27*gconst5))+(((-1.0)*gconst1*gconst22*gconst26*gconst6))+((gconst10*gconst15*gconst26*gconst4))+(((-1.0)*gconst10*gconst13*gconst23*gconst9))+((gconst11*gconst17*gconst23*gconst3))+(((-1.0)*gconst10*gconst17*gconst22*gconst5))+((gconst0*gconst15*gconst16*gconst22))+(((-1.0)*gconst11*gconst16*gconst21*gconst7))+((gconst0*gconst25*gconst26*gconst4))+(((-1.0)*gconst19*gconst24*gconst4*gconst8))+((gconst0*gconst22*gconst25*gconst8))+(((-1.0)*gconst18*gconst23*gconst4*gconst9))+((gconst11*gconst14*gconst21*gconst9))+(((-1.0)*gconst11*gconst16*gconst25*gconst3))+(((-1.0)*gconst11*gconst15*gconst21*gconst8))+((gconst14*gconst17*gconst20*gconst3))+((gconst12*gconst17*gconst20*gconst5))+((gconst11*gconst17*gconst21*gconst5))+(((-1.0)*gconst19*gconst22*gconst6*gconst8))+((gconst15*gconst16*gconst18*gconst4))+((gconst0*gconst22*gconst26*gconst7))+((gconst20*gconst23*gconst3*gconst9))+(((-1.0)*gconst1*gconst24*gconst26*gconst4))+((gconst10*gconst16*gconst25*gconst4))+(((-1.0)*gconst0*gconst13*gconst17*gconst23))+(((-1.0)*gconst15*gconst16*gconst20*gconst3)));
op[5]=(((gconst0*gconst13*gconst26*gconst7))+(((-1.0)*gconst16*gconst2*gconst25*gconst3))+(((-1.0)*gconst13*gconst18*gconst5*gconst9))+(((-1.0)*gconst16*gconst19*gconst4*gconst6))+((gconst17*gconst20*gconst3*gconst5))+(((-1.0)*gconst0*gconst14*gconst27*gconst4))+((gconst10*gconst15*gconst16*gconst4))+(((-1.0)*gconst0*gconst17*gconst23*gconst4))+(((-1.0)*gconst10*gconst13*gconst14*gconst9))+(((-1.0)*gconst16*gconst20*gconst3*gconst7))+((gconst12*gconst20*gconst5*gconst9))+(((-1.0)*gconst0*gconst14*gconst22*gconst9))+((gconst11*gconst14*gconst17*gconst3))+((gconst0*gconst15*gconst22*gconst8))+(((-1.0)*gconst0*gconst13*gconst14*gconst17))+(((-1.0)*gconst15*gconst2*gconst21*gconst8))+((gconst10*gconst25*gconst4*gconst8))+(((-1.0)*gconst11*gconst25*gconst3*gconst8))+(((-1.0)*gconst1*gconst16*gconst22*gconst6))+(((-1.0)*gconst15*gconst2*gconst26*gconst3))+(((-1.0)*gconst11*gconst26*gconst3*gconst7))+((gconst17*gconst2*gconst23*gconst3))+((gconst0*gconst16*gconst25*gconst4))+((gconst10*gconst26*gconst4*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst8))+((gconst14*gconst2*gconst21*gconst9))+(((-1.0)*gconst0*gconst13*gconst27*gconst5))+((gconst17*gconst2*gconst21*gconst5))+((gconst12*gconst14*gconst17*gconst2))+(((-1.0)*gconst16*gconst2*gconst21*gconst7))+((gconst11*gconst23*gconst3*gconst9))+((gconst10*gconst13*gconst16*gconst7))+((gconst11*gconst12*gconst17*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst8))+((gconst12*gconst2*gconst27*gconst5))+((gconst11*gconst21*gconst5*gconst9))+(((-1.0)*gconst13*gconst19*gconst6*gconst8))+(((-1.0)*gconst10*gconst23*gconst4*gconst9))+((gconst0*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst16*gconst24*gconst4))+((gconst14*gconst20*gconst3*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst2))+(((-1.0)*gconst0*gconst13*gconst23*gconst9))+(((-1.0)*gconst11*gconst15*gconst16*gconst3))+((gconst16*gconst18*gconst4*gconst7))+((gconst12*gconst2*gconst23*gconst9))+(((-1.0)*gconst12*gconst2*gconst26*gconst7))+((gconst10*gconst22*gconst7*gconst8))+(((-1.0)*gconst1*gconst13*gconst24*gconst8))+(((-1.0)*gconst15*gconst20*gconst3*gconst8))+(((-1.0)*gconst12*gconst20*gconst7*gconst8))+((gconst11*gconst12*gconst14*gconst9))+(((-1.0)*gconst10*gconst14*gconst17*gconst4))+((gconst13*gconst18*gconst7*gconst8))+((gconst10*gconst13*gconst15*gconst8))+(((-1.0)*gconst17*gconst18*gconst4*gconst5))+(((-1.0)*gconst10*gconst22*gconst5*gconst9))+(((-1.0)*gconst11*gconst21*gconst7*gconst8))+((gconst14*gconst2*gconst27*gconst3))+(((-1.0)*gconst1*gconst13*gconst26*gconst6))+(((-1.0)*gconst10*gconst27*gconst4*gconst5))+(((-1.0)*gconst14*gconst18*gconst4*gconst9))+((gconst0*gconst15*gconst26*gconst4))+((gconst15*gconst18*gconst4*gconst8))+(((-1.0)*gconst10*gconst13*gconst17*gconst5))+((gconst0*gconst13*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst5))+(((-1.0)*gconst11*gconst12*gconst16*gconst7))+((gconst11*gconst27*gconst3*gconst5))+((gconst0*gconst16*gconst22*gconst7)));
op[6]=((((-1.0)*gconst22*x68*x75))+(((-1.0)*gconst2*x69*x90))+((x79*x89))+((x110*x70))+((x100*x97))+(((-1.0)*gconst23*x74*x78))+((x79*x96))+((x117*x89))+(((-1.0)*gconst15*x68*x89))+((gconst23*gconst9*x77))+(((-1.0)*gconst15*x68*x96))+(((-1.0)*gconst13*x75*x82))+(((-1.0)*gconst5*x72*x74))+(((-1.0)*gconst2*x82*x84))+(((-1.0)*gconst9*x113*x78))+((x97*x98))+((gconst18*gconst8*x99))+((gconst25*gconst4*x70))+((x101*x77))+((x102*x105))+((x102*x104))+(((-1.0)*gconst25*x68*x77))+(((-1.0)*gconst10*x78*x79))+((x108*x99))+((x111*x87))+(((-1.0)*gconst20*x68*x69))+(((-1.0)*gconst14*x103*x74))+((x76*x77))+(((-1.0)*gconst10*x103*x97))+(((-1.0)*gconst4*x109*x68))+(((-1.0)*gconst0*x103*x79))+((x111*x92))+((gconst21*gconst5*x81))+(((-1.0)*gconst0*x101*x78))+(((-1.0)*gconst26*x75*x78))+(((-1.0)*gconst11*x68*x84))+((x104*x118))+((x80*x81))+((x70*x71))+(((-1.0)*gconst4*x68*x88))+(((-1.0)*gconst0*x76*x78))+(((-1.0)*gconst11*x69*x82))+(((-1.0)*gconst15*x77*x82))+(((-1.0)*gconst5*x78*x85))+(((-1.0)*gconst7*x68*x95)));
op[7]=((((-1.0)*gconst10*x78*x97))+((x89*x97))+(((-1.0)*gconst2*x69*x82))+(((-1.0)*gconst5*x103*x74))+(((-1.0)*gconst0*x78*x79))+((x117*x77))+((gconst12*gconst5*x81))+((x118*x70))+(((-1.0)*gconst2*x68*x84))+(((-1.0)*gconst13*x68*x75))+(((-1.0)*gconst11*x68*x69))+(((-1.0)*gconst14*x74*x78))+(((-1.0)*gconst15*x68*x77))+(((-1.0)*gconst16*x75*x78))+((x105*x99))+((x77*x79))+((x102*x70))+((x104*x99)));
op[8]=((((-1.0)*gconst5*x74*x78))+((x70*x99))+(((-1.0)*gconst2*x68*x69))+((x77*x97))+(((-1.0)*gconst4*x68*x75)));
polyroots8(op,zeror,numroots);
IkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];
int numsolutions = 0;
for(int ij27 = 0; ij27 < numroots; ++ij27)
{
IkReal htj27 = zeror[ij27];
tempj27array[0]=((2.0)*(atan(htj27)));
for(int kj27 = 0; kj27 < 1; ++kj27)
{
j27array[numsolutions] = tempj27array[kj27];
if( j27array[numsolutions] > IKPI )
{
    j27array[numsolutions]-=IK2PI;
}
else if( j27array[numsolutions] < -IKPI )
{
    j27array[numsolutions]+=IK2PI;
}
sj27array[numsolutions] = IKsin(j27array[numsolutions]);
cj27array[numsolutions] = IKcos(j27array[numsolutions]);
numsolutions++;
}
}
bool j27valid[8]={true,true,true,true,true,true,true,true};
_nj27 = 8;
for(int ij27 = 0; ij27 < numsolutions; ++ij27)
    {
if( !j27valid[ij27] )
{
    continue;
}
    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];
htj27 = IKtan(j27/2);

_ij27[0] = ij27; _ij27[1] = -1;
for(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)
{
if( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )
{
    j27valid[iij27]=false; _ij27[1] = iij27; break; 
}
}
{
IkReal dummyeval[1];
IkReal gconst44;
IkReal x124=((0.8)*sj29);
IkReal x125=(cj27*px);
IkReal x126=(py*sj27);
IkReal x127=((4.0)*sj29);
gconst44=IKsign(((((-1.0)*x127*(x125*x125)))+(((-1.0)*x127*(x126*x126)))+(((-8.0)*sj29*x125*x126))+((x124*x125))+((x124*x126))+(((-1.0)*x127*(pz*pz)))+(((-0.04)*sj29))));
IkReal x128=(py*sj27);
IkReal x129=((100.0)*sj29);
IkReal x130=(cj27*px*sj29);
dummyeval[0]=((((20.0)*sj29*x128))+(((-1.0)*x129*(cj27*cj27)*(px*px)))+(((-200.0)*x128*x130))+(((-1.0)*sj29))+(((-1.0)*x129*(pz*pz)))+(((-1.0)*x129*(x128*x128)))+(((20.0)*x130)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x131=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x131;
evalcond[2]=x131;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst51;
IkReal x132=(py*sj27);
IkReal x133=((321.0)*cj30);
IkReal x134=(cj27*px);
gconst51=IKsign(((40.0)+(((-321.0)*pz*sj30))+(((-1.0)*x133*x134))+(((-400.0)*x132))+(((-400.0)*x134))+(((-1.0)*x132*x133))+(((32.1)*cj30))));
IkReal x135=(py*sj27);
IkReal x136=((10.0)*cj30);
IkReal x137=(cj27*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x135*x136))+(((-12.4610591900312)*x137))+(((-12.4610591900312)*x135))+(((-10.0)*pz*sj30))+(((-1.0)*x136*x137))+cj30);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x138=((10.0)*sj30);
dummyeval[0]=((((-1.0)*cj27*px*x138))+(((-1.0)*py*sj27*x138))+sj30+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x139=IKsin(j28);
IkReal x140=IKcos(j28);
IkReal x141=(py*sj27*x140);
IkReal x142=(cj27*px*x140);
evalcond[0]=((0.721)*x139);
evalcond[1]=(((py*sj27*x139))+(((-0.1)*x139))+((cj27*px*x139)));
evalcond[2]=((0.721)+(((0.1)*x140))+(((-1.0)*x142))+(((-1.0)*x141)));
evalcond[3]=((-0.5768)+(((-0.08)*x140))+(((0.8)*x141))+(((0.8)*x142)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x826=IKsin(j28);
IkReal x827=IKcos(j28);
IkReal x828=(py*sj27*x827);
IkReal x829=(cj27*px*x827);
evalcond[0]=((0.079)*x826);
evalcond[1]=((((-0.1)*x826))+((py*sj27*x826))+((cj27*px*x826)));
evalcond[2]=((0.079)+(((0.1)*x827))+(((-1.0)*x828))+(((-1.0)*x829)));
evalcond[3]=((-0.0632)+(((0.8)*x829))+(((0.8)*x828))+(((-0.08)*x827)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x830=(cj30*pz);
IkReal x831=((1000.0)*pz);
IkReal x832=(py*sj27*sj30);
IkReal x833=(cj27*px*sj30);
CheckValue<IkReal> x834=IKPowWithIntegerCheck(((((321000.0)*x830))+(((32100.0)*sj30))+(((400000.0)*pz))+(((-321000.0)*x833))+(((-321000.0)*x832))),-1);
if(!x834.valid){
continue;
}
CheckValue<IkReal> x835=IKPowWithIntegerCheck(((((-321.0)*x832))+(((-321.0)*x833))+(((400.0)*pz))+(((32.1)*sj30))+(((321.0)*x830))),-1);
if(!x835.valid){
continue;
}
if( IKabs(((x834.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x835.value)*(((((-100.0)*pz))+((cj27*px*x831))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+((py*sj27*x831)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x834.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x835.value)*(((((-100.0)*pz))+((cj27*px*x831))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+((py*sj27*x831))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x834.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x835.value)*(((((-100.0)*pz))+((cj27*px*x831))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))+((py*sj27*x831))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x836=IKsin(j28);
IkReal x837=IKcos(j28);
IkReal x838=((0.321)*cj30);
IkReal x839=((0.321)*sj30);
IkReal x840=(cj27*px);
IkReal x841=(py*sj27);
IkReal x842=((1.0)*x841);
IkReal x843=(pz*x836);
IkReal x844=((0.8)*x837);
evalcond[0]=((((0.4)*x836))+((x836*x838))+((x837*x839))+pz);
evalcond[1]=(((pz*x837))+((x836*x841))+((x836*x840))+(((-0.1)*x836))+x839);
evalcond[2]=((0.1)+(((-1.0)*x836*x839))+(((0.4)*x837))+((x837*x838))+(((-1.0)*x842))+(((-1.0)*x840)));
evalcond[3]=((0.4)+(((-1.0)*x837*x842))+(((-1.0)*x837*x840))+(((0.1)*x837))+x838+x843);
evalcond[4]=((-0.066959)+((x840*x844))+(((-0.08)*x837))+(((-1.0)*pp))+(((-0.8)*x843))+(((0.2)*x841))+(((0.2)*x840))+((x841*x844)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x845=((1000.0)*pz);
CheckValue<IkReal> x846 = IKatan2WithCheck((gconst51*((((py*sj27*x845))+(((-100.0)*pz))+((cj27*px*x845))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))),(gconst51*(((-160.0)+((pz*x845))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x846.valid){
continue;
}
j28array[0]=x846.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x847=IKsin(j28);
IkReal x848=IKcos(j28);
IkReal x849=((0.321)*cj30);
IkReal x850=((0.321)*sj30);
IkReal x851=(cj27*px);
IkReal x852=(py*sj27);
IkReal x853=((1.0)*x852);
IkReal x854=(pz*x847);
IkReal x855=((0.8)*x848);
evalcond[0]=(((x848*x850))+(((0.4)*x847))+pz+((x847*x849)));
evalcond[1]=(((x847*x851))+((x847*x852))+((pz*x848))+(((-0.1)*x847))+x850);
evalcond[2]=((0.1)+(((-1.0)*x853))+(((-1.0)*x851))+(((0.4)*x848))+((x848*x849))+(((-1.0)*x847*x850)));
evalcond[3]=((0.4)+(((-1.0)*x848*x853))+(((0.1)*x848))+x854+x849+(((-1.0)*x848*x851)));
evalcond[4]=((-0.066959)+(((-0.8)*x854))+(((-0.08)*x848))+(((-1.0)*pp))+((x851*x855))+((x852*x855))+(((0.2)*x852))+(((0.2)*x851)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x856=(px*sj27);
IkReal x857=(cj27*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x857))+x856);
evalcond[2]=((((-1.0)*x856))+x857);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst52;
IkReal x858=(py*sj27);
IkReal x859=((321.0)*cj30);
IkReal x860=(cj27*px);
gconst52=IKsign(((-40.0)+(((400.0)*x860))+(((400.0)*x858))+(((-321.0)*pz*sj30))+((x858*x859))+((x859*x860))+(((-32.1)*cj30))));
IkReal x861=(cj27*px);
IkReal x862=(py*sj27);
IkReal x863=((10.0)*cj30);
dummyeval[0]=((-1.24610591900312)+(((12.4610591900312)*x861))+(((12.4610591900312)*x862))+(((-10.0)*pz*sj30))+(((-1.0)*cj30))+((x862*x863))+((x861*x863)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x864=((10.0)*sj30);
dummyeval[0]=(((cj27*px*x864))+(((-1.0)*sj30))+((py*sj27*x864))+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x865=IKsin(j28);
IkReal x866=IKcos(j28);
IkReal x867=((1.0)*x865);
IkReal x868=(py*sj27*x866);
IkReal x869=(cj27*px*x866);
evalcond[0]=((0.721)*x865);
evalcond[1]=((((-1.0)*cj27*px*x867))+(((0.1)*x865))+(((-1.0)*py*sj27*x867)));
evalcond[2]=((0.721)+(((-1.0)*x869))+(((-1.0)*x868))+(((0.1)*x866)));
evalcond[3]=((-0.5768)+(((0.8)*x869))+(((0.8)*x868))+(((-0.08)*x866)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x870=IKsin(j28);
IkReal x871=IKcos(j28);
IkReal x872=((1.0)*x870);
IkReal x873=(py*sj27*x871);
IkReal x874=(cj27*px*x871);
evalcond[0]=((0.079)*x870);
evalcond[1]=((((-1.0)*cj27*px*x872))+(((0.1)*x870))+(((-1.0)*py*sj27*x872)));
evalcond[2]=((0.079)+(((0.1)*x871))+(((-1.0)*x873))+(((-1.0)*x874)));
evalcond[3]=((-0.0632)+(((-0.08)*x871))+(((0.8)*x873))+(((0.8)*x874)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x875=(cj30*pz);
IkReal x876=(py*sj27);
IkReal x877=((321000.0)*sj30);
IkReal x878=((1000.0)*pz);
IkReal x879=((321.0)*sj30);
IkReal x880=(cj27*px);
CheckValue<IkReal> x881=IKPowWithIntegerCheck((((x876*x877))+((x877*x880))+(((400000.0)*pz))+(((-32100.0)*sj30))+(((321000.0)*x875))),-1);
if(!x881.valid){
continue;
}
CheckValue<IkReal> x882=IKPowWithIntegerCheck(((((321.0)*x875))+((x876*x879))+((x879*x880))+(((400.0)*pz))+(((-32.1)*sj30))),-1);
if(!x882.valid){
continue;
}
if( IKabs(((x881.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x882.value)*(((((-100.0)*pz))+((x876*x878))+(((128.4)*sj30))+((x878*x880))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x881.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x882.value)*(((((-100.0)*pz))+((x876*x878))+(((128.4)*sj30))+((x878*x880))+(((103.041)*cj30*sj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x881.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x882.value)*(((((-100.0)*pz))+((x876*x878))+(((128.4)*sj30))+((x878*x880))+(((103.041)*cj30*sj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x883=IKsin(j28);
IkReal x884=IKcos(j28);
IkReal x885=((0.321)*cj30);
IkReal x886=((0.321)*sj30);
IkReal x887=(py*sj27);
IkReal x888=(cj27*px);
IkReal x889=((1.0)*x887);
IkReal x890=(pz*x883);
IkReal x891=((1.0)*x884);
IkReal x892=((0.8)*x884);
evalcond[0]=(((x883*x885))+(((0.4)*x883))+pz+(((-1.0)*x884*x886)));
evalcond[1]=((0.1)+((x883*x886))+(((-1.0)*x888))+(((-1.0)*x889))+(((0.4)*x884))+((x884*x885)));
evalcond[2]=((0.4)+(((-1.0)*x888*x891))+x885+x890+(((-1.0)*x884*x889))+(((0.1)*x884)));
evalcond[3]=((((-1.0)*x883*x889))+(((-1.0)*x883*x888))+(((-1.0)*pz*x891))+x886+(((0.1)*x883)));
evalcond[4]=((-0.066959)+(((-0.8)*x890))+(((-1.0)*pp))+(((0.2)*x887))+(((0.2)*x888))+((x888*x892))+(((-0.08)*x884))+((x887*x892)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x893=((1000.0)*pz);
CheckValue<IkReal> x894 = IKatan2WithCheck((gconst52*(((((100.0)*pz))+(((-1.0)*cj27*px*x893))+(((128.4)*sj30))+(((-1.0)*py*sj27*x893))+(((103.041)*cj30*sj30))))),(gconst52*(((160.0)+(((-1.0)*pz*x893))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x894.valid){
continue;
}
j28array[0]=x894.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x895=IKsin(j28);
IkReal x896=IKcos(j28);
IkReal x897=((0.321)*cj30);
IkReal x898=((0.321)*sj30);
IkReal x899=(py*sj27);
IkReal x900=(cj27*px);
IkReal x901=((1.0)*x899);
IkReal x902=(pz*x895);
IkReal x903=((1.0)*x896);
IkReal x904=((0.8)*x896);
evalcond[0]=((((-1.0)*x896*x898))+((x895*x897))+(((0.4)*x895))+pz);
evalcond[1]=((0.1)+((x896*x897))+((x895*x898))+(((-1.0)*x901))+(((0.4)*x896))+(((-1.0)*x900)));
evalcond[2]=((0.4)+(((-1.0)*x900*x903))+(((-1.0)*x896*x901))+x897+x902+(((0.1)*x896)));
evalcond[3]=((((-1.0)*x895*x900))+(((-1.0)*x895*x901))+(((-1.0)*pz*x903))+x898+(((0.1)*x895)));
evalcond[4]=((-0.066959)+(((0.2)*x900))+((x900*x904))+(((-1.0)*pp))+((x899*x904))+(((-0.8)*x902))+(((0.2)*x899))+(((-0.08)*x896)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x905=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x905;
evalcond[2]=x905;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst53;
IkReal x906=(py*sj27);
IkReal x907=((321.0)*cj30);
IkReal x908=(cj27*px);
gconst53=IKsign(((40.0)+(((-321.0)*pz*sj30))+(((-400.0)*x908))+(((-400.0)*x906))+(((32.1)*cj30))+(((-1.0)*x907*x908))+(((-1.0)*x906*x907))));
IkReal x909=(py*sj27);
IkReal x910=((10.0)*cj30);
IkReal x911=(cj27*px);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x911))+(((-12.4610591900312)*x909))+(((-10.0)*pz*sj30))+cj30+(((-1.0)*x910*x911))+(((-1.0)*x909*x910)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x912=((10.0)*sj30);
dummyeval[0]=((((-1.0)*cj27*px*x912))+(((-1.0)*py*sj27*x912))+sj30+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x913=IKsin(j28);
IkReal x914=IKcos(j28);
IkReal x915=(py*sj27*x914);
IkReal x916=(cj27*px*x914);
evalcond[0]=((0.721)*x913);
evalcond[1]=(((py*sj27*x913))+(((-0.1)*x913))+((cj27*px*x913)));
evalcond[2]=((0.721)+(((-1.0)*x916))+(((-1.0)*x915))+(((0.1)*x914)));
evalcond[3]=((-0.5768)+(((-0.08)*x914))+(((0.8)*x915))+(((0.8)*x916)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x917=IKsin(j28);
IkReal x918=IKcos(j28);
IkReal x919=(py*sj27*x918);
IkReal x920=(cj27*px*x918);
evalcond[0]=((0.079)*x917);
evalcond[1]=(((py*sj27*x917))+(((-0.1)*x917))+((cj27*px*x917)));
evalcond[2]=((0.079)+(((-1.0)*x920))+(((-1.0)*x919))+(((0.1)*x918)));
evalcond[3]=((-0.0632)+(((-0.08)*x918))+(((0.8)*x920))+(((0.8)*x919)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x921=(cj30*pz);
IkReal x922=((1000.0)*pz);
IkReal x923=(py*sj27*sj30);
IkReal x924=(cj27*px*sj30);
CheckValue<IkReal> x925=IKPowWithIntegerCheck(((((32100.0)*sj30))+(((400000.0)*pz))+(((321000.0)*x921))+(((-321000.0)*x924))+(((-321000.0)*x923))),-1);
if(!x925.valid){
continue;
}
CheckValue<IkReal> x926=IKPowWithIntegerCheck(((((321.0)*x921))+(((-321.0)*x923))+(((-321.0)*x924))+(((400.0)*pz))+(((32.1)*sj30))),-1);
if(!x926.valid){
continue;
}
if( IKabs(((x925.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x926.value)*(((((-100.0)*pz))+((py*sj27*x922))+((cj27*px*x922))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x925.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x926.value)*(((((-100.0)*pz))+((py*sj27*x922))+((cj27*px*x922))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x925.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x926.value)*(((((-100.0)*pz))+((py*sj27*x922))+((cj27*px*x922))+(((-103.041)*cj30*sj30))+(((-128.4)*sj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x927=IKsin(j28);
IkReal x928=IKcos(j28);
IkReal x929=((0.321)*cj30);
IkReal x930=((0.321)*sj30);
IkReal x931=(cj27*px);
IkReal x932=(py*sj27);
IkReal x933=((1.0)*x932);
IkReal x934=(pz*x927);
IkReal x935=((0.8)*x928);
evalcond[0]=(((x927*x929))+((x928*x930))+pz+(((0.4)*x927)));
evalcond[1]=((((-0.1)*x927))+((x927*x932))+((x927*x931))+((pz*x928))+x930);
evalcond[2]=((0.1)+((x928*x929))+(((-1.0)*x927*x930))+(((-1.0)*x931))+(((0.4)*x928))+(((-1.0)*x933)));
evalcond[3]=((0.4)+(((0.1)*x928))+(((-1.0)*x928*x933))+x934+x929+(((-1.0)*x928*x931)));
evalcond[4]=((-0.066959)+(((-0.08)*x928))+(((0.2)*x931))+(((0.2)*x932))+(((-0.8)*x934))+(((-1.0)*pp))+((x931*x935))+((x932*x935)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x936=((1000.0)*pz);
CheckValue<IkReal> x937 = IKatan2WithCheck((gconst53*(((((-100.0)*pz))+((py*sj27*x936))+((cj27*px*x936))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))),(gconst53*(((-160.0)+((pz*x936))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x937.valid){
continue;
}
j28array[0]=x937.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x938=IKsin(j28);
IkReal x939=IKcos(j28);
IkReal x940=((0.321)*cj30);
IkReal x941=((0.321)*sj30);
IkReal x942=(cj27*px);
IkReal x943=(py*sj27);
IkReal x944=((1.0)*x943);
IkReal x945=(pz*x938);
IkReal x946=((0.8)*x939);
evalcond[0]=(((x938*x940))+((x939*x941))+pz+(((0.4)*x938)));
evalcond[1]=((((-0.1)*x938))+((x938*x943))+((x938*x942))+((pz*x939))+x941);
evalcond[2]=((0.1)+(((-1.0)*x944))+(((-1.0)*x938*x941))+((x939*x940))+(((-1.0)*x942))+(((0.4)*x939)));
evalcond[3]=((0.4)+(((0.1)*x939))+(((-1.0)*x939*x944))+(((-1.0)*x939*x942))+x940+x945);
evalcond[4]=((-0.066959)+(((-0.08)*x939))+(((-0.8)*x945))+(((0.2)*x942))+(((0.2)*x943))+((x943*x946))+(((-1.0)*pp))+((x942*x946)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x947=(px*sj27);
IkReal x948=(cj27*py);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((((-1.0)*x948))+x947);
evalcond[2]=((((-1.0)*x947))+x948);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst54;
IkReal x949=(py*sj27);
IkReal x950=((321.0)*cj30);
IkReal x951=(cj27*px);
gconst54=IKsign(((-40.0)+(((400.0)*x951))+((x949*x950))+(((-321.0)*pz*sj30))+(((400.0)*x949))+((x950*x951))+(((-32.1)*cj30))));
IkReal x952=(cj27*px);
IkReal x953=(py*sj27);
IkReal x954=((10.0)*cj30);
dummyeval[0]=((-1.24610591900312)+((x952*x954))+(((-10.0)*pz*sj30))+(((-1.0)*cj30))+((x953*x954))+(((12.4610591900312)*x952))+(((12.4610591900312)*x953)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x955=((10.0)*sj30);
dummyeval[0]=(((cj27*px*x955))+(((-1.0)*sj30))+((py*sj27*x955))+(((10.0)*cj30*pz))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x956=IKsin(j28);
IkReal x957=IKcos(j28);
IkReal x958=((1.0)*x956);
IkReal x959=(py*sj27*x957);
IkReal x960=(cj27*px*x957);
evalcond[0]=((0.721)*x956);
evalcond[1]=((((-1.0)*cj27*px*x958))+(((0.1)*x956))+(((-1.0)*py*sj27*x958)));
evalcond[2]=((0.721)+(((0.1)*x957))+(((-1.0)*x960))+(((-1.0)*x959)));
evalcond[3]=((-0.5768)+(((0.8)*x960))+(((0.8)*x959))+(((-0.08)*x957)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x961=IKsin(j28);
IkReal x962=IKcos(j28);
IkReal x963=((1.0)*x961);
IkReal x964=(py*sj27*x962);
IkReal x965=(cj27*px*x962);
evalcond[0]=((0.079)*x961);
evalcond[1]=((((-1.0)*cj27*px*x963))+(((0.1)*x961))+(((-1.0)*py*sj27*x963)));
evalcond[2]=((0.079)+(((-1.0)*x964))+(((-1.0)*x965))+(((0.1)*x962)));
evalcond[3]=((-0.0632)+(((0.8)*x965))+(((0.8)*x964))+(((-0.08)*x962)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x966=(cj30*pz);
IkReal x967=(py*sj27);
IkReal x968=((321000.0)*sj30);
IkReal x969=((1000.0)*pz);
IkReal x970=((321.0)*sj30);
IkReal x971=(cj27*px);
CheckValue<IkReal> x972=IKPowWithIntegerCheck(((((400000.0)*pz))+((x968*x971))+((x967*x968))+(((-32100.0)*sj30))+(((321000.0)*x966))),-1);
if(!x972.valid){
continue;
}
CheckValue<IkReal> x973=IKPowWithIntegerCheck(((((321.0)*x966))+(((400.0)*pz))+((x967*x970))+((x970*x971))+(((-32.1)*sj30))),-1);
if(!x973.valid){
continue;
}
if( IKabs(((x972.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x973.value)*(((((-100.0)*pz))+((x969*x971))+(((128.4)*sj30))+((x967*x969))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x972.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x973.value)*(((((-100.0)*pz))+((x969*x971))+(((128.4)*sj30))+((x967*x969))+(((103.041)*cj30*sj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x972.value)*(((((103041.0)*(sj30*sj30)))+(((-1000000.0)*(pz*pz)))))), ((x973.value)*(((((-100.0)*pz))+((x969*x971))+(((128.4)*sj30))+((x967*x969))+(((103.041)*cj30*sj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x974=IKsin(j28);
IkReal x975=IKcos(j28);
IkReal x976=((0.321)*cj30);
IkReal x977=((0.321)*sj30);
IkReal x978=(py*sj27);
IkReal x979=(cj27*px);
IkReal x980=((1.0)*x978);
IkReal x981=(pz*x974);
IkReal x982=((1.0)*x975);
IkReal x983=((0.8)*x975);
evalcond[0]=(pz+((x974*x976))+(((-1.0)*x975*x977))+(((0.4)*x974)));
evalcond[1]=((0.1)+(((-1.0)*x980))+((x975*x976))+(((-1.0)*x979))+((x974*x977))+(((0.4)*x975)));
evalcond[2]=((0.4)+(((0.1)*x975))+(((-1.0)*x975*x980))+(((-1.0)*x979*x982))+x981+x976);
evalcond[3]=((((0.1)*x974))+(((-1.0)*pz*x982))+(((-1.0)*x974*x980))+(((-1.0)*x974*x979))+x977);
evalcond[4]=((-0.066959)+(((-0.8)*x981))+((x979*x983))+(((-1.0)*pp))+(((0.2)*x978))+(((0.2)*x979))+(((-0.08)*x975))+((x978*x983)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x984=((1000.0)*pz);
CheckValue<IkReal> x985 = IKatan2WithCheck((gconst54*(((((-1.0)*cj27*px*x984))+(((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))+(((-1.0)*py*sj27*x984))))),(gconst54*(((160.0)+(((-1.0)*pz*x984))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x985.valid){
continue;
}
j28array[0]=x985.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x986=IKsin(j28);
IkReal x987=IKcos(j28);
IkReal x988=((0.321)*cj30);
IkReal x989=((0.321)*sj30);
IkReal x990=(py*sj27);
IkReal x991=(cj27*px);
IkReal x992=((1.0)*x990);
IkReal x993=(pz*x986);
IkReal x994=((1.0)*x987);
IkReal x995=((0.8)*x987);
evalcond[0]=((((0.4)*x986))+((x986*x988))+pz+(((-1.0)*x987*x989)));
evalcond[1]=((0.1)+(((-1.0)*x991))+(((0.4)*x987))+((x986*x989))+(((-1.0)*x992))+((x987*x988)));
evalcond[2]=((0.4)+(((0.1)*x987))+(((-1.0)*x991*x994))+x993+x988+(((-1.0)*x987*x992)));
evalcond[3]=((((-1.0)*x986*x991))+(((0.1)*x986))+(((-1.0)*pz*x994))+x989+(((-1.0)*x986*x992)));
evalcond[4]=((-0.066959)+(((-0.8)*x993))+((x991*x995))+((x990*x995))+(((-1.0)*pp))+(((-0.08)*x987))+(((0.2)*x991))+(((0.2)*x990)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x996=((-1.0)*cj27*py);
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x996;
evalcond[2]=x996;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*pz*sj30))+cj30);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst55;
CheckValue<IkReal> x997 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x997.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x998=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x998.valid){
continue;
}
if( (((1.24610591900312)*(x998.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x998.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst55=((((-1.0)*(x997.value)))+(((-1.0)*(IKasin(((1.24610591900312)*(x998.value)))))));
IkReal gconst56;
gconst56=IKsin(gconst55);
IkReal gconst57;
gconst57=IKcos(gconst55);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst55))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst57))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst57+(((-10.0)*gconst56*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x999=(gconst56*pz);
CheckValue<IkReal> x1000=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x999))+(((32.1)*gconst57))),-1);
if(!x1000.valid){
continue;
}
CheckValue<IkReal> x1001=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst57))+(((-321000.0)*x999))),-1);
if(!x1001.valid){
continue;
}
if( IKabs(((x1000.value)*(((((-100.0)*pz))+(((128.4)*gconst56))+(((103.041)*gconst56*gconst57)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1001.value)*(((-10000.0)+(((103041.0)*(gconst56*gconst56))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1000.value)*(((((-100.0)*pz))+(((128.4)*gconst56))+(((103.041)*gconst56*gconst57))))))+IKsqr(((x1001.value)*(((-10000.0)+(((103041.0)*(gconst56*gconst56)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1000.value)*(((((-100.0)*pz))+(((128.4)*gconst56))+(((103.041)*gconst56*gconst57))))), ((x1001.value)*(((-10000.0)+(((103041.0)*(gconst56*gconst56)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1002=IKcos(j28);
IkReal x1003=IKsin(j28);
IkReal x1004=((0.321)*gconst56);
IkReal x1005=((0.321)*gconst57);
IkReal x1006=((0.321)*x1003);
IkReal x1007=(pz*x1003);
evalcond[0]=(x1004+((pz*x1002))+(((-0.1)*x1003)));
evalcond[1]=((0.4)+(((0.1)*x1002))+x1007+x1005);
evalcond[2]=((-0.32)+(((-0.08)*x1002))+(((-0.2568)*gconst57))+(((-0.8)*x1007)));
evalcond[3]=((((0.4)*x1003))+pz+((x1002*x1004))+((x1003*x1005)));
evalcond[4]=((0.1)+(((0.4)*x1002))+((x1002*x1005))+(((-1.0)*x1003*x1004)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1008=pz*pz;
IkReal x1009=((321.0)*gconst56);
CheckValue<IkReal> x1010=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1008))),-1);
if(!x1010.valid){
continue;
}
CheckValue<IkReal> x1011=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1008))),-1);
if(!x1011.valid){
continue;
}
if( IKabs(((x1010.value)*(((((-3210.0)*gconst57*pz))+x1009+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1011.value)*(((-40.0)+(((-1.0)*pz*x1009))+(((-32.1)*gconst57)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1010.value)*(((((-3210.0)*gconst57*pz))+x1009+(((-4000.0)*pz))))))+IKsqr(((x1011.value)*(((-40.0)+(((-1.0)*pz*x1009))+(((-32.1)*gconst57))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1010.value)*(((((-3210.0)*gconst57*pz))+x1009+(((-4000.0)*pz))))), ((x1011.value)*(((-40.0)+(((-1.0)*pz*x1009))+(((-32.1)*gconst57))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1012=IKcos(j28);
IkReal x1013=IKsin(j28);
IkReal x1014=((0.321)*gconst56);
IkReal x1015=((0.321)*gconst57);
IkReal x1016=((0.321)*x1013);
IkReal x1017=(pz*x1013);
evalcond[0]=(x1014+((pz*x1012))+(((-0.1)*x1013)));
evalcond[1]=((0.4)+x1015+x1017+(((0.1)*x1012)));
evalcond[2]=((-0.32)+(((-0.08)*x1012))+(((-0.2568)*gconst57))+(((-0.8)*x1017)));
evalcond[3]=((((0.4)*x1013))+((x1013*x1015))+((x1012*x1014))+pz);
evalcond[4]=((0.1)+(((0.4)*x1012))+((x1012*x1015))+(((-1.0)*x1013*x1014)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1018=pz*pz;
IkReal x1019=((321.0)*gconst56);
CheckValue<IkReal> x1020=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1018))),-1);
if(!x1020.valid){
continue;
}
CheckValue<IkReal> x1021=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1018))),-1);
if(!x1021.valid){
continue;
}
if( IKabs(((x1020.value)*(((((-3210.0)*gconst57*pz))+x1019+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1021.value)*(((40.0)+((pz*x1019))+(((32.1)*gconst57)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1020.value)*(((((-3210.0)*gconst57*pz))+x1019+(((-4000.0)*pz))))))+IKsqr(((x1021.value)*(((40.0)+((pz*x1019))+(((32.1)*gconst57))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1020.value)*(((((-3210.0)*gconst57*pz))+x1019+(((-4000.0)*pz))))), ((x1021.value)*(((40.0)+((pz*x1019))+(((32.1)*gconst57))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1022=IKcos(j28);
IkReal x1023=IKsin(j28);
IkReal x1024=((0.321)*gconst56);
IkReal x1025=((0.321)*gconst57);
IkReal x1026=((0.321)*x1023);
IkReal x1027=(pz*x1023);
evalcond[0]=(x1024+(((-0.1)*x1023))+((pz*x1022)));
evalcond[1]=((0.4)+x1025+x1027+(((0.1)*x1022)));
evalcond[2]=((-0.32)+(((-0.08)*x1022))+(((-0.2568)*gconst57))+(((-0.8)*x1027)));
evalcond[3]=((((0.4)*x1023))+((x1023*x1025))+((x1022*x1024))+pz);
evalcond[4]=((0.1)+(((0.4)*x1022))+(((-1.0)*x1023*x1024))+((x1022*x1025)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst58;
CheckValue<IkReal> x1028 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1028.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1029=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1029.valid){
continue;
}
if( (((1.24610591900312)*(x1029.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1029.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst58=((3.14159265358979)+(((-1.0)*(x1028.value)))+(IKasin(((1.24610591900312)*(x1029.value)))));
IkReal gconst59;
gconst59=IKsin(gconst58);
IkReal gconst60;
gconst60=IKcos(gconst58);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst58))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst60))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst60+(((-10.0)*gconst59*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1030=(gconst59*pz);
CheckValue<IkReal> x1031=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1030))+(((32.1)*gconst60))),-1);
if(!x1031.valid){
continue;
}
CheckValue<IkReal> x1032=IKPowWithIntegerCheck(((40000.0)+(((-321000.0)*x1030))+(((32100.0)*gconst60))),-1);
if(!x1032.valid){
continue;
}
if( IKabs(((x1031.value)*(((((-100.0)*pz))+(((103.041)*gconst59*gconst60))+(((128.4)*gconst59)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1032.value)*(((-10000.0)+(((103041.0)*(gconst59*gconst59))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1031.value)*(((((-100.0)*pz))+(((103.041)*gconst59*gconst60))+(((128.4)*gconst59))))))+IKsqr(((x1032.value)*(((-10000.0)+(((103041.0)*(gconst59*gconst59)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1031.value)*(((((-100.0)*pz))+(((103.041)*gconst59*gconst60))+(((128.4)*gconst59))))), ((x1032.value)*(((-10000.0)+(((103041.0)*(gconst59*gconst59)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1033=IKcos(j28);
IkReal x1034=IKsin(j28);
IkReal x1035=((0.321)*gconst59);
IkReal x1036=((0.321)*gconst60);
IkReal x1037=(pz*x1034);
evalcond[0]=((((-0.1)*x1034))+x1035+((pz*x1033)));
evalcond[1]=((0.4)+(((0.1)*x1033))+x1036+x1037);
evalcond[2]=((-0.32)+(((-0.08)*x1033))+(((-0.2568)*gconst60))+(((-0.8)*x1037)));
evalcond[3]=((((0.4)*x1034))+pz+((x1034*x1036))+((x1033*x1035)));
evalcond[4]=((0.1)+(((0.4)*x1033))+(((-1.0)*x1034*x1035))+((x1033*x1036)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1038=pz*pz;
IkReal x1039=((321.0)*gconst59);
CheckValue<IkReal> x1040=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1038))),-1);
if(!x1040.valid){
continue;
}
CheckValue<IkReal> x1041=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1038))),-1);
if(!x1041.valid){
continue;
}
if( IKabs(((x1040.value)*(((((-3210.0)*gconst60*pz))+x1039+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1041.value)*(((-40.0)+(((-1.0)*pz*x1039))+(((-32.1)*gconst60)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1040.value)*(((((-3210.0)*gconst60*pz))+x1039+(((-4000.0)*pz))))))+IKsqr(((x1041.value)*(((-40.0)+(((-1.0)*pz*x1039))+(((-32.1)*gconst60))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1040.value)*(((((-3210.0)*gconst60*pz))+x1039+(((-4000.0)*pz))))), ((x1041.value)*(((-40.0)+(((-1.0)*pz*x1039))+(((-32.1)*gconst60))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1042=IKcos(j28);
IkReal x1043=IKsin(j28);
IkReal x1044=((0.321)*gconst59);
IkReal x1045=((0.321)*gconst60);
IkReal x1046=(pz*x1043);
evalcond[0]=(x1044+(((-0.1)*x1043))+((pz*x1042)));
evalcond[1]=((0.4)+x1046+x1045+(((0.1)*x1042)));
evalcond[2]=((-0.32)+(((-0.8)*x1046))+(((-0.2568)*gconst60))+(((-0.08)*x1042)));
evalcond[3]=(((x1042*x1044))+((x1043*x1045))+(((0.4)*x1043))+pz);
evalcond[4]=((0.1)+((x1042*x1045))+(((-1.0)*x1043*x1044))+(((0.4)*x1042)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1047=pz*pz;
IkReal x1048=((321.0)*gconst59);
CheckValue<IkReal> x1049=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1047))),-1);
if(!x1049.valid){
continue;
}
CheckValue<IkReal> x1050=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1047))),-1);
if(!x1050.valid){
continue;
}
if( IKabs(((x1049.value)*(((((-3210.0)*gconst60*pz))+x1048+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1050.value)*(((40.0)+((pz*x1048))+(((32.1)*gconst60)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1049.value)*(((((-3210.0)*gconst60*pz))+x1048+(((-4000.0)*pz))))))+IKsqr(((x1050.value)*(((40.0)+((pz*x1048))+(((32.1)*gconst60))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1049.value)*(((((-3210.0)*gconst60*pz))+x1048+(((-4000.0)*pz))))), ((x1050.value)*(((40.0)+((pz*x1048))+(((32.1)*gconst60))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1051=IKcos(j28);
IkReal x1052=IKsin(j28);
IkReal x1053=((0.321)*gconst59);
IkReal x1054=((0.321)*gconst60);
IkReal x1055=(pz*x1052);
evalcond[0]=(x1053+(((-0.1)*x1052))+((pz*x1051)));
evalcond[1]=((0.4)+x1054+x1055+(((0.1)*x1051)));
evalcond[2]=((-0.32)+(((-0.08)*x1051))+(((-0.8)*x1055))+(((-0.2568)*gconst60)));
evalcond[3]=(((x1052*x1054))+(((0.4)*x1052))+((x1051*x1053))+pz);
evalcond[4]=((0.1)+(((-1.0)*x1052*x1053))+(((0.4)*x1051))+((x1051*x1054)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1056=(pz*sj30);
CheckValue<IkReal> x1057=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1056))+(((32.1)*cj30))),-1);
if(!x1057.valid){
continue;
}
CheckValue<IkReal> x1058=IKPowWithIntegerCheck(((40000.0)+(((-321000.0)*x1056))+(((32100.0)*cj30))),-1);
if(!x1058.valid){
continue;
}
if( IKabs(((x1057.value)*(((((-100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1058.value)*(((-10000.0)+(((103041.0)*(sj30*sj30))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1057.value)*(((((-100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1058.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1057.value)*(((((-100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1058.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1059=IKcos(j28);
IkReal x1060=IKsin(j28);
IkReal x1061=(pz*x1060);
IkReal x1062=((0.321)*x1060);
IkReal x1063=((0.321)*x1059);
evalcond[0]=((((0.321)*sj30))+(((-0.1)*x1060))+((pz*x1059)));
evalcond[1]=((0.4)+x1061+(((0.321)*cj30))+(((0.1)*x1059)));
evalcond[2]=((-0.066959)+(((-0.08)*x1059))+(((-1.0)*pp))+(((-0.8)*x1061)));
evalcond[3]=(((sj30*x1063))+(((0.4)*x1060))+((cj30*x1062))+pz);
evalcond[4]=((0.1)+(((-1.0)*sj30*x1062))+((cj30*x1063))+(((0.4)*x1059)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1064=pz*pz;
IkReal x1065=((321.0)*sj30);
CheckValue<IkReal> x1066=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1064))),-1);
if(!x1066.valid){
continue;
}
CheckValue<IkReal> x1067=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1064))),-1);
if(!x1067.valid){
continue;
}
if( IKabs(((x1066.value)*(((((-836.9875)*pz))+x1065+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1067.value)*(((-8.369875)+(((-1.0)*pz*x1065))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1066.value)*(((((-836.9875)*pz))+x1065+(((-12500.0)*pp*pz))))))+IKsqr(((x1067.value)*(((-8.369875)+(((-1.0)*pz*x1065))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1066.value)*(((((-836.9875)*pz))+x1065+(((-12500.0)*pp*pz))))), ((x1067.value)*(((-8.369875)+(((-1.0)*pz*x1065))+(((-125.0)*pp))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1068=IKcos(j28);
IkReal x1069=IKsin(j28);
IkReal x1070=(pz*x1069);
IkReal x1071=((0.321)*x1069);
IkReal x1072=((0.321)*x1068);
evalcond[0]=((((0.321)*sj30))+(((-0.1)*x1069))+((pz*x1068)));
evalcond[1]=((0.4)+x1070+(((0.321)*cj30))+(((0.1)*x1068)));
evalcond[2]=((-0.066959)+(((-0.08)*x1068))+(((-1.0)*pp))+(((-0.8)*x1070)));
evalcond[3]=(((sj30*x1072))+(((0.4)*x1069))+((cj30*x1071))+pz);
evalcond[4]=((0.1)+(((-1.0)*sj30*x1071))+(((0.4)*x1068))+((cj30*x1072)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1073=pz*pz;
IkReal x1074=((321.0)*sj30);
CheckValue<IkReal> x1075=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1073))),-1);
if(!x1075.valid){
continue;
}
CheckValue<IkReal> x1076=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1073))),-1);
if(!x1076.valid){
continue;
}
if( IKabs(((x1075.value)*((x1074+(((-4000.0)*pz))+(((-3210.0)*cj30*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1076.value)*(((40.0)+((pz*x1074))+(((32.1)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1075.value)*((x1074+(((-4000.0)*pz))+(((-3210.0)*cj30*pz))))))+IKsqr(((x1076.value)*(((40.0)+((pz*x1074))+(((32.1)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1075.value)*((x1074+(((-4000.0)*pz))+(((-3210.0)*cj30*pz))))), ((x1076.value)*(((40.0)+((pz*x1074))+(((32.1)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1077=IKcos(j28);
IkReal x1078=IKsin(j28);
IkReal x1079=(pz*x1078);
IkReal x1080=((0.321)*x1078);
IkReal x1081=((0.321)*x1077);
evalcond[0]=((((0.321)*sj30))+((pz*x1077))+(((-0.1)*x1078)));
evalcond[1]=((0.4)+x1079+(((0.321)*cj30))+(((0.1)*x1077)));
evalcond[2]=((-0.066959)+(((-0.08)*x1077))+(((-1.0)*pp))+(((-0.8)*x1079)));
evalcond[3]=(((sj30*x1081))+(((0.4)*x1078))+pz+((cj30*x1080)));
evalcond[4]=((0.1)+(((0.4)*x1077))+((cj30*x1081))+(((-1.0)*sj30*x1080)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1082=(cj27*py);
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((-1.0)*x1082);
evalcond[2]=x1082;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj30))+(((-1.0)*cj30)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst61;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1083=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1083.valid){
continue;
}
if( (((1.24610591900312)*(x1083.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1083.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1084 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1084.valid){
continue;
}
gconst61=((IKasin(((1.24610591900312)*(x1083.value))))+(((-1.0)*(x1084.value))));
IkReal gconst62;
gconst62=IKsin(gconst61);
IkReal gconst63;
gconst63=IKcos(gconst61);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst61))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst63))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst63))+(((-10.0)*gconst62*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1085=(gconst62*pz);
CheckValue<IkReal> x1086=IKPowWithIntegerCheck(((-40.0)+(((-32.1)*gconst63))+(((-321.0)*x1085))),-1);
if(!x1086.valid){
continue;
}
CheckValue<IkReal> x1087=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst63))+(((321000.0)*x1085))),-1);
if(!x1087.valid){
continue;
}
if( IKabs(((x1086.value)*(((((100.0)*pz))+(((103.041)*gconst62*gconst63))+(((128.4)*gconst62)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1087.value)*(((-10000.0)+(((103041.0)*(gconst62*gconst62))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1086.value)*(((((100.0)*pz))+(((103.041)*gconst62*gconst63))+(((128.4)*gconst62))))))+IKsqr(((x1087.value)*(((-10000.0)+(((103041.0)*(gconst62*gconst62)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1086.value)*(((((100.0)*pz))+(((103.041)*gconst62*gconst63))+(((128.4)*gconst62))))), ((x1087.value)*(((-10000.0)+(((103041.0)*(gconst62*gconst62)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1088=IKsin(j28);
IkReal x1089=IKcos(j28);
IkReal x1090=((0.321)*gconst63);
IkReal x1091=((0.321)*gconst62);
IkReal x1092=(pz*x1088);
IkReal x1093=((0.321)*x1088);
evalcond[0]=((0.4)+x1090+x1092+(((0.1)*x1089)));
evalcond[1]=((((-1.0)*pz*x1089))+x1091+(((0.1)*x1088)));
evalcond[2]=((-0.32)+(((-0.8)*x1092))+(((-0.08)*x1089))+(((-0.2568)*gconst63)));
evalcond[3]=((((-1.0)*x1089*x1091))+((x1088*x1090))+pz+(((0.4)*x1088)));
evalcond[4]=((0.1)+((x1089*x1090))+((x1088*x1091))+(((0.4)*x1089)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1094=pz*pz;
IkReal x1095=((321.0)*gconst62);
CheckValue<IkReal> x1096=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1094))),-1);
if(!x1096.valid){
continue;
}
CheckValue<IkReal> x1097=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1094))),-1);
if(!x1097.valid){
continue;
}
if( IKabs(((x1096.value)*(((((-3210.0)*gconst63*pz))+(((-1.0)*x1095))+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1097.value)*(((-40.0)+(((-32.1)*gconst63))+((pz*x1095)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1096.value)*(((((-3210.0)*gconst63*pz))+(((-1.0)*x1095))+(((-4000.0)*pz))))))+IKsqr(((x1097.value)*(((-40.0)+(((-32.1)*gconst63))+((pz*x1095))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1096.value)*(((((-3210.0)*gconst63*pz))+(((-1.0)*x1095))+(((-4000.0)*pz))))), ((x1097.value)*(((-40.0)+(((-32.1)*gconst63))+((pz*x1095))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1098=IKsin(j28);
IkReal x1099=IKcos(j28);
IkReal x1100=((0.321)*gconst63);
IkReal x1101=((0.321)*gconst62);
IkReal x1102=(pz*x1098);
IkReal x1103=((0.321)*x1098);
evalcond[0]=((0.4)+x1102+x1100+(((0.1)*x1099)));
evalcond[1]=(x1101+(((0.1)*x1098))+(((-1.0)*pz*x1099)));
evalcond[2]=((-0.32)+(((-0.8)*x1102))+(((-0.08)*x1099))+(((-0.2568)*gconst63)));
evalcond[3]=(((x1098*x1100))+pz+(((-1.0)*x1099*x1101))+(((0.4)*x1098)));
evalcond[4]=((0.1)+((x1098*x1101))+((x1099*x1100))+(((0.4)*x1099)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1104=pz*pz;
IkReal x1105=((321.0)*gconst62);
CheckValue<IkReal> x1106=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1104))),-1);
if(!x1106.valid){
continue;
}
CheckValue<IkReal> x1107=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1104))),-1);
if(!x1107.valid){
continue;
}
if( IKabs(((x1106.value)*((x1105+(((4000.0)*pz))+(((3210.0)*gconst63*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1107.value)*(((-40.0)+((pz*x1105))+(((-32.1)*gconst63)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1106.value)*((x1105+(((4000.0)*pz))+(((3210.0)*gconst63*pz))))))+IKsqr(((x1107.value)*(((-40.0)+((pz*x1105))+(((-32.1)*gconst63))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1106.value)*((x1105+(((4000.0)*pz))+(((3210.0)*gconst63*pz))))), ((x1107.value)*(((-40.0)+((pz*x1105))+(((-32.1)*gconst63))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1108=IKsin(j28);
IkReal x1109=IKcos(j28);
IkReal x1110=((0.321)*gconst63);
IkReal x1111=((0.321)*gconst62);
IkReal x1112=(pz*x1108);
IkReal x1113=((0.321)*x1108);
evalcond[0]=((0.4)+x1110+x1112+(((0.1)*x1109)));
evalcond[1]=(x1111+(((0.1)*x1108))+(((-1.0)*pz*x1109)));
evalcond[2]=((-0.32)+(((-0.8)*x1112))+(((-0.08)*x1109))+(((-0.2568)*gconst63)));
evalcond[3]=(((x1108*x1110))+(((-1.0)*x1109*x1111))+pz+(((0.4)*x1108)));
evalcond[4]=((0.1)+((x1109*x1110))+((x1108*x1111))+(((0.4)*x1109)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst64;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1114=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1114.valid){
continue;
}
if( (((1.24610591900312)*(x1114.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1114.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1115 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1115.valid){
continue;
}
gconst64=((3.14159265358979)+(((-1.0)*(IKasin(((1.24610591900312)*(x1114.value))))))+(((-1.0)*(x1115.value))));
IkReal gconst65;
gconst65=IKsin(gconst64);
IkReal gconst66;
gconst66=IKcos(gconst64);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst64))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst66))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*gconst65*pz))+(((-1.0)*gconst66)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1116=(gconst65*pz);
CheckValue<IkReal> x1117=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1116))+(((-32.1)*gconst66))),-1);
if(!x1117.valid){
continue;
}
CheckValue<IkReal> x1118=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst66))+(((321000.0)*x1116))),-1);
if(!x1118.valid){
continue;
}
if( IKabs(((x1117.value)*(((((100.0)*pz))+(((128.4)*gconst65))+(((103.041)*gconst65*gconst66)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1118.value)*(((-10000.0)+(((103041.0)*(gconst65*gconst65))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1117.value)*(((((100.0)*pz))+(((128.4)*gconst65))+(((103.041)*gconst65*gconst66))))))+IKsqr(((x1118.value)*(((-10000.0)+(((103041.0)*(gconst65*gconst65)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1117.value)*(((((100.0)*pz))+(((128.4)*gconst65))+(((103.041)*gconst65*gconst66))))), ((x1118.value)*(((-10000.0)+(((103041.0)*(gconst65*gconst65)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1119=IKsin(j28);
IkReal x1120=IKcos(j28);
IkReal x1121=((0.321)*gconst65);
IkReal x1122=((0.321)*gconst66);
IkReal x1123=(pz*x1119);
evalcond[0]=((0.4)+x1122+x1123+(((0.1)*x1120)));
evalcond[1]=(x1121+(((-1.0)*pz*x1120))+(((0.1)*x1119)));
evalcond[2]=((-0.32)+(((-0.8)*x1123))+(((-0.2568)*gconst66))+(((-0.08)*x1120)));
evalcond[3]=(((x1119*x1122))+pz+(((0.4)*x1119))+(((-1.0)*x1120*x1121)));
evalcond[4]=((0.1)+((x1120*x1122))+((x1119*x1121))+(((0.4)*x1120)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1124=pz*pz;
IkReal x1125=((321.0)*gconst65);
CheckValue<IkReal> x1126=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1124))),-1);
if(!x1126.valid){
continue;
}
CheckValue<IkReal> x1127=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1124))),-1);
if(!x1127.valid){
continue;
}
if( IKabs(((x1126.value)*(((((-4000.0)*pz))+(((-1.0)*x1125))+(((-3210.0)*gconst66*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1127.value)*(((-40.0)+((pz*x1125))+(((-32.1)*gconst66)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1126.value)*(((((-4000.0)*pz))+(((-1.0)*x1125))+(((-3210.0)*gconst66*pz))))))+IKsqr(((x1127.value)*(((-40.0)+((pz*x1125))+(((-32.1)*gconst66))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1126.value)*(((((-4000.0)*pz))+(((-1.0)*x1125))+(((-3210.0)*gconst66*pz))))), ((x1127.value)*(((-40.0)+((pz*x1125))+(((-32.1)*gconst66))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1128=IKsin(j28);
IkReal x1129=IKcos(j28);
IkReal x1130=((0.321)*gconst65);
IkReal x1131=((0.321)*gconst66);
IkReal x1132=(pz*x1128);
evalcond[0]=((0.4)+x1132+x1131+(((0.1)*x1129)));
evalcond[1]=(x1130+(((-1.0)*pz*x1129))+(((0.1)*x1128)));
evalcond[2]=((-0.32)+(((-0.8)*x1132))+(((-0.2568)*gconst66))+(((-0.08)*x1129)));
evalcond[3]=(pz+(((0.4)*x1128))+((x1128*x1131))+(((-1.0)*x1129*x1130)));
evalcond[4]=((0.1)+((x1129*x1131))+(((0.4)*x1129))+((x1128*x1130)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1133=pz*pz;
IkReal x1134=((321.0)*gconst65);
CheckValue<IkReal> x1135=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1133))),-1);
if(!x1135.valid){
continue;
}
CheckValue<IkReal> x1136=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1133))),-1);
if(!x1136.valid){
continue;
}
if( IKabs(((x1135.value)*((x1134+(((4000.0)*pz))+(((3210.0)*gconst66*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1136.value)*(((-40.0)+((pz*x1134))+(((-32.1)*gconst66)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1135.value)*((x1134+(((4000.0)*pz))+(((3210.0)*gconst66*pz))))))+IKsqr(((x1136.value)*(((-40.0)+((pz*x1134))+(((-32.1)*gconst66))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1135.value)*((x1134+(((4000.0)*pz))+(((3210.0)*gconst66*pz))))), ((x1136.value)*(((-40.0)+((pz*x1134))+(((-32.1)*gconst66))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1137=IKsin(j28);
IkReal x1138=IKcos(j28);
IkReal x1139=((0.321)*gconst65);
IkReal x1140=((0.321)*gconst66);
IkReal x1141=(pz*x1137);
evalcond[0]=((0.4)+x1140+x1141+(((0.1)*x1138)));
evalcond[1]=(x1139+(((-1.0)*pz*x1138))+(((0.1)*x1137)));
evalcond[2]=((-0.32)+(((-0.8)*x1141))+(((-0.08)*x1138))+(((-0.2568)*gconst66)));
evalcond[3]=(((x1137*x1140))+(((0.4)*x1137))+pz+(((-1.0)*x1138*x1139)));
evalcond[4]=((0.1)+((x1137*x1139))+(((0.4)*x1138))+((x1138*x1140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1142=(pz*sj30);
CheckValue<IkReal> x1143=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1142))+(((-32.1)*cj30))),-1);
if(!x1143.valid){
continue;
}
CheckValue<IkReal> x1144=IKPowWithIntegerCheck(((40000.0)+(((321000.0)*x1142))+(((32100.0)*cj30))),-1);
if(!x1144.valid){
continue;
}
if( IKabs(((x1143.value)*(((((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1144.value)*(((-10000.0)+(((103041.0)*(sj30*sj30))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1143.value)*(((((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1144.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1143.value)*(((((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1144.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1145=IKsin(j28);
IkReal x1146=IKcos(j28);
IkReal x1147=((0.321)*cj30);
IkReal x1148=((0.321)*sj30);
IkReal x1149=(pz*x1145);
IkReal x1150=((0.321)*x1145);
evalcond[0]=((0.4)+x1147+x1149+(((0.1)*x1146)));
evalcond[1]=(x1148+(((-1.0)*pz*x1146))+(((0.1)*x1145)));
evalcond[2]=((-0.066959)+(((-0.8)*x1149))+(((-0.08)*x1146))+(((-1.0)*pp)));
evalcond[3]=(((x1145*x1147))+(((-1.0)*x1146*x1148))+pz+(((0.4)*x1145)));
evalcond[4]=((0.1)+((x1145*x1148))+((x1146*x1147))+(((0.4)*x1146)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1151=pz*pz;
IkReal x1152=((321.0)*sj30);
CheckValue<IkReal> x1153=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1151))),-1);
if(!x1153.valid){
continue;
}
CheckValue<IkReal> x1154=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1151))),-1);
if(!x1154.valid){
continue;
}
if( IKabs(((x1153.value)*(((((-836.9875)*pz))+(((-1.0)*x1152))+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1154.value)*(((-8.369875)+((pz*x1152))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1153.value)*(((((-836.9875)*pz))+(((-1.0)*x1152))+(((-12500.0)*pp*pz))))))+IKsqr(((x1154.value)*(((-8.369875)+((pz*x1152))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1153.value)*(((((-836.9875)*pz))+(((-1.0)*x1152))+(((-12500.0)*pp*pz))))), ((x1154.value)*(((-8.369875)+((pz*x1152))+(((-125.0)*pp))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1155=IKsin(j28);
IkReal x1156=IKcos(j28);
IkReal x1157=((0.321)*cj30);
IkReal x1158=((0.321)*sj30);
IkReal x1159=(pz*x1155);
IkReal x1160=((0.321)*x1155);
evalcond[0]=((0.4)+(((0.1)*x1156))+x1159+x1157);
evalcond[1]=((((0.1)*x1155))+x1158+(((-1.0)*pz*x1156)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x1156))+(((-0.8)*x1159)));
evalcond[3]=((((-1.0)*x1156*x1158))+pz+(((0.4)*x1155))+((x1155*x1157)));
evalcond[4]=((0.1)+(((0.4)*x1156))+((x1156*x1157))+((x1155*x1158)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1161=pz*pz;
IkReal x1162=((321.0)*sj30);
CheckValue<IkReal> x1163=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1161))),-1);
if(!x1163.valid){
continue;
}
CheckValue<IkReal> x1164=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1161))),-1);
if(!x1164.valid){
continue;
}
if( IKabs(((x1163.value)*((x1162+(((4000.0)*pz))+(((3210.0)*cj30*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1164.value)*(((-40.0)+((pz*x1162))+(((-32.1)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1163.value)*((x1162+(((4000.0)*pz))+(((3210.0)*cj30*pz))))))+IKsqr(((x1164.value)*(((-40.0)+((pz*x1162))+(((-32.1)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1163.value)*((x1162+(((4000.0)*pz))+(((3210.0)*cj30*pz))))), ((x1164.value)*(((-40.0)+((pz*x1162))+(((-32.1)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1165=IKsin(j28);
IkReal x1166=IKcos(j28);
IkReal x1167=((0.321)*cj30);
IkReal x1168=((0.321)*sj30);
IkReal x1169=(pz*x1165);
IkReal x1170=((0.321)*x1165);
evalcond[0]=((0.4)+x1167+x1169+(((0.1)*x1166)));
evalcond[1]=(x1168+(((0.1)*x1165))+(((-1.0)*pz*x1166)));
evalcond[2]=((-0.066959)+(((-0.08)*x1166))+(((-1.0)*pp))+(((-0.8)*x1169)));
evalcond[3]=((((-1.0)*x1166*x1168))+((x1165*x1167))+(((0.4)*x1165))+pz);
evalcond[4]=((0.1)+((x1165*x1168))+((x1166*x1167))+(((0.4)*x1166)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1171=(px*sj27);
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x1171;
evalcond[2]=x1171;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*pz*sj30))+cj30);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst67;
CheckValue<IkReal> x1172 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1172.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1173=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1173.valid){
continue;
}
if( (((1.24610591900312)*(x1173.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1173.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst67=((((-1.0)*(x1172.value)))+(((-1.0)*(IKasin(((1.24610591900312)*(x1173.value)))))));
IkReal gconst68;
gconst68=IKsin(gconst67);
IkReal gconst69;
gconst69=IKcos(gconst67);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst67))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst69))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst69+(((-10.0)*gconst68*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1174=(gconst68*pz);
CheckValue<IkReal> x1175=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1174))+(((32.1)*gconst69))),-1);
if(!x1175.valid){
continue;
}
CheckValue<IkReal> x1176=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst69))+(((-321000.0)*x1174))),-1);
if(!x1176.valid){
continue;
}
if( IKabs(((x1175.value)*(((((-100.0)*pz))+(((128.4)*gconst68))+(((103.041)*gconst68*gconst69)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1176.value)*(((-10000.0)+(((103041.0)*(gconst68*gconst68))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1175.value)*(((((-100.0)*pz))+(((128.4)*gconst68))+(((103.041)*gconst68*gconst69))))))+IKsqr(((x1176.value)*(((-10000.0)+(((103041.0)*(gconst68*gconst68)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1175.value)*(((((-100.0)*pz))+(((128.4)*gconst68))+(((103.041)*gconst68*gconst69))))), ((x1176.value)*(((-10000.0)+(((103041.0)*(gconst68*gconst68)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1177=IKcos(j28);
IkReal x1178=IKsin(j28);
IkReal x1179=((0.321)*gconst69);
IkReal x1180=((0.321)*gconst68);
IkReal x1181=(pz*x1178);
evalcond[0]=(x1180+((pz*x1177))+(((-0.1)*x1178)));
evalcond[1]=((0.4)+x1181+x1179+(((0.1)*x1177)));
evalcond[2]=((-0.32)+(((-0.08)*x1177))+(((-0.2568)*gconst69))+(((-0.8)*x1181)));
evalcond[3]=((((0.4)*x1178))+((x1177*x1180))+pz+((x1178*x1179)));
evalcond[4]=((0.1)+(((0.4)*x1177))+(((-1.0)*x1178*x1180))+((x1177*x1179)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1182=pz*pz;
IkReal x1183=((321.0)*gconst68);
CheckValue<IkReal> x1184=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1182))),-1);
if(!x1184.valid){
continue;
}
CheckValue<IkReal> x1185=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1182))),-1);
if(!x1185.valid){
continue;
}
if( IKabs(((x1184.value)*((x1183+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1185.value)*(((-40.0)+(((-1.0)*pz*x1183))+(((-32.1)*gconst69)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1184.value)*((x1183+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))))+IKsqr(((x1185.value)*(((-40.0)+(((-1.0)*pz*x1183))+(((-32.1)*gconst69))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1184.value)*((x1183+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))), ((x1185.value)*(((-40.0)+(((-1.0)*pz*x1183))+(((-32.1)*gconst69))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1186=IKcos(j28);
IkReal x1187=IKsin(j28);
IkReal x1188=((0.321)*gconst69);
IkReal x1189=((0.321)*gconst68);
IkReal x1190=(pz*x1187);
evalcond[0]=(x1189+((pz*x1186))+(((-0.1)*x1187)));
evalcond[1]=((0.4)+x1188+x1190+(((0.1)*x1186)));
evalcond[2]=((-0.32)+(((-0.2568)*gconst69))+(((-0.8)*x1190))+(((-0.08)*x1186)));
evalcond[3]=(((x1187*x1188))+((x1186*x1189))+(((0.4)*x1187))+pz);
evalcond[4]=((0.1)+((x1186*x1188))+(((-1.0)*x1187*x1189))+(((0.4)*x1186)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1191=pz*pz;
IkReal x1192=((321.0)*gconst68);
CheckValue<IkReal> x1193=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1191))),-1);
if(!x1193.valid){
continue;
}
CheckValue<IkReal> x1194=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1191))),-1);
if(!x1194.valid){
continue;
}
if( IKabs(((x1193.value)*((x1192+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1194.value)*(((40.0)+((pz*x1192))+(((32.1)*gconst69)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1193.value)*((x1192+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))))+IKsqr(((x1194.value)*(((40.0)+((pz*x1192))+(((32.1)*gconst69))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1193.value)*((x1192+(((-4000.0)*pz))+(((-3210.0)*gconst69*pz))))), ((x1194.value)*(((40.0)+((pz*x1192))+(((32.1)*gconst69))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1195=IKcos(j28);
IkReal x1196=IKsin(j28);
IkReal x1197=((0.321)*gconst69);
IkReal x1198=((0.321)*gconst68);
IkReal x1199=(pz*x1196);
evalcond[0]=(x1198+((pz*x1195))+(((-0.1)*x1196)));
evalcond[1]=((0.4)+x1199+x1197+(((0.1)*x1195)));
evalcond[2]=((-0.32)+(((-0.2568)*gconst69))+(((-0.08)*x1195))+(((-0.8)*x1199)));
evalcond[3]=(((x1195*x1198))+(((0.4)*x1196))+((x1196*x1197))+pz);
evalcond[4]=((0.1)+((x1195*x1197))+(((0.4)*x1195))+(((-1.0)*x1196*x1198)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst70;
CheckValue<IkReal> x1200 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1200.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1201=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1201.valid){
continue;
}
if( (((1.24610591900312)*(x1201.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1201.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst70=((3.14159265358979)+(((-1.0)*(x1200.value)))+(IKasin(((1.24610591900312)*(x1201.value)))));
IkReal gconst71;
gconst71=IKsin(gconst70);
IkReal gconst72;
gconst72=IKcos(gconst70);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst70))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst72))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*gconst71*pz))+gconst72);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1202=(gconst71*pz);
CheckValue<IkReal> x1203=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1202))+(((32.1)*gconst72))),-1);
if(!x1203.valid){
continue;
}
CheckValue<IkReal> x1204=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst72))+(((-321000.0)*x1202))),-1);
if(!x1204.valid){
continue;
}
if( IKabs(((x1203.value)*(((((-100.0)*pz))+(((103.041)*gconst71*gconst72))+(((128.4)*gconst71)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1204.value)*(((-10000.0)+(((103041.0)*(gconst71*gconst71))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1203.value)*(((((-100.0)*pz))+(((103.041)*gconst71*gconst72))+(((128.4)*gconst71))))))+IKsqr(((x1204.value)*(((-10000.0)+(((103041.0)*(gconst71*gconst71)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1203.value)*(((((-100.0)*pz))+(((103.041)*gconst71*gconst72))+(((128.4)*gconst71))))), ((x1204.value)*(((-10000.0)+(((103041.0)*(gconst71*gconst71)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1205=IKcos(j28);
IkReal x1206=IKsin(j28);
IkReal x1207=((0.321)*gconst71);
IkReal x1208=((0.321)*gconst72);
IkReal x1209=(pz*x1206);
evalcond[0]=(x1207+(((-0.1)*x1206))+((pz*x1205)));
evalcond[1]=((0.4)+x1209+x1208+(((0.1)*x1205)));
evalcond[2]=((-0.32)+(((-0.08)*x1205))+(((-0.8)*x1209))+(((-0.2568)*gconst72)));
evalcond[3]=((((0.4)*x1206))+pz+((x1205*x1207))+((x1206*x1208)));
evalcond[4]=((0.1)+(((0.4)*x1205))+((x1205*x1208))+(((-1.0)*x1206*x1207)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1210=pz*pz;
IkReal x1211=((321.0)*gconst71);
CheckValue<IkReal> x1212=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1210))),-1);
if(!x1212.valid){
continue;
}
CheckValue<IkReal> x1213=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1210))),-1);
if(!x1213.valid){
continue;
}
if( IKabs(((x1212.value)*(((((-3210.0)*gconst72*pz))+x1211+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1213.value)*(((-40.0)+(((-32.1)*gconst72))+(((-1.0)*pz*x1211)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1212.value)*(((((-3210.0)*gconst72*pz))+x1211+(((-4000.0)*pz))))))+IKsqr(((x1213.value)*(((-40.0)+(((-32.1)*gconst72))+(((-1.0)*pz*x1211))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1212.value)*(((((-3210.0)*gconst72*pz))+x1211+(((-4000.0)*pz))))), ((x1213.value)*(((-40.0)+(((-32.1)*gconst72))+(((-1.0)*pz*x1211))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1214=IKcos(j28);
IkReal x1215=IKsin(j28);
IkReal x1216=((0.321)*gconst71);
IkReal x1217=((0.321)*gconst72);
IkReal x1218=(pz*x1215);
evalcond[0]=(x1216+(((-0.1)*x1215))+((pz*x1214)));
evalcond[1]=((0.4)+x1217+x1218+(((0.1)*x1214)));
evalcond[2]=((-0.32)+(((-0.08)*x1214))+(((-0.2568)*gconst72))+(((-0.8)*x1218)));
evalcond[3]=(((x1214*x1216))+pz+(((0.4)*x1215))+((x1215*x1217)));
evalcond[4]=((0.1)+((x1214*x1217))+(((-1.0)*x1215*x1216))+(((0.4)*x1214)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1219=pz*pz;
IkReal x1220=((321.0)*gconst71);
CheckValue<IkReal> x1221=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1219))),-1);
if(!x1221.valid){
continue;
}
CheckValue<IkReal> x1222=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1219))),-1);
if(!x1222.valid){
continue;
}
if( IKabs(((x1221.value)*(((((-3210.0)*gconst72*pz))+x1220+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1222.value)*(((40.0)+((pz*x1220))+(((32.1)*gconst72)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1221.value)*(((((-3210.0)*gconst72*pz))+x1220+(((-4000.0)*pz))))))+IKsqr(((x1222.value)*(((40.0)+((pz*x1220))+(((32.1)*gconst72))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1221.value)*(((((-3210.0)*gconst72*pz))+x1220+(((-4000.0)*pz))))), ((x1222.value)*(((40.0)+((pz*x1220))+(((32.1)*gconst72))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1223=IKcos(j28);
IkReal x1224=IKsin(j28);
IkReal x1225=((0.321)*gconst71);
IkReal x1226=((0.321)*gconst72);
IkReal x1227=(pz*x1224);
evalcond[0]=(x1225+((pz*x1223))+(((-0.1)*x1224)));
evalcond[1]=((0.4)+(((0.1)*x1223))+x1227+x1226);
evalcond[2]=((-0.32)+(((-0.08)*x1223))+(((-0.2568)*gconst72))+(((-0.8)*x1227)));
evalcond[3]=(((x1223*x1225))+((x1224*x1226))+pz+(((0.4)*x1224)));
evalcond[4]=((0.1)+(((-1.0)*x1224*x1225))+((x1223*x1226))+(((0.4)*x1223)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1228=(pz*sj30);
CheckValue<IkReal> x1229=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x1228))+(((32.1)*cj30))),-1);
if(!x1229.valid){
continue;
}
CheckValue<IkReal> x1230=IKPowWithIntegerCheck(((40000.0)+(((-321000.0)*x1228))+(((32100.0)*cj30))),-1);
if(!x1230.valid){
continue;
}
if( IKabs(((x1229.value)*(((((-100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1230.value)*(((-10000.0)+(((103041.0)*(sj30*sj30))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1229.value)*(((((-100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1230.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1229.value)*(((((-100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1230.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1231=IKcos(j28);
IkReal x1232=IKsin(j28);
IkReal x1233=(pz*x1232);
IkReal x1234=((0.321)*x1232);
IkReal x1235=((0.321)*x1231);
evalcond[0]=(((pz*x1231))+(((0.321)*sj30))+(((-0.1)*x1232)));
evalcond[1]=((0.4)+x1233+(((0.1)*x1231))+(((0.321)*cj30)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x1231))+(((-0.8)*x1233)));
evalcond[3]=(((cj30*x1234))+((sj30*x1235))+pz+(((0.4)*x1232)));
evalcond[4]=((0.1)+((cj30*x1235))+(((0.4)*x1231))+(((-1.0)*sj30*x1234)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1236=pz*pz;
IkReal x1237=((321.0)*sj30);
CheckValue<IkReal> x1238=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1236))),-1);
if(!x1238.valid){
continue;
}
CheckValue<IkReal> x1239=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1236))),-1);
if(!x1239.valid){
continue;
}
if( IKabs(((x1238.value)*((x1237+(((-836.9875)*pz))+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1239.value)*(((-8.369875)+(((-1.0)*pz*x1237))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1238.value)*((x1237+(((-836.9875)*pz))+(((-12500.0)*pp*pz))))))+IKsqr(((x1239.value)*(((-8.369875)+(((-1.0)*pz*x1237))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1238.value)*((x1237+(((-836.9875)*pz))+(((-12500.0)*pp*pz))))), ((x1239.value)*(((-8.369875)+(((-1.0)*pz*x1237))+(((-125.0)*pp))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1240=IKcos(j28);
IkReal x1241=IKsin(j28);
IkReal x1242=(pz*x1241);
IkReal x1243=((0.321)*x1241);
IkReal x1244=((0.321)*x1240);
evalcond[0]=((((0.321)*sj30))+((pz*x1240))+(((-0.1)*x1241)));
evalcond[1]=((0.4)+x1242+(((0.321)*cj30))+(((0.1)*x1240)));
evalcond[2]=((-0.066959)+(((-0.8)*x1242))+(((-1.0)*pp))+(((-0.08)*x1240)));
evalcond[3]=(((cj30*x1243))+(((0.4)*x1241))+((sj30*x1244))+pz);
evalcond[4]=((0.1)+((cj30*x1244))+(((0.4)*x1240))+(((-1.0)*sj30*x1243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1245=pz*pz;
IkReal x1246=((321.0)*sj30);
CheckValue<IkReal> x1247=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1245))),-1);
if(!x1247.valid){
continue;
}
CheckValue<IkReal> x1248=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1245))),-1);
if(!x1248.valid){
continue;
}
if( IKabs(((x1247.value)*((x1246+(((-4000.0)*pz))+(((-3210.0)*cj30*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1248.value)*(((40.0)+((pz*x1246))+(((32.1)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1247.value)*((x1246+(((-4000.0)*pz))+(((-3210.0)*cj30*pz))))))+IKsqr(((x1248.value)*(((40.0)+((pz*x1246))+(((32.1)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1247.value)*((x1246+(((-4000.0)*pz))+(((-3210.0)*cj30*pz))))), ((x1248.value)*(((40.0)+((pz*x1246))+(((32.1)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1249=IKcos(j28);
IkReal x1250=IKsin(j28);
IkReal x1251=(pz*x1250);
IkReal x1252=((0.321)*x1250);
IkReal x1253=((0.321)*x1249);
evalcond[0]=((((0.321)*sj30))+((pz*x1249))+(((-0.1)*x1250)));
evalcond[1]=((0.4)+x1251+(((0.321)*cj30))+(((0.1)*x1249)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*x1251))+(((-0.08)*x1249)));
evalcond[3]=(((sj30*x1253))+pz+((cj30*x1252))+(((0.4)*x1250)));
evalcond[4]=((0.1)+(((-1.0)*sj30*x1252))+(((0.4)*x1249))+((cj30*x1253)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1254=(px*sj27);
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=x1254;
evalcond[2]=((-1.0)*x1254);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj30))+(((-1.0)*cj30)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst73;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1255=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1255.valid){
continue;
}
if( (((1.24610591900312)*(x1255.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1255.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1256 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1256.valid){
continue;
}
gconst73=((IKasin(((1.24610591900312)*(x1255.value))))+(((-1.0)*(x1256.value))));
IkReal gconst74;
gconst74=IKsin(gconst73);
IkReal gconst75;
gconst75=IKcos(gconst73);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst73))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst75))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst75))+(((-10.0)*gconst74*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1257=(gconst74*pz);
CheckValue<IkReal> x1258=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1257))+(((-32.1)*gconst75))),-1);
if(!x1258.valid){
continue;
}
CheckValue<IkReal> x1259=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst75))+(((321000.0)*x1257))),-1);
if(!x1259.valid){
continue;
}
if( IKabs(((x1258.value)*(((((100.0)*pz))+(((103.041)*gconst74*gconst75))+(((128.4)*gconst74)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1259.value)*(((-10000.0)+(((103041.0)*(gconst74*gconst74))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1258.value)*(((((100.0)*pz))+(((103.041)*gconst74*gconst75))+(((128.4)*gconst74))))))+IKsqr(((x1259.value)*(((-10000.0)+(((103041.0)*(gconst74*gconst74)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1258.value)*(((((100.0)*pz))+(((103.041)*gconst74*gconst75))+(((128.4)*gconst74))))), ((x1259.value)*(((-10000.0)+(((103041.0)*(gconst74*gconst74)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1260=IKsin(j28);
IkReal x1261=IKcos(j28);
IkReal x1262=((0.321)*gconst74);
IkReal x1263=((0.321)*gconst75);
IkReal x1264=(pz*x1260);
evalcond[0]=((0.4)+x1263+x1264+(((0.1)*x1261)));
evalcond[1]=(x1262+(((-1.0)*pz*x1261))+(((0.1)*x1260)));
evalcond[2]=((-0.32)+(((-0.08)*x1261))+(((-0.8)*x1264))+(((-0.2568)*gconst75)));
evalcond[3]=((((-1.0)*x1261*x1262))+((x1260*x1263))+pz+(((0.4)*x1260)));
evalcond[4]=((0.1)+((x1261*x1263))+((x1260*x1262))+(((0.4)*x1261)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1265=pz*pz;
IkReal x1266=((321.0)*gconst74);
CheckValue<IkReal> x1267=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1265))),-1);
if(!x1267.valid){
continue;
}
CheckValue<IkReal> x1268=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1265))),-1);
if(!x1268.valid){
continue;
}
if( IKabs(((x1267.value)*(((((-3210.0)*gconst75*pz))+(((-4000.0)*pz))+(((-1.0)*x1266)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1268.value)*(((-40.0)+(((-32.1)*gconst75))+((pz*x1266)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1267.value)*(((((-3210.0)*gconst75*pz))+(((-4000.0)*pz))+(((-1.0)*x1266))))))+IKsqr(((x1268.value)*(((-40.0)+(((-32.1)*gconst75))+((pz*x1266))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1267.value)*(((((-3210.0)*gconst75*pz))+(((-4000.0)*pz))+(((-1.0)*x1266))))), ((x1268.value)*(((-40.0)+(((-32.1)*gconst75))+((pz*x1266))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1269=IKsin(j28);
IkReal x1270=IKcos(j28);
IkReal x1271=((0.321)*gconst74);
IkReal x1272=((0.321)*gconst75);
IkReal x1273=(pz*x1269);
evalcond[0]=((0.4)+x1272+x1273+(((0.1)*x1270)));
evalcond[1]=(x1271+(((-1.0)*pz*x1270))+(((0.1)*x1269)));
evalcond[2]=((-0.32)+(((-0.08)*x1270))+(((-0.8)*x1273))+(((-0.2568)*gconst75)));
evalcond[3]=(((x1269*x1272))+(((-1.0)*x1270*x1271))+pz+(((0.4)*x1269)));
evalcond[4]=((0.1)+((x1269*x1271))+(((0.4)*x1270))+((x1270*x1272)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1274=pz*pz;
IkReal x1275=((321.0)*gconst74);
CheckValue<IkReal> x1276=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1274))),-1);
if(!x1276.valid){
continue;
}
CheckValue<IkReal> x1277=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1274))),-1);
if(!x1277.valid){
continue;
}
if( IKabs(((x1276.value)*((x1275+(((3210.0)*gconst75*pz))+(((4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1277.value)*(((-40.0)+((pz*x1275))+(((-32.1)*gconst75)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1276.value)*((x1275+(((3210.0)*gconst75*pz))+(((4000.0)*pz))))))+IKsqr(((x1277.value)*(((-40.0)+((pz*x1275))+(((-32.1)*gconst75))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1276.value)*((x1275+(((3210.0)*gconst75*pz))+(((4000.0)*pz))))), ((x1277.value)*(((-40.0)+((pz*x1275))+(((-32.1)*gconst75))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1278=IKsin(j28);
IkReal x1279=IKcos(j28);
IkReal x1280=((0.321)*gconst74);
IkReal x1281=((0.321)*gconst75);
IkReal x1282=(pz*x1278);
evalcond[0]=((0.4)+x1281+x1282+(((0.1)*x1279)));
evalcond[1]=(x1280+(((-1.0)*pz*x1279))+(((0.1)*x1278)));
evalcond[2]=((-0.32)+(((-0.08)*x1279))+(((-0.2568)*gconst75))+(((-0.8)*x1282)));
evalcond[3]=((((0.4)*x1278))+((x1278*x1281))+pz+(((-1.0)*x1279*x1280)));
evalcond[4]=((0.1)+((x1279*x1281))+(((0.4)*x1279))+((x1278*x1280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst76;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1283=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1283.valid){
continue;
}
if( (((1.24610591900312)*(x1283.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1283.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1284 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1284.valid){
continue;
}
gconst76=((3.14159265358979)+(((-1.0)*(IKasin(((1.24610591900312)*(x1283.value))))))+(((-1.0)*(x1284.value))));
IkReal gconst77;
gconst77=IKsin(gconst76);
IkReal gconst78;
gconst78=IKcos(gconst76);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst76))+j30)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst78))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst78))+(((-10.0)*gconst77*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1285=(gconst77*pz);
CheckValue<IkReal> x1286=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1285))+(((-32.1)*gconst78))),-1);
if(!x1286.valid){
continue;
}
CheckValue<IkReal> x1287=IKPowWithIntegerCheck(((40000.0)+(((321000.0)*x1285))+(((32100.0)*gconst78))),-1);
if(!x1287.valid){
continue;
}
if( IKabs(((x1286.value)*(((((100.0)*pz))+(((103.041)*gconst77*gconst78))+(((128.4)*gconst77)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1287.value)*(((-10000.0)+(((103041.0)*(gconst77*gconst77))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1286.value)*(((((100.0)*pz))+(((103.041)*gconst77*gconst78))+(((128.4)*gconst77))))))+IKsqr(((x1287.value)*(((-10000.0)+(((103041.0)*(gconst77*gconst77)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1286.value)*(((((100.0)*pz))+(((103.041)*gconst77*gconst78))+(((128.4)*gconst77))))), ((x1287.value)*(((-10000.0)+(((103041.0)*(gconst77*gconst77)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1288=IKsin(j28);
IkReal x1289=IKcos(j28);
IkReal x1290=((0.321)*gconst77);
IkReal x1291=((0.321)*gconst78);
IkReal x1292=((0.321)*x1289);
IkReal x1293=(pz*x1288);
evalcond[0]=((0.4)+x1293+x1291+(((0.1)*x1289)));
evalcond[1]=(x1290+(((0.1)*x1288))+(((-1.0)*pz*x1289)));
evalcond[2]=((-0.32)+(((-0.8)*x1293))+(((-0.08)*x1289))+(((-0.2568)*gconst78)));
evalcond[3]=((((-1.0)*x1289*x1290))+((x1288*x1291))+pz+(((0.4)*x1288)));
evalcond[4]=((0.1)+((x1288*x1290))+(((0.4)*x1289))+((x1289*x1291)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1294=pz*pz;
IkReal x1295=((321.0)*gconst77);
CheckValue<IkReal> x1296=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1294))),-1);
if(!x1296.valid){
continue;
}
CheckValue<IkReal> x1297=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1294))),-1);
if(!x1297.valid){
continue;
}
if( IKabs(((x1296.value)*(((((-1.0)*x1295))+(((-3210.0)*gconst78*pz))+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1297.value)*(((-40.0)+((pz*x1295))+(((-32.1)*gconst78)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1296.value)*(((((-1.0)*x1295))+(((-3210.0)*gconst78*pz))+(((-4000.0)*pz))))))+IKsqr(((x1297.value)*(((-40.0)+((pz*x1295))+(((-32.1)*gconst78))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1296.value)*(((((-1.0)*x1295))+(((-3210.0)*gconst78*pz))+(((-4000.0)*pz))))), ((x1297.value)*(((-40.0)+((pz*x1295))+(((-32.1)*gconst78))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1298=IKsin(j28);
IkReal x1299=IKcos(j28);
IkReal x1300=((0.321)*gconst77);
IkReal x1301=((0.321)*gconst78);
IkReal x1302=((0.321)*x1299);
IkReal x1303=(pz*x1298);
evalcond[0]=((0.4)+x1301+x1303+(((0.1)*x1299)));
evalcond[1]=(x1300+(((0.1)*x1298))+(((-1.0)*pz*x1299)));
evalcond[2]=((-0.32)+(((-0.08)*x1299))+(((-0.8)*x1303))+(((-0.2568)*gconst78)));
evalcond[3]=((((-1.0)*x1299*x1300))+(((0.4)*x1298))+pz+((x1298*x1301)));
evalcond[4]=((0.1)+((x1299*x1301))+(((0.4)*x1299))+((x1298*x1300)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1304=pz*pz;
IkReal x1305=((321.0)*gconst77);
CheckValue<IkReal> x1306=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1304))),-1);
if(!x1306.valid){
continue;
}
CheckValue<IkReal> x1307=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1304))),-1);
if(!x1307.valid){
continue;
}
if( IKabs(((x1306.value)*((x1305+(((3210.0)*gconst78*pz))+(((4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1307.value)*(((-40.0)+((pz*x1305))+(((-32.1)*gconst78)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1306.value)*((x1305+(((3210.0)*gconst78*pz))+(((4000.0)*pz))))))+IKsqr(((x1307.value)*(((-40.0)+((pz*x1305))+(((-32.1)*gconst78))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1306.value)*((x1305+(((3210.0)*gconst78*pz))+(((4000.0)*pz))))), ((x1307.value)*(((-40.0)+((pz*x1305))+(((-32.1)*gconst78))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1308=IKsin(j28);
IkReal x1309=IKcos(j28);
IkReal x1310=((0.321)*gconst77);
IkReal x1311=((0.321)*gconst78);
IkReal x1312=((0.321)*x1309);
IkReal x1313=(pz*x1308);
evalcond[0]=((0.4)+x1313+x1311+(((0.1)*x1309)));
evalcond[1]=(x1310+(((-1.0)*pz*x1309))+(((0.1)*x1308)));
evalcond[2]=((-0.32)+(((-0.08)*x1309))+(((-0.2568)*gconst78))+(((-0.8)*x1313)));
evalcond[3]=((((0.4)*x1308))+((x1308*x1311))+pz+(((-1.0)*x1309*x1310)));
evalcond[4]=((0.1)+(((0.4)*x1309))+((x1308*x1310))+((x1309*x1311)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1314=(pz*sj30);
CheckValue<IkReal> x1315=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1314))+(((-32.1)*cj30))),-1);
if(!x1315.valid){
continue;
}
CheckValue<IkReal> x1316=IKPowWithIntegerCheck(((40000.0)+(((321000.0)*x1314))+(((32100.0)*cj30))),-1);
if(!x1316.valid){
continue;
}
if( IKabs(((x1315.value)*(((((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1316.value)*(((-10000.0)+(((103041.0)*(sj30*sj30))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1315.value)*(((((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1316.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1315.value)*(((((100.0)*pz))+(((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1316.value)*(((-10000.0)+(((103041.0)*(sj30*sj30)))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1317=IKsin(j28);
IkReal x1318=IKcos(j28);
IkReal x1319=((0.321)*cj30);
IkReal x1320=((0.321)*sj30);
IkReal x1321=(pz*x1317);
IkReal x1322=((0.321)*x1317);
evalcond[0]=((0.4)+x1319+x1321+(((0.1)*x1318)));
evalcond[1]=(x1320+(((-1.0)*pz*x1318))+(((0.1)*x1317)));
evalcond[2]=((-0.066959)+(((-0.08)*x1318))+(((-1.0)*pp))+(((-0.8)*x1321)));
evalcond[3]=(((x1317*x1319))+(((0.4)*x1317))+pz+(((-1.0)*x1318*x1320)));
evalcond[4]=((0.1)+((x1318*x1319))+(((0.4)*x1318))+((x1317*x1320)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1323=pz*pz;
IkReal x1324=((321.0)*sj30);
CheckValue<IkReal> x1325=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1323))),-1);
if(!x1325.valid){
continue;
}
CheckValue<IkReal> x1326=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1323))),-1);
if(!x1326.valid){
continue;
}
if( IKabs(((x1325.value)*(((((-836.9875)*pz))+(((-1.0)*x1324))+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1326.value)*(((-8.369875)+((pz*x1324))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1325.value)*(((((-836.9875)*pz))+(((-1.0)*x1324))+(((-12500.0)*pp*pz))))))+IKsqr(((x1326.value)*(((-8.369875)+((pz*x1324))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1325.value)*(((((-836.9875)*pz))+(((-1.0)*x1324))+(((-12500.0)*pp*pz))))), ((x1326.value)*(((-8.369875)+((pz*x1324))+(((-125.0)*pp))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1327=IKsin(j28);
IkReal x1328=IKcos(j28);
IkReal x1329=((0.321)*cj30);
IkReal x1330=((0.321)*sj30);
IkReal x1331=(pz*x1327);
IkReal x1332=((0.321)*x1327);
evalcond[0]=((0.4)+x1329+x1331+(((0.1)*x1328)));
evalcond[1]=(x1330+(((-1.0)*pz*x1328))+(((0.1)*x1327)));
evalcond[2]=((-0.066959)+(((-0.08)*x1328))+(((-1.0)*pp))+(((-0.8)*x1331)));
evalcond[3]=((((0.4)*x1327))+(((-1.0)*x1328*x1330))+((x1327*x1329))+pz);
evalcond[4]=((0.1)+(((0.4)*x1328))+((x1328*x1329))+((x1327*x1330)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1333=pz*pz;
IkReal x1334=((321.0)*sj30);
CheckValue<IkReal> x1335=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1333))),-1);
if(!x1335.valid){
continue;
}
CheckValue<IkReal> x1336=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1333))),-1);
if(!x1336.valid){
continue;
}
if( IKabs(((x1335.value)*((x1334+(((4000.0)*pz))+(((3210.0)*cj30*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1336.value)*(((-40.0)+((pz*x1334))+(((-32.1)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1335.value)*((x1334+(((4000.0)*pz))+(((3210.0)*cj30*pz))))))+IKsqr(((x1336.value)*(((-40.0)+((pz*x1334))+(((-32.1)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1335.value)*((x1334+(((4000.0)*pz))+(((3210.0)*cj30*pz))))), ((x1336.value)*(((-40.0)+((pz*x1334))+(((-32.1)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1337=IKsin(j28);
IkReal x1338=IKcos(j28);
IkReal x1339=((0.321)*cj30);
IkReal x1340=((0.321)*sj30);
IkReal x1341=(pz*x1337);
IkReal x1342=((0.321)*x1337);
evalcond[0]=((0.4)+x1341+x1339+(((0.1)*x1338)));
evalcond[1]=(x1340+(((0.1)*x1337))+(((-1.0)*pz*x1338)));
evalcond[2]=((-0.066959)+(((-0.8)*x1341))+(((-0.08)*x1338))+(((-1.0)*pp)));
evalcond[3]=(((x1337*x1339))+(((-1.0)*x1338*x1340))+pz+(((0.4)*x1337)));
evalcond[4]=((0.1)+((x1338*x1339))+((x1337*x1340))+(((0.4)*x1338)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1343=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x1343;
evalcond[2]=x1343;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst79;
gconst79=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(sj30*sj30)))+(((103041.0)*(cj30*cj30)))));
dummyeval[0]=((1.5527799613746)+(sj30*sj30)+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*cj27*px))+(((10.0)*py*sj27)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*cj27*px))+(((10.0)*py*sj27)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst80;
CheckValue<IkReal> x1344 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1344.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1345=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1345.valid){
continue;
}
if( (x1345.value) < -1-IKFAST_SINCOS_THRESH || (x1345.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst80=((((-1.0)*(x1344.value)))+(IKasin(x1345.value)));
IkReal gconst81;
gconst81=IKsin(gconst80);
IkReal gconst82;
gconst82=IKcos(gconst80);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst80))+j27)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst81*py))+(((0.2568)*cj30))+(((0.2)*gconst82*px))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst81*py))+(((10.0)*gconst82*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst81*py))+(((10.0)*gconst82*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1346=((10.0)*cj30);
IkReal x1347=(gconst82*px);
IkReal x1348=(gconst81*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1346*x1348))+(((-1.0)*x1346*x1347))+cj30+(((-12.4610591900312)*x1348))+(((-12.4610591900312)*x1347)));
dummyeval[1]=((1.0)+(((-10.0)*x1347))+(((-10.0)*x1348)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1349=(gconst81*py);
IkReal x1350=(gconst82*px);
IkReal x1351=((321.0)*cj30);
CheckValue<IkReal> x1352=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1350*x1351))+(((-400.0)*x1349))+(((-400.0)*x1350))+(((-1.0)*x1349*x1351))+(((32.1)*cj30))),-1);
if(!x1352.valid){
continue;
}
CheckValue<IkReal> x1353=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1350))+(((-1.0)*x1349))),-1);
if(!x1353.valid){
continue;
}
if( IKabs(((x1352.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1353.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1352.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1353.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1352.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1353.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1354=IKsin(j28);
IkReal x1355=IKcos(j28);
IkReal x1356=(gconst82*px);
IkReal x1357=((0.321)*cj30);
IkReal x1358=((0.321)*sj30);
IkReal x1359=(gconst81*py);
IkReal x1360=((0.8)*x1355);
IkReal x1361=((0.321)*x1354);
IkReal x1362=((1.0)*x1359);
evalcond[0]=(((x1355*x1358))+((x1354*x1357))+(((0.4)*x1354)));
evalcond[1]=(x1358+((x1354*x1359))+((x1354*x1356))+(((-0.1)*x1354)));
evalcond[2]=((0.4)+x1357+(((0.1)*x1355))+(((-1.0)*x1355*x1362))+(((-1.0)*x1355*x1356)));
evalcond[3]=((-0.32)+((x1356*x1360))+(((-0.08)*x1355))+((x1359*x1360))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+(((-1.0)*x1356))+((x1355*x1357))+(((-1.0)*x1354*x1358))+(((0.4)*x1355))+(((-1.0)*x1362)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1363=(gconst82*px);
IkReal x1364=(gconst81*py);
CheckValue<IkReal> x1365=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1363))+(((1000.0)*x1364))),-1);
if(!x1365.valid){
continue;
}
CheckValue<IkReal> x1366=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1363))+(((-1.0)*x1364))),-1);
if(!x1366.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1365.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1366.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1365.value)))+IKsqr(((x1366.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1365.value)), ((x1366.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1367=IKsin(j28);
IkReal x1368=IKcos(j28);
IkReal x1369=(gconst82*px);
IkReal x1370=((0.321)*cj30);
IkReal x1371=((0.321)*sj30);
IkReal x1372=(gconst81*py);
IkReal x1373=((0.8)*x1368);
IkReal x1374=((0.321)*x1367);
IkReal x1375=((1.0)*x1372);
evalcond[0]=(((x1367*x1370))+(((0.4)*x1367))+((x1368*x1371)));
evalcond[1]=(x1371+((x1367*x1369))+((x1367*x1372))+(((-0.1)*x1367)));
evalcond[2]=((0.4)+(((-1.0)*x1368*x1369))+x1370+(((0.1)*x1368))+(((-1.0)*x1368*x1375)));
evalcond[3]=((-0.32)+((x1372*x1373))+(((-0.08)*x1368))+(((-0.2568)*cj30))+((x1369*x1373)));
evalcond[4]=((0.1)+(((-1.0)*x1369))+(((0.4)*x1368))+(((-1.0)*x1375))+((x1368*x1370))+(((-1.0)*x1367*x1371)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1376=(gconst82*px);
IkReal x1377=(gconst81*py);
CheckValue<IkReal> x1378=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1376))+(((1000.0)*x1377))),-1);
if(!x1378.valid){
continue;
}
CheckValue<IkReal> x1379=IKPowWithIntegerCheck(((-0.1)+x1377+x1376),-1);
if(!x1379.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1378.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1379.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1378.value)))+IKsqr(((x1379.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1378.value)), ((x1379.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1380=IKsin(j28);
IkReal x1381=IKcos(j28);
IkReal x1382=(gconst82*px);
IkReal x1383=((0.321)*cj30);
IkReal x1384=((0.321)*sj30);
IkReal x1385=(gconst81*py);
IkReal x1386=((0.8)*x1381);
IkReal x1387=((0.321)*x1380);
IkReal x1388=((1.0)*x1385);
evalcond[0]=(((x1380*x1383))+((x1381*x1384))+(((0.4)*x1380)));
evalcond[1]=((((-0.1)*x1380))+x1384+((x1380*x1385))+((x1380*x1382)));
evalcond[2]=((0.4)+x1383+(((0.1)*x1381))+(((-1.0)*x1381*x1388))+(((-1.0)*x1381*x1382)));
evalcond[3]=((-0.32)+(((-0.2568)*cj30))+(((-0.08)*x1381))+((x1385*x1386))+((x1382*x1386)));
evalcond[4]=((0.1)+(((-1.0)*x1388))+((x1381*x1383))+(((0.4)*x1381))+(((-1.0)*x1380*x1384))+(((-1.0)*x1382)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst83;
CheckValue<IkReal> x1389 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1389.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1390=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1390.valid){
continue;
}
if( (x1390.value) < -1-IKFAST_SINCOS_THRESH || (x1390.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst83=((3.14159265358979)+(((-1.0)*(x1389.value)))+(((-1.0)*(IKasin(x1390.value)))));
IkReal gconst84;
gconst84=IKsin(gconst83);
IkReal gconst85;
gconst85=IKcos(gconst83);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst83))+j27)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst84*py))+(((-1.0)*pp))+(((0.2)*gconst85*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst85*px))+(((10.0)*gconst84*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst85*px))+(((10.0)*gconst84*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1391=(gconst84*py);
IkReal x1392=(gconst85*px);
IkReal x1393=((10.0)*cj30);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1392*x1393))+(((-1.0)*x1391*x1393))+cj30+(((-12.4610591900312)*x1391))+(((-12.4610591900312)*x1392)));
dummyeval[1]=((1.0)+(((-10.0)*x1391))+(((-10.0)*x1392)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1394=((321.0)*cj30);
IkReal x1395=(gconst84*py);
IkReal x1396=(gconst85*px);
CheckValue<IkReal> x1397=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1394*x1395))+(((-1.0)*x1394*x1396))+(((-400.0)*x1395))+(((-400.0)*x1396))+(((32.1)*cj30))),-1);
if(!x1397.valid){
continue;
}
CheckValue<IkReal> x1398=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1396))+(((-1.0)*x1395))),-1);
if(!x1398.valid){
continue;
}
if( IKabs(((x1397.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1398.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1397.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1398.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1397.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1398.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1399=IKsin(j28);
IkReal x1400=IKcos(j28);
IkReal x1401=(gconst84*py);
IkReal x1402=(gconst85*px);
IkReal x1403=((0.321)*cj30);
IkReal x1404=((0.321)*sj30);
IkReal x1405=((0.8)*x1400);
IkReal x1406=((0.321)*x1399);
IkReal x1407=((1.0)*x1400);
evalcond[0]=((((0.4)*x1399))+((x1399*x1403))+((x1400*x1404)));
evalcond[1]=((((-0.1)*x1399))+((x1399*x1401))+((x1399*x1402))+x1404);
evalcond[2]=((0.4)+(((-1.0)*x1402*x1407))+x1403+(((-1.0)*x1401*x1407))+(((0.1)*x1400)));
evalcond[3]=((-0.32)+(((-0.08)*x1400))+(((-0.2568)*cj30))+((x1402*x1405))+((x1401*x1405)));
evalcond[4]=((0.1)+(((0.4)*x1400))+(((-1.0)*x1402))+(((-1.0)*x1401))+(((-1.0)*x1399*x1404))+((x1400*x1403)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1408=(gconst84*py);
IkReal x1409=(gconst85*px);
CheckValue<IkReal> x1410=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1408))+(((1000.0)*x1409))),-1);
if(!x1410.valid){
continue;
}
CheckValue<IkReal> x1411=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1409))+(((-1.0)*x1408))),-1);
if(!x1411.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1410.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1411.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1410.value)))+IKsqr(((x1411.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1410.value)), ((x1411.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1412=IKsin(j28);
IkReal x1413=IKcos(j28);
IkReal x1414=(gconst84*py);
IkReal x1415=(gconst85*px);
IkReal x1416=((0.321)*cj30);
IkReal x1417=((0.321)*sj30);
IkReal x1418=((0.8)*x1413);
IkReal x1419=((0.321)*x1412);
IkReal x1420=((1.0)*x1413);
evalcond[0]=((((0.4)*x1412))+((x1413*x1417))+((x1412*x1416)));
evalcond[1]=(((x1412*x1415))+((x1412*x1414))+(((-0.1)*x1412))+x1417);
evalcond[2]=((0.4)+(((-1.0)*x1415*x1420))+(((0.1)*x1413))+x1416+(((-1.0)*x1414*x1420)));
evalcond[3]=((-0.32)+((x1415*x1418))+(((-0.08)*x1413))+(((-0.2568)*cj30))+((x1414*x1418)));
evalcond[4]=((0.1)+(((0.4)*x1413))+((x1413*x1416))+(((-1.0)*x1412*x1417))+(((-1.0)*x1414))+(((-1.0)*x1415)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1421=(gconst85*px);
IkReal x1422=(gconst84*py);
CheckValue<IkReal> x1423=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1421))+(((1000.0)*x1422))),-1);
if(!x1423.valid){
continue;
}
CheckValue<IkReal> x1424=IKPowWithIntegerCheck(((-0.1)+x1421+x1422),-1);
if(!x1424.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1423.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1424.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1423.value)))+IKsqr(((x1424.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1423.value)), ((x1424.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1425=IKsin(j28);
IkReal x1426=IKcos(j28);
IkReal x1427=(gconst84*py);
IkReal x1428=(gconst85*px);
IkReal x1429=((0.321)*cj30);
IkReal x1430=((0.321)*sj30);
IkReal x1431=((0.8)*x1426);
IkReal x1432=((0.321)*x1425);
IkReal x1433=((1.0)*x1426);
evalcond[0]=(((x1425*x1429))+(((0.4)*x1425))+((x1426*x1430)));
evalcond[1]=(((x1425*x1428))+((x1425*x1427))+x1430+(((-0.1)*x1425)));
evalcond[2]=((0.4)+(((0.1)*x1426))+(((-1.0)*x1428*x1433))+x1429+(((-1.0)*x1427*x1433)));
evalcond[3]=((-0.32)+((x1428*x1431))+((x1427*x1431))+(((-0.2568)*cj30))+(((-0.08)*x1426)));
evalcond[4]=((0.1)+((x1426*x1429))+(((0.4)*x1426))+(((-1.0)*x1428))+(((-1.0)*x1427))+(((-1.0)*x1425*x1430)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst86;
CheckValue<IkReal> x1434 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1434.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1435=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1435.valid){
continue;
}
if( (x1435.value) < -1-IKFAST_SINCOS_THRESH || (x1435.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst86=((((-1.0)*(x1434.value)))+(IKasin(x1435.value)));
IkReal gconst87;
gconst87=IKsin(gconst86);
IkReal gconst88;
gconst88=IKcos(gconst86);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst86))+j27)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst88*px))+(((0.2)*gconst87*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst88*px))+(((10.0)*gconst87*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst88*px))+(((10.0)*gconst87*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1436=(gconst88*px);
IkReal x1437=(gconst87*py);
IkReal x1438=((10.0)*cj30);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1437*x1438))+(((-1.0)*x1436*x1438))+cj30+(((-12.4610591900312)*x1437))+(((-12.4610591900312)*x1436)));
dummyeval[1]=((1.0)+(((-10.0)*x1437))+(((-10.0)*x1436)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1439=(gconst88*px);
IkReal x1440=(gconst87*py);
IkReal x1441=((321.0)*cj30);
CheckValue<IkReal> x1442=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1439))+(((-400.0)*x1440))+(((-1.0)*x1439*x1441))+(((32.1)*cj30))+(((-1.0)*x1440*x1441))),-1);
if(!x1442.valid){
continue;
}
CheckValue<IkReal> x1443=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1439))+(((-1.0)*x1440))),-1);
if(!x1443.valid){
continue;
}
if( IKabs(((x1442.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1443.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1442.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1443.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1442.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1443.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1444=IKsin(j28);
IkReal x1445=IKcos(j28);
IkReal x1446=(gconst88*px);
IkReal x1447=(gconst87*py);
IkReal x1448=((0.321)*cj30);
IkReal x1449=((0.321)*sj30);
IkReal x1450=((0.321)*x1444);
IkReal x1451=((1.0)*x1445);
IkReal x1452=((0.8)*x1445);
evalcond[0]=(((x1445*x1449))+((x1444*x1448))+(((0.4)*x1444)));
evalcond[1]=(((x1444*x1447))+((x1444*x1446))+x1449+(((-0.1)*x1444)));
evalcond[2]=((0.4)+(((-1.0)*x1447*x1451))+(((0.1)*x1445))+(((-1.0)*x1446*x1451))+x1448);
evalcond[3]=((-0.32)+((x1446*x1452))+((x1447*x1452))+(((-0.08)*x1445))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+((x1445*x1448))+(((-1.0)*x1447))+(((-1.0)*x1446))+(((0.4)*x1445))+(((-1.0)*x1444*x1449)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1453=(gconst88*px);
IkReal x1454=(gconst87*py);
CheckValue<IkReal> x1455=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1454))+(((1000.0)*x1453))),-1);
if(!x1455.valid){
continue;
}
CheckValue<IkReal> x1456=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1453))+(((-1.0)*x1454))),-1);
if(!x1456.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1455.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1456.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1455.value)))+IKsqr(((x1456.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1455.value)), ((x1456.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1457=IKsin(j28);
IkReal x1458=IKcos(j28);
IkReal x1459=(gconst88*px);
IkReal x1460=(gconst87*py);
IkReal x1461=((0.321)*cj30);
IkReal x1462=((0.321)*sj30);
IkReal x1463=((0.321)*x1457);
IkReal x1464=((1.0)*x1458);
IkReal x1465=((0.8)*x1458);
evalcond[0]=(((x1458*x1462))+((x1457*x1461))+(((0.4)*x1457)));
evalcond[1]=((((-0.1)*x1457))+x1462+((x1457*x1460))+((x1457*x1459)));
evalcond[2]=((0.4)+(((-1.0)*x1459*x1464))+(((-1.0)*x1460*x1464))+x1461+(((0.1)*x1458)));
evalcond[3]=((-0.32)+((x1459*x1465))+(((-0.08)*x1458))+(((-0.2568)*cj30))+((x1460*x1465)));
evalcond[4]=((0.1)+(((-1.0)*x1459))+((x1458*x1461))+(((-1.0)*x1457*x1462))+(((0.4)*x1458))+(((-1.0)*x1460)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1466=(gconst87*py);
IkReal x1467=(gconst88*px);
CheckValue<IkReal> x1468=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1466))+(((1000.0)*x1467))),-1);
if(!x1468.valid){
continue;
}
CheckValue<IkReal> x1469=IKPowWithIntegerCheck(((-0.1)+x1467+x1466),-1);
if(!x1469.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1468.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1469.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1468.value)))+IKsqr(((x1469.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1468.value)), ((x1469.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1470=IKsin(j28);
IkReal x1471=IKcos(j28);
IkReal x1472=(gconst88*px);
IkReal x1473=(gconst87*py);
IkReal x1474=((0.321)*cj30);
IkReal x1475=((0.321)*sj30);
IkReal x1476=((0.321)*x1470);
IkReal x1477=((1.0)*x1471);
IkReal x1478=((0.8)*x1471);
evalcond[0]=(((x1471*x1475))+((x1470*x1474))+(((0.4)*x1470)));
evalcond[1]=(((x1470*x1472))+((x1470*x1473))+x1475+(((-0.1)*x1470)));
evalcond[2]=((0.4)+(((0.1)*x1471))+x1474+(((-1.0)*x1472*x1477))+(((-1.0)*x1473*x1477)));
evalcond[3]=((-0.32)+((x1473*x1478))+((x1472*x1478))+(((-0.08)*x1471))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+((x1471*x1474))+(((-1.0)*x1470*x1475))+(((-1.0)*x1472))+(((-1.0)*x1473))+(((0.4)*x1471)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst89;
CheckValue<IkReal> x1479 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1479.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1480=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1480.valid){
continue;
}
if( (x1480.value) < -1-IKFAST_SINCOS_THRESH || (x1480.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst89=((3.14159265358979)+(((-1.0)*(x1479.value)))+(((-1.0)*(IKasin(x1480.value)))));
IkReal gconst90;
gconst90=IKsin(gconst89);
IkReal gconst91;
gconst91=IKcos(gconst89);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst89))+j27)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst91*px))+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst90*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst90*py))+(((10.0)*gconst91*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst90*py))+(((10.0)*gconst91*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1481=(gconst91*px);
IkReal x1482=((10.0)*gconst90*py);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*gconst90*py))+cj30+(((-1.0)*cj30*x1482))+(((-12.4610591900312)*x1481))+(((-10.0)*cj30*x1481)));
dummyeval[1]=((1.0)+(((-10.0)*x1481))+(((-1.0)*x1482)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1483=(gconst91*px);
IkReal x1484=((321.0)*cj30);
IkReal x1485=(gconst90*py);
CheckValue<IkReal> x1486=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1483))+(((-400.0)*x1485))+(((-1.0)*x1484*x1485))+(((-1.0)*x1483*x1484))+(((32.1)*cj30))),-1);
if(!x1486.valid){
continue;
}
CheckValue<IkReal> x1487=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1483))+(((-1.0)*x1485))),-1);
if(!x1487.valid){
continue;
}
if( IKabs(((x1486.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1487.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1486.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))))+IKsqr(((x1487.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1486.value)*(((((128.4)*sj30))+(((103.041)*cj30*sj30))))), ((x1487.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1488=IKsin(j28);
IkReal x1489=IKcos(j28);
IkReal x1490=(gconst91*px);
IkReal x1491=((0.321)*cj30);
IkReal x1492=(gconst90*py);
IkReal x1493=((0.321)*sj30);
IkReal x1494=((0.8)*x1489);
IkReal x1495=((0.321)*x1488);
IkReal x1496=((1.0)*x1489);
evalcond[0]=(((x1489*x1493))+(((0.4)*x1488))+((x1488*x1491)));
evalcond[1]=((((-0.1)*x1488))+x1493+((x1488*x1492))+((x1488*x1490)));
evalcond[2]=((0.4)+(((-1.0)*x1492*x1496))+(((0.1)*x1489))+x1491+(((-1.0)*x1490*x1496)));
evalcond[3]=((-0.32)+(((-0.08)*x1489))+((x1492*x1494))+(((-0.2568)*cj30))+((x1490*x1494)));
evalcond[4]=((0.1)+((x1489*x1491))+(((-1.0)*x1492))+(((-1.0)*x1490))+(((-1.0)*x1488*x1493))+(((0.4)*x1489)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1497=(gconst91*px);
IkReal x1498=(gconst90*py);
CheckValue<IkReal> x1499=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1498))+(((1000.0)*x1497))),-1);
if(!x1499.valid){
continue;
}
CheckValue<IkReal> x1500=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1498))+(((-1.0)*x1497))),-1);
if(!x1500.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1499.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1500.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1499.value)))+IKsqr(((x1500.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1499.value)), ((x1500.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1501=IKsin(j28);
IkReal x1502=IKcos(j28);
IkReal x1503=(gconst91*px);
IkReal x1504=((0.321)*cj30);
IkReal x1505=(gconst90*py);
IkReal x1506=((0.321)*sj30);
IkReal x1507=((0.8)*x1502);
IkReal x1508=((0.321)*x1501);
IkReal x1509=((1.0)*x1502);
evalcond[0]=(((x1501*x1504))+((x1502*x1506))+(((0.4)*x1501)));
evalcond[1]=(((x1501*x1505))+((x1501*x1503))+x1506+(((-0.1)*x1501)));
evalcond[2]=((0.4)+x1504+(((-1.0)*x1503*x1509))+(((0.1)*x1502))+(((-1.0)*x1505*x1509)));
evalcond[3]=((-0.32)+(((-0.2568)*cj30))+(((-0.08)*x1502))+((x1503*x1507))+((x1505*x1507)));
evalcond[4]=((0.1)+(((-1.0)*x1505))+(((-1.0)*x1503))+(((-1.0)*x1501*x1506))+((x1502*x1504))+(((0.4)*x1502)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1510=(gconst91*px);
IkReal x1511=(gconst90*py);
CheckValue<IkReal> x1512=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1510))+(((1000.0)*x1511))),-1);
if(!x1512.valid){
continue;
}
CheckValue<IkReal> x1513=IKPowWithIntegerCheck(((-0.1)+x1511+x1510),-1);
if(!x1513.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1512.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1513.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1512.value)))+IKsqr(((x1513.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1512.value)), ((x1513.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1514=IKsin(j28);
IkReal x1515=IKcos(j28);
IkReal x1516=(gconst91*px);
IkReal x1517=((0.321)*cj30);
IkReal x1518=(gconst90*py);
IkReal x1519=((0.321)*sj30);
IkReal x1520=((0.8)*x1515);
IkReal x1521=((0.321)*x1514);
IkReal x1522=((1.0)*x1515);
evalcond[0]=(((x1514*x1517))+((x1515*x1519))+(((0.4)*x1514)));
evalcond[1]=(((x1514*x1516))+((x1514*x1518))+x1519+(((-0.1)*x1514)));
evalcond[2]=((0.4)+(((-1.0)*x1518*x1522))+x1517+(((0.1)*x1515))+(((-1.0)*x1516*x1522)));
evalcond[3]=((-0.32)+((x1518*x1520))+(((-0.2568)*cj30))+((x1516*x1520))+(((-0.08)*x1515)));
evalcond[4]=((0.1)+(((-1.0)*x1516))+(((-1.0)*x1518))+(((-1.0)*x1514*x1519))+((x1515*x1517))+(((0.4)*x1515)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1523=(py*sj27);
IkReal x1524=(cj27*px);
CheckValue<IkReal> x1525=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1524))+(((1000.0)*x1523))),-1);
if(!x1525.valid){
continue;
}
CheckValue<IkReal> x1526=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1523))+(((-1.0)*x1524))),-1);
if(!x1526.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1525.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1526.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1525.value)))+IKsqr(((x1526.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1525.value)), ((x1526.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1527=IKsin(j28);
IkReal x1528=IKcos(j28);
IkReal x1529=((0.321)*cj30);
IkReal x1530=((0.321)*sj30);
IkReal x1531=(cj27*px);
IkReal x1532=(py*sj27);
IkReal x1533=((1.0)*x1532);
IkReal x1534=((0.8)*x1528);
evalcond[0]=((((0.4)*x1527))+((x1528*x1530))+((x1527*x1529)));
evalcond[1]=(((x1527*x1532))+((x1527*x1531))+x1530+(((-0.1)*x1527)));
evalcond[2]=((0.4)+(((-1.0)*x1528*x1531))+x1529+(((-1.0)*x1528*x1533))+(((0.1)*x1528)));
evalcond[3]=((0.1)+(((-1.0)*x1531))+((x1528*x1529))+(((0.4)*x1528))+(((-1.0)*x1533))+(((-1.0)*x1527*x1530)));
evalcond[4]=((-0.066959)+((x1531*x1534))+((x1532*x1534))+(((-1.0)*pp))+(((-0.08)*x1528))+(((0.2)*x1531))+(((0.2)*x1532)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1535=(py*sj27);
IkReal x1536=(cj27*px);
CheckValue<IkReal> x1537=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1535))+(((1000.0)*x1536))),-1);
if(!x1537.valid){
continue;
}
CheckValue<IkReal> x1538=IKPowWithIntegerCheck(((-0.1)+x1536+x1535),-1);
if(!x1538.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1537.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1538.value)*(((0.4)+(((0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1537.value)))+IKsqr(((x1538.value)*(((0.4)+(((0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1537.value)), ((x1538.value)*(((0.4)+(((0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1539=IKsin(j28);
IkReal x1540=IKcos(j28);
IkReal x1541=((0.321)*cj30);
IkReal x1542=((0.321)*sj30);
IkReal x1543=(cj27*px);
IkReal x1544=(py*sj27);
IkReal x1545=((1.0)*x1544);
IkReal x1546=((0.8)*x1540);
evalcond[0]=((((0.4)*x1539))+((x1539*x1541))+((x1540*x1542)));
evalcond[1]=(((x1539*x1544))+((x1539*x1543))+x1542+(((-0.1)*x1539)));
evalcond[2]=((0.4)+(((-1.0)*x1540*x1545))+x1541+(((-1.0)*x1540*x1543))+(((0.1)*x1540)));
evalcond[3]=((0.1)+(((-1.0)*x1543))+(((0.4)*x1540))+((x1540*x1541))+(((-1.0)*x1539*x1542))+(((-1.0)*x1545)));
evalcond[4]=((-0.066959)+((x1544*x1546))+(((-1.0)*pp))+(((-0.08)*x1540))+((x1543*x1546))+(((0.2)*x1544))+(((0.2)*x1543)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1547=(cj27*px);
IkReal x1548=((321000.0)*py*sj27);
CheckValue<IkReal> x1549 = IKatan2WithCheck((gconst79*(((((-321000.0)*sj30*x1547))+(((32100.0)*sj30))+(((-1.0)*sj30*x1548))))),(gconst79*(((-40000.0)+((cj30*x1548))+(((-32100.0)*cj30))+(((400000.0)*x1547))+(((400000.0)*py*sj27))+(((321000.0)*cj30*x1547))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1549.valid){
continue;
}
j28array[0]=x1549.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1550=IKsin(j28);
IkReal x1551=IKcos(j28);
IkReal x1552=((0.321)*cj30);
IkReal x1553=((0.321)*sj30);
IkReal x1554=(cj27*px);
IkReal x1555=(py*sj27);
IkReal x1556=((1.0)*x1555);
IkReal x1557=((0.8)*x1551);
evalcond[0]=(((x1551*x1553))+((x1550*x1552))+(((0.4)*x1550)));
evalcond[1]=(((x1550*x1554))+((x1550*x1555))+x1553+(((-0.1)*x1550)));
evalcond[2]=((0.4)+(((0.1)*x1551))+x1552+(((-1.0)*x1551*x1554))+(((-1.0)*x1551*x1556)));
evalcond[3]=((0.1)+((x1551*x1552))+(((-1.0)*x1554))+(((0.4)*x1551))+(((-1.0)*x1550*x1553))+(((-1.0)*x1556)));
evalcond[4]=((-0.066959)+((x1555*x1557))+(((-1.0)*pp))+((x1554*x1557))+(((-0.08)*x1551))+(((0.2)*x1554))+(((0.2)*x1555)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1558=(px*sj27);
IkReal x1559=(cj27*py);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((((-1.0)*x1559))+x1558);
evalcond[2]=((((-1.0)*x1558))+x1559);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal dummyeval[1];
IkReal gconst92;
gconst92=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1560=(cj27*px);
IkReal x1561=(py*sj27);
IkReal x1562=((10.0)*cj30);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1560*x1562))+(((-12.4610591900312)*x1561))+(((-12.4610591900312)*x1560))+cj30+(((-1.0)*x1561*x1562)));
dummyeval[1]=((1.0)+(((-10.0)*x1560))+(((-10.0)*x1561)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst93;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1563=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1563.valid){
continue;
}
if( (x1563.value) < -1-IKFAST_SINCOS_THRESH || (x1563.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1564 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1564.valid){
continue;
}
gconst93=((((-1.0)*(IKasin(x1563.value))))+(((-1.0)*(x1564.value))));
IkReal gconst94;
gconst94=IKsin(gconst93);
IkReal gconst95;
gconst95=IKcos(gconst93);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst93))+j27)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst94*py))+(((0.2)*gconst95*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst105;
gconst105=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst95*px))+(((-10.0)*gconst94*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1565=((10.0)*cj30);
IkReal x1566=(gconst95*px);
IkReal x1567=(gconst94*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1565*x1566))+(((-1.0)*x1565*x1567))+(((-12.4610591900312)*x1567))+(((-12.4610591900312)*x1566))+cj30);
dummyeval[1]=((1.0)+(((-10.0)*x1567))+(((-10.0)*x1566)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1568=(gconst95*px);
IkReal x1569=((321.0)*cj30);
IkReal x1570=(gconst94*py);
CheckValue<IkReal> x1571=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1568))+(((-1.0)*x1568*x1569))+(((-1.0)*x1569*x1570))+(((32.1)*cj30))+(((-400.0)*x1570))),-1);
if(!x1571.valid){
continue;
}
CheckValue<IkReal> x1572=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1568))+(((-1.0)*x1570))),-1);
if(!x1572.valid){
continue;
}
if( IKabs(((x1571.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1572.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1571.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1572.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1571.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1572.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1573=IKsin(j28);
IkReal x1574=IKcos(j28);
IkReal x1575=((0.321)*cj30);
IkReal x1576=((0.321)*sj30);
IkReal x1577=((1.0)*gconst95*px);
IkReal x1578=((0.321)*x1573);
IkReal x1579=((1.0)*gconst94*py);
IkReal x1580=(gconst94*py*x1574);
evalcond[0]=(((x1573*x1575))+(((0.4)*x1573))+(((-1.0)*x1574*x1576)));
evalcond[1]=((((-1.0)*x1573*x1577))+(((-1.0)*x1573*x1579))+x1576+(((0.1)*x1573)));
evalcond[2]=((0.4)+x1575+(((-1.0)*x1574*x1579))+(((-1.0)*x1574*x1577))+(((0.1)*x1574)));
evalcond[3]=((-0.32)+(((0.8)*x1580))+(((-0.08)*x1574))+(((0.8)*gconst95*px*x1574))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+((x1573*x1576))+(((0.4)*x1574))+(((-1.0)*x1579))+(((-1.0)*x1577))+((x1574*x1575)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1581=(gconst94*py);
IkReal x1582=(gconst95*px);
CheckValue<IkReal> x1583=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1582))+(((-1000.0)*x1581))),-1);
if(!x1583.valid){
continue;
}
CheckValue<IkReal> x1584=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1581))+(((-1.0)*x1582))),-1);
if(!x1584.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1583.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1584.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1583.value)))+IKsqr(((x1584.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1583.value)), ((x1584.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1585=IKsin(j28);
IkReal x1586=IKcos(j28);
IkReal x1587=((0.321)*cj30);
IkReal x1588=((0.321)*sj30);
IkReal x1589=((1.0)*gconst95*px);
IkReal x1590=((0.321)*x1585);
IkReal x1591=((1.0)*gconst94*py);
IkReal x1592=(gconst94*py*x1586);
evalcond[0]=((((0.4)*x1585))+(((-1.0)*x1586*x1588))+((x1585*x1587)));
evalcond[1]=((((-1.0)*x1585*x1591))+(((-1.0)*x1585*x1589))+x1588+(((0.1)*x1585)));
evalcond[2]=((0.4)+x1587+(((-1.0)*x1586*x1591))+(((-1.0)*x1586*x1589))+(((0.1)*x1586)));
evalcond[3]=((-0.32)+(((0.8)*x1592))+(((0.8)*gconst95*px*x1586))+(((-0.08)*x1586))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+(((-1.0)*x1589))+((x1586*x1587))+(((-1.0)*x1591))+(((0.4)*x1586))+((x1585*x1588)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1593=(gconst95*px);
IkReal x1594=((321000.0)*cj30);
IkReal x1595=(gconst94*py);
IkReal x1596=((321000.0)*sj30);
CheckValue<IkReal> x1597 = IKatan2WithCheck((gconst105*(((((-1.0)*x1593*x1596))+(((32100.0)*sj30))+(((-1.0)*x1595*x1596))))),(gconst105*(((40000.0)+(((-1.0)*x1593*x1594))+(((-1.0)*x1594*x1595))+(((-400000.0)*x1595))+(((-400000.0)*x1593))+(((32100.0)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1597.valid){
continue;
}
j28array[0]=x1597.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1598=IKsin(j28);
IkReal x1599=IKcos(j28);
IkReal x1600=((0.321)*cj30);
IkReal x1601=((0.321)*sj30);
IkReal x1602=((1.0)*gconst95*px);
IkReal x1603=((0.321)*x1598);
IkReal x1604=((1.0)*gconst94*py);
IkReal x1605=(gconst94*py*x1599);
evalcond[0]=((((0.4)*x1598))+(((-1.0)*x1599*x1601))+((x1598*x1600)));
evalcond[1]=(x1601+(((0.1)*x1598))+(((-1.0)*x1598*x1604))+(((-1.0)*x1598*x1602)));
evalcond[2]=((0.4)+x1600+(((-1.0)*x1599*x1602))+(((-1.0)*x1599*x1604))+(((0.1)*x1599)));
evalcond[3]=((-0.32)+(((0.8)*gconst95*px*x1599))+(((0.8)*x1605))+(((-0.08)*x1599))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+(((-1.0)*x1604))+(((-1.0)*x1602))+((x1599*x1600))+(((0.4)*x1599))+((x1598*x1601)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst96;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1606=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1606.valid){
continue;
}
if( (x1606.value) < -1-IKFAST_SINCOS_THRESH || (x1606.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1607 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1607.valid){
continue;
}
gconst96=((3.14159265358979)+(IKasin(x1606.value))+(((-1.0)*(x1607.value))));
IkReal gconst97;
gconst97=IKsin(gconst96);
IkReal gconst98;
gconst98=IKcos(gconst96);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst96))+j27)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst98*px))+(((0.2)*gconst97*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst106;
gconst106=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst97*py))+(((-10.0)*gconst98*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1608=(gconst97*py);
IkReal x1609=((10.0)*gconst98*px);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*gconst98*px))+(((-12.4610591900312)*x1608))+(((-10.0)*cj30*x1608))+cj30+(((-1.0)*cj30*x1609)));
dummyeval[1]=((1.0)+(((-1.0)*x1609))+(((-10.0)*x1608)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1610=(gconst97*py);
IkReal x1611=((321.0)*cj30);
IkReal x1612=(gconst98*px);
CheckValue<IkReal> x1613=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1610))+(((-400.0)*x1612))+(((-1.0)*x1611*x1612))+(((-1.0)*x1610*x1611))+(((32.1)*cj30))),-1);
if(!x1613.valid){
continue;
}
CheckValue<IkReal> x1614=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1612))+(((-1.0)*x1610))),-1);
if(!x1614.valid){
continue;
}
if( IKabs(((x1613.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1614.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1613.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1614.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1613.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1614.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1615=IKsin(j28);
IkReal x1616=IKcos(j28);
IkReal x1617=((0.321)*cj30);
IkReal x1618=((0.321)*sj30);
IkReal x1619=((0.321)*x1615);
IkReal x1620=((1.0)*gconst97*py);
IkReal x1621=((1.0)*gconst98*px);
IkReal x1622=(gconst98*px*x1616);
evalcond[0]=((((-1.0)*x1616*x1618))+(((0.4)*x1615))+((x1615*x1617)));
evalcond[1]=(x1618+(((0.1)*x1615))+(((-1.0)*x1615*x1621))+(((-1.0)*x1615*x1620)));
evalcond[2]=((0.4)+(((-1.0)*x1616*x1621))+(((-1.0)*x1616*x1620))+x1617+(((0.1)*x1616)));
evalcond[3]=((-0.32)+(((0.8)*x1622))+(((-0.08)*x1616))+(((-0.2568)*cj30))+(((0.8)*gconst97*py*x1616)));
evalcond[4]=((0.1)+(((0.4)*x1616))+(((-1.0)*x1620))+(((-1.0)*x1621))+((x1615*x1618))+((x1616*x1617)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1623=(gconst97*py);
IkReal x1624=(gconst98*px);
CheckValue<IkReal> x1625=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1623))+(((-1000.0)*x1624))),-1);
if(!x1625.valid){
continue;
}
CheckValue<IkReal> x1626=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1624))+(((-1.0)*x1623))),-1);
if(!x1626.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1625.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1626.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1625.value)))+IKsqr(((x1626.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1625.value)), ((x1626.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1627=IKsin(j28);
IkReal x1628=IKcos(j28);
IkReal x1629=((0.321)*cj30);
IkReal x1630=((0.321)*sj30);
IkReal x1631=((0.321)*x1627);
IkReal x1632=((1.0)*gconst97*py);
IkReal x1633=((1.0)*gconst98*px);
IkReal x1634=(gconst98*px*x1628);
evalcond[0]=(((x1627*x1629))+(((0.4)*x1627))+(((-1.0)*x1628*x1630)));
evalcond[1]=(x1630+(((0.1)*x1627))+(((-1.0)*x1627*x1633))+(((-1.0)*x1627*x1632)));
evalcond[2]=((0.4)+x1629+(((-1.0)*x1628*x1632))+(((-1.0)*x1628*x1633))+(((0.1)*x1628)));
evalcond[3]=((-0.32)+(((0.8)*gconst97*py*x1628))+(((-0.2568)*cj30))+(((-0.08)*x1628))+(((0.8)*x1634)));
evalcond[4]=((0.1)+((x1627*x1630))+(((0.4)*x1628))+((x1628*x1629))+(((-1.0)*x1632))+(((-1.0)*x1633)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1635=(gconst98*px);
IkReal x1636=(gconst97*py);
IkReal x1637=((321000.0)*cj30);
IkReal x1638=((321000.0)*sj30);
CheckValue<IkReal> x1639 = IKatan2WithCheck((gconst106*(((((-1.0)*x1635*x1638))+(((32100.0)*sj30))+(((-1.0)*x1636*x1638))))),(gconst106*(((40000.0)+(((-1.0)*x1635*x1637))+(((-1.0)*x1636*x1637))+(((32100.0)*cj30))+(((-400000.0)*x1635))+(((-400000.0)*x1636))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1639.valid){
continue;
}
j28array[0]=x1639.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1640=IKsin(j28);
IkReal x1641=IKcos(j28);
IkReal x1642=((0.321)*cj30);
IkReal x1643=((0.321)*sj30);
IkReal x1644=((0.321)*x1640);
IkReal x1645=((1.0)*gconst97*py);
IkReal x1646=((1.0)*gconst98*px);
IkReal x1647=(gconst98*px*x1641);
evalcond[0]=(((x1640*x1642))+(((-1.0)*x1641*x1643))+(((0.4)*x1640)));
evalcond[1]=(x1643+(((-1.0)*x1640*x1645))+(((-1.0)*x1640*x1646))+(((0.1)*x1640)));
evalcond[2]=((0.4)+(((-1.0)*x1641*x1645))+(((-1.0)*x1641*x1646))+x1642+(((0.1)*x1641)));
evalcond[3]=((-0.32)+(((-0.08)*x1641))+(((0.8)*gconst97*py*x1641))+(((-0.2568)*cj30))+(((0.8)*x1647)));
evalcond[4]=((0.1)+((x1640*x1643))+((x1641*x1642))+(((-1.0)*x1645))+(((-1.0)*x1646))+(((0.4)*x1641)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst99;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1648=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1648.valid){
continue;
}
if( (x1648.value) < -1-IKFAST_SINCOS_THRESH || (x1648.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1649 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1649.valid){
continue;
}
gconst99=((((-1.0)*(IKasin(x1648.value))))+(((-1.0)*(x1649.value))));
IkReal gconst100;
gconst100=IKsin(gconst99);
IkReal gconst101;
gconst101=IKcos(gconst99);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst99))+j27)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*cj30))+(((0.2)*gconst101*px))+(((0.2)*gconst100*py))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst107;
gconst107=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst101*px))+(((-10.0)*gconst100*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1650=((10.0)*cj30);
IkReal x1651=(gconst101*px);
IkReal x1652=(gconst100*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1650*x1652))+(((-1.0)*x1650*x1651))+(((-12.4610591900312)*x1651))+(((-12.4610591900312)*x1652))+cj30);
dummyeval[1]=((1.0)+(((-10.0)*x1652))+(((-10.0)*x1651)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1653=(gconst100*py);
IkReal x1654=(gconst101*px);
IkReal x1655=((321.0)*cj30);
CheckValue<IkReal> x1656=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1654*x1655))+(((-400.0)*x1653))+(((-400.0)*x1654))+(((-1.0)*x1653*x1655))+(((32.1)*cj30))),-1);
if(!x1656.valid){
continue;
}
CheckValue<IkReal> x1657=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1653))+(((-1.0)*x1654))),-1);
if(!x1657.valid){
continue;
}
if( IKabs(((x1656.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1657.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1656.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1657.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1656.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1657.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1658=IKsin(j28);
IkReal x1659=IKcos(j28);
IkReal x1660=((0.321)*cj30);
IkReal x1661=(gconst101*px);
IkReal x1662=((0.321)*sj30);
IkReal x1663=((1.0)*gconst100*py);
IkReal x1664=((0.321)*x1658);
IkReal x1665=((0.8)*x1659);
evalcond[0]=(((x1658*x1660))+(((0.4)*x1658))+(((-1.0)*x1659*x1662)));
evalcond[1]=(x1662+(((0.1)*x1658))+(((-1.0)*x1658*x1661))+(((-1.0)*x1658*x1663)));
evalcond[2]=((0.4)+x1660+(((0.1)*x1659))+(((-1.0)*x1659*x1661))+(((-1.0)*x1659*x1663)));
evalcond[3]=((-0.32)+((gconst100*py*x1665))+(((-0.2568)*cj30))+((x1661*x1665))+(((-0.08)*x1659)));
evalcond[4]=((0.1)+(((-1.0)*x1661))+(((-1.0)*x1663))+((x1658*x1662))+((x1659*x1660))+(((0.4)*x1659)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1666=(gconst100*py);
IkReal x1667=(gconst101*px);
CheckValue<IkReal> x1668=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1667))+(((-1000.0)*x1666))),-1);
if(!x1668.valid){
continue;
}
CheckValue<IkReal> x1669=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1666))+(((-1.0)*x1667))),-1);
if(!x1669.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1668.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1669.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1668.value)))+IKsqr(((x1669.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1668.value)), ((x1669.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1670=IKsin(j28);
IkReal x1671=IKcos(j28);
IkReal x1672=((0.321)*cj30);
IkReal x1673=(gconst101*px);
IkReal x1674=((0.321)*sj30);
IkReal x1675=((1.0)*gconst100*py);
IkReal x1676=((0.321)*x1670);
IkReal x1677=((0.8)*x1671);
evalcond[0]=((((0.4)*x1670))+(((-1.0)*x1671*x1674))+((x1670*x1672)));
evalcond[1]=(x1674+(((0.1)*x1670))+(((-1.0)*x1670*x1673))+(((-1.0)*x1670*x1675)));
evalcond[2]=((0.4)+(((-1.0)*x1671*x1673))+x1672+(((0.1)*x1671))+(((-1.0)*x1671*x1675)));
evalcond[3]=((-0.32)+(((-0.08)*x1671))+((gconst100*py*x1677))+((x1673*x1677))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+(((0.4)*x1671))+(((-1.0)*x1673))+((x1671*x1672))+(((-1.0)*x1675))+((x1670*x1674)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1678=((321000.0)*cj30);
IkReal x1679=(gconst101*px);
IkReal x1680=(gconst100*py);
IkReal x1681=((321000.0)*sj30);
CheckValue<IkReal> x1682 = IKatan2WithCheck((gconst107*(((((32100.0)*sj30))+(((-1.0)*x1679*x1681))+(((-1.0)*x1680*x1681))))),(gconst107*(((40000.0)+(((-1.0)*x1678*x1679))+(((-1.0)*x1678*x1680))+(((-400000.0)*x1679))+(((32100.0)*cj30))+(((-400000.0)*x1680))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1682.valid){
continue;
}
j28array[0]=x1682.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1683=IKsin(j28);
IkReal x1684=IKcos(j28);
IkReal x1685=((0.321)*cj30);
IkReal x1686=(gconst101*px);
IkReal x1687=((0.321)*sj30);
IkReal x1688=((1.0)*gconst100*py);
IkReal x1689=((0.321)*x1683);
IkReal x1690=((0.8)*x1684);
evalcond[0]=((((0.4)*x1683))+((x1683*x1685))+(((-1.0)*x1684*x1687)));
evalcond[1]=(x1687+(((-1.0)*x1683*x1688))+(((-1.0)*x1683*x1686))+(((0.1)*x1683)));
evalcond[2]=((0.4)+x1685+(((-1.0)*x1684*x1686))+(((0.1)*x1684))+(((-1.0)*x1684*x1688)));
evalcond[3]=((-0.32)+((gconst100*py*x1690))+((x1686*x1690))+(((-0.2568)*cj30))+(((-0.08)*x1684)));
evalcond[4]=((0.1)+(((-1.0)*x1688))+(((-1.0)*x1686))+((x1684*x1685))+(((0.4)*x1684))+((x1683*x1687)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst102;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1691=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1691.valid){
continue;
}
if( (x1691.value) < -1-IKFAST_SINCOS_THRESH || (x1691.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1692 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1692.valid){
continue;
}
gconst102=((3.14159265358979)+(IKasin(x1691.value))+(((-1.0)*(x1692.value))));
IkReal gconst103;
gconst103=IKsin(gconst102);
IkReal gconst104;
gconst104=IKcos(gconst102);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j27+(((-1.0)*gconst102)))))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst104*px))+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*gconst103*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst108;
gconst108=IKsign(((-160000.0)+(((-256800.0)*cj30))+(((-103041.0)*(sj30*sj30)))+(((-103041.0)*(cj30*cj30)))));
dummyeval[0]=((-1.5527799613746)+(((-2.49221183800623)*cj30))+(((-1.0)*(cj30*cj30)))+(((-1.0)*(sj30*sj30))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst104*px))+(((-10.0)*gconst103*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1693=((10.0)*cj30);
IkReal x1694=(gconst104*px);
IkReal x1695=(gconst103*py);
dummyeval[0]=((1.24610591900312)+cj30+(((-12.4610591900312)*x1695))+(((-12.4610591900312)*x1694))+(((-1.0)*x1693*x1694))+(((-1.0)*x1693*x1695)));
dummyeval[1]=((1.0)+(((-10.0)*x1695))+(((-10.0)*x1694)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1696=(gconst104*px);
IkReal x1697=((321.0)*cj30);
IkReal x1698=(gconst103*py);
CheckValue<IkReal> x1699=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1696*x1697))+(((-1.0)*x1697*x1698))+(((-400.0)*x1696))+(((-400.0)*x1698))+(((32.1)*cj30))),-1);
if(!x1699.valid){
continue;
}
CheckValue<IkReal> x1700=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1698))+(((-1.0)*x1696))),-1);
if(!x1700.valid){
continue;
}
if( IKabs(((x1699.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1700.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1699.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1700.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1699.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1700.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1701=IKsin(j28);
IkReal x1702=IKcos(j28);
IkReal x1703=(gconst104*px);
IkReal x1704=(gconst103*py);
IkReal x1705=((0.321)*cj30);
IkReal x1706=((0.321)*sj30);
IkReal x1707=((1.0)*x1702);
IkReal x1708=((0.321)*x1701);
IkReal x1709=((0.8)*x1702);
IkReal x1710=((1.0)*x1701);
evalcond[0]=((((-1.0)*x1702*x1706))+(((0.4)*x1701))+((x1701*x1705)));
evalcond[1]=(x1706+(((-1.0)*x1704*x1710))+(((-1.0)*x1703*x1710))+(((0.1)*x1701)));
evalcond[2]=((0.4)+x1705+(((-1.0)*x1704*x1707))+(((-1.0)*x1703*x1707))+(((0.1)*x1702)));
evalcond[3]=((-0.32)+((x1703*x1709))+((x1704*x1709))+(((-0.2568)*cj30))+(((-0.08)*x1702)));
evalcond[4]=((0.1)+(((0.4)*x1702))+(((-1.0)*x1703))+(((-1.0)*x1704))+((x1701*x1706))+((x1702*x1705)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1711=(gconst103*py);
IkReal x1712=(gconst104*px);
CheckValue<IkReal> x1713=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1711))+(((-1000.0)*x1712))),-1);
if(!x1713.valid){
continue;
}
CheckValue<IkReal> x1714=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1712))+(((-1.0)*x1711))),-1);
if(!x1714.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1713.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1714.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1713.value)))+IKsqr(((x1714.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1713.value)), ((x1714.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1715=IKsin(j28);
IkReal x1716=IKcos(j28);
IkReal x1717=(gconst104*px);
IkReal x1718=(gconst103*py);
IkReal x1719=((0.321)*cj30);
IkReal x1720=((0.321)*sj30);
IkReal x1721=((1.0)*x1716);
IkReal x1722=((0.321)*x1715);
IkReal x1723=((0.8)*x1716);
IkReal x1724=((1.0)*x1715);
evalcond[0]=(((x1715*x1719))+(((-1.0)*x1716*x1720))+(((0.4)*x1715)));
evalcond[1]=(x1720+(((-1.0)*x1717*x1724))+(((-1.0)*x1718*x1724))+(((0.1)*x1715)));
evalcond[2]=((0.4)+x1719+(((-1.0)*x1717*x1721))+(((-1.0)*x1718*x1721))+(((0.1)*x1716)));
evalcond[3]=((-0.32)+(((-0.08)*x1716))+((x1718*x1723))+((x1717*x1723))+(((-0.2568)*cj30)));
evalcond[4]=((0.1)+((x1715*x1720))+((x1716*x1719))+(((-1.0)*x1717))+(((-1.0)*x1718))+(((0.4)*x1716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1725=(gconst103*py);
IkReal x1726=(gconst104*px);
IkReal x1727=((321000.0)*cj30);
IkReal x1728=((321000.0)*sj30);
CheckValue<IkReal> x1729 = IKatan2WithCheck((gconst108*(((((-1.0)*x1726*x1728))+(((32100.0)*sj30))+(((-1.0)*x1725*x1728))))),(gconst108*(((40000.0)+(((-400000.0)*x1726))+(((-400000.0)*x1725))+(((-1.0)*x1726*x1727))+(((32100.0)*cj30))+(((-1.0)*x1725*x1727))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1729.valid){
continue;
}
j28array[0]=x1729.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1730=IKsin(j28);
IkReal x1731=IKcos(j28);
IkReal x1732=(gconst104*px);
IkReal x1733=(gconst103*py);
IkReal x1734=((0.321)*cj30);
IkReal x1735=((0.321)*sj30);
IkReal x1736=((1.0)*x1731);
IkReal x1737=((0.321)*x1730);
IkReal x1738=((0.8)*x1731);
IkReal x1739=((1.0)*x1730);
evalcond[0]=((((-1.0)*x1731*x1735))+((x1730*x1734))+(((0.4)*x1730)));
evalcond[1]=((((-1.0)*x1733*x1739))+x1735+(((0.1)*x1730))+(((-1.0)*x1732*x1739)));
evalcond[2]=((0.4)+(((-1.0)*x1733*x1736))+x1734+(((0.1)*x1731))+(((-1.0)*x1732*x1736)));
evalcond[3]=((-0.32)+(((-0.08)*x1731))+(((-0.2568)*cj30))+((x1732*x1738))+((x1733*x1738)));
evalcond[4]=((0.1)+((x1730*x1735))+((x1731*x1734))+(((0.4)*x1731))+(((-1.0)*x1733))+(((-1.0)*x1732)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1740=(py*sj27);
IkReal x1741=((321.0)*cj30);
IkReal x1742=(cj27*px);
CheckValue<IkReal> x1743=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1741*x1742))+(((-1.0)*x1740*x1741))+(((-400.0)*x1742))+(((-400.0)*x1740))+(((32.1)*cj30))),-1);
if(!x1743.valid){
continue;
}
CheckValue<IkReal> x1744=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1740))+(((-1.0)*x1742))),-1);
if(!x1744.valid){
continue;
}
if( IKabs(((x1743.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1744.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1743.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))))+IKsqr(((x1744.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((x1743.value)*(((((-103.041)*cj30*sj30))+(((-128.4)*sj30))))), ((x1744.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1745=IKsin(j28);
IkReal x1746=IKcos(j28);
IkReal x1747=((0.321)*cj30);
IkReal x1748=((0.321)*sj30);
IkReal x1749=(py*sj27);
IkReal x1750=(cj27*px);
IkReal x1751=((1.0)*x1749);
IkReal x1752=((0.8)*x1746);
evalcond[0]=(((x1745*x1747))+(((-1.0)*x1746*x1748))+(((0.4)*x1745)));
evalcond[1]=(x1748+(((-1.0)*x1745*x1751))+(((0.1)*x1745))+(((-1.0)*x1745*x1750)));
evalcond[2]=((0.4)+(((-1.0)*x1746*x1750))+x1747+(((-1.0)*x1746*x1751))+(((0.1)*x1746)));
evalcond[3]=((0.1)+((x1745*x1748))+((x1746*x1747))+(((-1.0)*x1751))+(((-1.0)*x1750))+(((0.4)*x1746)));
evalcond[4]=((-0.066959)+(((0.2)*x1750))+(((0.2)*x1749))+((x1749*x1752))+(((-0.08)*x1746))+((x1750*x1752))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1753=(py*sj27);
IkReal x1754=(cj27*px);
CheckValue<IkReal> x1755=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1753))+(((-1000.0)*x1754))),-1);
if(!x1755.valid){
continue;
}
CheckValue<IkReal> x1756=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1754))+(((-1.0)*x1753))),-1);
if(!x1756.valid){
continue;
}
if( IKabs(((-321.0)*sj30*(x1755.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1756.value)*(((-0.4)+(((-0.321)*cj30)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj30*(x1755.value)))+IKsqr(((x1756.value)*(((-0.4)+(((-0.321)*cj30))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j28array[0]=IKatan2(((-321.0)*sj30*(x1755.value)), ((x1756.value)*(((-0.4)+(((-0.321)*cj30))))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1757=IKsin(j28);
IkReal x1758=IKcos(j28);
IkReal x1759=((0.321)*cj30);
IkReal x1760=((0.321)*sj30);
IkReal x1761=(py*sj27);
IkReal x1762=(cj27*px);
IkReal x1763=((1.0)*x1761);
IkReal x1764=((0.8)*x1758);
evalcond[0]=((((-1.0)*x1758*x1760))+(((0.4)*x1757))+((x1757*x1759)));
evalcond[1]=(x1760+(((-1.0)*x1757*x1762))+(((-1.0)*x1757*x1763))+(((0.1)*x1757)));
evalcond[2]=((0.4)+x1759+(((0.1)*x1758))+(((-1.0)*x1758*x1762))+(((-1.0)*x1758*x1763)));
evalcond[3]=((0.1)+((x1758*x1759))+(((-1.0)*x1762))+(((-1.0)*x1763))+((x1757*x1760))+(((0.4)*x1758)));
evalcond[4]=((-0.066959)+(((-0.08)*x1758))+(((0.2)*x1761))+(((0.2)*x1762))+(((-1.0)*pp))+((x1762*x1764))+((x1761*x1764)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1765=(cj27*px);
IkReal x1766=((321000.0)*py*sj27);
CheckValue<IkReal> x1767 = IKatan2WithCheck((gconst92*(((((32100.0)*sj30))+(((-1.0)*sj30*x1766))+(((-321000.0)*sj30*x1765))))),(gconst92*(((40000.0)+(((-400000.0)*py*sj27))+(((-321000.0)*cj30*x1765))+(((32100.0)*cj30))+(((-1.0)*cj30*x1766))+(((-400000.0)*x1765))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1767.valid){
continue;
}
j28array[0]=x1767.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x1768=IKsin(j28);
IkReal x1769=IKcos(j28);
IkReal x1770=((0.321)*cj30);
IkReal x1771=((0.321)*sj30);
IkReal x1772=(py*sj27);
IkReal x1773=(cj27*px);
IkReal x1774=((1.0)*x1772);
IkReal x1775=((0.8)*x1769);
evalcond[0]=((((0.4)*x1768))+((x1768*x1770))+(((-1.0)*x1769*x1771)));
evalcond[1]=((((0.1)*x1768))+x1771+(((-1.0)*x1768*x1773))+(((-1.0)*x1768*x1774)));
evalcond[2]=((0.4)+(((0.1)*x1769))+x1770+(((-1.0)*x1769*x1773))+(((-1.0)*x1769*x1774)));
evalcond[3]=((0.1)+(((0.4)*x1769))+(((-1.0)*x1773))+(((-1.0)*x1774))+((x1768*x1771))+((x1769*x1770)));
evalcond[4]=((-0.066959)+(((0.2)*x1772))+(((0.2)*x1773))+((x1773*x1775))+(((-1.0)*pp))+(((-0.08)*x1769))+((x1772*x1775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1776=IKPowWithIntegerCheck(sj29,-1);
if(!x1776.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1776.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1776.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1776.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[2];
evalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));
evalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst45;
IkReal x1777=(py*sj27);
IkReal x1778=((321.0)*cj30);
IkReal x1779=(cj27*px);
gconst45=IKsign(((-40.0)+(((400.0)*x1777))+(((400.0)*x1779))+(((321.0)*cj29*pz*sj30))+((x1777*x1778))+((x1778*x1779))+(((-32.1)*cj30))));
IkReal x1780=(cj27*px);
IkReal x1781=(py*sj27);
IkReal x1782=((10.0)*cj30);
dummyeval[0]=((-1.24610591900312)+(((12.4610591900312)*x1780))+(((12.4610591900312)*x1781))+(((-1.0)*cj30))+((x1780*x1782))+((x1781*x1782))+(((10.0)*cj29*pz*sj30)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst46;
gconst46=IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*(cj30*cj30)))+(((103041.0)*(cj29*cj29)*(sj30*sj30)))));
dummyeval[0]=((1.5527799613746)+(((cj29*cj29)*(sj30*sj30)))+(((2.49221183800623)*cj30))+(cj30*cj30));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1783=(cj27*px);
IkReal x1784=((321000.0)*cj30);
IkReal x1785=(py*sj27);
IkReal x1786=((321000.0)*cj29*sj30);
CheckValue<IkReal> x1787 = IKatan2WithCheck((gconst46*(((((-1.0)*x1783*x1786))+(((32100.0)*cj29*sj30))+(((-1.0)*pz*x1784))+(((-1.0)*x1785*x1786))+(((-400000.0)*pz))))),(gconst46*(((-40000.0)+(((400000.0)*x1783))+(((400000.0)*x1785))+((x1783*x1784))+(((-32100.0)*cj30))+(((-1.0)*pz*x1786))+((x1784*x1785))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1787.valid){
continue;
}
j28array[0]=x1787.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x1788=IKsin(j28);
IkReal x1789=IKcos(j28);
IkReal x1790=((0.321)*cj30);
IkReal x1791=(py*sj27);
IkReal x1792=((0.321)*sj30);
IkReal x1793=((1.0)*sj29);
IkReal x1794=(px*sj27);
IkReal x1795=(cj27*px);
IkReal x1796=(cj27*py);
IkReal x1797=((1.0)*x1791);
IkReal x1798=(pz*x1788);
IkReal x1799=(cj29*x1788);
IkReal x1800=(pz*x1789);
IkReal x1801=((0.8)*x1789);
IkReal x1802=(sj29*x1788);
evalcond[0]=(pz+(((0.4)*x1788))+((cj29*x1789*x1792))+((x1788*x1790)));
evalcond[1]=((0.1)+(((-1.0)*x1792*x1799))+(((-1.0)*x1797))+((x1789*x1790))+(((0.4)*x1789))+(((-1.0)*x1795)));
evalcond[2]=((0.4)+(((-1.0)*x1789*x1795))+x1798+x1790+(((0.1)*x1789))+(((-1.0)*x1789*x1797)));
evalcond[3]=((-0.066959)+((x1795*x1801))+(((-0.8)*x1798))+(((-0.08)*x1789))+(((-1.0)*pp))+(((0.2)*x1791))+(((0.2)*x1795))+((x1791*x1801)));
evalcond[4]=(((cj29*x1794))+(((-1.0)*x1788*x1791*x1793))+(((-1.0)*cj29*x1796))+(((0.1)*x1802))+(((-1.0)*x1788*x1793*x1795))+(((-1.0)*x1793*x1800)));
evalcond[5]=(x1792+(((-1.0)*x1793*x1796))+((sj29*x1794))+(((-0.1)*x1799))+((cj29*x1800))+((x1795*x1799))+((x1791*x1799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1803=(cj29*sj30);
IkReal x1804=((1000.0)*pz);
CheckValue<IkReal> x1805 = IKatan2WithCheck((gconst45*(((((-103.041)*cj30*x1803))+(((100.0)*pz))+(((-128.4)*x1803))+(((-1.0)*cj27*px*x1804))+(((-1.0)*py*sj27*x1804))))),(gconst45*(((160.0)+(((-1.0)*pz*x1804))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1805.valid){
continue;
}
j28array[0]=x1805.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x1806=IKsin(j28);
IkReal x1807=IKcos(j28);
IkReal x1808=((0.321)*cj30);
IkReal x1809=(py*sj27);
IkReal x1810=((0.321)*sj30);
IkReal x1811=((1.0)*sj29);
IkReal x1812=(px*sj27);
IkReal x1813=(cj27*px);
IkReal x1814=(cj27*py);
IkReal x1815=((1.0)*x1809);
IkReal x1816=(pz*x1806);
IkReal x1817=(cj29*x1806);
IkReal x1818=(pz*x1807);
IkReal x1819=((0.8)*x1807);
IkReal x1820=(sj29*x1806);
evalcond[0]=(((x1806*x1808))+((cj29*x1807*x1810))+(((0.4)*x1806))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1815))+(((-1.0)*x1810*x1817))+(((0.4)*x1807))+((x1807*x1808))+(((-1.0)*x1813)));
evalcond[2]=((0.4)+(((-1.0)*x1807*x1815))+x1816+x1808+(((-1.0)*x1807*x1813))+(((0.1)*x1807)));
evalcond[3]=((-0.066959)+(((0.2)*x1809))+((x1813*x1819))+((x1809*x1819))+(((-1.0)*pp))+(((0.2)*x1813))+(((-0.08)*x1807))+(((-0.8)*x1816)));
evalcond[4]=(((cj29*x1812))+(((-1.0)*x1811*x1818))+(((-1.0)*x1806*x1809*x1811))+(((-1.0)*cj29*x1814))+(((-1.0)*x1806*x1811*x1813))+(((0.1)*x1820)));
evalcond[5]=(((cj29*x1818))+((x1813*x1817))+(((-1.0)*x1811*x1814))+(((-0.1)*x1817))+((x1809*x1817))+((sj29*x1812))+x1810);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x1821=py*py;
IkReal x1822=sj27*sj27;
IkReal x1823=cj27*cj27;
IkReal x1824=px*px;
IkReal x1825=(pz*sj27);
IkReal x1826=(py*sj29);
IkReal x1827=((5.0)*pp);
IkReal x1828=(pz*sj29);
IkReal x1829=((0.4)*cj29);
IkReal x1830=(px*sj27);
IkReal x1831=((4.0)*cj29*px);
IkReal x1832=(cj27*px*sj29);
IkReal x1833=((4.0)*cj27*cj29);
CheckValue<IkReal> x1834 = IKatan2WithCheck((gconst44*(((((-1.0)*x1825*x1826))+(((-1.0)*cj27*py*x1829))+(((-1.0)*sj27*x1824*x1833))+((x1829*x1830))+((x1827*x1828))+((sj27*x1821*x1833))+((py*x1823*x1831))+(((-1.0)*py*x1822*x1831))+(((0.334795)*x1828))+(((-1.0)*cj27*px*x1828))))),(gconst44*(((((2.0)*cj27*x1826*x1830))+((sj29*x1821*x1822))+(((0.5)*pp*sj29))+((sj29*x1823*x1824))+(((-1.0)*x1825*x1831))+(((0.0334795)*sj29))+(((-1.0)*sj27*x1826*x1827))+(((-1.0)*x1827*x1832))+(((-0.434795)*x1832))+((py*pz*x1833))+(((-0.434795)*sj27*x1826))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1834.valid){
continue;
}
j28array[0]=x1834.value;
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[2];
IkReal x1835=IKcos(j28);
IkReal x1836=IKsin(j28);
IkReal x1837=(py*sj27);
IkReal x1838=((1.0)*cj27);
IkReal x1839=(cj27*px);
IkReal x1840=((0.8)*x1835);
IkReal x1841=(sj29*x1836);
evalcond[0]=((-0.066959)+(((-0.8)*pz*x1836))+((x1837*x1840))+(((0.2)*x1837))+(((0.2)*x1839))+(((-1.0)*pp))+((x1839*x1840))+(((-0.08)*x1835)));
evalcond[1]=((((0.1)*x1841))+((cj29*px*sj27))+(((-1.0)*pz*sj29*x1835))+(((-1.0)*px*x1838*x1841))+(((-1.0)*x1837*x1841))+(((-1.0)*cj29*py*x1838)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=cj28;
dummyeval[1]=cj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1842=(cj27*px);
IkReal x1843=((1.0)*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*x1842))+(((-1.0)*pp))+(((0.2)*py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*sj27*sj29*x1843))+(((-1.0)*cj27*cj29*x1843))+(((0.1)*sj29))+(((-1.0)*sj29*x1842)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1844=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1844))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1844))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1845=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1845))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1845))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1846=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1846))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1846))+(((0.8)*pz)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1847=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1847))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1847))+(((0.8)*pz)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1848=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1848))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1848))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1849=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1849))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1849))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1850=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1850))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1850)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1851=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1851))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1851)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1852=IKPowWithIntegerCheck(cj29,-1);
if(!x1852.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1852.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1852.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1852.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1853=IKcos(j30);
IkReal x1854=IKsin(j30);
IkReal x1855=((1.0)*py);
IkReal x1856=(cj27*px);
IkReal x1857=(px*sj27);
IkReal x1858=((0.321)*x1854);
evalcond[0]=((0.4)+(((0.321)*x1853))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1853)));
evalcond[2]=(((sj29*x1858))+x1857+(((-1.0)*cj27*x1855)));
evalcond[3]=((0.1)+(((-1.0)*x1856))+(((-1.0)*cj29*x1858))+(((-1.0)*sj27*x1855)));
evalcond[4]=(((cj29*py*sj27))+((cj29*x1856))+(((-1.0)*cj27*sj29*x1855))+((sj29*x1857))+x1858+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1859=IKPowWithIntegerCheck(sj29,-1);
if(!x1859.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1859.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1859.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1859.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1860=IKcos(j30);
IkReal x1861=IKsin(j30);
IkReal x1862=((1.0)*py);
IkReal x1863=(cj27*px);
IkReal x1864=(px*sj27);
IkReal x1865=((0.321)*x1861);
evalcond[0]=((0.4)+pz+(((0.321)*x1860)));
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1860)));
evalcond[2]=((((-1.0)*cj27*x1862))+x1864+((sj29*x1865)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1862))+(((-1.0)*x1863))+(((-1.0)*cj29*x1865)));
evalcond[4]=(((cj29*py*sj27))+(((-1.0)*cj27*sj29*x1862))+x1865+((sj29*x1864))+((cj29*x1863))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1866=IKPowWithIntegerCheck(sj29,-1);
if(!x1866.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1866.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1866.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1866.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1867=IKcos(j30);
IkReal x1868=IKsin(j30);
IkReal x1869=((1.0)*py);
IkReal x1870=(cj27*px);
IkReal x1871=(px*sj27);
IkReal x1872=((0.321)*x1868);
evalcond[0]=((0.4)+pz+(((0.321)*x1867)));
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1867)));
evalcond[2]=((((-1.0)*cj27*x1869))+((sj29*x1872))+x1871);
evalcond[3]=((0.1)+(((-1.0)*cj29*x1872))+(((-1.0)*sj27*x1869))+(((-1.0)*x1870)));
evalcond[4]=(((cj29*py*sj27))+(((-1.0)*cj27*sj29*x1869))+((cj29*x1870))+((sj29*x1871))+x1872+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1873=(py*sj27);
IkReal x1874=(cj27*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((0.2)*x1874))+(((0.2)*x1873))+(((-1.0)*pp)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((sj29*x1873))+((sj29*x1874))+(((-0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1875=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1875))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1875)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1876=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1876))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1876)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1877=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1877))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1877)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1878=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1878))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1878)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1879=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1879))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1879)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1880=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1880))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1880)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1881=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1881))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1881)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1882=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1882))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1882)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1883=IKPowWithIntegerCheck(cj29,-1);
if(!x1883.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1883.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1883.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1883.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1884=IKcos(j30);
IkReal x1885=IKsin(j30);
IkReal x1886=((1.0)*py);
IkReal x1887=(px*sj27);
IkReal x1888=((1.0)*cj27*px);
IkReal x1889=((0.321)*x1885);
evalcond[0]=((-0.4)+(((-0.321)*x1884))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1884)));
evalcond[2]=((((-1.0)*cj27*x1886))+x1887+((sj29*x1889)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1886))+(((-1.0)*x1888))+((cj29*x1889)));
evalcond[4]=((((-1.0)*cj29*x1888))+(((-1.0)*cj29*sj27*x1886))+(((-1.0)*cj27*sj29*x1886))+x1889+((sj29*x1887))+(((0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1890=IKPowWithIntegerCheck(sj29,-1);
if(!x1890.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1890.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1890.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1890.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1891=IKcos(j30);
IkReal x1892=IKsin(j30);
IkReal x1893=((1.0)*py);
IkReal x1894=(px*sj27);
IkReal x1895=((1.0)*cj27*px);
IkReal x1896=((0.321)*x1892);
evalcond[0]=((-0.4)+(((-0.321)*x1891))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1891)));
evalcond[2]=(x1894+(((-1.0)*cj27*x1893))+((sj29*x1896)));
evalcond[3]=((0.1)+((cj29*x1896))+(((-1.0)*sj27*x1893))+(((-1.0)*x1895)));
evalcond[4]=((((-1.0)*cj29*sj27*x1893))+x1896+(((0.1)*cj29))+(((-1.0)*cj27*sj29*x1893))+(((-1.0)*cj29*x1895))+((sj29*x1894)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1897=IKPowWithIntegerCheck(sj29,-1);
if(!x1897.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1897.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1897.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1897.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1898=IKcos(j30);
IkReal x1899=IKsin(j30);
IkReal x1900=((1.0)*py);
IkReal x1901=(px*sj27);
IkReal x1902=((1.0)*cj27*px);
IkReal x1903=((0.321)*x1899);
evalcond[0]=((-0.4)+(((-0.321)*x1898))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1898)));
evalcond[2]=(((sj29*x1903))+(((-1.0)*cj27*x1900))+x1901);
evalcond[3]=((0.1)+((cj29*x1903))+(((-1.0)*sj27*x1900))+(((-1.0)*x1902)));
evalcond[4]=(((sj29*x1901))+(((-1.0)*cj29*x1902))+(((-1.0)*cj29*sj27*x1900))+(((-1.0)*cj27*sj29*x1900))+x1903+(((0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1904=(cj27*px);
IkReal x1905=((0.8)*cj28);
IkReal x1906=(py*sj27);
IkReal x1907=((1.0)*sj28);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1905*x1906))+((x1904*x1905))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1906))+(((0.2)*x1904))+(((-0.8)*pz*sj28)));
evalcond[2]=((((-1.0)*x1904*x1907))+(((0.1)*sj28))+(((-1.0)*x1906*x1907))+(((-1.0)*cj28*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1908=IKcos(j30);
IkReal x1909=((1.0)*py);
IkReal x1910=(cj27*px);
IkReal x1911=((0.321)*x1908);
evalcond[0]=((((0.4)*sj28))+pz+((sj28*x1911)));
evalcond[1]=((((-1.0)*cj27*x1909))+((px*sj27))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1908))+(((-1.0)*pp))+(((0.2)*x1910))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+((cj28*x1911))+(((0.4)*cj28))+(((-1.0)*x1910))+(((-1.0)*sj27*x1909)));
evalcond[4]=((0.4)+(((-1.0)*cj28*x1910))+x1911+(((-1.0)*cj28*sj27*x1909))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1912=(cj27*px);
IkReal x1913=((0.8)*cj28);
IkReal x1914=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1913*x1914))+((x1912*x1913))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1914))+(((0.2)*x1912))+(((-0.8)*pz*sj28)));
evalcond[2]=(((cj28*pz))+(((-0.1)*sj28))+((sj28*x1912))+((sj28*x1914)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1915=IKcos(j30);
IkReal x1916=((1.0)*py);
IkReal x1917=(cj27*px);
IkReal x1918=((0.321)*x1915);
evalcond[0]=((((0.4)*sj28))+pz+((sj28*x1918)));
evalcond[1]=((((-0.321)*(IKsin(j30))))+((px*sj27))+(((-1.0)*cj27*x1916)));
evalcond[2]=((0.253041)+(((0.2568)*x1915))+(((-1.0)*pp))+(((0.2)*x1917))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+((cj28*x1918))+(((0.4)*cj28))+(((-1.0)*x1917))+(((-1.0)*sj27*x1916)));
evalcond[4]=((0.4)+(((-1.0)*cj28*x1917))+x1918+(((-1.0)*cj28*sj27*x1916))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1919=(cj27*px);
IkReal x1920=((0.8)*cj28);
IkReal x1921=(py*sj27);
IkReal x1922=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x1922;
evalcond[2]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1919))+((x1919*x1920))+((x1920*x1921))+(((-0.8)*pz*sj28))+(((0.2)*x1921)));
evalcond[3]=x1922;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst47;
gconst47=IKsign(((((321.0)*(cj28*cj28)))+(((321.0)*(sj28*sj28)))));
dummyeval[0]=((cj28*cj28)+(sj28*sj28));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1923=IKcos(j30);
IkReal x1924=(py*sj27);
IkReal x1925=(cj27*px);
IkReal x1926=((0.321)*x1923);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.5)+(((-1.0)*x1924))+(((-1.0)*x1925))+x1926);
evalcond[2]=((0.253041)+(((0.2568)*x1923))+(((-1.0)*pp))+(((0.2)*x1924))+(((0.2)*x1925)));
CheckValue<IkReal> x1927=IKPowWithIntegerCheck(py,-1);
if(!x1927.valid){
continue;
}
evalcond[3]=((0.31630125)+(((0.25)*x1924))+(((-1.25)*pp))+x1926+(((0.25)*sj27*(px*px)*(x1927.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1928=IKcos(j30);
IkReal x1929=(py*sj27);
IkReal x1930=(cj27*px);
IkReal x1931=((0.321)*x1928);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((-0.3)+(((-1.0)*x1929))+(((-1.0)*x1930))+(((-1.0)*x1931)));
evalcond[2]=((0.253041)+(((0.2568)*x1928))+(((-1.0)*pp))+(((0.2)*x1930))+(((0.2)*x1929)));
CheckValue<IkReal> x1932=IKPowWithIntegerCheck(py,-1);
if(!x1932.valid){
continue;
}
evalcond[3]=((0.31630125)+(((0.25)*x1929))+(((-1.25)*pp))+x1931+(((0.25)*sj27*(px*px)*(x1932.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j28), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1933=IKcos(j30);
IkReal x1934=(py*sj27);
IkReal x1935=(cj27*px);
IkReal x1936=((0.321)*x1933);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.5)+(((-1.0)*x1935))+(((-1.0)*x1934))+x1936);
evalcond[2]=((0.253041)+(((0.2568)*x1933))+(((-1.0)*pp))+(((0.2)*x1935))+(((0.2)*x1934)));
CheckValue<IkReal> x1937=IKPowWithIntegerCheck(py,-1);
if(!x1937.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x1936+(((0.25)*x1934))+(((0.25)*sj27*(px*px)*(x1937.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j28, 6.28318530717959)))))+(IKabs(j12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1938=IKcos(j30);
IkReal x1939=(py*sj27);
IkReal x1940=(cj27*px);
IkReal x1941=((0.321)*x1938);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((-0.3)+(((-1.0)*x1941))+(((-1.0)*x1939))+(((-1.0)*x1940)));
evalcond[2]=((0.253041)+(((0.2568)*x1938))+(((-1.0)*pp))+(((0.2)*x1940))+(((0.2)*x1939)));
CheckValue<IkReal> x1942=IKPowWithIntegerCheck(py,-1);
if(!x1942.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x1941+(((0.25)*x1939))+(((0.25)*sj27*(px*px)*(x1942.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j28), 6.28318530717959)))))+(IKabs(j12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1943=IKcos(j30);
IkReal x1944=(py*sj27);
IkReal x1945=(cj27*px);
IkReal x1946=((0.321)*x1943);
evalcond[0]=((0.4)+x1946+pz);
evalcond[1]=((0.1)+(((-0.321)*(IKsin(j30))))+(((-1.0)*x1944))+(((-1.0)*x1945)));
evalcond[2]=((0.253041)+(((0.2568)*x1943))+(((-1.0)*pp))+(((0.2)*x1945))+(((0.2)*x1944)));
CheckValue<IkReal> x1947=IKPowWithIntegerCheck(py,-1);
if(!x1947.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x1944))+x1946+(((0.25)*sj27*(px*px)*(x1947.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j28), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1948=IKcos(j30);
IkReal x1949=(py*sj27);
IkReal x1950=(cj27*px);
IkReal x1951=((0.321)*x1948);
evalcond[0]=((-0.4)+(((-1.0)*x1951))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1949))+(((-1.0)*x1950))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2568)*x1948))+(((0.2)*x1950))+(((-1.0)*pp))+(((0.2)*x1949)));
CheckValue<IkReal> x1952=IKPowWithIntegerCheck(py,-1);
if(!x1952.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x1949))+x1951+(((0.25)*sj27*(px*px)*(x1952.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1953=((1000.0)*pz);
IkReal x1954=(cj28*sj28);
IkReal x1955=(py*sj27);
IkReal x1956=((3.11526479750779)*sj28);
IkReal x1957=(cj27*px);
CheckValue<IkReal> x1958=IKPowWithIntegerCheck(sj28,-1);
if(!x1958.valid){
continue;
}
if( IKabs(((((-3.11526479750779)*cj28*pz))+(((-1.0)*x1955*x1956))+(((0.311526479750779)*sj28))+(((-1.0)*x1956*x1957)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00311526479750779)*(x1958.value)*(((((-1.0)*x1953))+(((1000.0)*x1954*x1955))+(((1000.0)*x1954*x1957))+(((-100.0)*x1954))+((x1953*(cj28*cj28)))+(((-400.0)*sj28)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj28*pz))+(((-1.0)*x1955*x1956))+(((0.311526479750779)*sj28))+(((-1.0)*x1956*x1957))))+IKsqr(((0.00311526479750779)*(x1958.value)*(((((-1.0)*x1953))+(((1000.0)*x1954*x1955))+(((1000.0)*x1954*x1957))+(((-100.0)*x1954))+((x1953*(cj28*cj28)))+(((-400.0)*sj28))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj28*pz))+(((-1.0)*x1955*x1956))+(((0.311526479750779)*sj28))+(((-1.0)*x1956*x1957))), ((0.00311526479750779)*(x1958.value)*(((((-1.0)*x1953))+(((1000.0)*x1954*x1955))+(((1000.0)*x1954*x1957))+(((-100.0)*x1954))+((x1953*(cj28*cj28)))+(((-400.0)*sj28))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1959=IKcos(j30);
IkReal x1960=IKsin(j30);
IkReal x1961=(py*sj27);
IkReal x1962=(cj27*px);
IkReal x1963=((0.321)*x1959);
IkReal x1964=((0.321)*x1960);
evalcond[0]=((((0.4)*sj28))+pz+((cj28*x1964))+((sj28*x1963)));
evalcond[1]=((0.253041)+(((0.2568)*x1959))+(((0.2)*x1961))+(((0.2)*x1962))+(((-1.0)*pp)));
evalcond[2]=(((cj28*pz))+x1964+(((-0.1)*sj28))+((sj28*x1961))+((sj28*x1962)));
CheckValue<IkReal> x1965=IKPowWithIntegerCheck(py,-1);
if(!x1965.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x1961))+x1963+(((0.25)*sj27*(px*px)*(x1965.value))));
evalcond[4]=((0.1)+(((-1.0)*sj28*x1964))+(((0.4)*cj28))+(((-1.0)*x1961))+(((-1.0)*x1962))+((cj28*x1963)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1966=((250.0)*sj28);
IkReal x1967=(py*sj27);
IkReal x1968=(cj27*px);
CheckValue<IkReal> x1969=IKPowWithIntegerCheck(cj28,-1);
if(!x1969.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1969.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1966*x1967))+((x1966*x1968)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1967))+(((-0.778816199376947)*x1968)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1969.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1966*x1967))+((x1966*x1968))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1967))+(((-0.778816199376947)*x1968))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1969.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1966*x1967))+((x1966*x1968))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1967))+(((-0.778816199376947)*x1968))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1970=IKcos(j30);
IkReal x1971=IKsin(j30);
IkReal x1972=(py*sj27);
IkReal x1973=(cj27*px);
IkReal x1974=((0.321)*x1970);
IkReal x1975=((0.321)*x1971);
evalcond[0]=((((0.4)*sj28))+pz+((cj28*x1975))+((sj28*x1974)));
evalcond[1]=((0.253041)+(((0.2568)*x1970))+(((0.2)*x1973))+(((0.2)*x1972))+(((-1.0)*pp)));
evalcond[2]=(((cj28*pz))+x1975+((sj28*x1973))+((sj28*x1972))+(((-0.1)*sj28)));
CheckValue<IkReal> x1976=IKPowWithIntegerCheck(py,-1);
if(!x1976.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x1972))+x1974+(((0.25)*sj27*(px*px)*(x1976.value))));
evalcond[4]=((0.1)+(((-1.0)*sj28*x1975))+(((0.4)*cj28))+(((-1.0)*x1972))+(((-1.0)*x1973))+((cj28*x1974)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1977=((1000.0)*cj28);
IkReal x1978=(py*sj27);
IkReal x1979=((1000.0)*sj28);
IkReal x1980=(cj27*px);
CheckValue<IkReal> x1981 = IKatan2WithCheck((gconst47*(((((-1.0)*x1979*x1980))+(((-1.0)*x1978*x1979))+(((-1.0)*pz*x1977))+(((100.0)*sj28))))),(gconst47*(((((-400.0)*(sj28*sj28)))+(((-400.0)*(cj28*cj28)))+(((-100.0)*cj28))+(((-1.0)*pz*x1979))+((x1977*x1978))+((x1977*x1980))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1981.valid){
continue;
}
j30array[0]=x1981.value;
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1982=IKcos(j30);
IkReal x1983=IKsin(j30);
IkReal x1984=(py*sj27);
IkReal x1985=(cj27*px);
IkReal x1986=((0.321)*x1982);
IkReal x1987=((0.321)*x1983);
evalcond[0]=((((0.4)*sj28))+((cj28*x1987))+pz+((sj28*x1986)));
evalcond[1]=((0.253041)+(((0.2568)*x1982))+(((0.2)*x1984))+(((0.2)*x1985))+(((-1.0)*pp)));
evalcond[2]=(((cj28*pz))+x1987+((sj28*x1984))+((sj28*x1985))+(((-0.1)*sj28)));
CheckValue<IkReal> x1988=IKPowWithIntegerCheck(py,-1);
if(!x1988.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x1984))+x1986+(((0.25)*sj27*(px*px)*(x1988.value))));
evalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x1986))+(((-1.0)*sj28*x1987))+(((-1.0)*x1984))+(((-1.0)*x1985)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1989=(cj27*px);
IkReal x1990=((0.8)*cj28);
IkReal x1991=(cj27*py);
IkReal x1992=(px*sj27);
IkReal x1993=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=(x1992+(((-1.0)*x1991)));
evalcond[2]=((-0.066959)+(((0.2)*x1993))+(((0.2)*x1989))+(((-0.08)*cj28))+(((-1.0)*pp))+((x1989*x1990))+((x1990*x1993))+(((-0.8)*pz*sj28)));
evalcond[3]=(x1991+(((-1.0)*x1992)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst48;
gconst48=IKsign(((((321.0)*(cj28*cj28)))+(((321.0)*(sj28*sj28)))));
dummyeval[0]=((cj28*cj28)+(sj28*sj28));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1994=IKcos(j30);
IkReal x1995=(py*sj27);
IkReal x1996=(cj27*px);
IkReal x1997=((0.321)*x1994);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.5)+x1997+(((-1.0)*x1996))+(((-1.0)*x1995)));
evalcond[2]=((0.253041)+(((0.2)*x1996))+(((0.2)*x1995))+(((-1.0)*pp))+(((0.2568)*x1994)));
CheckValue<IkReal> x1998=IKPowWithIntegerCheck(py,-1);
if(!x1998.valid){
continue;
}
evalcond[3]=((0.31630125)+(((0.25)*x1995))+(((-1.25)*pp))+x1997+(((0.25)*sj27*(px*px)*(x1998.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x1999=IKcos(j30);
IkReal x2000=(py*sj27);
IkReal x2001=(cj27*px);
IkReal x2002=((0.321)*x1999);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((-0.3)+(((-1.0)*x2002))+(((-1.0)*x2000))+(((-1.0)*x2001)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1999))+(((0.2)*x2001))+(((0.2)*x2000)));
CheckValue<IkReal> x2003=IKPowWithIntegerCheck(py,-1);
if(!x2003.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x2002+(((0.25)*x2000))+(((0.25)*sj27*(px*px)*(x2003.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j28), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2004=IKcos(j30);
IkReal x2005=(py*sj27);
IkReal x2006=(cj27*px);
IkReal x2007=((0.321)*x2004);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.5)+x2007+(((-1.0)*x2005))+(((-1.0)*x2006)));
evalcond[2]=((0.253041)+(((0.2568)*x2004))+(((-1.0)*pp))+(((0.2)*x2006))+(((0.2)*x2005)));
CheckValue<IkReal> x2008=IKPowWithIntegerCheck(py,-1);
if(!x2008.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x2007+(((0.25)*x2005))+(((0.25)*sj27*(px*px)*(x2008.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j28, 6.28318530717959)))))+(IKabs(j12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2009=IKcos(j30);
IkReal x2010=(py*sj27);
IkReal x2011=(cj27*px);
IkReal x2012=((0.321)*x2009);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((-0.3)+(((-1.0)*x2012))+(((-1.0)*x2011))+(((-1.0)*x2010)));
evalcond[2]=((0.253041)+(((0.2568)*x2009))+(((-1.0)*pp))+(((0.2)*x2011))+(((0.2)*x2010)));
CheckValue<IkReal> x2013=IKPowWithIntegerCheck(py,-1);
if(!x2013.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x2010))+x2012+(((0.25)*sj27*(px*px)*(x2013.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j28), 6.28318530717959)))))+(IKabs(j12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2014=IKcos(j30);
IkReal x2015=(py*sj27);
IkReal x2016=(cj27*px);
IkReal x2017=((0.321)*x2014);
evalcond[0]=((0.4)+x2017+pz);
evalcond[1]=((0.1)+(((-1.0)*x2016))+(((-1.0)*x2015))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x2015))+(((0.2)*x2016))+(((0.2568)*x2014)));
CheckValue<IkReal> x2018=IKPowWithIntegerCheck(py,-1);
if(!x2018.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x2015))+x2017+(((0.25)*sj27*(px*px)*(x2018.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j28), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2019=IKcos(j30);
IkReal x2020=(py*sj27);
IkReal x2021=(cj27*px);
IkReal x2022=((0.321)*x2019);
evalcond[0]=((-0.4)+pz+(((-1.0)*x2022)));
evalcond[1]=((0.1)+(((-0.321)*(IKsin(j30))))+(((-1.0)*x2020))+(((-1.0)*x2021)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x2021))+(((0.2)*x2020))+(((0.2568)*x2019)));
CheckValue<IkReal> x2023=IKPowWithIntegerCheck(py,-1);
if(!x2023.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x2022+(((0.25)*x2020))+(((0.25)*sj27*(px*px)*(x2023.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2024=((1000.0)*pz);
IkReal x2025=(cj28*sj28);
IkReal x2026=(py*sj27);
IkReal x2027=((3.11526479750779)*sj28);
IkReal x2028=(cj27*px);
CheckValue<IkReal> x2029=IKPowWithIntegerCheck(sj28,-1);
if(!x2029.valid){
continue;
}
if( IKabs((((x2026*x2027))+(((-0.311526479750779)*sj28))+((x2027*x2028))+(((3.11526479750779)*cj28*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00311526479750779)*(x2029.value)*(((((-100.0)*x2025))+((x2024*(cj28*cj28)))+(((-400.0)*sj28))+(((-1.0)*x2024))+(((1000.0)*x2025*x2028))+(((1000.0)*x2025*x2026)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x2026*x2027))+(((-0.311526479750779)*sj28))+((x2027*x2028))+(((3.11526479750779)*cj28*pz))))+IKsqr(((0.00311526479750779)*(x2029.value)*(((((-100.0)*x2025))+((x2024*(cj28*cj28)))+(((-400.0)*sj28))+(((-1.0)*x2024))+(((1000.0)*x2025*x2028))+(((1000.0)*x2025*x2026))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((((x2026*x2027))+(((-0.311526479750779)*sj28))+((x2027*x2028))+(((3.11526479750779)*cj28*pz))), ((0.00311526479750779)*(x2029.value)*(((((-100.0)*x2025))+((x2024*(cj28*cj28)))+(((-400.0)*sj28))+(((-1.0)*x2024))+(((1000.0)*x2025*x2028))+(((1000.0)*x2025*x2026))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2030=IKcos(j30);
IkReal x2031=IKsin(j30);
IkReal x2032=(cj27*px);
IkReal x2033=((1.0)*sj28);
IkReal x2034=((0.25)*sj27);
IkReal x2035=(py*sj27);
IkReal x2036=((0.321)*x2030);
IkReal x2037=((0.321)*x2031);
evalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x2037))+pz+((sj28*x2036)));
evalcond[1]=((0.253041)+(((0.2568)*x2030))+(((-1.0)*pp))+(((0.2)*x2035))+(((0.2)*x2032)));
CheckValue<IkReal> x2038=IKPowWithIntegerCheck(py,-1);
if(!x2038.valid){
continue;
}
evalcond[2]=((0.31630125)+(((-1.25)*pp))+x2036+((py*x2034))+((x2034*(px*px)*(x2038.value))));
evalcond[3]=(x2037+(((0.1)*sj28))+(((-1.0)*x2032*x2033))+(((-1.0)*cj28*pz))+(((-1.0)*x2033*x2035)));
evalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x2036))+(((-1.0)*x2032))+(((-1.0)*x2035))+((sj28*x2037)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2039=((250.0)*sj28);
IkReal x2040=(py*sj27);
IkReal x2041=(cj27*px);
CheckValue<IkReal> x2042=IKPowWithIntegerCheck(cj28,-1);
if(!x2042.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2042.value)*(((((1250.0)*pp*sj28))+(((-1.0)*x2039*x2041))+(((-1.0)*x2039*x2040))+(((83.69875)*sj28))+(((1000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2040))+(((-0.778816199376947)*x2041)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2042.value)*(((((1250.0)*pp*sj28))+(((-1.0)*x2039*x2041))+(((-1.0)*x2039*x2040))+(((83.69875)*sj28))+(((1000.0)*pz))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2040))+(((-0.778816199376947)*x2041))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2042.value)*(((((1250.0)*pp*sj28))+(((-1.0)*x2039*x2041))+(((-1.0)*x2039*x2040))+(((83.69875)*sj28))+(((1000.0)*pz))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2040))+(((-0.778816199376947)*x2041))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2043=IKcos(j30);
IkReal x2044=IKsin(j30);
IkReal x2045=(cj27*px);
IkReal x2046=((1.0)*sj28);
IkReal x2047=((0.25)*sj27);
IkReal x2048=(py*sj27);
IkReal x2049=((0.321)*x2043);
IkReal x2050=((0.321)*x2044);
evalcond[0]=((((0.4)*sj28))+((sj28*x2049))+(((-1.0)*cj28*x2050))+pz);
evalcond[1]=((0.253041)+(((0.2)*x2048))+(((0.2)*x2045))+(((0.2568)*x2043))+(((-1.0)*pp)));
CheckValue<IkReal> x2051=IKPowWithIntegerCheck(py,-1);
if(!x2051.valid){
continue;
}
evalcond[2]=((0.31630125)+(((-1.25)*pp))+x2049+((x2047*(px*px)*(x2051.value)))+((py*x2047)));
evalcond[3]=(x2050+(((-1.0)*x2045*x2046))+(((0.1)*sj28))+(((-1.0)*cj28*pz))+(((-1.0)*x2046*x2048)));
evalcond[4]=((0.1)+(((0.4)*cj28))+(((-1.0)*x2045))+(((-1.0)*x2048))+((sj28*x2050))+((cj28*x2049)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2052=((1000.0)*cj28);
IkReal x2053=(py*sj27);
IkReal x2054=((1000.0)*sj28);
IkReal x2055=(cj27*px);
CheckValue<IkReal> x2056 = IKatan2WithCheck((gconst48*((((x2053*x2054))+(((-100.0)*sj28))+((x2054*x2055))+((pz*x2052))))),(gconst48*(((((-400.0)*(sj28*sj28)))+((x2052*x2055))+((x2052*x2053))+(((-400.0)*(cj28*cj28)))+(((-1.0)*pz*x2054))+(((-100.0)*cj28))))),IKFAST_ATAN2_MAGTHRESH);
if(!x2056.valid){
continue;
}
j30array[0]=x2056.value;
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2057=IKcos(j30);
IkReal x2058=IKsin(j30);
IkReal x2059=(cj27*px);
IkReal x2060=((1.0)*sj28);
IkReal x2061=((0.25)*sj27);
IkReal x2062=(py*sj27);
IkReal x2063=((0.321)*x2057);
IkReal x2064=((0.321)*x2058);
evalcond[0]=((((0.4)*sj28))+((sj28*x2063))+(((-1.0)*cj28*x2064))+pz);
evalcond[1]=((0.253041)+(((0.2568)*x2057))+(((-1.0)*pp))+(((0.2)*x2059))+(((0.2)*x2062)));
CheckValue<IkReal> x2065=IKPowWithIntegerCheck(py,-1);
if(!x2065.valid){
continue;
}
evalcond[2]=((0.31630125)+(((-1.25)*pp))+x2063+((x2061*(px*px)*(x2065.value)))+((py*x2061)));
evalcond[3]=(x2064+(((0.1)*sj28))+(((-1.0)*x2059*x2060))+(((-1.0)*cj28*pz))+(((-1.0)*x2060*x2062)));
evalcond[4]=((0.1)+((sj28*x2064))+(((0.4)*cj28))+(((-1.0)*x2062))+(((-1.0)*x2059))+((cj28*x2063)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2066=(cj27*px);
IkReal x2067=((1.0)*py);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j28), 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*x2066)));
evalcond[2]=((((-1.0)*sj29*x2066))+((cj29*px*sj27))+(((-1.0)*sj27*sj29*x2067))+(((0.1)*sj29))+(((-1.0)*cj27*cj29*x2067)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2068=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x2068))+pz);
evalcond[1]=((0.32)+(((0.2568)*x2068))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2069=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x2069))+pz);
evalcond[1]=((0.32)+(((0.2568)*x2069))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2070=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x2070))+pz);
evalcond[1]=((0.32)+(((0.2568)*x2070))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2071=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x2071))+pz);
evalcond[1]=((0.32)+(((0.2568)*x2071))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2072=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x2072))+pz);
evalcond[1]=((0.32)+(((0.2568)*x2072))+(((0.8)*pz)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2073=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x2073))+pz);
evalcond[1]=((0.32)+(((0.2568)*x2073))+(((0.8)*pz)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x2074=IKPowWithIntegerCheck(cj29,-1);
if(!x2074.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2074.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2074.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2074.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2075=IKcos(j30);
IkReal x2076=IKsin(j30);
IkReal x2077=((1.0)*py);
IkReal x2078=(cj27*px);
IkReal x2079=(px*sj27);
IkReal x2080=((0.321)*x2076);
evalcond[0]=((0.4)+(((0.321)*x2075))+pz);
evalcond[1]=((0.32)+(((0.2568)*x2075))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*x2077))+x2079+((sj29*x2080)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x2077))+(((-1.0)*x2078))+(((-1.0)*cj29*x2080)));
evalcond[4]=(((cj29*py*sj27))+((sj29*x2079))+x2080+(((-1.0)*cj27*sj29*x2077))+(((-0.1)*cj29))+((cj29*x2078)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x2081=IKPowWithIntegerCheck(sj29,-1);
if(!x2081.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2081.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2081.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2081.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2082=IKcos(j30);
IkReal x2083=IKsin(j30);
IkReal x2084=((1.0)*py);
IkReal x2085=(cj27*px);
IkReal x2086=(px*sj27);
IkReal x2087=((0.321)*x2083);
evalcond[0]=((0.4)+(((0.321)*x2082))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x2082)));
evalcond[2]=(x2086+((sj29*x2087))+(((-1.0)*cj27*x2084)));
evalcond[3]=((0.1)+(((-1.0)*x2085))+(((-1.0)*sj27*x2084))+(((-1.0)*cj29*x2087)));
evalcond[4]=(((cj29*py*sj27))+(((-1.0)*cj27*sj29*x2084))+x2087+((sj29*x2086))+((cj29*x2085))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x2088=IKPowWithIntegerCheck(sj29,-1);
if(!x2088.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2088.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2088.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2088.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2089=IKcos(j30);
IkReal x2090=IKsin(j30);
IkReal x2091=((1.0)*py);
IkReal x2092=(cj27*px);
IkReal x2093=(px*sj27);
IkReal x2094=((0.321)*x2090);
evalcond[0]=((0.4)+(((0.321)*x2089))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x2089)));
evalcond[2]=(x2093+((sj29*x2094))+(((-1.0)*cj27*x2091)));
evalcond[3]=((0.1)+(((-1.0)*cj29*x2094))+(((-1.0)*x2092))+(((-1.0)*sj27*x2091)));
evalcond[4]=(((cj29*py*sj27))+(((-1.0)*cj27*sj29*x2091))+x2094+((cj29*x2092))+((sj29*x2093))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2095=(py*sj27);
IkReal x2096=(cj27*px);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j28), 6.28318530717959))))));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x2095))+(((0.2)*x2096)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((sj29*x2095))+((sj29*x2096))+(((-0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj29;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2097=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x2097))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2097)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2098=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x2098))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2098)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2099=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x2099))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2099)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2100=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x2100))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2100)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2101=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x2101))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2101)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x2102=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x2102))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2102)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x2103=IKPowWithIntegerCheck(cj29,-1);
if(!x2103.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2103.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2103.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2103.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2104=IKcos(j30);
IkReal x2105=IKsin(j30);
IkReal x2106=((1.0)*py);
IkReal x2107=(px*sj27);
IkReal x2108=((1.0)*cj27*px);
IkReal x2109=((0.321)*x2105);
evalcond[0]=((-0.4)+(((-0.321)*x2104))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2104)));
evalcond[2]=(x2107+((sj29*x2109))+(((-1.0)*cj27*x2106)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x2106))+(((-1.0)*x2108))+((cj29*x2109)));
evalcond[4]=((((-1.0)*cj29*x2108))+(((-1.0)*cj27*sj29*x2106))+x2109+(((-1.0)*cj29*sj27*x2106))+((sj29*x2107))+(((0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x2110=IKPowWithIntegerCheck(sj29,-1);
if(!x2110.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2110.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2110.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2110.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2111=IKcos(j30);
IkReal x2112=IKsin(j30);
IkReal x2113=((1.0)*py);
IkReal x2114=(px*sj27);
IkReal x2115=((1.0)*cj27*px);
IkReal x2116=((0.321)*x2112);
evalcond[0]=((-0.4)+(((-0.321)*x2111))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2111)));
evalcond[2]=((((-1.0)*cj27*x2113))+x2114+((sj29*x2116)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x2113))+(((-1.0)*x2115))+((cj29*x2116)));
evalcond[4]=((((-1.0)*cj29*x2115))+x2116+(((0.1)*cj29))+(((-1.0)*cj27*sj29*x2113))+(((-1.0)*cj29*sj27*x2113))+((sj29*x2114)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x2117=IKPowWithIntegerCheck(sj29,-1);
if(!x2117.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2117.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2117.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2117.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2118=IKcos(j30);
IkReal x2119=IKsin(j30);
IkReal x2120=((1.0)*py);
IkReal x2121=(px*sj27);
IkReal x2122=((1.0)*cj27*px);
IkReal x2123=((0.321)*x2119);
evalcond[0]=((-0.4)+(((-0.321)*x2118))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x2118)));
evalcond[2]=((((-1.0)*cj27*x2120))+((sj29*x2123))+x2121);
evalcond[3]=((0.1)+(((-1.0)*x2122))+(((-1.0)*sj27*x2120))+((cj29*x2123)));
evalcond[4]=(((sj29*x2121))+x2123+(((-1.0)*cj27*sj29*x2120))+(((0.1)*cj29))+(((-1.0)*cj29*x2122))+(((-1.0)*cj29*sj27*x2120)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2124=(cj27*px);
IkReal x2125=((0.8)*cj28);
IkReal x2126=(py*sj27);
IkReal x2127=((1.0)*sj28);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=((-0.066959)+((x2125*x2126))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x2124))+(((0.2)*x2126))+((x2124*x2125))+(((-0.8)*pz*sj28)));
evalcond[2]=((((0.1)*sj28))+(((-1.0)*x2124*x2127))+(((-1.0)*cj28*pz))+(((-1.0)*x2126*x2127)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2128=IKcos(j30);
IkReal x2129=((1.0)*py);
IkReal x2130=(cj27*px);
IkReal x2131=((0.321)*x2128);
evalcond[0]=((((0.4)*sj28))+pz+((sj28*x2131)));
evalcond[1]=((((-1.0)*cj27*x2129))+((px*sj27))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2)*x2130))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2568)*x2128)));
evalcond[3]=((0.1)+(((0.4)*cj28))+((cj28*x2131))+(((-1.0)*sj27*x2129))+(((-1.0)*x2130)));
evalcond[4]=((0.4)+(((-1.0)*cj28*x2130))+x2131+(((0.1)*cj28))+((pz*sj28))+(((-1.0)*cj28*sj27*x2129)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2132=(cj27*px);
IkReal x2133=((0.8)*cj28);
IkReal x2134=(py*sj27);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((-0.066959)+(((0.2)*x2134))+(((0.2)*x2132))+(((-0.08)*cj28))+(((-1.0)*pp))+((x2132*x2133))+((x2133*x2134))+(((-0.8)*pz*sj28)));
evalcond[2]=(((cj28*pz))+((sj28*x2134))+((sj28*x2132))+(((-0.1)*sj28)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2135=IKcos(j30);
IkReal x2136=((1.0)*py);
IkReal x2137=(cj27*px);
IkReal x2138=((0.321)*x2135);
evalcond[0]=((((0.4)*sj28))+pz+((sj28*x2138)));
evalcond[1]=((((-0.321)*(IKsin(j30))))+((px*sj27))+(((-1.0)*cj27*x2136)));
evalcond[2]=((0.253041)+(((0.2)*x2137))+(((-1.0)*pp))+(((0.2568)*x2135))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x2136))+(((0.4)*cj28))+((cj28*x2138))+(((-1.0)*x2137)));
evalcond[4]=((0.4)+(((-1.0)*cj28*x2137))+x2138+(((0.1)*cj28))+(((-1.0)*cj28*sj27*x2136))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2139=(cj27*px);
IkReal x2140=((0.8)*cj28);
IkReal x2141=(py*sj27);
IkReal x2142=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j29), 6.28318530717959))))));
evalcond[1]=x2142;
evalcond[2]=((-0.066959)+(((0.2)*x2139))+(((-0.08)*cj28))+(((-1.0)*pp))+((x2140*x2141))+(((-0.8)*pz*sj28))+(((0.2)*x2141))+((x2139*x2140)));
evalcond[3]=x2142;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst49;
gconst49=IKsign(((((321.0)*(cj28*cj28)))+(((321.0)*(sj28*sj28)))));
dummyeval[0]=((cj28*cj28)+(sj28*sj28));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2143=IKcos(j30);
IkReal x2144=(py*sj27);
IkReal x2145=(cj27*px);
IkReal x2146=((0.321)*x2143);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.5)+(((-1.0)*x2144))+(((-1.0)*x2145))+x2146);
evalcond[2]=((0.253041)+(((0.2568)*x2143))+(((-1.0)*pp))+(((0.2)*x2144))+(((0.2)*x2145)));
CheckValue<IkReal> x2147=IKPowWithIntegerCheck(py,-1);
if(!x2147.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x2146+(((0.25)*x2144))+(((0.25)*sj27*(px*px)*(x2147.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2148=IKcos(j30);
IkReal x2149=(py*sj27);
IkReal x2150=(cj27*px);
IkReal x2151=((0.321)*x2148);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((-0.3)+(((-1.0)*x2149))+(((-1.0)*x2151))+(((-1.0)*x2150)));
evalcond[2]=((0.253041)+(((0.2)*x2150))+(((0.2568)*x2148))+(((-1.0)*pp))+(((0.2)*x2149)));
CheckValue<IkReal> x2152=IKPowWithIntegerCheck(py,-1);
if(!x2152.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x2151+(((0.25)*x2149))+(((0.25)*sj27*(px*px)*(x2152.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j28), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2153=IKcos(j30);
IkReal x2154=(py*sj27);
IkReal x2155=(cj27*px);
IkReal x2156=((0.321)*x2153);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.5)+x2156+(((-1.0)*x2154))+(((-1.0)*x2155)));
evalcond[2]=((0.253041)+(((0.2)*x2154))+(((0.2)*x2155))+(((0.2568)*x2153))+(((-1.0)*pp)));
CheckValue<IkReal> x2157=IKPowWithIntegerCheck(py,-1);
if(!x2157.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x2156+(((0.25)*x2154))+(((0.25)*sj27*(px*px)*(x2157.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j28, 6.28318530717959)))))+(IKabs(j12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2158=IKcos(j30);
IkReal x2159=(py*sj27);
IkReal x2160=(cj27*px);
IkReal x2161=((0.321)*x2158);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((-0.3)+(((-1.0)*x2161))+(((-1.0)*x2160))+(((-1.0)*x2159)));
evalcond[2]=((0.253041)+(((0.2)*x2159))+(((0.2568)*x2158))+(((-1.0)*pp))+(((0.2)*x2160)));
CheckValue<IkReal> x2162=IKPowWithIntegerCheck(py,-1);
if(!x2162.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+x2161+(((0.25)*x2159))+(((0.25)*sj27*(px*px)*(x2162.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2163=((1000.0)*pz);
IkReal x2164=(cj28*sj28);
IkReal x2165=(py*sj27);
IkReal x2166=((3.11526479750779)*sj28);
IkReal x2167=(cj27*px);
CheckValue<IkReal> x2168=IKPowWithIntegerCheck(sj28,-1);
if(!x2168.valid){
continue;
}
if( IKabs(((((-1.0)*x2166*x2167))+(((-3.11526479750779)*cj28*pz))+(((-1.0)*x2165*x2166))+(((0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00311526479750779)*(x2168.value)*((((x2163*(cj28*cj28)))+(((-100.0)*x2164))+(((-400.0)*sj28))+(((1000.0)*x2164*x2167))+(((1000.0)*x2164*x2165))+(((-1.0)*x2163)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x2166*x2167))+(((-3.11526479750779)*cj28*pz))+(((-1.0)*x2165*x2166))+(((0.311526479750779)*sj28))))+IKsqr(((0.00311526479750779)*(x2168.value)*((((x2163*(cj28*cj28)))+(((-100.0)*x2164))+(((-400.0)*sj28))+(((1000.0)*x2164*x2167))+(((1000.0)*x2164*x2165))+(((-1.0)*x2163))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-1.0)*x2166*x2167))+(((-3.11526479750779)*cj28*pz))+(((-1.0)*x2165*x2166))+(((0.311526479750779)*sj28))), ((0.00311526479750779)*(x2168.value)*((((x2163*(cj28*cj28)))+(((-100.0)*x2164))+(((-400.0)*sj28))+(((1000.0)*x2164*x2167))+(((1000.0)*x2164*x2165))+(((-1.0)*x2163))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2169=IKcos(j30);
IkReal x2170=IKsin(j30);
IkReal x2171=(py*sj27);
IkReal x2172=(cj27*px);
IkReal x2173=((0.321)*x2169);
IkReal x2174=((0.321)*x2170);
evalcond[0]=((((0.4)*sj28))+((cj28*x2174))+pz+((sj28*x2173)));
evalcond[1]=((0.253041)+(((0.2)*x2171))+(((0.2)*x2172))+(((-1.0)*pp))+(((0.2568)*x2169)));
evalcond[2]=(x2174+((cj28*pz))+(((-0.1)*sj28))+((sj28*x2172))+((sj28*x2171)));
CheckValue<IkReal> x2175=IKPowWithIntegerCheck(py,-1);
if(!x2175.valid){
continue;
}
evalcond[3]=((0.31630125)+(((0.25)*x2171))+(((-1.25)*pp))+x2173+(((0.25)*sj27*(px*px)*(x2175.value))));
evalcond[4]=((0.1)+((cj28*x2173))+(((-1.0)*sj28*x2174))+(((0.4)*cj28))+(((-1.0)*x2171))+(((-1.0)*x2172)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2176=((250.0)*sj28);
IkReal x2177=(py*sj27);
IkReal x2178=(cj27*px);
CheckValue<IkReal> x2179=IKPowWithIntegerCheck(cj28,-1);
if(!x2179.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2179.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x2176*x2177))+((x2176*x2178))+(((-1250.0)*pp*sj28)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x2178))+(((-0.778816199376947)*x2177))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2179.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x2176*x2177))+((x2176*x2178))+(((-1250.0)*pp*sj28))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x2178))+(((-0.778816199376947)*x2177))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2179.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x2176*x2177))+((x2176*x2178))+(((-1250.0)*pp*sj28))))), ((-0.98536214953271)+(((-0.778816199376947)*x2178))+(((-0.778816199376947)*x2177))+(((3.89408099688474)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2180=IKcos(j30);
IkReal x2181=IKsin(j30);
IkReal x2182=(py*sj27);
IkReal x2183=(cj27*px);
IkReal x2184=((0.321)*x2180);
IkReal x2185=((0.321)*x2181);
evalcond[0]=((((0.4)*sj28))+((sj28*x2184))+pz+((cj28*x2185)));
evalcond[1]=((0.253041)+(((0.2568)*x2180))+(((-1.0)*pp))+(((0.2)*x2183))+(((0.2)*x2182)));
evalcond[2]=(((sj28*x2183))+((sj28*x2182))+x2185+((cj28*pz))+(((-0.1)*sj28)));
CheckValue<IkReal> x2186=IKPowWithIntegerCheck(py,-1);
if(!x2186.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x2182))+x2184+(((0.25)*sj27*(px*px)*(x2186.value))));
evalcond[4]=((0.1)+(((-1.0)*sj28*x2185))+(((0.4)*cj28))+(((-1.0)*x2183))+(((-1.0)*x2182))+((cj28*x2184)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2187=((1000.0)*cj28);
IkReal x2188=(py*sj27);
IkReal x2189=((1000.0)*sj28);
IkReal x2190=(cj27*px);
CheckValue<IkReal> x2191 = IKatan2WithCheck((gconst49*(((((-1.0)*x2189*x2190))+(((-1.0)*x2188*x2189))+(((-1.0)*pz*x2187))+(((100.0)*sj28))))),(gconst49*(((((-400.0)*(sj28*sj28)))+(((-400.0)*(cj28*cj28)))+((x2187*x2190))+(((-1.0)*pz*x2189))+((x2187*x2188))+(((-100.0)*cj28))))),IKFAST_ATAN2_MAGTHRESH);
if(!x2191.valid){
continue;
}
j30array[0]=x2191.value;
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2192=IKcos(j30);
IkReal x2193=IKsin(j30);
IkReal x2194=(py*sj27);
IkReal x2195=(cj27*px);
IkReal x2196=((0.321)*x2192);
IkReal x2197=((0.321)*x2193);
evalcond[0]=((((0.4)*sj28))+((sj28*x2196))+pz+((cj28*x2197)));
evalcond[1]=((0.253041)+(((0.2568)*x2192))+(((-1.0)*pp))+(((0.2)*x2194))+(((0.2)*x2195)));
evalcond[2]=(((sj28*x2194))+((sj28*x2195))+x2197+((cj28*pz))+(((-0.1)*sj28)));
CheckValue<IkReal> x2198=IKPowWithIntegerCheck(py,-1);
if(!x2198.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x2194))+x2196+(((0.25)*sj27*(px*px)*(x2198.value))));
evalcond[4]=((0.1)+(((-1.0)*sj28*x2197))+(((0.4)*cj28))+(((-1.0)*x2195))+(((-1.0)*x2194))+((cj28*x2196)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x2199=(cj27*px);
IkReal x2200=((0.8)*cj28);
IkReal x2201=(cj27*py);
IkReal x2202=(px*sj27);
IkReal x2203=(py*sj27);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j29, 6.28318530717959))))));
evalcond[1]=((((-1.0)*x2201))+x2202);
evalcond[2]=((-0.066959)+((x2200*x2203))+(((-0.08)*cj28))+(((-1.0)*pp))+((x2199*x2200))+(((0.2)*x2199))+(((0.2)*x2203))+(((-0.8)*pz*sj28)));
evalcond[3]=((((-1.0)*x2202))+x2201);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst50;
gconst50=IKsign(((((321.0)*(cj28*cj28)))+(((321.0)*(sj28*sj28)))));
dummyeval[0]=((cj28*cj28)+(sj28*sj28));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj28;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2204=IKcos(j30);
IkReal x2205=(py*sj27);
IkReal x2206=(cj27*px);
IkReal x2207=((0.321)*x2204);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.5)+(((-1.0)*x2205))+(((-1.0)*x2206))+x2207);
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x2204))+(((0.2)*x2206))+(((0.2)*x2205)));
CheckValue<IkReal> x2208=IKPowWithIntegerCheck(py,-1);
if(!x2208.valid){
continue;
}
evalcond[3]=((0.31630125)+x2207+(((-1.25)*pp))+(((0.25)*x2205))+(((0.25)*sj27*(px*px)*(x2208.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2209=IKcos(j30);
IkReal x2210=(py*sj27);
IkReal x2211=(cj27*px);
IkReal x2212=((0.321)*x2209);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((-0.3)+(((-1.0)*x2211))+(((-1.0)*x2210))+(((-1.0)*x2212)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x2209))+(((0.2)*x2211))+(((0.2)*x2210)));
CheckValue<IkReal> x2213=IKPowWithIntegerCheck(py,-1);
if(!x2213.valid){
continue;
}
evalcond[3]=((0.31630125)+x2212+(((-1.25)*pp))+(((0.25)*x2210))+(((0.25)*sj27*(px*px)*(x2213.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j28), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2214=IKcos(j30);
IkReal x2215=(py*sj27);
IkReal x2216=(cj27*px);
IkReal x2217=((0.321)*x2214);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.5)+(((-1.0)*x2216))+(((-1.0)*x2215))+x2217);
evalcond[2]=((0.253041)+(((0.2568)*x2214))+(((-1.0)*pp))+(((0.2)*x2215))+(((0.2)*x2216)));
CheckValue<IkReal> x2218=IKPowWithIntegerCheck(py,-1);
if(!x2218.valid){
continue;
}
evalcond[3]=((0.31630125)+x2217+(((-1.25)*pp))+(((0.25)*x2215))+(((0.25)*sj27*(px*px)*(x2218.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j28, 6.28318530717959)))))+(IKabs(j12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[4];
IkReal x2219=IKcos(j30);
IkReal x2220=(py*sj27);
IkReal x2221=(cj27*px);
IkReal x2222=((0.321)*x2219);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((-0.3)+(((-1.0)*x2220))+(((-1.0)*x2221))+(((-1.0)*x2222)));
evalcond[2]=((0.253041)+(((0.2568)*x2219))+(((-1.0)*pp))+(((0.2)*x2220))+(((0.2)*x2221)));
CheckValue<IkReal> x2223=IKPowWithIntegerCheck(py,-1);
if(!x2223.valid){
continue;
}
evalcond[3]=((0.31630125)+x2222+(((0.25)*x2220))+(((-1.25)*pp))+(((0.25)*sj27*(px*px)*(x2223.value))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2224=((1000.0)*pz);
IkReal x2225=(cj28*sj28);
IkReal x2226=(py*sj27);
IkReal x2227=((3.11526479750779)*sj28);
IkReal x2228=(cj27*px);
CheckValue<IkReal> x2229=IKPowWithIntegerCheck(sj28,-1);
if(!x2229.valid){
continue;
}
if( IKabs((((x2226*x2227))+((x2227*x2228))+(((-0.311526479750779)*sj28))+(((3.11526479750779)*cj28*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.00311526479750779)*(x2229.value)*((((x2224*(cj28*cj28)))+(((1000.0)*x2225*x2228))+(((1000.0)*x2225*x2226))+(((-100.0)*x2225))+(((-1.0)*x2224))+(((-400.0)*sj28)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x2226*x2227))+((x2227*x2228))+(((-0.311526479750779)*sj28))+(((3.11526479750779)*cj28*pz))))+IKsqr(((0.00311526479750779)*(x2229.value)*((((x2224*(cj28*cj28)))+(((1000.0)*x2225*x2228))+(((1000.0)*x2225*x2226))+(((-100.0)*x2225))+(((-1.0)*x2224))+(((-400.0)*sj28))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((((x2226*x2227))+((x2227*x2228))+(((-0.311526479750779)*sj28))+(((3.11526479750779)*cj28*pz))), ((0.00311526479750779)*(x2229.value)*((((x2224*(cj28*cj28)))+(((1000.0)*x2225*x2228))+(((1000.0)*x2225*x2226))+(((-100.0)*x2225))+(((-1.0)*x2224))+(((-400.0)*sj28))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2230=IKcos(j30);
IkReal x2231=IKsin(j30);
IkReal x2232=(cj27*px);
IkReal x2233=((1.0)*sj28);
IkReal x2234=((0.25)*sj27);
IkReal x2235=(py*sj27);
IkReal x2236=((0.321)*x2230);
IkReal x2237=((0.321)*x2231);
evalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x2237))+((sj28*x2236))+pz);
evalcond[1]=((0.253041)+(((0.2568)*x2230))+(((0.2)*x2235))+(((0.2)*x2232))+(((-1.0)*pp)));
CheckValue<IkReal> x2238=IKPowWithIntegerCheck(py,-1);
if(!x2238.valid){
continue;
}
evalcond[2]=((0.31630125)+((py*x2234))+x2236+(((-1.25)*pp))+((x2234*(px*px)*(x2238.value))));
evalcond[3]=(x2237+(((-1.0)*x2232*x2233))+(((0.1)*sj28))+(((-1.0)*x2233*x2235))+(((-1.0)*cj28*pz)));
evalcond[4]=((0.1)+(((0.4)*cj28))+((sj28*x2237))+(((-1.0)*x2232))+(((-1.0)*x2235))+((cj28*x2236)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2239=((250.0)*sj28);
IkReal x2240=(py*sj27);
IkReal x2241=(cj27*px);
CheckValue<IkReal> x2242=IKPowWithIntegerCheck(cj28,-1);
if(!x2242.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2242.value)*(((((1250.0)*pp*sj28))+(((83.69875)*sj28))+(((-1.0)*x2239*x2240))+(((-1.0)*x2239*x2241))+(((1000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2240))+(((-0.778816199376947)*x2241)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2242.value)*(((((1250.0)*pp*sj28))+(((83.69875)*sj28))+(((-1.0)*x2239*x2240))+(((-1.0)*x2239*x2241))+(((1000.0)*pz))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2240))+(((-0.778816199376947)*x2241))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2242.value)*(((((1250.0)*pp*sj28))+(((83.69875)*sj28))+(((-1.0)*x2239*x2240))+(((-1.0)*x2239*x2241))+(((1000.0)*pz))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2240))+(((-0.778816199376947)*x2241))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2243=IKcos(j30);
IkReal x2244=IKsin(j30);
IkReal x2245=(cj27*px);
IkReal x2246=((1.0)*sj28);
IkReal x2247=((0.25)*sj27);
IkReal x2248=(py*sj27);
IkReal x2249=((0.321)*x2243);
IkReal x2250=((0.321)*x2244);
evalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x2250))+pz+((sj28*x2249)));
evalcond[1]=((0.253041)+(((0.2568)*x2243))+(((-1.0)*pp))+(((0.2)*x2248))+(((0.2)*x2245)));
CheckValue<IkReal> x2251=IKPowWithIntegerCheck(py,-1);
if(!x2251.valid){
continue;
}
evalcond[2]=((0.31630125)+x2249+(((-1.25)*pp))+((x2247*(px*px)*(x2251.value)))+((py*x2247)));
evalcond[3]=(x2250+(((0.1)*sj28))+(((-1.0)*x2246*x2248))+(((-1.0)*cj28*pz))+(((-1.0)*x2245*x2246)));
evalcond[4]=((0.1)+(((-1.0)*x2245))+(((-1.0)*x2248))+(((0.4)*cj28))+((sj28*x2250))+((cj28*x2249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2252=((1000.0)*cj28);
IkReal x2253=(py*sj27);
IkReal x2254=((1000.0)*sj28);
IkReal x2255=(cj27*px);
CheckValue<IkReal> x2256 = IKatan2WithCheck((gconst50*(((((-100.0)*sj28))+((x2254*x2255))+((x2253*x2254))+((pz*x2252))))),(gconst50*(((((-400.0)*(sj28*sj28)))+(((-400.0)*(cj28*cj28)))+(((-1.0)*pz*x2254))+((x2252*x2253))+((x2252*x2255))+(((-100.0)*cj28))))),IKFAST_ATAN2_MAGTHRESH);
if(!x2256.valid){
continue;
}
j30array[0]=x2256.value;
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x2257=IKcos(j30);
IkReal x2258=IKsin(j30);
IkReal x2259=(cj27*px);
IkReal x2260=((1.0)*sj28);
IkReal x2261=((0.25)*sj27);
IkReal x2262=(py*sj27);
IkReal x2263=((0.321)*x2257);
IkReal x2264=((0.321)*x2258);
evalcond[0]=((((0.4)*sj28))+((sj28*x2263))+(((-1.0)*cj28*x2264))+pz);
evalcond[1]=((0.253041)+(((0.2)*x2262))+(((-1.0)*pp))+(((0.2568)*x2257))+(((0.2)*x2259)));
CheckValue<IkReal> x2265=IKPowWithIntegerCheck(py,-1);
if(!x2265.valid){
continue;
}
evalcond[2]=((0.31630125)+x2263+(((-1.25)*pp))+((x2261*(px*px)*(x2265.value)))+((py*x2261)));
evalcond[3]=(x2264+(((-1.0)*x2260*x2262))+(((-1.0)*x2259*x2260))+(((0.1)*sj28))+(((-1.0)*cj28*pz)));
evalcond[4]=((0.1)+((sj28*x2264))+(((-1.0)*x2259))+(((0.4)*cj28))+((cj28*x2263))+(((-1.0)*x2262)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2266=((250.0)*sj28);
IkReal x2267=(py*sj27);
IkReal x2268=(cj27*px);
CheckValue<IkReal> x2269=IKPowWithIntegerCheck(cj28,-1);
if(!x2269.valid){
continue;
}
CheckValue<IkReal> x2270=IKPowWithIntegerCheck(cj29,-1);
if(!x2270.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2269.value)*(x2270.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x2266*x2267))+((x2266*x2268)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2268))+(((-0.778816199376947)*x2267)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2269.value)*(x2270.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x2266*x2267))+((x2266*x2268))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2268))+(((-0.778816199376947)*x2267))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2269.value)*(x2270.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x2266*x2267))+((x2266*x2268))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x2268))+(((-0.778816199376947)*x2267))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x2271=IKsin(j30);
IkReal x2272=IKcos(j30);
IkReal x2273=((1.0)*py);
IkReal x2274=(cj29*sj28);
IkReal x2275=(cj27*px);
IkReal x2276=(cj28*cj29);
IkReal x2277=(py*sj27);
IkReal x2278=(px*sj27);
IkReal x2279=((0.321)*x2271);
IkReal x2280=((0.321)*x2272);
evalcond[0]=(((sj29*x2279))+x2278+(((-1.0)*cj27*x2273)));
evalcond[1]=((0.253041)+(((0.2)*x2275))+(((0.2)*x2277))+(((-1.0)*pp))+(((0.2568)*x2272)));
evalcond[2]=((((0.4)*sj28))+((x2276*x2279))+((sj28*x2280))+pz);
evalcond[3]=((0.4)+x2280+(((-1.0)*cj28*x2275))+(((-1.0)*cj28*sj27*x2273))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*x2274*x2279))+(((0.4)*cj28))+((cj28*x2280))+(((-1.0)*sj27*x2273))+(((-1.0)*x2275)));
evalcond[5]=(((sj29*x2278))+x2279+((pz*x2276))+(((-1.0)*cj27*sj29*x2273))+((x2274*x2275))+((x2274*x2277))+(((-0.1)*x2274)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x2281=((3.11526479750779)*cj28);
CheckValue<IkReal> x2282=IKPowWithIntegerCheck(sj29,-1);
if(!x2282.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2282.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-3.11526479750779)*pz*sj28))+((py*sj27*x2281))+((cj27*px*x2281)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2282.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-3.11526479750779)*pz*sj28))+((py*sj27*x2281))+((cj27*px*x2281))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2282.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-3.11526479750779)*pz*sj28))+((py*sj27*x2281))+((cj27*px*x2281))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x2283=IKsin(j30);
IkReal x2284=IKcos(j30);
IkReal x2285=((1.0)*py);
IkReal x2286=(cj29*sj28);
IkReal x2287=(cj27*px);
IkReal x2288=(cj28*cj29);
IkReal x2289=(py*sj27);
IkReal x2290=(px*sj27);
IkReal x2291=((0.321)*x2283);
IkReal x2292=((0.321)*x2284);
evalcond[0]=(x2290+(((-1.0)*cj27*x2285))+((sj29*x2291)));
evalcond[1]=((0.253041)+(((0.2568)*x2284))+(((-1.0)*pp))+(((0.2)*x2289))+(((0.2)*x2287)));
evalcond[2]=((((0.4)*sj28))+((sj28*x2292))+pz+((x2288*x2291)));
evalcond[3]=((0.4)+(((-1.0)*cj28*sj27*x2285))+x2292+(((0.1)*cj28))+(((-1.0)*cj28*x2287))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*sj27*x2285))+(((0.4)*cj28))+(((-1.0)*x2287))+(((-1.0)*x2286*x2291))+((cj28*x2292)));
evalcond[5]=(x2291+(((-1.0)*cj27*sj29*x2285))+((sj29*x2290))+(((-0.1)*x2286))+((pz*x2288))+((x2286*x2287))+((x2286*x2289)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x2293=IKPowWithIntegerCheck(sj29,-1);
if(!x2293.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x2293.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x2293.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x2293.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x2294=IKsin(j30);
IkReal x2295=IKcos(j30);
IkReal x2296=((1.0)*py);
IkReal x2297=(cj29*sj28);
IkReal x2298=(cj27*px);
IkReal x2299=(cj28*cj29);
IkReal x2300=(py*sj27);
IkReal x2301=(px*sj27);
IkReal x2302=((0.321)*x2294);
IkReal x2303=((0.321)*x2295);
evalcond[0]=(x2301+((sj29*x2302))+(((-1.0)*cj27*x2296)));
evalcond[1]=((0.253041)+(((0.2568)*x2295))+(((0.2)*x2300))+(((0.2)*x2298))+(((-1.0)*pp)));
evalcond[2]=((((0.4)*sj28))+((sj28*x2303))+pz+((x2299*x2302)));
evalcond[3]=((0.4)+x2303+(((0.1)*cj28))+(((-1.0)*cj28*x2298))+(((-1.0)*cj28*sj27*x2296))+((pz*sj28)));
evalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x2303))+(((-1.0)*x2297*x2302))+(((-1.0)*x2298))+(((-1.0)*sj27*x2296)));
evalcond[5]=((((-0.1)*x2297))+((pz*x2299))+x2302+((x2297*x2300))+((sj29*x2301))+(((-1.0)*cj27*sj29*x2296))+((x2297*x2298)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x143=(sj27*sj29);
IkReal x144=(cj27*sj29);
IkReal x145=(cj28*sj29);
IkReal x146=(cj28*cj30);
IkReal x147=((1.0)*sj30);
IkReal x148=((1.0)*cj29);
IkReal x149=(cj29*x147);
IkReal x150=((1.0)*cj30*sj28);
IkReal x151=(((sj28*sj30))+(((-1.0)*x146*x148)));
IkReal x152=((((-1.0)*sj27*x148))+((sj28*x144)));
IkReal x153=(((sj28*x143))+((cj27*cj29)));
IkReal x154=(x146+(((-1.0)*sj28*x149)));
IkReal x155=(cj27*x154);
IkReal x156=((((-1.0)*cj30*sj28*x148))+(((-1.0)*cj28*x147)));
IkReal x157=((((-1.0)*x150))+(((-1.0)*cj28*x149)));
IkReal x158=(cj27*x156);
IkReal x159=(((sj27*x154))+((sj30*x144)));
IkReal x160=(x155+(((-1.0)*sj30*x143)));
IkReal x161=(((cj30*x144))+((sj27*x156)));
IkReal x162=((((-1.0)*cj30*x143))+x158);
new_r00=(((r20*x151))+((r00*(((((-1.0)*cj30*x143))+x158))))+((r10*x161)));
new_r01=(((r01*x162))+((r21*x151))+((r11*x161)));
new_r02=(((r12*x161))+((r22*x151))+((r02*x162)));
new_r10=(((r20*x145))+((r00*x152))+((r10*x153)));
new_r11=(((r01*x152))+((r21*x145))+((r11*x153)));
new_r12=(((r02*x152))+((r22*x145))+((r12*x153)));
new_r20=(((r00*x160))+((r20*x157))+((r10*x159)));
new_r21=(((r01*x160))+((r21*x157))+((r11*x159)));
new_r22=(((r02*(((((-1.0)*x143*x147))+x155))))+((r22*x157))+((r12*x159)));
{
IkReal j32array[2], cj32array[2], sj32array[2];
bool j32valid[2]={false};
_nj32 = 2;
cj32array[0]=new_r22;
if( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j32valid[0] = j32valid[1] = true;
    j32array[0] = IKacos(cj32array[0]);
    sj32array[0] = IKsin(j32array[0]);
    cj32array[1] = cj32array[0];
    j32array[1] = -j32array[0];
    sj32array[1] = -sj32array[0];
}
else if( isnan(cj32array[0]) )
{
    // probably any value will work
    j32valid[0] = true;
    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;
}
for(int ij32 = 0; ij32 < 2; ++ij32)
{
if( !j32valid[ij32] )
{
    continue;
}
_ij32[0] = ij32; _ij32[1] = -1;
for(int iij32 = ij32+1; iij32 < 2; ++iij32)
{
if( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )
{
    j32valid[iij32]=false; _ij32[1] = iij32; break; 
}
}
j32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];

{
IkReal dummyeval[1];
IkReal gconst109;
gconst109=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst110;
gconst110=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst111;
gconst111=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x163=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x163;
evalcond[2]=x163;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x163;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
IkReal j33mul = 1;
j33=0;
j31mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].fmul = j31mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].fmul = j33mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x164=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x164;
evalcond[2]=x164;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x166 = IKatan2WithCheck(new_r02,new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x166.valid){
continue;
}
IkReal x165=x166.value;
j31array[0]=((-1.0)*x165);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x165)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst173;
gconst173=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst174;
gconst174=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x167=((1.0)*sj31);
CheckValue<IkReal> x168 = IKatan2WithCheck((gconst174*(((((-1.0)*new_r00*x167))+((cj31*new_r10))))),(gconst174*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x167))))),IKFAST_ATAN2_MAGTHRESH);
if(!x168.valid){
continue;
}
j33array[0]=x168.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x169=IKsin(j33);
IkReal x170=IKcos(j33);
IkReal x171=((1.0)*sj31);
IkReal x172=((1.0)*x169);
IkReal x173=(sj31*x170);
IkReal x174=((1.0)*x170);
IkReal x175=(cj31*x172);
evalcond[0]=(((cj31*new_r00))+x170+((new_r10*sj31)));
evalcond[1]=((((-1.0)*x172))+((cj31*new_r01))+((new_r11*sj31)));
evalcond[2]=(((sj31*x169))+new_r00+((cj31*x170)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x172))+(((-1.0)*new_r00*x171)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x174))+(((-1.0)*new_r01*x171)));
evalcond[5]=((((-1.0)*x175))+x173+new_r01);
evalcond[6]=((((-1.0)*x175))+x173+new_r10);
evalcond[7]=((((-1.0)*cj31*x174))+new_r11+(((-1.0)*x169*x171)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x176=((1.0)*new_r00);
CheckValue<IkReal> x177 = IKatan2WithCheck((gconst173*(((((-1.0)*sj31*x176))+((cj31*new_r01))))),(gconst173*(((((-1.0)*cj31*x176))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x177.valid){
continue;
}
j33array[0]=x177.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x178=IKsin(j33);
IkReal x179=IKcos(j33);
IkReal x180=((1.0)*sj31);
IkReal x181=((1.0)*x178);
IkReal x182=(sj31*x179);
IkReal x183=((1.0)*x179);
IkReal x184=(cj31*x181);
evalcond[0]=(((cj31*new_r00))+x179+((new_r10*sj31)));
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x181))+((new_r11*sj31)));
evalcond[2]=(new_r00+((cj31*x179))+((sj31*x178)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x181))+(((-1.0)*new_r00*x180)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x183))+(((-1.0)*new_r01*x180)));
evalcond[5]=((((-1.0)*x184))+x182+new_r01);
evalcond[6]=((((-1.0)*x184))+x182+new_r10);
evalcond[7]=((((-1.0)*x178*x180))+(((-1.0)*cj31*x183))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x185=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959))))));
evalcond[1]=x185;
evalcond[2]=x185;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x185;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
IkReal j33mul = 1;
j33=0;
j31mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].fmul = j31mul;
vinfos[5].freeind = 0;
vinfos[5].maxsolutions = 0;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].fmul = j33mul;
vinfos[7].freeind = 0;
vinfos[7].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 7;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x186=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959))))));
evalcond[1]=x186;
evalcond[2]=x186;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x188 = IKatan2WithCheck(new_r02,new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x188.valid){
continue;
}
IkReal x187=x188.value;
j31array[0]=((-1.0)*x187);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x187)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst175;
gconst175=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst176;
gconst176=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x189=((1.0)*sj31);
CheckValue<IkReal> x190 = IKatan2WithCheck((gconst176*((((cj31*new_r10))+(((-1.0)*new_r00*x189))))),(gconst176*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x189))))),IKFAST_ATAN2_MAGTHRESH);
if(!x190.valid){
continue;
}
j33array[0]=x190.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x191=IKsin(j33);
IkReal x192=IKcos(j33);
IkReal x193=((1.0)*sj31);
IkReal x194=((1.0)*x191);
IkReal x195=(sj31*x192);
IkReal x196=((1.0)*x192);
IkReal x197=(cj31*x194);
evalcond[0]=(((cj31*new_r00))+x192+((new_r10*sj31)));
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x194))+((new_r11*sj31)));
evalcond[2]=(((sj31*x191))+new_r00+((cj31*x192)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x194))+(((-1.0)*new_r00*x193)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x196))+(((-1.0)*new_r01*x193)));
evalcond[5]=((((-1.0)*x197))+x195+new_r01);
evalcond[6]=((((-1.0)*x197))+x195+new_r10);
evalcond[7]=((((-1.0)*x191*x193))+(((-1.0)*cj31*x196))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x198=((1.0)*new_r00);
CheckValue<IkReal> x199 = IKatan2WithCheck((gconst175*(((((-1.0)*sj31*x198))+((cj31*new_r01))))),(gconst175*(((((-1.0)*cj31*x198))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x199.valid){
continue;
}
j33array[0]=x199.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x200=IKsin(j33);
IkReal x201=IKcos(j33);
IkReal x202=((1.0)*sj31);
IkReal x203=((1.0)*x200);
IkReal x204=(sj31*x201);
IkReal x205=((1.0)*x201);
IkReal x206=(cj31*x203);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x201);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x203)));
evalcond[2]=(new_r00+((sj31*x200))+((cj31*x201)));
evalcond[3]=((((-1.0)*new_r00*x202))+((cj31*new_r10))+(((-1.0)*x203)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x205))+(((-1.0)*new_r01*x202)));
evalcond[5]=((((-1.0)*x206))+x204+new_r01);
evalcond[6]=((((-1.0)*x206))+x204+new_r10);
evalcond[7]=((((-1.0)*x200*x202))+(((-1.0)*cj31*x205))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x207 = IKatan2WithCheck((gconst111*new_r21),((-1.0)*gconst111*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x207.valid){
continue;
}
j33array[0]=x207.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[2];
evalcond[0]=(((sj32*(IKcos(j33))))+new_r20);
evalcond[1]=((((-1.0)*sj32*(IKsin(j33))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst112;
gconst112=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst113;
gconst113=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x208=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x208;
evalcond[2]=x208;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x208;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst114;
gconst114=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst115;
gconst115=IKsign((((new_r12*sj33))+(((-1.0)*cj33*new_r02))));
dummyeval[0]=(((new_r12*sj33))+(((-1.0)*cj33*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst116;
CheckValue<IkReal> x209 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x209.valid){
continue;
}
gconst116=((-1.0)*(x209.value));
IkReal gconst117;
gconst117=IKsin(gconst116);
IkReal gconst118;
gconst118=IKcos(gconst116);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst116)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst122;
gconst122=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst123;
gconst123=IKsign(((((-1.0)*gconst118*new_r02))+((gconst117*new_r12))));
dummyeval[0]=((((-1.0)*gconst118*new_r02))+((gconst117*new_r12)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x210=(gconst123*new_r01);
CheckValue<IkReal> x211 = IKatan2WithCheck((new_r02*x210),((-1.0)*new_r12*x210),IKFAST_ATAN2_MAGTHRESH);
if(!x211.valid){
continue;
}
j31array[0]=x211.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x212=IKcos(j31);
IkReal x213=IKsin(j31);
IkReal x214=((1.0)*gconst118);
IkReal x215=((1.0)*gconst117);
IkReal x216=(gconst117*x213);
IkReal x217=(gconst118*x213);
IkReal x218=((1.0)*x213);
IkReal x219=(x212*x214);
evalcond[0]=(((new_r02*x212))+((new_r12*x213)));
evalcond[1]=((((-1.0)*new_r02*x218))+((new_r12*x212)));
evalcond[2]=(((new_r01*x212))+gconst117+((new_r11*x213)));
evalcond[3]=(x217+new_r01+((gconst117*x212)));
evalcond[4]=(x216+new_r00+(((-1.0)*x219)));
evalcond[5]=(x216+new_r11+(((-1.0)*x219)));
evalcond[6]=(((new_r00*x212))+(((-1.0)*x214))+((new_r10*x213)));
evalcond[7]=((((-1.0)*x213*x214))+new_r10+(((-1.0)*x212*x215)));
evalcond[8]=((((-1.0)*x215))+(((-1.0)*new_r00*x218))+((new_r10*x212)));
evalcond[9]=((((-1.0)*new_r01*x218))+(((-1.0)*x214))+((new_r11*x212)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x220=(gconst117*gconst122);
CheckValue<IkReal> x221 = IKatan2WithCheck((new_r02*x220),((-1.0)*new_r12*x220),IKFAST_ATAN2_MAGTHRESH);
if(!x221.valid){
continue;
}
j31array[0]=x221.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x222=IKcos(j31);
IkReal x223=IKsin(j31);
IkReal x224=((1.0)*gconst118);
IkReal x225=((1.0)*gconst117);
IkReal x226=(gconst117*x223);
IkReal x227=(gconst118*x223);
IkReal x228=((1.0)*x223);
IkReal x229=(x222*x224);
evalcond[0]=(((new_r02*x222))+((new_r12*x223)));
evalcond[1]=(((new_r12*x222))+(((-1.0)*new_r02*x228)));
evalcond[2]=(((new_r01*x222))+((new_r11*x223))+gconst117);
evalcond[3]=(x227+new_r01+((gconst117*x222)));
evalcond[4]=(x226+new_r00+(((-1.0)*x229)));
evalcond[5]=(x226+new_r11+(((-1.0)*x229)));
evalcond[6]=(((new_r00*x222))+((new_r10*x223))+(((-1.0)*x224)));
evalcond[7]=((((-1.0)*x222*x225))+(((-1.0)*x223*x224))+new_r10);
evalcond[8]=(((new_r10*x222))+(((-1.0)*x225))+(((-1.0)*new_r00*x228)));
evalcond[9]=((((-1.0)*new_r01*x228))+((new_r11*x222))+(((-1.0)*x224)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst119;
CheckValue<IkReal> x230 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x230.valid){
continue;
}
gconst119=((3.14159265358979)+(((-1.0)*(x230.value))));
IkReal gconst120;
gconst120=IKsin(gconst119);
IkReal gconst121;
gconst121=IKcos(gconst119);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst119)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst124;
gconst124=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst125;
gconst125=IKsign((((gconst120*new_r12))+(((-1.0)*gconst121*new_r02))));
dummyeval[0]=(((gconst120*new_r12))+(((-1.0)*gconst121*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x231=(gconst125*new_r01);
CheckValue<IkReal> x232 = IKatan2WithCheck((new_r02*x231),((-1.0)*new_r12*x231),IKFAST_ATAN2_MAGTHRESH);
if(!x232.valid){
continue;
}
j31array[0]=x232.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x233=IKcos(j31);
IkReal x234=IKsin(j31);
IkReal x235=((1.0)*gconst121);
IkReal x236=(gconst120*x234);
IkReal x237=(gconst121*x234);
IkReal x238=(gconst120*x233);
IkReal x239=((1.0)*x234);
IkReal x240=(x233*x235);
evalcond[0]=(((new_r02*x233))+((new_r12*x234)));
evalcond[1]=((((-1.0)*new_r02*x239))+((new_r12*x233)));
evalcond[2]=(((new_r11*x234))+((new_r01*x233))+gconst120);
evalcond[3]=(x238+x237+new_r01);
evalcond[4]=(x236+(((-1.0)*x240))+new_r00);
evalcond[5]=(x236+(((-1.0)*x240))+new_r11);
evalcond[6]=(((new_r10*x234))+((new_r00*x233))+(((-1.0)*x235)));
evalcond[7]=(new_r10+(((-1.0)*x234*x235))+(((-1.0)*x238)));
evalcond[8]=(((new_r10*x233))+(((-1.0)*gconst120))+(((-1.0)*new_r00*x239)));
evalcond[9]=(((new_r11*x233))+(((-1.0)*x235))+(((-1.0)*new_r01*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x241=(gconst120*gconst124);
CheckValue<IkReal> x242 = IKatan2WithCheck((new_r02*x241),((-1.0)*new_r12*x241),IKFAST_ATAN2_MAGTHRESH);
if(!x242.valid){
continue;
}
j31array[0]=x242.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x243=IKcos(j31);
IkReal x244=IKsin(j31);
IkReal x245=((1.0)*gconst121);
IkReal x246=(gconst120*x244);
IkReal x247=(gconst121*x244);
IkReal x248=(gconst120*x243);
IkReal x249=((1.0)*x244);
IkReal x250=(x243*x245);
evalcond[0]=(((new_r12*x244))+((new_r02*x243)));
evalcond[1]=(((new_r12*x243))+(((-1.0)*new_r02*x249)));
evalcond[2]=(((new_r01*x243))+gconst120+((new_r11*x244)));
evalcond[3]=(x247+x248+new_r01);
evalcond[4]=(x246+new_r00+(((-1.0)*x250)));
evalcond[5]=(x246+new_r11+(((-1.0)*x250)));
evalcond[6]=(((new_r00*x243))+(((-1.0)*x245))+((new_r10*x244)));
evalcond[7]=((((-1.0)*x248))+new_r10+(((-1.0)*x244*x245)));
evalcond[8]=((((-1.0)*new_r00*x249))+(((-1.0)*gconst120))+((new_r10*x243)));
evalcond[9]=((((-1.0)*new_r01*x249))+(((-1.0)*x245))+((new_r11*x243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x251=(gconst115*new_r01);
CheckValue<IkReal> x252 = IKatan2WithCheck((new_r02*x251),((-1.0)*new_r12*x251),IKFAST_ATAN2_MAGTHRESH);
if(!x252.valid){
continue;
}
j31array[0]=x252.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x253=IKcos(j31);
IkReal x254=IKsin(j31);
IkReal x255=((1.0)*cj33);
IkReal x256=((1.0)*sj33);
IkReal x257=(sj33*x254);
IkReal x258=((1.0)*x254);
IkReal x259=(x253*x255);
evalcond[0]=(((new_r02*x253))+((new_r12*x254)));
evalcond[1]=(((new_r12*x253))+(((-1.0)*new_r02*x258)));
evalcond[2]=(((new_r01*x253))+sj33+((new_r11*x254)));
evalcond[3]=(((cj33*x254))+((sj33*x253))+new_r01);
evalcond[4]=(x257+new_r00+(((-1.0)*x259)));
evalcond[5]=(x257+new_r11+(((-1.0)*x259)));
evalcond[6]=(((new_r00*x253))+((new_r10*x254))+(((-1.0)*x255)));
evalcond[7]=((((-1.0)*x254*x255))+new_r10+(((-1.0)*x253*x256)));
evalcond[8]=(((new_r10*x253))+(((-1.0)*new_r00*x258))+(((-1.0)*x256)));
evalcond[9]=((((-1.0)*new_r01*x258))+((new_r11*x253))+(((-1.0)*x255)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x260=(gconst114*sj33);
CheckValue<IkReal> x261 = IKatan2WithCheck((new_r02*x260),((-1.0)*new_r12*x260),IKFAST_ATAN2_MAGTHRESH);
if(!x261.valid){
continue;
}
j31array[0]=x261.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x262=IKcos(j31);
IkReal x263=IKsin(j31);
IkReal x264=((1.0)*cj33);
IkReal x265=((1.0)*sj33);
IkReal x266=(sj33*x263);
IkReal x267=((1.0)*x263);
IkReal x268=(x262*x264);
evalcond[0]=(((new_r12*x263))+((new_r02*x262)));
evalcond[1]=(((new_r12*x262))+(((-1.0)*new_r02*x267)));
evalcond[2]=(sj33+((new_r01*x262))+((new_r11*x263)));
evalcond[3]=(((cj33*x263))+new_r01+((sj33*x262)));
evalcond[4]=(x266+new_r00+(((-1.0)*x268)));
evalcond[5]=(x266+new_r11+(((-1.0)*x268)));
evalcond[6]=(((new_r00*x262))+(((-1.0)*x264))+((new_r10*x263)));
evalcond[7]=((((-1.0)*x262*x265))+(((-1.0)*x263*x264))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x267))+(((-1.0)*x265))+((new_r10*x262)));
evalcond[9]=((((-1.0)*new_r01*x267))+(((-1.0)*x264))+((new_r11*x262)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x269=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x269;
evalcond[2]=x269;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst126;
gconst126=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst127;
gconst127=IKsign((((cj33*new_r12))+(((-1.0)*new_r02*sj33))));
dummyeval[0]=(((cj33*new_r12))+(((-1.0)*new_r02*sj33)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst128;
CheckValue<IkReal> x270 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x270.valid){
continue;
}
gconst128=((-1.0)*(x270.value));
IkReal gconst129;
gconst129=IKsin(gconst128);
IkReal gconst130;
gconst130=IKcos(gconst128);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst128)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst134;
gconst134=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst135;
gconst135=IKsign((((gconst130*new_r12))+(((-1.0)*gconst129*new_r02))));
dummyeval[0]=(((gconst130*new_r12))+(((-1.0)*gconst129*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x271=(gconst135*new_r00);
CheckValue<IkReal> x272 = IKatan2WithCheck((new_r02*x271),((-1.0)*new_r12*x271),IKFAST_ATAN2_MAGTHRESH);
if(!x272.valid){
continue;
}
j31array[0]=x272.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x273=IKcos(j31);
IkReal x274=IKsin(j31);
IkReal x275=((1.0)*gconst129);
IkReal x276=((1.0)*gconst130);
IkReal x277=(gconst130*x274);
IkReal x278=((1.0)*x274);
IkReal x279=(x273*x275);
evalcond[0]=(((new_r02*x273))+((new_r12*x274)));
evalcond[1]=((((-1.0)*new_r02*x278))+((new_r12*x273)));
evalcond[2]=(((new_r00*x273))+gconst130+((new_r10*x274)));
evalcond[3]=(((gconst130*x273))+((gconst129*x274))+new_r00);
evalcond[4]=(x277+(((-1.0)*x279))+new_r01);
evalcond[5]=(x277+(((-1.0)*x279))+new_r10);
evalcond[6]=(((new_r01*x273))+(((-1.0)*x275))+((new_r11*x274)));
evalcond[7]=((((-1.0)*x273*x276))+(((-1.0)*x274*x275))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x278))+(((-1.0)*x275))+((new_r10*x273)));
evalcond[9]=((((-1.0)*new_r01*x278))+(((-1.0)*x276))+((new_r11*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x280=(gconst130*gconst134);
CheckValue<IkReal> x281 = IKatan2WithCheck((new_r02*x280),((-1.0)*new_r12*x280),IKFAST_ATAN2_MAGTHRESH);
if(!x281.valid){
continue;
}
j31array[0]=x281.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x282=IKcos(j31);
IkReal x283=IKsin(j31);
IkReal x284=((1.0)*gconst129);
IkReal x285=((1.0)*gconst130);
IkReal x286=(gconst130*x283);
IkReal x287=((1.0)*x283);
IkReal x288=(x282*x284);
evalcond[0]=(((new_r02*x282))+((new_r12*x283)));
evalcond[1]=((((-1.0)*new_r02*x287))+((new_r12*x282)));
evalcond[2]=(gconst130+((new_r00*x282))+((new_r10*x283)));
evalcond[3]=(((gconst129*x283))+((gconst130*x282))+new_r00);
evalcond[4]=(x286+(((-1.0)*x288))+new_r01);
evalcond[5]=(x286+(((-1.0)*x288))+new_r10);
evalcond[6]=((((-1.0)*x284))+((new_r11*x283))+((new_r01*x282)));
evalcond[7]=((((-1.0)*x282*x285))+new_r11+(((-1.0)*x283*x284)));
evalcond[8]=((((-1.0)*new_r00*x287))+(((-1.0)*x284))+((new_r10*x282)));
evalcond[9]=((((-1.0)*new_r01*x287))+(((-1.0)*x285))+((new_r11*x282)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst131;
CheckValue<IkReal> x289 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x289.valid){
continue;
}
gconst131=((3.14159265358979)+(((-1.0)*(x289.value))));
IkReal gconst132;
gconst132=IKsin(gconst131);
IkReal gconst133;
gconst133=IKcos(gconst131);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst131)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst136;
gconst136=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst137;
gconst137=IKsign((((gconst133*new_r12))+(((-1.0)*gconst132*new_r02))));
dummyeval[0]=(((gconst133*new_r12))+(((-1.0)*gconst132*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x290=(gconst137*new_r00);
CheckValue<IkReal> x291 = IKatan2WithCheck((new_r02*x290),((-1.0)*new_r12*x290),IKFAST_ATAN2_MAGTHRESH);
if(!x291.valid){
continue;
}
j31array[0]=x291.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x292=IKcos(j31);
IkReal x293=IKsin(j31);
IkReal x294=((1.0)*gconst132);
IkReal x295=((1.0)*gconst133);
IkReal x296=(gconst133*x293);
IkReal x297=(gconst132*x293);
IkReal x298=((1.0)*x293);
IkReal x299=(x292*x294);
evalcond[0]=(((new_r02*x292))+((new_r12*x293)));
evalcond[1]=(((new_r12*x292))+(((-1.0)*new_r02*x298)));
evalcond[2]=(((new_r10*x293))+((new_r00*x292))+gconst133);
evalcond[3]=(((gconst133*x292))+x297+new_r00);
evalcond[4]=((((-1.0)*x299))+x296+new_r01);
evalcond[5]=((((-1.0)*x299))+x296+new_r10);
evalcond[6]=(((new_r11*x293))+(((-1.0)*x294))+((new_r01*x292)));
evalcond[7]=((((-1.0)*x293*x294))+new_r11+(((-1.0)*x292*x295)));
evalcond[8]=((((-1.0)*x294))+((new_r10*x292))+(((-1.0)*new_r00*x298)));
evalcond[9]=((((-1.0)*new_r01*x298))+((new_r11*x292))+(((-1.0)*x295)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x300=(gconst133*gconst136);
CheckValue<IkReal> x301 = IKatan2WithCheck((new_r02*x300),((-1.0)*new_r12*x300),IKFAST_ATAN2_MAGTHRESH);
if(!x301.valid){
continue;
}
j31array[0]=x301.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x302=IKcos(j31);
IkReal x303=IKsin(j31);
IkReal x304=((1.0)*gconst132);
IkReal x305=((1.0)*gconst133);
IkReal x306=(gconst133*x303);
IkReal x307=(gconst132*x303);
IkReal x308=((1.0)*x303);
IkReal x309=(x302*x304);
evalcond[0]=(((new_r12*x303))+((new_r02*x302)));
evalcond[1]=((((-1.0)*new_r02*x308))+((new_r12*x302)));
evalcond[2]=(((new_r00*x302))+((new_r10*x303))+gconst133);
evalcond[3]=(((gconst133*x302))+x307+new_r00);
evalcond[4]=(x306+new_r01+(((-1.0)*x309)));
evalcond[5]=(x306+new_r10+(((-1.0)*x309)));
evalcond[6]=(((new_r01*x302))+((new_r11*x303))+(((-1.0)*x304)));
evalcond[7]=((((-1.0)*x303*x304))+(((-1.0)*x302*x305))+new_r11);
evalcond[8]=(((new_r10*x302))+(((-1.0)*new_r00*x308))+(((-1.0)*x304)));
evalcond[9]=(((new_r11*x302))+(((-1.0)*new_r01*x308))+(((-1.0)*x305)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x310=(gconst127*new_r00);
CheckValue<IkReal> x311 = IKatan2WithCheck((new_r02*x310),((-1.0)*new_r12*x310),IKFAST_ATAN2_MAGTHRESH);
if(!x311.valid){
continue;
}
j31array[0]=x311.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x312=IKcos(j31);
IkReal x313=IKsin(j31);
IkReal x314=((1.0)*sj33);
IkReal x315=(cj33*x313);
IkReal x316=(cj33*x312);
IkReal x317=((1.0)*x313);
IkReal x318=(x312*x314);
evalcond[0]=(((new_r02*x312))+((new_r12*x313)));
evalcond[1]=((((-1.0)*new_r02*x317))+((new_r12*x312)));
evalcond[2]=(((new_r00*x312))+cj33+((new_r10*x313)));
evalcond[3]=(((sj33*x313))+x316+new_r00);
evalcond[4]=(x315+(((-1.0)*x318))+new_r01);
evalcond[5]=(x315+(((-1.0)*x318))+new_r10);
evalcond[6]=(((new_r01*x312))+(((-1.0)*x314))+((new_r11*x313)));
evalcond[7]=((((-1.0)*x313*x314))+(((-1.0)*x316))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x317))+(((-1.0)*x314))+((new_r10*x312)));
evalcond[9]=((((-1.0)*cj33))+((new_r11*x312))+(((-1.0)*new_r01*x317)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x319=(cj33*gconst126);
CheckValue<IkReal> x320 = IKatan2WithCheck((new_r02*x319),((-1.0)*new_r12*x319),IKFAST_ATAN2_MAGTHRESH);
if(!x320.valid){
continue;
}
j31array[0]=x320.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x321=IKcos(j31);
IkReal x322=IKsin(j31);
IkReal x323=((1.0)*sj33);
IkReal x324=(cj33*x322);
IkReal x325=(cj33*x321);
IkReal x326=((1.0)*x322);
IkReal x327=(x321*x323);
evalcond[0]=(((new_r12*x322))+((new_r02*x321)));
evalcond[1]=(((new_r12*x321))+(((-1.0)*new_r02*x326)));
evalcond[2]=(((new_r00*x321))+cj33+((new_r10*x322)));
evalcond[3]=(((sj33*x322))+x325+new_r00);
evalcond[4]=((((-1.0)*x327))+x324+new_r01);
evalcond[5]=((((-1.0)*x327))+x324+new_r10);
evalcond[6]=(((new_r01*x321))+(((-1.0)*x323))+((new_r11*x322)));
evalcond[7]=((((-1.0)*x325))+(((-1.0)*x322*x323))+new_r11);
evalcond[8]=((((-1.0)*x323))+(((-1.0)*new_r00*x326))+((new_r10*x321)));
evalcond[9]=((((-1.0)*cj33))+(((-1.0)*new_r01*x326))+((new_r11*x321)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x328=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959))))));
evalcond[1]=x328;
evalcond[2]=x328;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x328;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst138;
gconst138=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst139;
gconst139=IKsign((((new_r12*sj33))+(((-1.0)*cj33*new_r02))));
dummyeval[0]=(((new_r12*sj33))+(((-1.0)*cj33*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst140;
CheckValue<IkReal> x329 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x329.valid){
continue;
}
gconst140=((-1.0)*(x329.value));
IkReal gconst141;
gconst141=IKsin(gconst140);
IkReal gconst142;
gconst142=IKcos(gconst140);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst140)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst146;
gconst146=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst147;
gconst147=IKsign((((gconst141*new_r12))+(((-1.0)*gconst142*new_r02))));
dummyeval[0]=(((gconst141*new_r12))+(((-1.0)*gconst142*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x330=(gconst147*new_r01);
CheckValue<IkReal> x331 = IKatan2WithCheck((new_r02*x330),((-1.0)*new_r12*x330),IKFAST_ATAN2_MAGTHRESH);
if(!x331.valid){
continue;
}
j31array[0]=x331.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x332=IKcos(j31);
IkReal x333=IKsin(j31);
IkReal x334=((1.0)*gconst142);
IkReal x335=(gconst141*x333);
IkReal x336=(gconst141*x332);
IkReal x337=((1.0)*x333);
IkReal x338=(x332*x334);
evalcond[0]=(((new_r12*x333))+((new_r02*x332)));
evalcond[1]=(((new_r12*x332))+(((-1.0)*new_r02*x337)));
evalcond[2]=(((new_r01*x332))+((new_r11*x333))+gconst141);
evalcond[3]=(x336+((gconst142*x333))+new_r01);
evalcond[4]=(x335+(((-1.0)*x338))+new_r00);
evalcond[5]=(x335+(((-1.0)*x338))+new_r11);
evalcond[6]=(((new_r00*x332))+((new_r10*x333))+(((-1.0)*x334)));
evalcond[7]=((((-1.0)*x333*x334))+(((-1.0)*x336))+new_r10);
evalcond[8]=(((new_r10*x332))+(((-1.0)*new_r00*x337))+(((-1.0)*gconst141)));
evalcond[9]=(((new_r11*x332))+(((-1.0)*x334))+(((-1.0)*new_r01*x337)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x339=(gconst141*gconst146);
CheckValue<IkReal> x340 = IKatan2WithCheck((new_r02*x339),((-1.0)*new_r12*x339),IKFAST_ATAN2_MAGTHRESH);
if(!x340.valid){
continue;
}
j31array[0]=x340.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x341=IKcos(j31);
IkReal x342=IKsin(j31);
IkReal x343=((1.0)*gconst142);
IkReal x344=(gconst141*x342);
IkReal x345=(gconst141*x341);
IkReal x346=((1.0)*x342);
IkReal x347=(x341*x343);
evalcond[0]=(((new_r02*x341))+((new_r12*x342)));
evalcond[1]=((((-1.0)*new_r02*x346))+((new_r12*x341)));
evalcond[2]=(((new_r11*x342))+((new_r01*x341))+gconst141);
evalcond[3]=(x345+((gconst142*x342))+new_r01);
evalcond[4]=(x344+new_r00+(((-1.0)*x347)));
evalcond[5]=(x344+new_r11+(((-1.0)*x347)));
evalcond[6]=(((new_r00*x341))+((new_r10*x342))+(((-1.0)*x343)));
evalcond[7]=(new_r10+(((-1.0)*x342*x343))+(((-1.0)*x345)));
evalcond[8]=(((new_r10*x341))+(((-1.0)*new_r00*x346))+(((-1.0)*gconst141)));
evalcond[9]=(((new_r11*x341))+(((-1.0)*new_r01*x346))+(((-1.0)*x343)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst143;
CheckValue<IkReal> x348 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x348.valid){
continue;
}
gconst143=((3.14159265358979)+(((-1.0)*(x348.value))));
IkReal gconst144;
gconst144=IKsin(gconst143);
IkReal gconst145;
gconst145=IKcos(gconst143);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j33+(((-1.0)*gconst143)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst148;
gconst148=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst149;
gconst149=IKsign(((((-1.0)*gconst145*new_r02))+((gconst144*new_r12))));
dummyeval[0]=((((-1.0)*gconst145*new_r02))+((gconst144*new_r12)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x349=(gconst149*new_r01);
CheckValue<IkReal> x350 = IKatan2WithCheck((new_r02*x349),((-1.0)*new_r12*x349),IKFAST_ATAN2_MAGTHRESH);
if(!x350.valid){
continue;
}
j31array[0]=x350.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x351=IKcos(j31);
IkReal x352=IKsin(j31);
IkReal x353=((1.0)*gconst145);
IkReal x354=((1.0)*gconst144);
IkReal x355=(gconst144*x352);
IkReal x356=((1.0)*x352);
IkReal x357=(x351*x353);
evalcond[0]=(((new_r02*x351))+((new_r12*x352)));
evalcond[1]=((((-1.0)*new_r02*x356))+((new_r12*x351)));
evalcond[2]=(((new_r01*x351))+gconst144+((new_r11*x352)));
evalcond[3]=(((gconst144*x351))+new_r01+((gconst145*x352)));
evalcond[4]=((((-1.0)*x357))+x355+new_r00);
evalcond[5]=((((-1.0)*x357))+x355+new_r11);
evalcond[6]=((((-1.0)*x353))+((new_r10*x352))+((new_r00*x351)));
evalcond[7]=((((-1.0)*x351*x354))+new_r10+(((-1.0)*x352*x353)));
evalcond[8]=((((-1.0)*x354))+(((-1.0)*new_r00*x356))+((new_r10*x351)));
evalcond[9]=((((-1.0)*x353))+(((-1.0)*new_r01*x356))+((new_r11*x351)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x358=(gconst144*gconst148);
CheckValue<IkReal> x359 = IKatan2WithCheck((new_r02*x358),((-1.0)*new_r12*x358),IKFAST_ATAN2_MAGTHRESH);
if(!x359.valid){
continue;
}
j31array[0]=x359.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x360=IKcos(j31);
IkReal x361=IKsin(j31);
IkReal x362=((1.0)*gconst145);
IkReal x363=((1.0)*gconst144);
IkReal x364=(gconst144*x361);
IkReal x365=((1.0)*x361);
IkReal x366=(x360*x362);
evalcond[0]=(((new_r02*x360))+((new_r12*x361)));
evalcond[1]=((((-1.0)*new_r02*x365))+((new_r12*x360)));
evalcond[2]=(((new_r01*x360))+gconst144+((new_r11*x361)));
evalcond[3]=(((gconst144*x360))+new_r01+((gconst145*x361)));
evalcond[4]=((((-1.0)*x366))+x364+new_r00);
evalcond[5]=((((-1.0)*x366))+x364+new_r11);
evalcond[6]=((((-1.0)*x362))+((new_r00*x360))+((new_r10*x361)));
evalcond[7]=((((-1.0)*x361*x362))+(((-1.0)*x360*x363))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x365))+(((-1.0)*x363))+((new_r10*x360)));
evalcond[9]=((((-1.0)*x362))+(((-1.0)*new_r01*x365))+((new_r11*x360)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x367=(gconst139*new_r01);
CheckValue<IkReal> x368 = IKatan2WithCheck((new_r02*x367),((-1.0)*new_r12*x367),IKFAST_ATAN2_MAGTHRESH);
if(!x368.valid){
continue;
}
j31array[0]=x368.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x369=IKcos(j31);
IkReal x370=IKsin(j31);
IkReal x371=((1.0)*cj33);
IkReal x372=((1.0)*sj33);
IkReal x373=(sj33*x370);
IkReal x374=((1.0)*x370);
IkReal x375=(x369*x371);
evalcond[0]=(((new_r12*x370))+((new_r02*x369)));
evalcond[1]=((((-1.0)*new_r02*x374))+((new_r12*x369)));
evalcond[2]=(((new_r01*x369))+sj33+((new_r11*x370)));
evalcond[3]=(((cj33*x370))+((sj33*x369))+new_r01);
evalcond[4]=((((-1.0)*x375))+x373+new_r00);
evalcond[5]=((((-1.0)*x375))+x373+new_r11);
evalcond[6]=((((-1.0)*x371))+((new_r00*x369))+((new_r10*x370)));
evalcond[7]=((((-1.0)*x370*x371))+(((-1.0)*x369*x372))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x374))+(((-1.0)*x372))+((new_r10*x369)));
evalcond[9]=((((-1.0)*x371))+(((-1.0)*new_r01*x374))+((new_r11*x369)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x376=(gconst138*sj33);
CheckValue<IkReal> x377 = IKatan2WithCheck((new_r02*x376),((-1.0)*new_r12*x376),IKFAST_ATAN2_MAGTHRESH);
if(!x377.valid){
continue;
}
j31array[0]=x377.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x378=IKcos(j31);
IkReal x379=IKsin(j31);
IkReal x380=((1.0)*cj33);
IkReal x381=((1.0)*sj33);
IkReal x382=(sj33*x379);
IkReal x383=((1.0)*x379);
IkReal x384=(x378*x380);
evalcond[0]=(((new_r12*x379))+((new_r02*x378)));
evalcond[1]=(((new_r12*x378))+(((-1.0)*new_r02*x383)));
evalcond[2]=(((new_r01*x378))+sj33+((new_r11*x379)));
evalcond[3]=(((cj33*x379))+((sj33*x378))+new_r01);
evalcond[4]=(x382+(((-1.0)*x384))+new_r00);
evalcond[5]=(x382+(((-1.0)*x384))+new_r11);
evalcond[6]=(((new_r00*x378))+(((-1.0)*x380))+((new_r10*x379)));
evalcond[7]=((((-1.0)*x379*x380))+(((-1.0)*x378*x381))+new_r10);
evalcond[8]=((((-1.0)*new_r00*x383))+(((-1.0)*x381))+((new_r10*x378)));
evalcond[9]=((((-1.0)*new_r01*x383))+(((-1.0)*x380))+((new_r11*x378)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x385=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959))))));
evalcond[1]=x385;
evalcond[2]=x385;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst150;
gconst150=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst151;
gconst151=IKsign((((cj33*new_r12))+(((-1.0)*new_r02*sj33))));
dummyeval[0]=(((cj33*new_r12))+(((-1.0)*new_r02*sj33)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst152;
CheckValue<IkReal> x386 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x386.valid){
continue;
}
gconst152=((-1.0)*(x386.value));
IkReal gconst153;
gconst153=IKsin(gconst152);
IkReal gconst154;
gconst154=IKcos(gconst152);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst152))+j33)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst158;
gconst158=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst159;
gconst159=IKsign((((gconst154*new_r12))+(((-1.0)*gconst153*new_r02))));
dummyeval[0]=(((gconst154*new_r12))+(((-1.0)*gconst153*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x387=(gconst159*new_r00);
CheckValue<IkReal> x388 = IKatan2WithCheck((new_r02*x387),((-1.0)*new_r12*x387),IKFAST_ATAN2_MAGTHRESH);
if(!x388.valid){
continue;
}
j31array[0]=x388.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x389=IKcos(j31);
IkReal x390=IKsin(j31);
IkReal x391=((1.0)*gconst153);
IkReal x392=((1.0)*gconst154);
IkReal x393=(gconst154*x390);
IkReal x394=((1.0)*x390);
IkReal x395=(x389*x391);
evalcond[0]=(((new_r02*x389))+((new_r12*x390)));
evalcond[1]=(((new_r12*x389))+(((-1.0)*new_r02*x394)));
evalcond[2]=(((new_r00*x389))+gconst154+((new_r10*x390)));
evalcond[3]=(((gconst154*x389))+new_r00+((gconst153*x390)));
evalcond[4]=((((-1.0)*x395))+x393+new_r01);
evalcond[5]=((((-1.0)*x395))+x393+new_r10);
evalcond[6]=(((new_r11*x390))+(((-1.0)*x391))+((new_r01*x389)));
evalcond[7]=((((-1.0)*x389*x392))+(((-1.0)*x390*x391))+new_r11);
evalcond[8]=((((-1.0)*x391))+((new_r10*x389))+(((-1.0)*new_r00*x394)));
evalcond[9]=((((-1.0)*new_r01*x394))+(((-1.0)*x392))+((new_r11*x389)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x396=(gconst154*gconst158);
CheckValue<IkReal> x397 = IKatan2WithCheck((new_r02*x396),((-1.0)*new_r12*x396),IKFAST_ATAN2_MAGTHRESH);
if(!x397.valid){
continue;
}
j31array[0]=x397.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x398=IKcos(j31);
IkReal x399=IKsin(j31);
IkReal x400=((1.0)*gconst153);
IkReal x401=((1.0)*gconst154);
IkReal x402=(gconst154*x399);
IkReal x403=((1.0)*x399);
IkReal x404=(x398*x400);
evalcond[0]=(((new_r02*x398))+((new_r12*x399)));
evalcond[1]=((((-1.0)*new_r02*x403))+((new_r12*x398)));
evalcond[2]=(((new_r00*x398))+gconst154+((new_r10*x399)));
evalcond[3]=(new_r00+((gconst154*x398))+((gconst153*x399)));
evalcond[4]=(x402+new_r01+(((-1.0)*x404)));
evalcond[5]=(x402+new_r10+(((-1.0)*x404)));
evalcond[6]=(((new_r11*x399))+((new_r01*x398))+(((-1.0)*x400)));
evalcond[7]=((((-1.0)*x398*x401))+(((-1.0)*x399*x400))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x403))+(((-1.0)*x400))+((new_r10*x398)));
evalcond[9]=(((new_r11*x398))+(((-1.0)*new_r01*x403))+(((-1.0)*x401)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst155;
CheckValue<IkReal> x405 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x405.valid){
continue;
}
gconst155=((3.14159265358979)+(((-1.0)*(x405.value))));
IkReal gconst156;
gconst156=IKsin(gconst155);
IkReal gconst157;
gconst157=IKcos(gconst155);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst155))+j33)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst160;
gconst160=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst161;
gconst161=IKsign((((gconst157*new_r12))+(((-1.0)*gconst156*new_r02))));
dummyeval[0]=(((gconst157*new_r12))+(((-1.0)*gconst156*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x406=(gconst161*new_r00);
CheckValue<IkReal> x407 = IKatan2WithCheck((new_r02*x406),((-1.0)*new_r12*x406),IKFAST_ATAN2_MAGTHRESH);
if(!x407.valid){
continue;
}
j31array[0]=x407.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x408=IKcos(j31);
IkReal x409=IKsin(j31);
IkReal x410=((1.0)*gconst156);
IkReal x411=(gconst157*x409);
IkReal x412=(gconst157*x408);
IkReal x413=((1.0)*x409);
IkReal x414=(x408*x410);
evalcond[0]=(((new_r12*x409))+((new_r02*x408)));
evalcond[1]=(((new_r12*x408))+(((-1.0)*new_r02*x413)));
evalcond[2]=(((new_r10*x409))+gconst157+((new_r00*x408)));
evalcond[3]=(((gconst156*x409))+x412+new_r00);
evalcond[4]=(x411+new_r01+(((-1.0)*x414)));
evalcond[5]=(x411+new_r10+(((-1.0)*x414)));
evalcond[6]=(((new_r11*x409))+((new_r01*x408))+(((-1.0)*x410)));
evalcond[7]=(new_r11+(((-1.0)*x409*x410))+(((-1.0)*x412)));
evalcond[8]=(((new_r10*x408))+(((-1.0)*new_r00*x413))+(((-1.0)*x410)));
evalcond[9]=((((-1.0)*gconst157))+((new_r11*x408))+(((-1.0)*new_r01*x413)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x415=(gconst157*gconst160);
CheckValue<IkReal> x416 = IKatan2WithCheck((new_r02*x415),((-1.0)*new_r12*x415),IKFAST_ATAN2_MAGTHRESH);
if(!x416.valid){
continue;
}
j31array[0]=x416.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x417=IKcos(j31);
IkReal x418=IKsin(j31);
IkReal x419=((1.0)*gconst156);
IkReal x420=(gconst157*x418);
IkReal x421=(gconst157*x417);
IkReal x422=((1.0)*x418);
IkReal x423=(x417*x419);
evalcond[0]=(((new_r12*x418))+((new_r02*x417)));
evalcond[1]=(((new_r12*x417))+(((-1.0)*new_r02*x422)));
evalcond[2]=(gconst157+((new_r10*x418))+((new_r00*x417)));
evalcond[3]=(((gconst156*x418))+x421+new_r00);
evalcond[4]=((((-1.0)*x423))+x420+new_r01);
evalcond[5]=((((-1.0)*x423))+x420+new_r10);
evalcond[6]=(((new_r11*x418))+(((-1.0)*x419))+((new_r01*x417)));
evalcond[7]=((((-1.0)*x421))+(((-1.0)*x418*x419))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x422))+((new_r10*x417))+(((-1.0)*x419)));
evalcond[9]=((((-1.0)*gconst157))+((new_r11*x417))+(((-1.0)*new_r01*x422)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x424=(gconst151*new_r00);
CheckValue<IkReal> x425 = IKatan2WithCheck((new_r02*x424),((-1.0)*new_r12*x424),IKFAST_ATAN2_MAGTHRESH);
if(!x425.valid){
continue;
}
j31array[0]=x425.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x426=IKcos(j31);
IkReal x427=IKsin(j31);
IkReal x428=((1.0)*sj33);
IkReal x429=(cj33*x427);
IkReal x430=(cj33*x426);
IkReal x431=((1.0)*x427);
IkReal x432=(x426*x428);
evalcond[0]=(((new_r12*x427))+((new_r02*x426)));
evalcond[1]=(((new_r12*x426))+(((-1.0)*new_r02*x431)));
evalcond[2]=(((new_r10*x427))+cj33+((new_r00*x426)));
evalcond[3]=(((sj33*x427))+x430+new_r00);
evalcond[4]=((((-1.0)*x432))+x429+new_r01);
evalcond[5]=((((-1.0)*x432))+x429+new_r10);
evalcond[6]=((((-1.0)*x428))+((new_r11*x427))+((new_r01*x426)));
evalcond[7]=((((-1.0)*x430))+(((-1.0)*x427*x428))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x431))+(((-1.0)*x428))+((new_r10*x426)));
evalcond[9]=((((-1.0)*new_r01*x431))+(((-1.0)*cj33))+((new_r11*x426)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
IkReal x433=(cj33*gconst150);
CheckValue<IkReal> x434 = IKatan2WithCheck((new_r02*x433),((-1.0)*new_r12*x433),IKFAST_ATAN2_MAGTHRESH);
if(!x434.valid){
continue;
}
j31array[0]=x434.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[10];
IkReal x435=IKcos(j31);
IkReal x436=IKsin(j31);
IkReal x437=((1.0)*sj33);
IkReal x438=(cj33*x436);
IkReal x439=(cj33*x435);
IkReal x440=((1.0)*x436);
IkReal x441=(x435*x437);
evalcond[0]=(((new_r12*x436))+((new_r02*x435)));
evalcond[1]=(((new_r12*x435))+(((-1.0)*new_r02*x440)));
evalcond[2]=(((new_r00*x435))+cj33+((new_r10*x436)));
evalcond[3]=(x439+new_r00+((sj33*x436)));
evalcond[4]=((((-1.0)*x441))+x438+new_r01);
evalcond[5]=((((-1.0)*x441))+x438+new_r10);
evalcond[6]=(((new_r01*x435))+(((-1.0)*x437))+((new_r11*x436)));
evalcond[7]=((((-1.0)*x439))+(((-1.0)*x436*x437))+new_r11);
evalcond[8]=((((-1.0)*x437))+(((-1.0)*new_r00*x440))+((new_r10*x435)));
evalcond[9]=((((-1.0)*new_r01*x440))+(((-1.0)*cj33))+((new_r11*x435)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x442 = IKatan2WithCheck((gconst113*new_r12),(gconst113*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x442.valid){
continue;
}
j31array[0]=x442.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x443=IKcos(j31);
IkReal x444=IKsin(j31);
IkReal x445=((1.0)*cj33);
IkReal x446=((1.0)*sj33);
IkReal x447=(cj32*sj33);
IkReal x448=((1.0)*sj32);
IkReal x449=(new_r10*x444);
IkReal x450=(cj32*x443);
IkReal x451=(sj32*x443);
IkReal x452=(new_r11*x444);
IkReal x453=(new_r12*x444);
IkReal x454=((1.0)*x444);
evalcond[0]=((((-1.0)*x443*x448))+new_r02);
evalcond[1]=((((-1.0)*x444*x448))+new_r12);
evalcond[2]=(((new_r12*x443))+(((-1.0)*new_r02*x454)));
evalcond[3]=(((cj33*x444))+new_r01+((x443*x447)));
evalcond[4]=((((-1.0)*x448))+x453+((new_r02*x443)));
evalcond[5]=(((new_r01*x443))+x447+x452);
evalcond[6]=((((-1.0)*x445*x450))+new_r00+((sj33*x444)));
evalcond[7]=((((-1.0)*x443*x445))+((x444*x447))+new_r11);
evalcond[8]=((((-1.0)*x446))+(((-1.0)*new_r00*x454))+((new_r10*x443)));
evalcond[9]=((((-1.0)*x445))+(((-1.0)*new_r01*x454))+((new_r11*x443)));
evalcond[10]=(((new_r00*x443))+x449+(((-1.0)*cj32*x445)));
evalcond[11]=((((-1.0)*cj32*x444*x445))+(((-1.0)*x443*x446))+new_r10);
evalcond[12]=(((sj32*x449))+((new_r00*x451))+((cj32*new_r20)));
evalcond[13]=(((new_r01*x451))+((sj32*x452))+((cj32*new_r21)));
evalcond[14]=((-1.0)+((sj32*x453))+((new_r02*x451))+((cj32*new_r22)));
evalcond[15]=(((new_r02*x450))+((cj32*x453))+(((-1.0)*new_r22*x448)));
evalcond[16]=(((new_r01*x450))+sj33+((cj32*x452))+(((-1.0)*new_r21*x448)));
evalcond[17]=((((-1.0)*x445))+((new_r00*x450))+((cj32*x449))+(((-1.0)*new_r20*x448)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x455 = IKatan2WithCheck((gconst112*new_r12),(gconst112*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x455.valid){
continue;
}
j31array[0]=x455.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[18];
IkReal x456=IKcos(j31);
IkReal x457=IKsin(j31);
IkReal x458=((1.0)*cj33);
IkReal x459=((1.0)*sj33);
IkReal x460=(cj32*sj33);
IkReal x461=((1.0)*sj32);
IkReal x462=(new_r10*x457);
IkReal x463=(cj32*x456);
IkReal x464=(sj32*x456);
IkReal x465=(new_r11*x457);
IkReal x466=(new_r12*x457);
IkReal x467=((1.0)*x457);
evalcond[0]=((((-1.0)*x456*x461))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x457*x461)));
evalcond[2]=(((new_r12*x456))+(((-1.0)*new_r02*x467)));
evalcond[3]=(((x456*x460))+((cj33*x457))+new_r01);
evalcond[4]=((((-1.0)*x461))+x466+((new_r02*x456)));
evalcond[5]=(((new_r01*x456))+x460+x465);
evalcond[6]=(((sj33*x457))+(((-1.0)*x458*x463))+new_r00);
evalcond[7]=((((-1.0)*x456*x458))+new_r11+((x457*x460)));
evalcond[8]=(((new_r10*x456))+(((-1.0)*x459))+(((-1.0)*new_r00*x467)));
evalcond[9]=(((new_r11*x456))+(((-1.0)*new_r01*x467))+(((-1.0)*x458)));
evalcond[10]=((((-1.0)*cj32*x458))+((new_r00*x456))+x462);
evalcond[11]=((((-1.0)*cj32*x457*x458))+(((-1.0)*x456*x459))+new_r10);
evalcond[12]=(((new_r00*x464))+((sj32*x462))+((cj32*new_r20)));
evalcond[13]=(((new_r01*x464))+((sj32*x465))+((cj32*new_r21)));
evalcond[14]=((-1.0)+((sj32*x466))+((new_r02*x464))+((cj32*new_r22)));
evalcond[15]=((((-1.0)*new_r22*x461))+((new_r02*x463))+((cj32*x466)));
evalcond[16]=((((-1.0)*new_r21*x461))+((new_r01*x463))+sj33+((cj32*x465)));
evalcond[17]=(((new_r00*x463))+(((-1.0)*new_r20*x461))+(((-1.0)*x458))+((cj32*x462)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x468 = IKatan2WithCheck((gconst110*new_r12),(gconst110*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x468.valid){
continue;
}
j31array[0]=x468.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x469=IKcos(j31);
IkReal x470=IKsin(j31);
IkReal x471=((1.0)*sj32);
IkReal x472=(new_r02*x469);
IkReal x473=(new_r12*x470);
IkReal x474=(sj32*x469);
IkReal x475=(sj32*x470);
evalcond[0]=((((-1.0)*x469*x471))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x470*x471)));
evalcond[2]=(((new_r12*x469))+(((-1.0)*new_r02*x470)));
evalcond[3]=((((-1.0)*x471))+x472+x473);
evalcond[4]=(((new_r10*x475))+((new_r00*x474))+((cj32*new_r20)));
evalcond[5]=(((new_r01*x474))+((new_r11*x475))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((sj32*x472))+((sj32*x473))+((cj32*new_r22)));
evalcond[7]=((((-1.0)*new_r22*x471))+((cj32*x473))+((cj32*x472)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst162;
gconst162=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj32;
dummyeval[1]=sj31;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj31;
dummyeval[1]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x476=((((-1.0)*cj32))+new_r22);
IkReal x477=((((-1.0)*sj32))+new_r02);
IkReal x478=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x476;
evalcond[2]=x476;
evalcond[3]=x477;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x477;
evalcond[8]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[9]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[10]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[11]=(((cj32*new_r02))+(((-1.0)*new_r22*x478)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x479=IKcos(j33);
IkReal x480=IKsin(j33);
IkReal x481=((1.0)*new_r02);
IkReal x482=((1.0)*x479);
evalcond[0]=(((new_r02*x479))+new_r20);
evalcond[1]=((((-1.0)*x480))+new_r10);
evalcond[2]=((((-1.0)*x482))+new_r11);
evalcond[3]=(new_r01+((new_r22*x480)));
evalcond[4]=((((-1.0)*x480*x481))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*new_r22*x482)));
evalcond[6]=((((-1.0)*new_r21*x481))+((new_r01*new_r22))+x480);
evalcond[7]=((((-1.0)*x482))+((new_r00*new_r22))+(((-1.0)*new_r20*x481)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x483=((((-1.0)*cj32))+new_r22);
IkReal x484=((1.0)*sj32);
IkReal x485=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x483;
evalcond[2]=x483;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x484))+(((-1.0)*x485)));
evalcond[7]=((((-1.0)*new_r00*x484))+((cj32*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x484))+((cj32*new_r21)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x484))+((cj32*new_r22)));
evalcond[10]=((((-1.0)*cj32*x485))+(((-1.0)*new_r22*x484)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x486=IKsin(j33);
IkReal x487=IKcos(j33);
IkReal x488=((1.0)*new_r22);
IkReal x489=((1.0)*x487);
evalcond[0]=(((new_r02*x486))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x489))+new_r20);
evalcond[2]=((((-1.0)*x486))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x489))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((new_r22*x486)));
evalcond[5]=((((-1.0)*x487*x488))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x488))+x486+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x489))+(((-1.0)*new_r00*x488))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x490=((-1.0)+new_r22);
IkReal x491=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x492=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x490;
evalcond[2]=x490;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x491;
evalcond[10]=x491;
evalcond[11]=x492;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x490;
evalcond[15]=x492;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst164;
gconst164=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst165;
gconst165=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x493 = IKatan2WithCheck((gconst165*((((cj31*new_r01))+((new_r11*sj31))))),(gconst165*(((((-1.0)*cj31*new_r11))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x493.valid){
continue;
}
j33array[0]=x493.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x494=IKsin(j33);
IkReal x495=IKcos(j33);
IkReal x496=((1.0)*sj31);
IkReal x497=((1.0)*x495);
IkReal x498=(sj31*x494);
IkReal x499=((1.0)*x494);
IkReal x500=(cj31*x497);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x494);
evalcond[1]=(((sj31*x495))+((cj31*x494))+new_r01);
evalcond[2]=((((-1.0)*x497))+((cj31*new_r00))+((new_r10*sj31)));
evalcond[3]=((((-1.0)*new_r00*x496))+(((-1.0)*x499))+((cj31*new_r10)));
evalcond[4]=((((-1.0)*x497))+(((-1.0)*new_r01*x496))+((cj31*new_r11)));
evalcond[5]=((((-1.0)*x500))+x498+new_r00);
evalcond[6]=((((-1.0)*x500))+x498+new_r11);
evalcond[7]=((((-1.0)*cj31*x499))+(((-1.0)*x495*x496))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x501 = IKatan2WithCheck((gconst164*((((new_r00*sj31))+((cj31*new_r01))))),(gconst164*(((((-1.0)*cj31*new_r00))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x501.valid){
continue;
}
j33array[0]=x501.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x502=IKsin(j33);
IkReal x503=IKcos(j33);
IkReal x504=((1.0)*sj31);
IkReal x505=((1.0)*x503);
IkReal x506=(sj31*x502);
IkReal x507=((1.0)*x502);
IkReal x508=(cj31*x505);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x502);
evalcond[1]=(((sj31*x503))+new_r01+((cj31*x502)));
evalcond[2]=(((cj31*new_r00))+(((-1.0)*x505))+((new_r10*sj31)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x504))+(((-1.0)*x507)));
evalcond[4]=((((-1.0)*new_r01*x504))+((cj31*new_r11))+(((-1.0)*x505)));
evalcond[5]=((((-1.0)*x508))+x506+new_r00);
evalcond[6]=((((-1.0)*x508))+x506+new_r11);
evalcond[7]=((((-1.0)*x503*x504))+(((-1.0)*cj31*x507))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x509=((1.0)+new_r22);
IkReal x510=(cj31*new_r02);
IkReal x511=(new_r12*sj31);
IkReal x512=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x509;
evalcond[2]=x509;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x512;
evalcond[10]=x512;
evalcond[11]=(x511+x510);
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x511))+(((-1.0)*x510)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst166;
gconst166=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst167;
gconst167=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x513=((1.0)*sj31);
CheckValue<IkReal> x514 = IKatan2WithCheck((gconst167*((((cj31*new_r10))+(((-1.0)*new_r00*x513))))),(gconst167*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x513))))),IKFAST_ATAN2_MAGTHRESH);
if(!x514.valid){
continue;
}
j33array[0]=x514.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x515=IKsin(j33);
IkReal x516=IKcos(j33);
IkReal x517=((1.0)*sj31);
IkReal x518=((1.0)*x515);
IkReal x519=(sj31*x516);
IkReal x520=((1.0)*x516);
IkReal x521=(cj31*x518);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x516);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x518)));
evalcond[2]=(((cj31*x516))+new_r00+((sj31*x515)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x517))+(((-1.0)*x518)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x520))+(((-1.0)*new_r01*x517)));
evalcond[5]=((((-1.0)*x521))+x519+new_r01);
evalcond[6]=((((-1.0)*x521))+x519+new_r10);
evalcond[7]=((((-1.0)*x515*x517))+(((-1.0)*cj31*x520))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x522=((1.0)*new_r00);
CheckValue<IkReal> x523 = IKatan2WithCheck((gconst166*((((cj31*new_r01))+(((-1.0)*sj31*x522))))),(gconst166*(((((-1.0)*cj31*x522))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x523.valid){
continue;
}
j33array[0]=x523.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x524=IKsin(j33);
IkReal x525=IKcos(j33);
IkReal x526=((1.0)*sj31);
IkReal x527=((1.0)*x524);
IkReal x528=(sj31*x525);
IkReal x529=((1.0)*x525);
IkReal x530=(cj31*x527);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x525);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x527)));
evalcond[2]=(((sj31*x524))+((cj31*x525))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x526))+(((-1.0)*x527)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x529))+(((-1.0)*new_r01*x526)));
evalcond[5]=((((-1.0)*x530))+x528+new_r01);
evalcond[6]=((((-1.0)*x530))+x528+new_r10);
evalcond[7]=((((-1.0)*x524*x526))+(((-1.0)*cj31*x529))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x531=((((-1.0)*cj32))+new_r22);
IkReal x532=((((-1.0)*sj32))+new_r02);
IkReal x533=((1.0)*sj32);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j31), 6.28318530717959))))));
evalcond[1]=x531;
evalcond[2]=x531;
evalcond[3]=x532;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x532;
evalcond[8]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[9]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[10]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[11]=((((-1.0)*new_r22*x533))+((cj32*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x534=IKcos(j33);
IkReal x535=IKsin(j33);
IkReal x536=((1.0)*new_r02);
IkReal x537=((1.0)*x534);
evalcond[0]=(((new_r02*x534))+new_r20);
evalcond[1]=((((-1.0)*x535))+new_r10);
evalcond[2]=((((-1.0)*x537))+new_r11);
evalcond[3]=(((new_r22*x535))+new_r01);
evalcond[4]=((((-1.0)*x535*x536))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x537))+new_r00);
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x536))+x535);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*x537))+(((-1.0)*new_r20*x536)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x538=((((-1.0)*cj32))+new_r22);
IkReal x539=((1.0)*sj32);
IkReal x540=((1.0)*new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j31, 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=x538;
evalcond[2]=x538;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x539))+(((-1.0)*x540)));
evalcond[7]=((((-1.0)*new_r00*x539))+((cj32*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x539))+((cj32*new_r21)));
evalcond[9]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x539)));
evalcond[10]=((((-1.0)*new_r22*x539))+(((-1.0)*cj32*x540)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x541=IKsin(j33);
IkReal x542=IKcos(j33);
IkReal x543=((1.0)*new_r22);
IkReal x544=((1.0)*x542);
evalcond[0]=(((new_r02*x541))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*new_r02*x544)));
evalcond[2]=((((-1.0)*x541))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x544))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x541))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x542*x543))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x543))+x541+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x543))+(((-1.0)*x544))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x545=((-1.0)+new_r22);
IkReal x546=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x547=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959))))));
evalcond[1]=x545;
evalcond[2]=x545;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x546;
evalcond[10]=x546;
evalcond[11]=x547;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x545;
evalcond[15]=x547;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst169;
gconst169=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst170;
gconst170=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x548 = IKatan2WithCheck((gconst170*((((cj31*new_r01))+((new_r11*sj31))))),(gconst170*(((((-1.0)*cj31*new_r11))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x548.valid){
continue;
}
j33array[0]=x548.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x549=IKsin(j33);
IkReal x550=IKcos(j33);
IkReal x551=((1.0)*sj31);
IkReal x552=((1.0)*x550);
IkReal x553=(sj31*x549);
IkReal x554=((1.0)*x549);
IkReal x555=(cj31*x552);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x549);
evalcond[1]=(((sj31*x550))+((cj31*x549))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x552)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x551))+(((-1.0)*x554)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x551))+(((-1.0)*x552)));
evalcond[5]=((((-1.0)*x555))+x553+new_r00);
evalcond[6]=((((-1.0)*x555))+x553+new_r11);
evalcond[7]=((((-1.0)*x550*x551))+new_r10+(((-1.0)*cj31*x554)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x556 = IKatan2WithCheck((gconst169*((((new_r00*sj31))+((cj31*new_r01))))),(gconst169*(((((-1.0)*cj31*new_r00))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x556.valid){
continue;
}
j33array[0]=x556.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x557=IKsin(j33);
IkReal x558=IKcos(j33);
IkReal x559=((1.0)*sj31);
IkReal x560=((1.0)*x558);
IkReal x561=(sj31*x557);
IkReal x562=((1.0)*x557);
IkReal x563=(cj31*x560);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x557);
evalcond[1]=(((cj31*x557))+((sj31*x558))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x560)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x559))+(((-1.0)*x562)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x559))+(((-1.0)*x560)));
evalcond[5]=(x561+new_r00+(((-1.0)*x563)));
evalcond[6]=(x561+new_r11+(((-1.0)*x563)));
evalcond[7]=((((-1.0)*cj31*x562))+(((-1.0)*x558*x559))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x564=((1.0)+new_r22);
IkReal x565=(cj31*new_r02);
IkReal x566=(new_r12*sj31);
IkReal x567=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959))))));
evalcond[1]=x564;
evalcond[2]=x564;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x567;
evalcond[10]=x567;
evalcond[11]=(x566+x565);
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x565))+(((-1.0)*x566)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst171;
gconst171=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst172;
gconst172=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x568=((1.0)*sj31);
CheckValue<IkReal> x569 = IKatan2WithCheck((gconst172*(((((-1.0)*new_r00*x568))+((cj31*new_r10))))),(gconst172*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x568))))),IKFAST_ATAN2_MAGTHRESH);
if(!x569.valid){
continue;
}
j33array[0]=x569.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x570=IKsin(j33);
IkReal x571=IKcos(j33);
IkReal x572=((1.0)*sj31);
IkReal x573=((1.0)*x570);
IkReal x574=(sj31*x571);
IkReal x575=((1.0)*x571);
IkReal x576=(cj31*x573);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x571);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x573)));
evalcond[2]=(((cj31*x571))+new_r00+((sj31*x570)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x573))+(((-1.0)*new_r00*x572)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x575))+(((-1.0)*new_r01*x572)));
evalcond[5]=((((-1.0)*x576))+x574+new_r01);
evalcond[6]=((((-1.0)*x576))+x574+new_r10);
evalcond[7]=((((-1.0)*x570*x572))+new_r11+(((-1.0)*cj31*x575)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x577=((1.0)*new_r00);
CheckValue<IkReal> x578 = IKatan2WithCheck((gconst171*((((cj31*new_r01))+(((-1.0)*sj31*x577))))),(gconst171*(((((-1.0)*new_r01*sj31))+(((-1.0)*cj31*x577))))),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
j33array[0]=x578.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x579=IKsin(j33);
IkReal x580=IKcos(j33);
IkReal x581=((1.0)*sj31);
IkReal x582=((1.0)*x579);
IkReal x583=(sj31*x580);
IkReal x584=((1.0)*x580);
IkReal x585=(cj31*x582);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x580);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x582)));
evalcond[2]=(((cj31*x580))+new_r00+((sj31*x579)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x582))+(((-1.0)*new_r00*x581)));
evalcond[4]=((((-1.0)*new_r01*x581))+((cj31*new_r11))+(((-1.0)*x584)));
evalcond[5]=(x583+new_r01+(((-1.0)*x585)));
evalcond[6]=(x583+new_r10+(((-1.0)*x585)));
evalcond[7]=((((-1.0)*cj31*x584))+(((-1.0)*x579*x581))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x586=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959))))));
evalcond[1]=x586;
evalcond[2]=x586;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x586;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x587=IKsin(j33);
IkReal x588=((1.0)*(IKcos(j33)));
evalcond[0]=(x587+new_r01);
evalcond[1]=((((-1.0)*x587))+new_r10);
evalcond[2]=(new_r11+(((-1.0)*x588)));
evalcond[3]=(new_r00+(((-1.0)*x588)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x589=((1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959))))));
evalcond[1]=x589;
evalcond[2]=x589;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x590=IKcos(j33);
IkReal x591=((1.0)*(IKsin(j33)));
evalcond[0]=(x590+new_r00);
evalcond[1]=((((-1.0)*x591))+new_r10);
evalcond[2]=((((-1.0)*x590))+new_r11);
evalcond[3]=((((-1.0)*x591))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x592=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959)))))))));
evalcond[1]=x592;
evalcond[2]=x592;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x592;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x593=IKsin(j33);
IkReal x594=((1.0)*(IKcos(j33)));
evalcond[0]=(x593+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x593))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x594))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x594))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x595=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959)))))))));
evalcond[1]=x595;
evalcond[2]=x595;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x596=IKcos(j33);
IkReal x597=((1.0)*(IKsin(j33)));
evalcond[0]=(x596+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x597))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x596))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x597))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x598=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j31), 6.28318530717959))))));
evalcond[1]=x598;
evalcond[2]=x598;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x598;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x599=IKsin(j33);
IkReal x600=((1.0)*(IKcos(j33)));
evalcond[0]=(x599+new_r01);
evalcond[1]=((((-1.0)*x599))+new_r10);
evalcond[2]=((((-1.0)*x600))+new_r11);
evalcond[3]=((((-1.0)*x600))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x601=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(((-3.14159265358979)+(IKfmod(j31, 6.28318530717959)))))+(IKabs(j12)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959))))));
evalcond[1]=x601;
evalcond[2]=x601;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x601;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x602=IKsin(j33);
IkReal x603=((1.0)*(IKcos(j33)));
evalcond[0]=(x602+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x602))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x603)));
evalcond[3]=((((-1.0)*x603))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x604=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j31), 6.28318530717959))))));
evalcond[1]=x604;
evalcond[2]=x604;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x605=IKcos(j33);
IkReal x606=((1.0)*(IKsin(j33)));
evalcond[0]=(x605+new_r00);
evalcond[1]=((((-1.0)*x606))+new_r10);
evalcond[2]=((((-1.0)*x605))+new_r11);
evalcond[3]=((((-1.0)*x606))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x607=((1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(((-3.14159265358979)+(IKfmod(j31, 6.28318530717959)))))+(IKabs(j12)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959))))));
evalcond[1]=x607;
evalcond[2]=x607;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x608=IKcos(j33);
IkReal x609=((1.0)*(IKsin(j33)));
evalcond[0]=(x608+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x609)));
evalcond[2]=((((-1.0)*x608))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x609))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x611=IKPowWithIntegerCheck(sj32,-1);
if(!x611.valid){
continue;
}
IkReal x610=x611.value;
CheckValue<IkReal> x612=IKPowWithIntegerCheck(sj31,-1);
if(!x612.valid){
continue;
}
if( IKabs((x610*(x612.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x610)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x610*(x612.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x610))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x610*(x612.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x610));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x613=IKsin(j33);
IkReal x614=IKcos(j33);
IkReal x615=(cj31*cj32);
IkReal x616=((1.0)*sj31);
IkReal x617=(new_r11*sj31);
IkReal x618=(new_r10*sj31);
IkReal x619=((1.0)*sj32);
IkReal x620=((1.0)*x614);
IkReal x621=((1.0)*x613);
IkReal x622=(sj31*x613);
evalcond[0]=(((sj32*x614))+new_r20);
evalcond[1]=((((-1.0)*x613*x619))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x613))+x617);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x621))+(((-1.0)*new_r00*x616)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x620))+(((-1.0)*new_r01*x616)));
evalcond[5]=(((sj31*x614))+((x613*x615))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x620))+x618);
evalcond[7]=(x622+new_r00+(((-1.0)*x615*x620)));
evalcond[8]=(((cj32*x622))+new_r11+(((-1.0)*cj31*x620)));
evalcond[9]=((((-1.0)*cj32*x614*x616))+new_r10+(((-1.0)*cj31*x621)));
evalcond[10]=((((-1.0)*new_r21*x619))+((cj32*x617))+x613+((new_r01*x615)));
evalcond[11]=((((-1.0)*x620))+((cj32*x618))+(((-1.0)*new_r20*x619))+((new_r00*x615)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x624=IKPowWithIntegerCheck(sj32,-1);
if(!x624.valid){
continue;
}
IkReal x623=x624.value;
CheckValue<IkReal> x625=IKPowWithIntegerCheck(sj31,-1);
if(!x625.valid){
continue;
}
if( IKabs((new_r21*x623)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x623*(x625.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x623))+IKsqr((x623*(x625.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*x623), (x623*(x625.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x626=IKsin(j33);
IkReal x627=IKcos(j33);
IkReal x628=(cj31*cj32);
IkReal x629=((1.0)*sj31);
IkReal x630=(new_r11*sj31);
IkReal x631=(new_r10*sj31);
IkReal x632=((1.0)*sj32);
IkReal x633=((1.0)*x627);
IkReal x634=((1.0)*x626);
IkReal x635=(sj31*x626);
evalcond[0]=(((sj32*x627))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x626*x632)));
evalcond[2]=(((cj31*new_r01))+x630+((cj32*x626)));
evalcond[3]=((((-1.0)*new_r00*x629))+((cj31*new_r10))+(((-1.0)*x634)));
evalcond[4]=((((-1.0)*new_r01*x629))+((cj31*new_r11))+(((-1.0)*x633)));
evalcond[5]=(((sj31*x627))+new_r01+((x626*x628)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x633))+x631);
evalcond[7]=((((-1.0)*x628*x633))+x635+new_r00);
evalcond[8]=((((-1.0)*cj31*x633))+new_r11+((cj32*x635)));
evalcond[9]=((((-1.0)*cj32*x627*x629))+(((-1.0)*cj31*x634))+new_r10);
evalcond[10]=(((new_r01*x628))+(((-1.0)*new_r21*x632))+x626+((cj32*x630)));
evalcond[11]=((((-1.0)*x633))+((new_r00*x628))+(((-1.0)*new_r20*x632))+((cj32*x631)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x636 = IKatan2WithCheck((gconst162*new_r21),((-1.0)*gconst162*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x636.valid){
continue;
}
j33array[0]=x636.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x637=IKsin(j33);
IkReal x638=IKcos(j33);
IkReal x639=(cj31*cj32);
IkReal x640=((1.0)*sj31);
IkReal x641=(new_r11*sj31);
IkReal x642=(new_r10*sj31);
IkReal x643=((1.0)*sj32);
IkReal x644=((1.0)*x638);
IkReal x645=((1.0)*x637);
IkReal x646=(sj31*x637);
evalcond[0]=(((sj32*x638))+new_r20);
evalcond[1]=((((-1.0)*x637*x643))+new_r21);
evalcond[2]=(((cj31*new_r01))+x641+((cj32*x637)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x645))+(((-1.0)*new_r00*x640)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x644))+(((-1.0)*new_r01*x640)));
evalcond[5]=(((sj31*x638))+new_r01+((x637*x639)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x644))+x642);
evalcond[7]=((((-1.0)*x639*x644))+x646+new_r00);
evalcond[8]=(((cj32*x646))+new_r11+(((-1.0)*cj31*x644)));
evalcond[9]=((((-1.0)*cj32*x638*x640))+new_r10+(((-1.0)*cj31*x645)));
evalcond[10]=(((cj32*x641))+((new_r01*x639))+(((-1.0)*new_r21*x643))+x637);
evalcond[11]=(((cj32*x642))+((new_r00*x639))+(((-1.0)*x644))+(((-1.0)*new_r20*x643)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x647 = IKatan2WithCheck((gconst109*new_r12),(gconst109*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x647.valid){
continue;
}
j31array[0]=x647.value;
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x648=IKcos(j31);
IkReal x649=IKsin(j31);
IkReal x650=((1.0)*sj32);
IkReal x651=(new_r02*x648);
IkReal x652=(new_r12*x649);
IkReal x653=(sj32*x648);
IkReal x654=(sj32*x649);
evalcond[0]=(new_r02+(((-1.0)*x648*x650)));
evalcond[1]=((((-1.0)*x649*x650))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x649))+((new_r12*x648)));
evalcond[3]=((((-1.0)*x650))+x651+x652);
evalcond[4]=(((new_r10*x654))+((cj32*new_r20))+((new_r00*x653)));
evalcond[5]=(((new_r01*x653))+((new_r11*x654))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((cj32*new_r22))+((sj32*x651))+((sj32*x652)));
evalcond[7]=(((cj32*x652))+((cj32*x651))+(((-1.0)*new_r22*x650)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst162;
gconst162=IKsign(sj32);
dummyeval[0]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj32;
dummyeval[1]=sj31;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj31;
dummyeval[1]=sj32;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x655=((((-1.0)*cj32))+new_r22);
IkReal x656=((((-1.0)*sj32))+new_r02);
IkReal x657=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x655;
evalcond[2]=x655;
evalcond[3]=x656;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x656;
evalcond[8]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[9]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[10]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[11]=(((cj32*new_r02))+(((-1.0)*new_r22*x657)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x658=IKcos(j33);
IkReal x659=IKsin(j33);
IkReal x660=((1.0)*new_r02);
IkReal x661=((1.0)*x658);
evalcond[0]=(((new_r02*x658))+new_r20);
evalcond[1]=((((-1.0)*x659))+new_r10);
evalcond[2]=((((-1.0)*x661))+new_r11);
evalcond[3]=(((new_r22*x659))+new_r01);
evalcond[4]=((((-1.0)*x659*x660))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*new_r22*x661)));
evalcond[6]=((((-1.0)*new_r21*x660))+((new_r01*new_r22))+x659);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*x661))+(((-1.0)*new_r20*x660)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x662=((((-1.0)*cj32))+new_r22);
IkReal x663=((1.0)*sj32);
IkReal x664=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x662;
evalcond[2]=x662;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x663))+(((-1.0)*x664)));
evalcond[7]=(((cj32*new_r20))+(((-1.0)*new_r00*x663)));
evalcond[8]=(((cj32*new_r21))+(((-1.0)*new_r01*x663)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x663))+((cj32*new_r22)));
evalcond[10]=((((-1.0)*cj32*x664))+(((-1.0)*new_r22*x663)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x665=IKsin(j33);
IkReal x666=IKcos(j33);
IkReal x667=((1.0)*new_r22);
IkReal x668=((1.0)*x666);
evalcond[0]=(((new_r02*x665))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x668))+new_r20);
evalcond[2]=((((-1.0)*x665))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x668))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x665))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x666*x667)));
evalcond[6]=(x665+((new_r02*new_r21))+(((-1.0)*new_r01*x667)));
evalcond[7]=((((-1.0)*x668))+((new_r02*new_r20))+(((-1.0)*new_r00*x667)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x669=((-1.0)+new_r22);
IkReal x670=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x671=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=x669;
evalcond[2]=x669;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x670;
evalcond[10]=x670;
evalcond[11]=x671;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x669;
evalcond[15]=x671;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst164;
gconst164=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst165;
gconst165=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x672 = IKatan2WithCheck((gconst165*((((cj31*new_r01))+((new_r11*sj31))))),(gconst165*(((((-1.0)*cj31*new_r11))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x672.valid){
continue;
}
j33array[0]=x672.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x673=IKsin(j33);
IkReal x674=IKcos(j33);
IkReal x675=((1.0)*sj31);
IkReal x676=((1.0)*x674);
IkReal x677=(sj31*x673);
IkReal x678=((1.0)*x673);
IkReal x679=(cj31*x676);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x673);
evalcond[1]=(((sj31*x674))+((cj31*x673))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x676)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x675))+(((-1.0)*x678)));
evalcond[4]=((((-1.0)*new_r01*x675))+((cj31*new_r11))+(((-1.0)*x676)));
evalcond[5]=(x677+new_r00+(((-1.0)*x679)));
evalcond[6]=(x677+new_r11+(((-1.0)*x679)));
evalcond[7]=((((-1.0)*cj31*x678))+(((-1.0)*x674*x675))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x680 = IKatan2WithCheck((gconst164*((((new_r00*sj31))+((cj31*new_r01))))),(gconst164*(((((-1.0)*cj31*new_r00))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x680.valid){
continue;
}
j33array[0]=x680.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x681=IKsin(j33);
IkReal x682=IKcos(j33);
IkReal x683=((1.0)*sj31);
IkReal x684=((1.0)*x682);
IkReal x685=(sj31*x681);
IkReal x686=((1.0)*x681);
IkReal x687=(cj31*x684);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x681);
evalcond[1]=(((sj31*x682))+new_r01+((cj31*x681)));
evalcond[2]=((((-1.0)*x684))+((cj31*new_r00))+((new_r10*sj31)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x686))+(((-1.0)*new_r00*x683)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x683))+(((-1.0)*x684)));
evalcond[5]=((((-1.0)*x687))+x685+new_r00);
evalcond[6]=((((-1.0)*x687))+x685+new_r11);
evalcond[7]=((((-1.0)*cj31*x686))+(((-1.0)*x682*x683))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x688=((1.0)+new_r22);
IkReal x689=(cj31*new_r02);
IkReal x690=(new_r12*sj31);
IkReal x691=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=x688;
evalcond[2]=x688;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x691;
evalcond[10]=x691;
evalcond[11]=(x689+x690);
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x689))+(((-1.0)*x690)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst166;
gconst166=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst167;
gconst167=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x692=((1.0)*sj31);
CheckValue<IkReal> x693 = IKatan2WithCheck((gconst167*((((cj31*new_r10))+(((-1.0)*new_r00*x692))))),(gconst167*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x692))))),IKFAST_ATAN2_MAGTHRESH);
if(!x693.valid){
continue;
}
j33array[0]=x693.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x694=IKsin(j33);
IkReal x695=IKcos(j33);
IkReal x696=((1.0)*sj31);
IkReal x697=((1.0)*x694);
IkReal x698=(sj31*x695);
IkReal x699=((1.0)*x695);
IkReal x700=(cj31*x697);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x695);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x697)));
evalcond[2]=(((cj31*x695))+((sj31*x694))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x696))+(((-1.0)*x697)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x696))+(((-1.0)*x699)));
evalcond[5]=((((-1.0)*x700))+x698+new_r01);
evalcond[6]=((((-1.0)*x700))+x698+new_r10);
evalcond[7]=((((-1.0)*cj31*x699))+(((-1.0)*x694*x696))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x701=((1.0)*new_r00);
CheckValue<IkReal> x702 = IKatan2WithCheck((gconst166*((((cj31*new_r01))+(((-1.0)*sj31*x701))))),(gconst166*(((((-1.0)*cj31*x701))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x702.valid){
continue;
}
j33array[0]=x702.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x703=IKsin(j33);
IkReal x704=IKcos(j33);
IkReal x705=((1.0)*sj31);
IkReal x706=((1.0)*x703);
IkReal x707=(sj31*x704);
IkReal x708=((1.0)*x704);
IkReal x709=(cj31*x706);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x704);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x706)));
evalcond[2]=(((sj31*x703))+new_r00+((cj31*x704)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x706))+(((-1.0)*new_r00*x705)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x708))+(((-1.0)*new_r01*x705)));
evalcond[5]=((((-1.0)*x709))+x707+new_r01);
evalcond[6]=((((-1.0)*x709))+x707+new_r10);
evalcond[7]=((((-1.0)*x703*x705))+(((-1.0)*cj31*x708))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x710=((((-1.0)*cj32))+new_r22);
IkReal x711=((((-1.0)*sj32))+new_r02);
IkReal x712=((1.0)*sj32);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j31), 6.28318530717959))))));
evalcond[1]=x710;
evalcond[2]=x710;
evalcond[3]=x711;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x711;
evalcond[8]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[9]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[10]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[11]=((((-1.0)*new_r22*x712))+((cj32*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x713=IKcos(j33);
IkReal x714=IKsin(j33);
IkReal x715=((1.0)*new_r02);
IkReal x716=((1.0)*x713);
evalcond[0]=(((new_r02*x713))+new_r20);
evalcond[1]=((((-1.0)*x714))+new_r10);
evalcond[2]=((((-1.0)*x716))+new_r11);
evalcond[3]=(new_r01+((new_r22*x714)));
evalcond[4]=((((-1.0)*x714*x715))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x716))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x715))+((new_r01*new_r22))+x714);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x715))+(((-1.0)*x716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x717=((((-1.0)*cj32))+new_r22);
IkReal x718=((1.0)*sj32);
IkReal x719=((1.0)*new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j31, 6.28318530717959)))))+(IKabs(j12)));
evalcond[1]=x717;
evalcond[2]=x717;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x718))+(((-1.0)*x719)));
evalcond[7]=(((cj32*new_r20))+(((-1.0)*new_r00*x718)));
evalcond[8]=(((cj32*new_r21))+(((-1.0)*new_r01*x718)));
evalcond[9]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x718)));
evalcond[10]=((((-1.0)*new_r22*x718))+(((-1.0)*cj32*x719)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x720=IKsin(j33);
IkReal x721=IKcos(j33);
IkReal x722=((1.0)*new_r22);
IkReal x723=((1.0)*x721);
evalcond[0]=(((new_r02*x720))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x723))+new_r20);
evalcond[2]=((((-1.0)*x720))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x723))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((new_r22*x720)));
evalcond[5]=((((-1.0)*x721*x722))+(((-1.0)*new_r00)));
evalcond[6]=(x720+((new_r02*new_r21))+(((-1.0)*new_r01*x722)));
evalcond[7]=((((-1.0)*x723))+((new_r02*new_r20))+(((-1.0)*new_r00*x722)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x724=((-1.0)+new_r22);
IkReal x725=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x726=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959))))));
evalcond[1]=x724;
evalcond[2]=x724;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x725;
evalcond[10]=x725;
evalcond[11]=x726;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x724;
evalcond[15]=x726;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst169;
gconst169=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst170;
gconst170=IKsign(((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31)))));
dummyeval[0]=((((-1.0)*(cj31*cj31)))+(((-1.0)*(sj31*sj31))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x727 = IKatan2WithCheck((gconst170*((((cj31*new_r01))+((new_r11*sj31))))),(gconst170*(((((-1.0)*cj31*new_r11))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x727.valid){
continue;
}
j33array[0]=x727.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x728=IKsin(j33);
IkReal x729=IKcos(j33);
IkReal x730=((1.0)*sj31);
IkReal x731=((1.0)*x729);
IkReal x732=(sj31*x728);
IkReal x733=((1.0)*x728);
IkReal x734=(cj31*x731);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x728);
evalcond[1]=(((cj31*x728))+((sj31*x729))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x731)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x733))+(((-1.0)*new_r00*x730)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x731))+(((-1.0)*new_r01*x730)));
evalcond[5]=((((-1.0)*x734))+x732+new_r00);
evalcond[6]=((((-1.0)*x734))+x732+new_r11);
evalcond[7]=((((-1.0)*cj31*x733))+new_r10+(((-1.0)*x729*x730)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x735 = IKatan2WithCheck((gconst169*((((new_r00*sj31))+((cj31*new_r01))))),(gconst169*(((((-1.0)*cj31*new_r00))+((new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x735.valid){
continue;
}
j33array[0]=x735.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x736=IKsin(j33);
IkReal x737=IKcos(j33);
IkReal x738=((1.0)*sj31);
IkReal x739=((1.0)*x737);
IkReal x740=(sj31*x736);
IkReal x741=((1.0)*x736);
IkReal x742=(cj31*x739);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x736);
evalcond[1]=(((sj31*x737))+new_r01+((cj31*x736)));
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x739)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x738))+(((-1.0)*x741)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x739))+(((-1.0)*new_r01*x738)));
evalcond[5]=(x740+new_r00+(((-1.0)*x742)));
evalcond[6]=(x740+new_r11+(((-1.0)*x742)));
evalcond[7]=((((-1.0)*x737*x738))+new_r10+(((-1.0)*cj31*x741)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x743=((1.0)+new_r22);
IkReal x744=(cj31*new_r02);
IkReal x745=(new_r12*sj31);
IkReal x746=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959))))));
evalcond[1]=x743;
evalcond[2]=x743;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x746;
evalcond[10]=x746;
evalcond[11]=(x744+x745);
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*x744))+(((-1.0)*x745)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst171;
gconst171=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst172;
gconst172=IKsign(((sj31*sj31)+(cj31*cj31)));
dummyeval[0]=((sj31*sj31)+(cj31*cj31));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x747=((1.0)*sj31);
CheckValue<IkReal> x748 = IKatan2WithCheck((gconst172*(((((-1.0)*new_r00*x747))+((cj31*new_r10))))),(gconst172*(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r10*x747))))),IKFAST_ATAN2_MAGTHRESH);
if(!x748.valid){
continue;
}
j33array[0]=x748.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x749=IKsin(j33);
IkReal x750=IKcos(j33);
IkReal x751=((1.0)*sj31);
IkReal x752=((1.0)*x749);
IkReal x753=(sj31*x750);
IkReal x754=((1.0)*x750);
IkReal x755=(cj31*x752);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x750);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x752)));
evalcond[2]=(((sj31*x749))+((cj31*x750))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x751))+(((-1.0)*x752)));
evalcond[4]=((((-1.0)*new_r01*x751))+((cj31*new_r11))+(((-1.0)*x754)));
evalcond[5]=(x753+new_r01+(((-1.0)*x755)));
evalcond[6]=(x753+new_r10+(((-1.0)*x755)));
evalcond[7]=((((-1.0)*cj31*x754))+new_r11+(((-1.0)*x749*x751)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x756=((1.0)*new_r00);
CheckValue<IkReal> x757 = IKatan2WithCheck((gconst171*((((cj31*new_r01))+(((-1.0)*sj31*x756))))),(gconst171*(((((-1.0)*cj31*x756))+(((-1.0)*new_r01*sj31))))),IKFAST_ATAN2_MAGTHRESH);
if(!x757.valid){
continue;
}
j33array[0]=x757.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x758=IKsin(j33);
IkReal x759=IKcos(j33);
IkReal x760=((1.0)*sj31);
IkReal x761=((1.0)*x758);
IkReal x762=(sj31*x759);
IkReal x763=((1.0)*x759);
IkReal x764=(cj31*x761);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x759);
evalcond[1]=(((cj31*new_r01))+(((-1.0)*x761))+((new_r11*sj31)));
evalcond[2]=(((cj31*x759))+((sj31*x758))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x760))+((cj31*new_r10))+(((-1.0)*x761)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x763))+(((-1.0)*new_r01*x760)));
evalcond[5]=((((-1.0)*x764))+x762+new_r01);
evalcond[6]=((((-1.0)*x764))+x762+new_r10);
evalcond[7]=((((-1.0)*x758*x760))+(((-1.0)*cj31*x763))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x765=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959))))));
evalcond[1]=x765;
evalcond[2]=x765;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x765;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x766=IKsin(j33);
IkReal x767=((1.0)*(IKcos(j33)));
evalcond[0]=(x766+new_r01);
evalcond[1]=((((-1.0)*x766))+new_r10);
evalcond[2]=((((-1.0)*x767))+new_r11);
evalcond[3]=((((-1.0)*x767))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x768=((1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959))))))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959))))));
evalcond[1]=x768;
evalcond[2]=x768;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x769=IKcos(j33);
IkReal x770=((1.0)*(IKsin(j33)));
evalcond[0]=(x769+new_r00);
evalcond[1]=((((-1.0)*x770))+new_r10);
evalcond[2]=((((-1.0)*x769))+new_r11);
evalcond[3]=((((-1.0)*x770))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x771=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j32), 6.28318530717959)))))))));
evalcond[1]=x771;
evalcond[2]=x771;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x771;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x772=IKsin(j33);
IkReal x773=((1.0)*(IKcos(j33)));
evalcond[0]=((((-1.0)*new_r01))+x772);
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x772)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x773)));
evalcond[3]=((((-1.0)*new_r00))+(((-1.0)*x773)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x774=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)))))+(IKabs(((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(j32, 6.28318530717959)))))))));
evalcond[1]=x774;
evalcond[2]=x774;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x775=IKcos(j33);
IkReal x776=((1.0)*(IKsin(j33)));
evalcond[0]=((((-1.0)*new_r00))+x775);
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x776)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x775)));
evalcond[3]=((((-1.0)*new_r01))+(((-1.0)*x776)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x777=((-1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j31), 6.28318530717959))))));
evalcond[1]=x777;
evalcond[2]=x777;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x777;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x778=IKsin(j33);
IkReal x779=((1.0)*(IKcos(j33)));
evalcond[0]=(x778+new_r01);
evalcond[1]=(new_r10+(((-1.0)*x778)));
evalcond[2]=((((-1.0)*x779))+new_r11);
evalcond[3]=((((-1.0)*x779))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x780=((-1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(((-3.14159265358979)+(IKfmod(j31, 6.28318530717959)))))+(IKabs(j12)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959))))));
evalcond[1]=x780;
evalcond[2]=x780;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x780;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x781=IKsin(j33);
IkReal x782=((1.0)*(IKcos(j33)));
evalcond[0]=((((-1.0)*new_r01))+x781);
evalcond[1]=((((-1.0)*new_r10))+(((-1.0)*x781)));
evalcond[2]=((((-1.0)*x782))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x782))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x783=((1.0)+new_r22);
evalcond[0]=((IKabs(j12))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j31), 6.28318530717959))))));
evalcond[1]=x783;
evalcond[2]=x783;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x784=IKcos(j33);
IkReal x785=((1.0)*(IKsin(j33)));
evalcond[0]=(x784+new_r00);
evalcond[1]=((((-1.0)*x785))+new_r10);
evalcond[2]=((((-1.0)*x784))+new_r11);
evalcond[3]=((((-1.0)*x785))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x786=((1.0)+new_r22);
evalcond[0]=((IKabs(((IKabs(((-3.14159265358979)+(IKfmod(j31, 6.28318530717959)))))+(IKabs(j12)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959))))));
evalcond[1]=x786;
evalcond[2]=x786;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[4];
IkReal x787=IKcos(j33);
IkReal x788=((1.0)*(IKsin(j33)));
evalcond[0]=((((-1.0)*new_r00))+x787);
evalcond[1]=((((-1.0)*x788))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*new_r11))+(((-1.0)*x787)));
evalcond[3]=((((-1.0)*x788))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x790=IKPowWithIntegerCheck(sj32,-1);
if(!x790.valid){
continue;
}
IkReal x789=x790.value;
CheckValue<IkReal> x791=IKPowWithIntegerCheck(sj31,-1);
if(!x791.valid){
continue;
}
if( IKabs((x789*(x791.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x789)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x789*(x791.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x789))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x789*(x791.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x789));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x792=IKsin(j33);
IkReal x793=IKcos(j33);
IkReal x794=(cj31*cj32);
IkReal x795=((1.0)*sj31);
IkReal x796=(new_r11*sj31);
IkReal x797=(new_r10*sj31);
IkReal x798=((1.0)*sj32);
IkReal x799=((1.0)*x793);
IkReal x800=((1.0)*x792);
IkReal x801=(sj31*x792);
evalcond[0]=(new_r20+((sj32*x793)));
evalcond[1]=((((-1.0)*x792*x798))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x792))+x796);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x800))+(((-1.0)*new_r00*x795)));
evalcond[4]=((((-1.0)*new_r01*x795))+(((-1.0)*x799))+((cj31*new_r11)));
evalcond[5]=(((sj31*x793))+((x792*x794))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x799))+x797);
evalcond[7]=((((-1.0)*x794*x799))+new_r00+x801);
evalcond[8]=((((-1.0)*cj31*x799))+((cj32*x801))+new_r11);
evalcond[9]=((((-1.0)*cj31*x800))+(((-1.0)*cj32*x793*x795))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x798))+((cj32*x796))+((new_r01*x794))+x792);
evalcond[11]=((((-1.0)*x799))+((cj32*x797))+((new_r00*x794))+(((-1.0)*new_r20*x798)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x803=IKPowWithIntegerCheck(sj32,-1);
if(!x803.valid){
continue;
}
IkReal x802=x803.value;
CheckValue<IkReal> x804=IKPowWithIntegerCheck(sj31,-1);
if(!x804.valid){
continue;
}
if( IKabs((new_r21*x802)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x802*(x804.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x802))+IKsqr((x802*(x804.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*x802), (x802*(x804.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x805=IKsin(j33);
IkReal x806=IKcos(j33);
IkReal x807=(cj31*cj32);
IkReal x808=((1.0)*sj31);
IkReal x809=(new_r11*sj31);
IkReal x810=(new_r10*sj31);
IkReal x811=((1.0)*sj32);
IkReal x812=((1.0)*x806);
IkReal x813=((1.0)*x805);
IkReal x814=(sj31*x805);
evalcond[0]=(((sj32*x806))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x805*x811)));
evalcond[2]=(((cj31*new_r01))+((cj32*x805))+x809);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x808))+(((-1.0)*x813)));
evalcond[4]=((((-1.0)*new_r01*x808))+((cj31*new_r11))+(((-1.0)*x812)));
evalcond[5]=(((sj31*x806))+((x805*x807))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x812))+x810);
evalcond[7]=((((-1.0)*x807*x812))+new_r00+x814);
evalcond[8]=(((cj32*x814))+(((-1.0)*cj31*x812))+new_r11);
evalcond[9]=((((-1.0)*cj32*x806*x808))+(((-1.0)*cj31*x813))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x811))+((new_r01*x807))+((cj32*x809))+x805);
evalcond[11]=(((cj32*x810))+(((-1.0)*x812))+(((-1.0)*new_r20*x811))+((new_r00*x807)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x815 = IKatan2WithCheck((gconst162*new_r21),((-1.0)*gconst162*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x815.valid){
continue;
}
j33array[0]=x815.value;
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x816=IKsin(j33);
IkReal x817=IKcos(j33);
IkReal x818=(cj31*cj32);
IkReal x819=((1.0)*sj31);
IkReal x820=(new_r11*sj31);
IkReal x821=(new_r10*sj31);
IkReal x822=((1.0)*sj32);
IkReal x823=((1.0)*x817);
IkReal x824=((1.0)*x816);
IkReal x825=(sj31*x816);
evalcond[0]=(new_r20+((sj32*x817)));
evalcond[1]=((((-1.0)*x816*x822))+new_r21);
evalcond[2]=(((cj32*x816))+((cj31*new_r01))+x820);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x824))+(((-1.0)*new_r00*x819)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x823))+(((-1.0)*new_r01*x819)));
evalcond[5]=(((x816*x818))+((sj31*x817))+new_r01);
evalcond[6]=((((-1.0)*cj32*x823))+((cj31*new_r00))+x821);
evalcond[7]=((((-1.0)*x818*x823))+new_r00+x825);
evalcond[8]=(((cj32*x825))+(((-1.0)*cj31*x823))+new_r11);
evalcond[9]=((((-1.0)*cj32*x817*x819))+(((-1.0)*cj31*x824))+new_r10);
evalcond[10]=(((cj32*x820))+((new_r01*x818))+(((-1.0)*new_r21*x822))+x816);
evalcond[11]=(((cj32*x821))+((new_r00*x818))+(((-1.0)*new_r20*x822))+(((-1.0)*x823)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "c363859a2d7a151a22dc1e251d6d8669"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
