/// autogenerated analytical inverse kinematics code from ikfast program
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// generated 2010-10-28 00:10:10.474052
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object:
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -shared -Wl,-soname,ik.so -o ik.so ik.cpp
#include <cmath>
#include <cassert>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                assert(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

inline float IKasin(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline float IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

IKFAST_API int getNumFreeParameters() { return 1; }
IKFAST_API int* getFreeParameters() { static int freeparams[] = {0}; return freeparams; }
IKFAST_API int getNumJoints() { return 3; }

IKFAST_API int getIKRealSize() { return sizeof(IKReal); }

IKFAST_API int getIKType() { return 6; }

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {
    IKReal x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, __dummy__;
    x0=IKcos(j[1]);
    x1=IKsin(j[2]);
    x2=((0.121380000000000)*(x1));
    x3=IKcos(j[2]);
    x4=((0.0494500000000000)*(x3));
    x5=((0.0680000000000000)+(x2)+(x4));
    x6=IKsin(j[1]);
    x7=((0.999801572239199)*(x3));
    x8=((0.00408346724546153)*(x1));
    x9=((x7)+(((-1.00000000000000)*(x8))));
    eetrans[0]=((-0.0670700000000000)+(((x0)*(x5)))+(((-0.0313600000000000)*(x6))));
    eetrans[1]=((((x5)*(x6)))+(((0.0313600000000000)*(x0))));
    eetrans[2]=((1.12113000000000)+(((-0.0494500000000000)*(x1)))+(((0.121380000000000)*(x3)))+(j[0]));
    eerot[0]=((((x0)*(x9)))+(((-0.0194972162957103)*(x6))));
    eerot[1]=((((0.0194972162957103)*(x0)))+(((x6)*(x9))));
    eerot[2]=((((-0.00408346724546153)*(x3)))+(((-0.999801572239199)*(x1))));
}

class IKSolver {
public:
IKReal j1, cj1, sj1,
j2, cj2, sj2,
j0, cj0, sj0,
new_px, new_py, new_pz, px, py, pz;

bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    vsolutions.resize(0); vsolutions.reserve(8);
    px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
    
    j0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]);
    new_px=((0.0670700000000000)+(px));
    new_py=py;
    new_pz=((-1.12113000000000)+(pz));
    px = new_px; py = new_py; pz = new_pz;
    {
        if( 1 )
        {
        IKReal op[6+1], zeror[6];
        int numroots;
        IKReal j1evalpoly[3];
        IKReal x0=(px)*(px);
        IKReal x1=(py)*(py);
        IKReal x2=(px)*(px)*(px)*(px);
        IKReal x3=(py)*(py)*(py)*(py);
        IKReal x4=(px)*(px)*(px);
        IKReal x5=(py)*(py)*(py);
        IKReal x6=(px)*(px)*(px)*(px)*(px)*(px);
        IKReal x7=(j0)*(j0);
        IKReal x8=(pz)*(pz);
        IKReal x9=(py)*(py)*(py)*(py)*(py)*(py);
        IKReal x10=(py)*(py)*(py)*(py)*(py);
        IKReal x11=(px)*(px)*(px)*(px)*(px);
        IKReal x12=(pz)*(pz)*(pz)*(pz);
        IKReal x13=(j0)*(j0)*(j0)*(j0);
        IKReal x14=(pz)*(pz)*(pz);
        IKReal x15=(j0)*(j0)*(j0);
        IKReal x16=((9.70002687301235e-15)*(px)*(x0)*(x7));
        IKReal x17=((9.70002687301235e-15)*(px)*(x0)*(x8));
        IKReal x18=((1.94000537460247e-14)*(j0)*(px)*(pz)*(x0));
        IKReal x19=((1.42647454014887e-13)*(j0)*(pz)*(x0)*(x7));
        IKReal x20=((1.42647454014887e-13)*(j0)*(pz)*(x0)*(x8));
        IKReal x21=((3.56618635037219e-14)*(x0)*(x12));
        IKReal x22=((2.13971181022331e-13)*(x0)*(x7)*(x8));
        IKReal x23=((3.56618635037219e-14)*(x0)*(x13));
        op[0]=((((7.40346196557906e-7)*(x1)*(x2)))+(((2.46782065519302e-7)*(x1)*(x3)))+(((2.46782065519302e-7)*(x0)*(x2)))+(((7.40346196557906e-7)*(x0)*(x3))));
        op[1]=((((-3.31525678328902e-7)*(x1)*(x5)))+(((-2.55168886330133e-11)*(px)*(x3)))+(((-5.10337772660267e-11)*(px)*(x0)*(x1)))+(((-6.63051356657805e-7)*(py)*(x0)*(x1)))+(((-2.55168886330133e-11)*(x0)*(x4)))+(((-3.31525678328902e-7)*(py)*(x2))));
        op[2]=((((1.30129335870576e-7)*(x3)))+(((1.87624181125098e-10)*(x2)*(x7)))+(((1.87624181125098e-10)*(x2)*(x8)))+(((-7.40533820739031e-7)*(x0)*(x3)))+(((2.22684893675861e-7)*(x0)*(x1)))+(((9.25555578052848e-8)*(x2)))+(((-3.75248362250196e-10)*(j0)*(pz)*(x2)))+(((3.11770282710248e-11)*(px)*(py)*(x1)))+(((-1.48050476893469e-6)*(x1)*(x2)))+(((-1.87624181125098e-10)*(x3)*(x7)))+(((-1.87624181125098e-10)*(x3)*(x8)))+(((-7.40158572376781e-7)*(x0)*(x2)))+(((3.75248362250196e-10)*(j0)*(pz)*(x3)))+(((-1.87624181125098e-10)*(x1)*(x3)))+(((3.11770282710248e-11)*(px)*(py)*(x0))));
        op[3]=((((2.40648077311900e-10)*(x1)*(x5)))+(((-1.00000000000000)*(x16)))+(((-1.00000000000000)*(x17)))+(((-9.70002687301235e-15)*(px)*(x1)*(x7)))+(((-9.70002687301235e-15)*(px)*(x1)*(x8)))+(((5.10240772391537e-11)*(x0)*(x4)))+(((4.35675265112225e-10)*(j0)*(py)*(pz)*(x0)))+(((5.10240772391537e-11)*(px)*(x3)))+(((6.63074167102561e-7)*(py)*(x0)*(x1)))+(((-9.49949453952907e-12)*(px)*(x1)))+(((1.02048154478307e-10)*(px)*(x0)*(x1)))+(x18)+(((6.62833519025248e-7)*(py)*(x2)))+(((1.94000537460247e-14)*(j0)*(px)*(pz)*(x1)))+(((2.40648077311900e-10)*(py)*(x1)*(x8)))+(((2.40648077311900e-10)*(py)*(x1)*(x7)))+(((-2.17837632556112e-10)*(py)*(x0)*(x7)))+(((-2.17837632556112e-10)*(py)*(x0)*(x8)))+(((-9.49949453952907e-12)*(px)*(x0)))+(((-4.81296154623800e-10)*(j0)*(py)*(pz)*(x1)))+(((-1.28989149592682e-8)*(py)*(x1)))+(((-1.17796664846003e-8)*(py)*(x0))));
        op[4]=((((7.50354077046377e-10)*(j0)*(pz)*(x2)))+(((-1.42647454014887e-13)*(j0)*(pz)*(x3)))+(((-6.38933151049190e-11)*(px)*(py)*(x1)))+(((-1.00000000000000)*(x19)))+(((-1.00000000000000)*(x20)))+(((2.13971181022331e-13)*(x1)*(x7)*(x8)))+(((6.98492245553608e-11)*(x0)*(x8)))+(((6.98492245553608e-11)*(x0)*(x7)))+(((-3.27162868338942e-11)*(px)*(py)*(x0)))+(((-3.75177038523189e-10)*(x2)*(x8)))+(((-3.75177038523189e-10)*(x2)*(x7)))+(((1.69600693311115e-10)*(x0)))+(((-2.89321456774751e-14)*(px)*(py)))+(((5.45498764552681e-10)*(x1)))+(((-8.41332343804748e-11)*(x3)))+(((1.18516805241821e-14)*(px)*(py)*(x8)))+(((1.18516805241821e-14)*(px)*(py)*(x7)))+(((1.68265149557295e-10)*(j0)*(pz)*(x1)))+(((1.06985590511166e-13)*(x0)*(x3)))+(((7.39971055181247e-7)*(x1)*(x2)))+(((-1.42647454014887e-13)*(j0)*(pz)*(x1)*(x7)))+(((-1.42647454014887e-13)*(j0)*(pz)*(x1)*(x8)))+(x21)+(x22)+(x23)+(((3.56618635037219e-14)*(x1)*(x3)))+(((-8.41325747786475e-11)*(x1)*(x8)))+(((-8.41325747786475e-11)*(x1)*(x7)))+(((7.39970983857520e-7)*(x0)*(x2)))+(((1.42647454014887e-13)*(x0)*(x1)*(x7)))+(((1.42647454014887e-13)*(x0)*(x1)*(x8)))+(((-2.85294908029775e-13)*(j0)*(pz)*(x0)*(x1)))+(((-2.37033610483641e-14)*(j0)*(px)*(py)*(pz)))+(((-2.22699177026085e-7)*(x0)*(x1)))+(((-1.85041265726412e-7)*(x2)))+(((7.13237270074437e-14)*(x3)*(x7)))+(((7.13237270074437e-14)*(x3)*(x8)))+(((-1.39698449110722e-10)*(j0)*(pz)*(x0)))+(((3.56618635037219e-14)*(x1)*(x12)))+(((3.56618635037219e-14)*(x1)*(x13))));
        op[5]=((((-1.00000000000000)*(x18)))+(((8.83746385287187e-15)*(px)))+(((9.49587438638192e-12)*(px)*(x0)))+(((-4.35723548683164e-14)*(py)*(x12)))+(((-4.35723548683164e-14)*(py)*(x13)))+(((4.46928660228611e-12)*(py)*(x7)))+(((4.46928660228611e-12)*(py)*(x8)))+(((2.09379045562780e-11)*(px)*(x1)))+(((4.47009251656175e-12)*(py)*(x1)))+(((2.17750487846376e-10)*(py)*(x0)*(x1)))+(((2.17750487846376e-10)*(py)*(x0)*(x7)))+(((2.17750487846376e-10)*(py)*(x0)*(x8)))+(((-3.31307884268701e-7)*(py)*(x2)))+(((-2.61434129209898e-13)*(py)*(x7)*(x8)))+(((-2.55071886061403e-11)*(x0)*(x4)))+(x17)+(x16)+(((1.74289419473266e-13)*(j0)*(py)*(pz)*(x8)))+(((1.74289419473266e-13)*(j0)*(py)*(pz)*(x7)))+(((1.74289419473266e-13)*(j0)*(py)*(pz)*(x1)))+(((-4.35500975692751e-10)*(j0)*(py)*(pz)*(x0)))+(((-3.62015314715452e-15)*(px)*(x8)))+(((-3.62015314715452e-15)*(px)*(x7)))+(((1.17841349652883e-8)*(py)*(x0)))+(((-8.93857320457222e-12)*(j0)*(py)*(pz)))+(((-4.35723548683164e-14)*(x1)*(x5)))+(((-5.10240772391537e-11)*(px)*(x0)*(x1)))+(((-8.71447097366328e-14)*(py)*(x1)*(x8)))+(((-8.71447097366328e-14)*(py)*(x1)*(x7)))+(((-1.06506913545846e-11)*(py)))+(((7.24030629430904e-15)*(j0)*(px)*(pz))));
        op[6]=((7.93157533430809e-14)+(((9.24857212305142e-8)*(x2)))+(((-1.00000000000000)*(x23)))+(((-1.00000000000000)*(x22)))+(((-1.00000000000000)*(x21)))+(((1.42647454014887e-13)*(j0)*(pz)*(x0)*(x1)))+(((-3.75105714796181e-10)*(j0)*(pz)*(x2)))+(((-6.49813518593520e-14)*(x8)))+(((-6.49813518593520e-14)*(x7)))+(((1.87552857398091e-10)*(x1)*(x2)))+(((-5.32375462816841e-14)*(j0)*(pz)*(x1)))+(((-5.32375462816841e-14)*(j0)*(pz)*(x7)))+(((-5.32375462816841e-14)*(j0)*(pz)*(x8)))+(((-6.52275222733585e-14)*(x1)))+(((7.98563194225261e-14)*(x7)*(x8)))+(((2.66187731408420e-14)*(x1)*(x7)))+(((2.66187731408420e-14)*(x1)*(x8)))+(((1.55111024339356e-12)*(px)*(py)*(x0)))+(((4.39735813042862e-31)*(j0)*(px)*(py)*(pz)))+(x19)+(x20)+(((-5.78890832233436e-13)*(px)*(py)))+(((-6.98226057822200e-11)*(x0)*(x8)))+(((-6.98226057822200e-11)*(x0)*(x7)))+(((1.29962703718704e-13)*(j0)*(pz)))+(((-7.13237270074437e-14)*(x0)*(x1)*(x8)))+(((-7.13237270074437e-14)*(x0)*(x1)*(x7)))+(((-3.56618635037219e-14)*(x0)*(x3)))+(((1.33093865704210e-14)*(x3)))+(((1.39645211564440e-10)*(j0)*(pz)*(x0)))+(((-2.46594477000041e-7)*(x0)*(x2)))+(((-1.69665428492560e-10)*(x0)))+(((-2.19867906521431e-31)*(px)*(py)*(x8)))+(((-2.19867906521431e-31)*(px)*(py)*(x7)))+(((-2.19867906521431e-31)*(px)*(py)*(x1)))+(((1.87552857398091e-10)*(x2)*(x7)))+(((1.87552857398091e-10)*(x2)*(x8)))+(((1.33093865704210e-14)*(x13)))+(((1.33093865704210e-14)*(x12)))+(((-6.98219461803926e-11)*(x0)*(x1))));
        polyroots6(op,zeror,numroots);
        IKReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
        int numsolutions = 0;
        for(int ij1 = 0; ij1 < numroots; ++ij1)
        {
            cj1 = zeror[ij1];
            IKReal x24=x7;
            IKReal x25=x8;
            IKReal x26=x1;
            IKReal x27=x0;
            IKReal x28=x5;
            IKReal x29=(cj1)*(cj1);
            IKReal x30=x4;
            tempj1array[0]=IKatan2(((-1.00000000000000)*(((IKabs(((((-1.88843489439594e-7)*(px)*(x24)))+(((-1.88843489439594e-7)*(px)*(x25)))+(((-1.88843489439594e-7)*(px)*(x26)))+(((0.000496582799742440)*(px)*(x27)))+(((x29)*(((((0.00149031492969564)*(px)*(x26)))+(((-0.000496771643231880)*(px)*(x27)))))))+(((1.56898188009456e-8)*(py)))+(((1.89089788926183e-5)*(px)))+(((3.77686978879187e-7)*(j0)*(px)*(pz)))+(((cj1)*(((((-2.56827145637847e-8)*(x26)))+(((2.56827145637847e-8)*(x27)))+(((-0.000667360311011462)*(px)*(py))))))))) != 0)?((IKReal)1/(((((-1.88843489439594e-7)*(px)*(x24)))+(((-1.88843489439594e-7)*(px)*(x25)))+(((-1.88843489439594e-7)*(px)*(x26)))+(((0.000496582799742440)*(px)*(x27)))+(((x29)*(((((0.00149031492969564)*(px)*(x26)))+(((-0.000496771643231880)*(px)*(x27)))))))+(((1.56898188009456e-8)*(py)))+(((1.89089788926183e-5)*(px)))+(((3.77686978879187e-7)*(j0)*(px)*(pz)))+(((cj1)*(((((-2.56827145637847e-8)*(x26)))+(((2.56827145637847e-8)*(x27)))+(((-0.000667360311011462)*(px)*(py)))))))))):(IKReal)1.0e30))*(((2.81630526298342e-7)+(((0.000333564789191018)*(x27)))+(((x29)*(((((0.000333680155505731)*(x26)))+(((-0.000333680155505731)*(x27)))+(((-5.13654291275694e-8)*(px)*(py)))))))+(((2.30732629425671e-7)*(j0)*(pz)))+(((cj1)*(((((-3.77686978879187e-7)*(j0)*(py)*(pz)))+(((-1.89089788926183e-5)*(py)))+(((-0.00149012608620620)*(py)*(x27)))+(((1.88843489439594e-7)*(py)*(x26)))+(((1.88843489439594e-7)*(py)*(x24)))+(((1.88843489439594e-7)*(py)*(x25)))+(((1.56898188009456e-8)*(px)))))))+(((2.56827145637847e-8)*(px)*(py)))+((((cj1)*(cj1)*(cj1))*(((((-0.000496771643231880)*(py)*(x26)))+(((0.00149031492969564)*(py)*(x27)))))))+(((-1.15366314712836e-7)*(x25)))+(((-1.15366314712836e-7)*(x24)))+(((-1.15366314712836e-7)*(x26)))))), cj1);
            for(int kj1 = 0; kj1 < 1; ++kj1)
            {
            j1array[numsolutions] = tempj1array[kj1];
            if( j1array[numsolutions] > IKPI )
                j1array[numsolutions]-=IK2PI;
            else if( j1array[numsolutions] < -IKPI )
                j1array[numsolutions]+=IK2PI;
            cj1array[numsolutions] = zeror[ij1];
            sj1array[numsolutions] = IKsin(j1array[numsolutions]);
            bool valid = true;
            for( int jj1 = 0; jj1 < numsolutions; ++jj1)
            {
                if( IKabs(cj1array[jj1]-cj1array[numsolutions]) < 0.0001 && IKabs(sj1array[jj1]-sj1array[numsolutions]) < 0.0001 )
                {
                    valid=false; break;
                }
            }
            if( valid ) { numsolutions++; }
            }
        }
        for(int ij1 = 0; ij1 < numsolutions; ++ij1)
            {
            j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
        
            j1evalpoly[0]=((0.00249512474880781)+(((-0.00408427767953597)*(cj1)*(py)))+(((0.00408427767953597)*(px)*(sj1))));
            j1evalpoly[1]=((0.000930122481568997)+(((-2.00003336264833)*(cj1)*(px)*(py)*(sj1)))+(((0.0608117241738253)*(px)*(sj1)))+(((1.00001668132416)*((cj1)*(cj1))*((py)*(py))))+(((1.00001668132416)*((px)*(px))*((sj1)*(sj1))))+(((-0.0608117241738253)*(cj1)*(py))));
            j1evalpoly[2]=((0.000161226666312189)+(((sj1)*(((((1.00001668132416)*(px)*(pz)))+(((-0.00237098038694395)*(py)))+(((-1.00001668132416)*(j0)*(px)))))))+(((cj1)*(((((-1.00001668132416)*(py)*(pz)))+(((-0.00237098038694395)*(px)))+(((1.00001668132416)*(j0)*(py)))))))+(((0.0304058620869126)*(pz)))+(((-0.0304058620869126)*(j0))));
            if( IKabs(j1evalpoly[0]) < 0.000001  || IKabs(j1evalpoly[1]) < 0.000001  || IKabs(j1evalpoly[2]) < 0.000001  )
            {
                continue;
            }
            IKReal x31=((7.96478496741179e-5)*(j0)*(px));
            IKReal x32=((0.000496574516221964)*(py));
            IKReal x33=((7.96478496741179e-5)*(px)*(pz));
            IKReal x34=((x33)+(x32));
            IKReal x35=((((-1.00000000000000)*(x34)))+(x31));
            IKReal x36=((7.96478496741179e-5)*(j0)*(py));
            IKReal x37=((0.000496574516221964)*(px));
            IKReal x38=((x37)+(x36));
            IKReal x39=((7.96478496741179e-5)*(py)*(pz));
            IKReal x40=((((-1.00000000000000)*(x39)))+(x38));
            IKReal x41=x8;
            IKReal x42=x7;
            IKReal x43=((0.0304058620869126)*(pz));
            IKReal x44=((1.00001668132416)*(j0)*(py));
            IKReal x45=((1.00001668132416)*(py)*(pz));
            IKReal x46=((0.00237098038694395)*(px));
            IKReal x47=((x46)+(x45));
            IKReal x48=((((-1.00000000000000)*(x47)))+(x44));
            IKReal x49=((cj1)*(x48));
            IKReal x50=((1.00001668132416)*(px)*(pz));
            IKReal x51=((1.00001668132416)*(j0)*(px));
            IKReal x52=((0.00237098038694395)*(py));
            IKReal x53=((x51)+(x52));
            IKReal x54=((x50)+(((-1.00000000000000)*(x53))));
            IKReal x55=((sj1)*(x54));
            IKReal x56=((0.000161226666312189)+(x49)+(x43)+(x55));
            IKReal x57=((0.0304058620869126)*(j0));
            IKReal x58=((x56)+(((-1.00000000000000)*(x57))));
            IKReal x59=((IKabs(x58) != 0)?((IKReal)1/(x58)):(IKReal)1.0e30);
            IKReal x60=((cj1)*(x35));
            IKReal x61=((sj1)*(x40));
            IKReal x62=((5.41605377784002e-6)*(pz));
            IKReal x63=((0.0390021717050184)*(j0)*(pz));
            IKReal x64=((0.000303362176195977)+(x60)+(x61)+(x62)+(x63));
            IKReal x65=((0.0195010858525092)*(x41));
            IKReal x66=((0.0195010858525092)*(x42));
            IKReal x67=((5.41605377784002e-6)*(j0));
            IKReal x68=((x65)+(x66)+(x67));
            IKReal x69=((x64)+(((-1.00000000000000)*(x68))));
            j1evalpoly[0]=((-1.00000000000000)+((((x59)*(x59))*((x69)*(x69))))+(((((IKabs(((0.00249512474880781)+(((-0.00408427767953597)*(cj1)*(py)))+(((0.00408427767953597)*(px)*(sj1))))) != 0)?(pow(((0.00249512474880781)+(((-0.00408427767953597)*(cj1)*(py)))+(((0.00408427767953597)*(px)*(sj1)))),-2.00000000000000)):(IKReal)1.0e30))*((((((x59)*(((9.22089699389908e-6)+(((-0.000592748595655526)*(x41)))+(((-0.000592748595655526)*(x42)))+(((0.00118549719131105)*(j0)*(pz)))+(((-1.64624590399227e-7)*(j0)))+(((0.0303956713045934)*(x60)))+(((0.0303956713045934)*(x61)))+(((1.64624590399227e-7)*(pz)))))))+(((-1.00000000000000)*(cj1)*(py)*(x59)*(x69)))+(((-0.0195010858525092)*(j0)))+(((px)*(sj1)*(x59)*(x69)))+(((0.0195010858525092)*(pz)))))*(((((x59)*(((9.22089699389908e-6)+(((-0.000592748595655526)*(x41)))+(((-0.000592748595655526)*(x42)))+(((0.00118549719131105)*(j0)*(pz)))+(((-1.64624590399227e-7)*(j0)))+(((0.0303956713045934)*(x60)))+(((0.0303956713045934)*(x61)))+(((1.64624590399227e-7)*(pz)))))))+(((-1.00000000000000)*(cj1)*(py)*(x59)*(x69)))+(((-0.0195010858525092)*(j0)))+(((px)*(sj1)*(x59)*(x69)))+(((0.0195010858525092)*(pz)))))))));
            if( IKabs(j1evalpoly[0]) > 0.000001  )
            {
                continue;
            }
        {
            IKReal j2eval[1];
            j2eval[0]=(((((0.0303896399595984)+(((-0.999801572239199)*(cj1)*(py)))+(((0.999801572239199)*(px)*(sj1)))))*(((0.0303896399595984)+(((-0.999801572239199)*(cj1)*(py)))+(((0.999801572239199)*(px)*(sj1))))))+((((0.00249462964679099)+(((-0.00408346724546153)*(cj1)*(py)))+(((0.00408346724546153)*(px)*(sj1)))))*(((0.00249462964679099)+(((-0.00408346724546153)*(cj1)*(py)))+(((0.00408346724546153)*(px)*(sj1)))))));
            if( IKabs(j2eval[0]) < 0.000001  )
            {
                {
                    if( 1 )
                    {
                    {
                        IKReal j2eval[1];
                        j2eval[0]=((((-1.00000000000000)*(((0.0303896399595984)+(((-0.999801572239199)*(cj1)*(py)))+(((0.999801572239199)*(px)*(sj1)))))*(((0.000277675772691384)+(((-0.00408346724546153)*(py)*(sj1)))+(((0.999801572239199)*(j0)))+(((-0.00408346724546153)*(cj1)*(px)))+(((-0.999801572239199)*(pz)))))))+(((((0.00249462964679099)+(((-0.00408346724546153)*(cj1)*(py)))+(((0.00408346724546153)*(px)*(sj1)))))*(((0.0679865069122655)+(((-0.999801572239199)*(cj1)*(px)))+(((-0.999801572239199)*(py)*(sj1)))+(((0.00408346724546153)*(pz)))+(((-0.00408346724546153)*(j0))))))));
                        if( IKabs(j2eval[0]) < 0.000001  )
                        {
                            {
                                if( 1 )
                                {
                                continue;
                            
                            } else
                            {
                            }
                            }
                        
                        } else
                        {
                            {
                            IKReal j2array[1], cj2array[1], sj2array[1];
                            bool j2valid[1]={false};
                            IKReal x70=((0.999801572239199)*(j0));
                            IKReal x71=((0.000277675772691384)+(x70));
                            IKReal x72=((0.00408346724546153)*(cj1)*(px));
                            IKReal x73=((0.999801572239199)*(pz));
                            IKReal x74=((0.00408346724546153)*(py)*(sj1));
                            IKReal x75=((x74)+(x73)+(x72));
                            IKReal x76=((((-1.00000000000000)*(x75)))+(x71));
                            IKReal x77=((0.0194972162957103)*(j0));
                            IKReal x78=((0.00408346724546153)*(pz));
                            IKReal x79=((0.0679865069122655)+(x78));
                            IKReal x80=((0.999801572239199)*(py)*(sj1));
                            IKReal x81=((0.00408346724546153)*(j0));
                            IKReal x82=((0.999801572239199)*(cj1)*(px));
                            IKReal x83=((x82)+(x80)+(x81));
                            IKReal x84=((x79)+(((-1.00000000000000)*(x83))));
                            IKReal x85=((0.00408346724546153)*(px)*(sj1));
                            IKReal x86=((0.00249462964679099)+(x85));
                            IKReal x87=((0.00408346724546153)*(cj1)*(py));
                            IKReal x88=((x86)+(((-1.00000000000000)*(x87))));
                            IKReal x89=((x84)*(x88));
                            IKReal x90=((0.999801572239199)*(px)*(sj1));
                            IKReal x91=((0.0303896399595984)+(x90));
                            IKReal x92=((0.999801572239199)*(cj1)*(py));
                            IKReal x93=((x91)+(((-1.00000000000000)*(x92))));
                            IKReal x94=((x76)*(x93));
                            IKReal x95=((x89)+(((-1.00000000000000)*(x94))));
                            IKReal x96=((IKabs(x95) != 0)?((IKReal)1/(x95)):(IKReal)1.0e30);
                            j2array[0]=IKatan2(((-1.00000000000000)*(x96)*(((0.000303241797185762)+(((0.000496377467435229)*(px)*(sj1)))+(((-0.000496377467435229)*(cj1)*(py)))+(((-1.00000000000000)*(x76)*(((((-0.0194972162957103)*(pz)))+(x77)))))))), ((x96)*(((0.00369409906157064)+(((0.121533721843228)*(px)*(sj1)))+(((-0.121533721843228)*(cj1)*(py)))+(((x84)*(((((-1.00000000000000)*(x77)))+(((0.0194972162957103)*(pz)))))))))));
                            sj2array[0]=IKsin(j2array[0]);
                            cj2array[0]=IKcos(j2array[0]);
                            if( j2array[0] > IKPI )
                                j2array[0]-=IK2PI;
                            else if( j2array[0] < -IKPI )
                                j2array[0]+=IK2PI;
                            j2valid[0] = true;
                            for(int ij2 = 0; ij2 < 1; ++ij2)
                            {
                            if( !j2valid[ij2] ) { continue; }
                            j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
                            
                            vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
                            solution.basesol.resize(3);
                            solution.basesol[0].foffset = j0;
                            solution.basesol[1].foffset = j1;
                            solution.basesol[2].foffset = j2;
                            solution.vfree.resize(0);
                            }
                            }
                        
                        }
                    
                    }
                
                } else
                {
                }
                }
            
            } else
            {
                {
                IKReal j2array[1], cj2array[1], sj2array[1];
                bool j2valid[1]={false};
                IKReal x97=((0.00408346724546153)*(px)*(sj1));
                IKReal x98=((0.00249462964679099)+(x97));
                IKReal x99=((0.00408346724546153)*(cj1)*(py));
                IKReal x100=((x98)+(((-1.00000000000000)*(x99))));
                IKReal x101=((0.999801572239199)*(px)*(sj1));
                IKReal x102=((0.0303896399595984)+(x101));
                IKReal x103=((0.999801572239199)*(cj1)*(py));
                IKReal x104=((((-1.00000000000000)*(x103)))+(x102));
                IKReal x105=(x104)*(x104);
                IKReal x106=(x100)*(x100);
                IKReal x107=((x105)+(x106));
                IKReal x108=((IKabs(x107) != 0)?((IKReal)1/(x107)):(IKReal)1.0e30);
                IKReal x109=((0.0194972162957103)*(pz));
                IKReal x110=((0.0194972162957103)*(j0));
                IKReal x111=((((-1.00000000000000)*(x110)))+(x109));
                IKReal x112=((0.0194972162957103)*(cj1)*(px));
                IKReal x113=((0.0194972162957103)*(py)*(sj1));
                j2array[0]=IKatan2(((x108)*(((((x104)*(x111)))+(((-1.00000000000000)*(x100)*(((0.00132581070810830)+(((-0.0194972162957103)*(cj1)*(px)))+(((-0.0194972162957103)*(py)*(sj1)))))))))), ((x108)*(((((x100)*(x111)))+(((x104)*(((0.00132581070810830)+(((-1.00000000000000)*(x112)))+(((-1.00000000000000)*(x113)))))))))));
                sj2array[0]=IKsin(j2array[0]);
                cj2array[0]=IKcos(j2array[0]);
                if( j2array[0] > IKPI )
                    j2array[0]-=IK2PI;
                else if( j2array[0] < -IKPI )
                    j2array[0]+=IK2PI;
                j2valid[0] = true;
                for(int ij2 = 0; ij2 < 1; ++ij2)
                {
                if( !j2valid[ij2] ) { continue; }
                j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
                
                vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
                solution.basesol.resize(3);
                solution.basesol[0].foffset = j0;
                solution.basesol[1].foffset = j1;
                solution.basesol[2].foffset = j2;
                solution.vfree.resize(0);
                }
                }
            
            }
        
        }
            }
    
    } else
    {
    }
    }
}
return vsolutions.size()>0;
}

    /// Durand-Kerner polynomial root finding method
    static void polyroots6(IKReal rawcoeffs[6+1], IKReal rawroots[6], int& numroots)
    {
        using std::complex;
        assert(rawcoeffs[0] != 0);
        const IKReal tol = 128.0*std::numeric_limits<IKReal>::epsilon();
        complex<IKReal> coeffs[6];
        const int maxsteps = 50;
        for(int i = 0; i < 6; ++i) {
            coeffs[i] = complex<IKReal>(rawcoeffs[i+1]/rawcoeffs[0]);
        }
        complex<IKReal> roots[6];
        IKReal err[6];
        roots[0] = complex<IKReal>(1,0);
        roots[1] = complex<IKReal>(0.4,0.9); // any complex number not a root of unity is works
        err[0] = 1.0;
        err[1] = 1.0;
        for(int i = 2; i < 6; ++i) {
            roots[i] = roots[i-1]*roots[1];
            err[i] = 1.0;
        }
        for(int step = 0; step < maxsteps; ++step) {
            bool changed = false;
            for(int i = 0; i < 6; ++i) {
                if ( err[i] >= tol ) {
                    changed = true;
                    // evaluate
                    complex<IKReal> x = roots[i] + coeffs[0];
                    for(int j = 1; j < 6; ++j) {
                        x = roots[i] * x + coeffs[j];
                    }
                    for(int j = 0; j < 6; ++j) {
                        if( i != j ) {
                            if( roots[i] != roots[j] ) {
                                x /= (roots[i] - roots[j]);
                            }
                        }
                    }
                    roots[i] -= x;
                    err[i] = abs(x);
                }
            }
            if( !changed ) {
                break;
            }
        }
        numroots = 0;
        for(int i = 0; i < 6; ++i) {
            if( IKabs(imag(roots[i])) < std::numeric_limits<IKReal>::epsilon() ) {
                rawroots[numroots++] = real(roots[i]);
            }
        }
    }
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
IKSolver solver;
return solver.ik(eetrans,eerot,pfree,vsolutions);
}

IKFAST_API const char* getKinematicsHash() { return "da61455279f74c4a21f17e52faf0abba"; }

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\n");
    }
    return 0;
}

#endif
