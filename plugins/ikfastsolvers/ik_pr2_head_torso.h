/// autogenerated analytical inverse kinematics code from ikfast program
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// generated 2010-11-18 17:20:33.399116
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object:
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -shared -Wl,-soname,ik.so -o ik.so ik.cpp
#include <cmath>
#include <cassert>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                assert(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

inline float IKasin(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline float IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

IKFAST_API int getNumFreeParameters() { return 1; }
IKFAST_API int* getFreeParameters() { static int freeparams[] = {0}; return freeparams; }
IKFAST_API int getNumJoints() { return 3; }

IKFAST_API int getIKRealSize() { return sizeof(IKReal); }

IKFAST_API int getIKType() { return 6; }

/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {
IKReal x0, x1, x2, x3, __dummy__;
x0=IKcos(j[1]);
x1=IKsin(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
eetrans[0]=((-0.0670700000000000)+(((0.121380000000000)*(x0)*(x2)))+(((-0.0313600000000000)*(x1)))+(((0.0680000000000000)*(x0)))+(((0.0494500000000000)*(x0)*(x3))));
eetrans[1]=((((0.0313600000000000)*(x0)))+(((0.0680000000000000)*(x1)))+(((0.0494500000000000)*(x1)*(x3)))+(((0.121380000000000)*(x1)*(x2))));
eetrans[2]=((1.12113000000000)+(((-0.0494500000000000)*(x2)))+(((0.121380000000000)*(x3)))+(j[0]));
eerot[0]=((((-0.00408346724546153)*(x0)*(x2)))+(((-0.0194972162957103)*(x1)))+(((0.999801572239199)*(x0)*(x3))));
eerot[1]=((((0.0194972162957103)*(x0)))+(((-0.00408346724546153)*(x1)*(x2)))+(((0.999801572239199)*(x1)*(x3))));
eerot[2]=((((-0.00408346724546153)*(x3)))+(((-0.999801572239199)*(x2))));
}

class IKSolver {
public:
IKReal j1, cj1, sj1,
j2, cj2, sj2,
j0, cj0, sj0,
new_px, new_py, new_pz, px, py, pz;

bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
vsolutions.resize(0); vsolutions.reserve(8);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

j0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]);
new_px=((0.0670700000000000)+(px));
new_py=py;
new_pz=((-1.12113000000000)+(pz));
px = new_px; py = new_py; pz = new_pz;
{
if( 1 )
{
IKReal op[6+1], zeror[6];
int numroots;
IKReal j1evalpoly[3];
IKReal x0=(px)*(px)*(px)*(px);
IKReal x1=(py)*(py);
IKReal x2=(px)*(px);
IKReal x3=(py)*(py)*(py)*(py);
IKReal x4=(px)*(px)*(px);
IKReal x5=(py)*(py)*(py);
IKReal x6=(px)*(px)*(px)*(px)*(px)*(px);
IKReal x7=(j0)*(j0);
IKReal x8=(pz)*(pz);
IKReal x9=(py)*(py)*(py)*(py)*(py)*(py);
IKReal x10=(px)*(px)*(px)*(px)*(px);
IKReal x11=(py)*(py)*(py)*(py)*(py);
IKReal x12=(pz)*(pz)*(pz)*(pz);
IKReal x13=(j0)*(j0)*(j0)*(j0);
IKReal x14=(j0)*(j0)*(j0);
IKReal x15=(pz)*(pz)*(pz);
IKReal x16=((9.70002687301235e-15)*(px)*(x2)*(x7));
IKReal x17=((9.70002687301235e-15)*(px)*(x2)*(x8));
IKReal x18=((1.94000537460247e-14)*(j0)*(px)*(pz)*(x2));
IKReal x19=((1.42647454014887e-13)*(j0)*(pz)*(x2)*(x7));
IKReal x20=((1.42647454014887e-13)*(j0)*(pz)*(x2)*(x8));
IKReal x21=((2.13971181022331e-13)*(x2)*(x7)*(x8));
IKReal x22=((3.56618635037219e-14)*(x12)*(x2));
IKReal x23=((3.56618635037219e-14)*(x13)*(x2));
op[0]=((((7.40346196557906e-7)*(x2)*(x3)))+(((7.40346196557906e-7)*(x0)*(x1)))+(((2.46782065519302e-7)*(x0)*(x2)))+(((2.46782065519302e-7)*(x1)*(x3))));
op[1]=((((-2.55168886330133e-11)*(px)*(x3)))+(((-3.31525678328902e-7)*(py)*(x0)))+(((-3.31525678328902e-7)*(x1)*(x5)))+(((-6.63051356657805e-7)*(py)*(x1)*(x2)))+(((-2.55168886330133e-11)*(px)*(x0)))+(((-5.10337772660267e-11)*(px)*(x1)*(x2))));
op[2]=((((-1.87624181125098e-10)*(x3)*(x8)))+(((-1.87624181125098e-10)*(x3)*(x7)))+(((1.87624181125098e-10)*(x0)*(x8)))+(((1.87624181125098e-10)*(x0)*(x7)))+(((2.22684893675861e-7)*(x1)*(x2)))+(((-3.75248362250196e-10)*(j0)*(pz)*(x0)))+(((3.75248362250196e-10)*(j0)*(pz)*(x3)))+(((1.30129335870576e-7)*(x3)))+(((-7.40158572376781e-7)*(x0)*(x2)))+(((3.11770282710248e-11)*(px)*(py)*(x1)))+(((3.11770282710248e-11)*(px)*(py)*(x2)))+(((-1.48050476893469e-6)*(x0)*(x1)))+(((-1.87624181125098e-10)*(x1)*(x3)))+(((9.25555578052848e-8)*(x0)))+(((-7.40533820739031e-7)*(x2)*(x3))));
op[3]=((((4.35675265112225e-10)*(j0)*(py)*(pz)*(x2)))+(((2.40648077311900e-10)*(py)*(x1)*(x8)))+(((2.40648077311900e-10)*(py)*(x1)*(x7)))+(((-1.00000000000000)*(x16)))+(((-1.00000000000000)*(x17)))+(((2.40648077311900e-10)*(x1)*(x5)))+(((-1.17796664846003e-8)*(py)*(x2)))+(((6.62833519025248e-7)*(py)*(x0)))+(((1.94000537460247e-14)*(j0)*(px)*(pz)*(x1)))+(((6.63074167102561e-7)*(py)*(x1)*(x2)))+(x18)+(((-9.49949453952907e-12)*(px)*(x1)))+(((-9.70002687301235e-15)*(px)*(x1)*(x7)))+(((-9.70002687301235e-15)*(px)*(x1)*(x8)))+(((-9.49949453952907e-12)*(px)*(x2)))+(((1.02048154478307e-10)*(px)*(x1)*(x2)))+(((-2.17837632556112e-10)*(py)*(x2)*(x8)))+(((-2.17837632556112e-10)*(py)*(x2)*(x7)))+(((-1.28989149592682e-8)*(py)*(x1)))+(((-4.81296154623800e-10)*(j0)*(py)*(pz)*(x1)))+(((5.10240772391537e-11)*(px)*(x0)))+(((5.10240772391537e-11)*(px)*(x3))));
op[4]=((((3.56618635037219e-14)*(x1)*(x3)))+(((-1.00000000000000)*(x19)))+(((-2.89321456774751e-14)*(px)*(py)))+(((-1.00000000000000)*(x20)))+(((-1.42647454014887e-13)*(j0)*(pz)*(x1)*(x7)))+(((-1.42647454014887e-13)*(j0)*(pz)*(x1)*(x8)))+(((7.13237270074437e-14)*(x3)*(x7)))+(((7.13237270074437e-14)*(x3)*(x8)))+(((-6.38933151049190e-11)*(px)*(py)*(x1)))+(((6.98492245553608e-11)*(x2)*(x7)))+(((6.98492245553608e-11)*(x2)*(x8)))+(((-3.75177038523189e-10)*(x0)*(x7)))+(((-3.75177038523189e-10)*(x0)*(x8)))+(((1.68265149557295e-10)*(j0)*(pz)*(x1)))+(((-8.41325747786475e-11)*(x1)*(x8)))+(((-8.41325747786475e-11)*(x1)*(x7)))+(((2.13971181022331e-13)*(x1)*(x7)*(x8)))+(((1.42647454014887e-13)*(x1)*(x2)*(x7)))+(((1.42647454014887e-13)*(x1)*(x2)*(x8)))+(((3.56618635037219e-14)*(x1)*(x13)))+(((3.56618635037219e-14)*(x1)*(x12)))+(((1.06985590511166e-13)*(x2)*(x3)))+(((5.45498764552681e-10)*(x1)))+(x21)+(x22)+(x23)+(((1.18516805241821e-14)*(px)*(py)*(x7)))+(((1.18516805241821e-14)*(px)*(py)*(x8)))+(((-2.85294908029775e-13)*(j0)*(pz)*(x1)*(x2)))+(((1.69600693311115e-10)*(x2)))+(((-2.22699177026085e-7)*(x1)*(x2)))+(((-3.27162868338942e-11)*(px)*(py)*(x2)))+(((-2.37033610483641e-14)*(j0)*(px)*(py)*(pz)))+(((-1.39698449110722e-10)*(j0)*(pz)*(x2)))+(((7.39971055181247e-7)*(x0)*(x1)))+(((7.39970983857520e-7)*(x0)*(x2)))+(((-1.85041265726412e-7)*(x0)))+(((7.50354077046377e-10)*(j0)*(pz)*(x0)))+(((-1.42647454014887e-13)*(j0)*(pz)*(x3)))+(((-8.41332343804748e-11)*(x3))));
op[5]=((((2.17750487846376e-10)*(py)*(x1)*(x2)))+(((-1.00000000000000)*(x18)))+(((2.09379045562780e-11)*(px)*(x1)))+(((-1.06506913545846e-11)*(py)))+(((-2.61434129209898e-13)*(py)*(x7)*(x8)))+(((-4.35500975692751e-10)*(j0)*(py)*(pz)*(x2)))+(((-4.35723548683164e-14)*(x1)*(x5)))+(((-3.62015314715452e-15)*(px)*(x7)))+(((-3.62015314715452e-15)*(px)*(x8)))+(((-8.93857320457222e-12)*(j0)*(py)*(pz)))+(((2.17750487846376e-10)*(py)*(x2)*(x8)))+(((2.17750487846376e-10)*(py)*(x2)*(x7)))+(((-5.10240772391537e-11)*(px)*(x1)*(x2)))+(((1.74289419473265e-13)*(j0)*(py)*(pz)*(x8)))+(((1.74289419473265e-13)*(j0)*(py)*(pz)*(x1)))+(((1.74289419473265e-13)*(j0)*(py)*(pz)*(x7)))+(((-8.71447097366327e-14)*(py)*(x1)*(x8)))+(((-8.71447097366327e-14)*(py)*(x1)*(x7)))+(((8.83746385287187e-15)*(px)))+(x17)+(x16)+(((7.24030629430904e-15)*(j0)*(px)*(pz)))+(((4.46928660228611e-12)*(py)*(x7)))+(((4.46928660228611e-12)*(py)*(x8)))+(((4.47009251656175e-12)*(py)*(x1)))+(((1.17841349652883e-8)*(py)*(x2)))+(((9.49587438638192e-12)*(px)*(x2)))+(((-3.31307884268701e-7)*(py)*(x0)))+(((-2.55071886061403e-11)*(px)*(x0)))+(((-4.35723548683164e-14)*(py)*(x13)))+(((-4.35723548683164e-14)*(py)*(x12))));
op[6]=((7.93157533430809e-14)+(((-6.52275222733585e-14)*(x1)))+(((-1.00000000000000)*(x23)))+(((-1.00000000000000)*(x22)))+(((-1.00000000000000)*(x21)))+(((-3.75105714796181e-10)*(j0)*(pz)*(x0)))+(((-7.13237270074437e-14)*(x1)*(x2)*(x8)))+(((-7.13237270074437e-14)*(x1)*(x2)*(x7)))+(((-5.32375462816841e-14)*(j0)*(pz)*(x8)))+(((-5.32375462816841e-14)*(j0)*(pz)*(x7)))+(((-5.32375462816841e-14)*(j0)*(pz)*(x1)))+(((1.29962703718704e-13)*(j0)*(pz)))+(((-1.69665428492560e-10)*(x2)))+(((1.33093865704210e-14)*(x12)))+(((1.33093865704210e-14)*(x13)))+(((-6.49813518593520e-14)*(x7)))+(((-6.49813518593520e-14)*(x8)))+(((1.42647454014887e-13)*(j0)*(pz)*(x1)*(x2)))+(((-5.78890832233436e-13)*(px)*(py)))+(((-3.56618635037219e-14)*(x2)*(x3)))+(((-2.46594477000041e-7)*(x0)*(x2)))+(((1.33093865704210e-14)*(x3)))+(((1.55111024339356e-12)*(px)*(py)*(x2)))+(((9.24857212305142e-8)*(x0)))+(((2.66187731408420e-14)*(x1)*(x8)))+(((2.66187731408420e-14)*(x1)*(x7)))+(x19)+(x20)+(((-6.98219461803926e-11)*(x1)*(x2)))+(((7.98563194225261e-14)*(x7)*(x8)))+(((1.87552857398091e-10)*(x0)*(x8)))+(((1.87552857398091e-10)*(x0)*(x7)))+(((1.87552857398091e-10)*(x0)*(x1)))+(((-6.98226057822200e-11)*(x2)*(x7)))+(((-6.98226057822200e-11)*(x2)*(x8)))+(((1.39645211564440e-10)*(j0)*(pz)*(x2))));
polyroots6(op,zeror,numroots);
IKReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
cj1 = zeror[ij1];
IKReal x24=x7;
IKReal x25=x8;
IKReal x26=x1;
IKReal x27=x2;
IKReal x28=x5;
IKReal x29=(cj1)*(cj1);
IKReal x30=x4;
tempj1array[0]=IKatan2(((-1.00000000000000)*(((IKabs(((((-1.88843489439594e-7)*(px)*(x24)))+(((-1.88843489439594e-7)*(px)*(x25)))+(((-1.88843489439594e-7)*(px)*(x26)))+(((0.000496582799742440)*(px)*(x27)))+(((x29)*(((((0.00149031492969564)*(px)*(x26)))+(((-0.000496771643231880)*(px)*(x27)))))))+(((1.56898188009456e-8)*(py)))+(((1.89089788926183e-5)*(px)))+(((3.77686978879187e-7)*(j0)*(px)*(pz)))+(((cj1)*(((((-2.56827145637847e-8)*(x26)))+(((2.56827145637847e-8)*(x27)))+(((-0.000667360311011462)*(px)*(py))))))))) != 0)?((IKReal)1/(((((-1.88843489439594e-7)*(px)*(x24)))+(((-1.88843489439594e-7)*(px)*(x25)))+(((-1.88843489439594e-7)*(px)*(x26)))+(((0.000496582799742440)*(px)*(x27)))+(((x29)*(((((0.00149031492969564)*(px)*(x26)))+(((-0.000496771643231880)*(px)*(x27)))))))+(((1.56898188009456e-8)*(py)))+(((1.89089788926183e-5)*(px)))+(((3.77686978879187e-7)*(j0)*(px)*(pz)))+(((cj1)*(((((-2.56827145637847e-8)*(x26)))+(((2.56827145637847e-8)*(x27)))+(((-0.000667360311011462)*(px)*(py)))))))))):(IKReal)1.0e30))*(((2.81630526298342e-7)+(((0.000333564789191018)*(x27)))+(((x29)*(((((0.000333680155505731)*(x26)))+(((-0.000333680155505731)*(x27)))+(((-5.13654291275694e-8)*(px)*(py)))))))+(((2.30732629425671e-7)*(j0)*(pz)))+(((cj1)*(((((-3.77686978879187e-7)*(j0)*(py)*(pz)))+(((-1.89089788926183e-5)*(py)))+(((-0.00149012608620620)*(py)*(x27)))+(((1.88843489439594e-7)*(py)*(x26)))+(((1.88843489439594e-7)*(py)*(x24)))+(((1.88843489439594e-7)*(py)*(x25)))+(((1.56898188009456e-8)*(px)))))))+(((2.56827145637847e-8)*(px)*(py)))+((((cj1)*(cj1)*(cj1))*(((((-0.000496771643231880)*(py)*(x26)))+(((0.00149031492969564)*(py)*(x27)))))))+(((-1.15366314712836e-7)*(x25)))+(((-1.15366314712836e-7)*(x24)))+(((-1.15366314712836e-7)*(x26)))))), cj1);
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
    j1array[numsolutions]-=IK2PI;
else if( j1array[numsolutions] < -IKPI )
    j1array[numsolutions]+=IK2PI;
cj1array[numsolutions] = zeror[ij1];
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
bool valid = true;
for( int jj1 = 0; jj1 < numsolutions; ++jj1)
{
    if( IKabs(cj1array[jj1]-cj1array[numsolutions]) < 0.0001 && IKabs(sj1array[jj1]-sj1array[numsolutions]) < 0.0001 )
    {
        valid=false; break;
    }
}
if( valid ) { numsolutions++; }
}
}
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

j1evalpoly[0]=((0.00249512474880781)+(((-0.00408427767953597)*(cj1)*(py)))+(((0.00408427767953597)*(px)*(sj1))));
j1evalpoly[1]=((0.000930122481568997)+(((-2.00003336264833)*(cj1)*(px)*(py)*(sj1)))+(((0.0608117241738253)*(px)*(sj1)))+(((1.00001668132416)*((cj1)*(cj1))*((py)*(py))))+(((1.00001668132416)*((px)*(px))*((sj1)*(sj1))))+(((-0.0608117241738253)*(cj1)*(py))));
j1evalpoly[2]=((0.000161226666312189)+(((sj1)*(((((1.00001668132416)*(px)*(pz)))+(((-0.00237098038694395)*(py)))+(((-1.00001668132416)*(j0)*(px)))))))+(((cj1)*(((((-1.00001668132416)*(py)*(pz)))+(((-0.00237098038694395)*(px)))+(((1.00001668132416)*(j0)*(py)))))))+(((0.0304058620869126)*(pz)))+(((-0.0304058620869126)*(j0))));
if( IKabs(j1evalpoly[0]) < 0.000001  || IKabs(j1evalpoly[1]) < 0.000001  || IKabs(j1evalpoly[2]) < 0.000001  )
{
    continue;
}
IKReal x31=((7.96478496741179e-5)*(j0)*(px));
IKReal x32=((0.000496574516221964)*(py));
IKReal x33=((7.96478496741179e-5)*(px)*(pz));
IKReal x34=((x33)+(x32));
IKReal x35=((((-1.00000000000000)*(x34)))+(x31));
IKReal x36=((7.96478496741179e-5)*(j0)*(py));
IKReal x37=((0.000496574516221964)*(px));
IKReal x38=((x37)+(x36));
IKReal x39=((7.96478496741179e-5)*(py)*(pz));
IKReal x40=((((-1.00000000000000)*(x39)))+(x38));
IKReal x41=x8;
IKReal x42=x7;
IKReal x43=((0.0304058620869126)*(pz));
IKReal x44=((1.00001668132416)*(j0)*(py));
IKReal x45=((1.00001668132416)*(py)*(pz));
IKReal x46=((0.00237098038694395)*(px));
IKReal x47=((x46)+(x45));
IKReal x48=((((-1.00000000000000)*(x47)))+(x44));
IKReal x49=((cj1)*(x48));
IKReal x50=((1.00001668132416)*(px)*(pz));
IKReal x51=((1.00001668132416)*(j0)*(px));
IKReal x52=((0.00237098038694395)*(py));
IKReal x53=((x51)+(x52));
IKReal x54=((x50)+(((-1.00000000000000)*(x53))));
IKReal x55=((sj1)*(x54));
IKReal x56=((0.000161226666312189)+(x49)+(x43)+(x55));
IKReal x57=((0.0304058620869126)*(j0));
IKReal x58=((x56)+(((-1.00000000000000)*(x57))));
IKReal x59=((IKabs(x58) != 0)?((IKReal)1/(x58)):(IKReal)1.0e30);
IKReal x60=((cj1)*(x35));
IKReal x61=((sj1)*(x40));
IKReal x62=((5.41605377784002e-6)*(pz));
IKReal x63=((0.0390021717050184)*(j0)*(pz));
IKReal x64=((0.000303362176195977)+(x60)+(x61)+(x62)+(x63));
IKReal x65=((0.0195010858525092)*(x41));
IKReal x66=((0.0195010858525092)*(x42));
IKReal x67=((5.41605377784002e-6)*(j0));
IKReal x68=((x65)+(x66)+(x67));
IKReal x69=((x64)+(((-1.00000000000000)*(x68))));
j1evalpoly[0]=((-1.00000000000000)+((((x59)*(x59))*((x69)*(x69))))+(((((IKabs(((0.00249512474880781)+(((-0.00408427767953597)*(cj1)*(py)))+(((0.00408427767953597)*(px)*(sj1))))) != 0)?(pow(((0.00249512474880781)+(((-0.00408427767953597)*(cj1)*(py)))+(((0.00408427767953597)*(px)*(sj1)))),-2.00000000000000)):(IKReal)1.0e30))*((((((x59)*(((9.22089699389908e-6)+(((-0.000592748595655526)*(x41)))+(((-0.000592748595655526)*(x42)))+(((0.00118549719131105)*(j0)*(pz)))+(((-1.64624590399227e-7)*(j0)))+(((0.0303956713045934)*(x60)))+(((0.0303956713045934)*(x61)))+(((1.64624590399227e-7)*(pz)))))))+(((-1.00000000000000)*(cj1)*(py)*(x59)*(x69)))+(((-0.0195010858525092)*(j0)))+(((px)*(sj1)*(x59)*(x69)))+(((0.0195010858525092)*(pz)))))*(((((x59)*(((9.22089699389908e-6)+(((-0.000592748595655526)*(x41)))+(((-0.000592748595655526)*(x42)))+(((0.00118549719131105)*(j0)*(pz)))+(((-1.64624590399227e-7)*(j0)))+(((0.0303956713045934)*(x60)))+(((0.0303956713045934)*(x61)))+(((1.64624590399227e-7)*(pz)))))))+(((-1.00000000000000)*(cj1)*(py)*(x59)*(x69)))+(((-0.0195010858525092)*(j0)))+(((px)*(sj1)*(x59)*(x69)))+(((0.0195010858525092)*(pz)))))))));
if( IKabs(j1evalpoly[0]) > 0.000001  )
{
    continue;
}
{
IKReal j2eval[1];
j2eval[0]=((0.000161162688967503)+(((0.999619858556718)*(px)*(pz)*(sj1)))+(((0.0303937965498419)*(pz)))+(((-0.999619858556718)*(cj1)*(py)*(pz)))+(((-0.0303937965498419)*(j0)))+(((-0.999619858556718)*(j0)*(px)*(sj1)))+(((-0.00237003954363976)*(cj1)*(px)))+(((0.999619858556718)*(cj1)*(j0)*(py)))+(((-0.00237003954363976)*(py)*(sj1))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.000929753393948668)+(((-0.0607875930996838)*(cj1)*(py)))+(((0.0607875930996838)*(px)*(sj1)))+(((0.999619858556718)*((cj1)*(cj1))*((py)*(py))))+(((0.999619858556718)*((px)*(px))*((sj1)*(sj1))))+(((-1.99923971711344)*(cj1)*(px)*(py)*(sj1))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.00206677816538925)+(((-0.0679741503818568)*(cj1)*(py)))+(((-0.0303937965498419)*(cj1)*(px)))+(((0.999619858556718)*(cj1)*(sj1)*((py)*(py))))+(((0.00237003954363976)*(j0)))+(((-0.0303937965498419)*(py)*(sj1)))+(((0.999619858556718)*(px)*(py)*((cj1)*(cj1))))+(((-0.00237003954363976)*(pz)))+(((0.0679741503818568)*(px)*(sj1)))+(((-0.999619858556718)*(cj1)*(sj1)*((px)*(px))))+(((-0.999619858556718)*(px)*(py)*((sj1)*(sj1)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x70=((0.0194972162957103)*(cj1)*(px));
IKReal x71=((0.0194972162957103)*(py)*(sj1));
IKReal x72=((x71)+(x70));
IKReal x73=((0.00132581070810830)+(((-1.00000000000000)*(x72))));
IKReal x74=x1;
IKReal x75=((0.999619858556718)*(cj1)*(sj1)*(x74));
IKReal x76=((0.00237003954363976)*(j0));
IKReal x77=(cj1)*(cj1);
IKReal x78=((0.999619858556718)*(px)*(py)*(x77));
IKReal x79=((0.0679741503818568)*(px)*(sj1));
IKReal x80=((0.00206677816538925)+(x76)+(x75)+(x79)+(x78));
IKReal x81=x2;
IKReal x82=((0.999619858556718)*(cj1)*(sj1)*(x81));
IKReal x83=((0.00237003954363976)*(pz));
IKReal x84=((0.0303937965498419)*(py)*(sj1));
IKReal x85=((0.0303937965498419)*(cj1)*(px));
IKReal x86=(sj1)*(sj1);
IKReal x87=((0.999619858556718)*(px)*(py)*(x86));
IKReal x88=((0.0679741503818568)*(cj1)*(py));
IKReal x89=((x88)+(x82)+(x83)+(x87)+(x84)+(x85));
IKReal x90=((x80)+(((-1.00000000000000)*(x89))));
IKReal x91=((IKabs(x90) != 0)?((IKReal)1/(x90)):(IKReal)1.0e30);
j2array[0]=IKatan2(((-1.00000000000000)*(x91)*(((0.00369409906157064)+(((x73)*(((0.000277675772691384)+(((-0.00408346724546153)*(py)*(sj1)))+(((0.999801572239199)*(j0)))+(((-0.00408346724546153)*(cj1)*(px)))+(((-0.999801572239199)*(pz)))))))+(((0.121533721843228)*(px)*(sj1)))+(((-0.121533721843228)*(cj1)*(py)))))), ((-1.00000000000000)*(x91)*(((0.000303241797185762)+(((-1.00000000000000)*(x73)*(((0.0679865069122655)+(((-0.999801572239199)*(cj1)*(px)))+(((-0.999801572239199)*(py)*(sj1)))+(((0.00408346724546153)*(pz)))+(((-0.00408346724546153)*(j0)))))))+(((0.000496377467435229)*(px)*(sj1)))+(((-0.000496377467435229)*(cj1)*(py)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(3);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.vfree.resize(0);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x92=((0.999801572239199)*(px)*(sj1));
IKReal x93=((0.0303896399595984)+(x92));
IKReal x94=((0.999801572239199)*(cj1)*(py));
IKReal x95=((x93)+(((-1.00000000000000)*(x94))));
IKReal x96=((0.0194972162957103)*(cj1)*(px));
IKReal x97=((0.0194972162957103)*(py)*(sj1));
IKReal x98=((x97)+(x96));
IKReal x99=((0.00132581070810830)+(((-1.00000000000000)*(x98))));
IKReal x100=((0.0194972162957103)*(pz));
IKReal x101=((0.0194972162957103)*(j0));
IKReal x102=((((-1.00000000000000)*(x101)))+(x100));
IKReal x103=((0.00408346724546153)*(px)*(sj1));
IKReal x104=((0.00249462964679099)+(x103));
IKReal x105=((0.00408346724546153)*(cj1)*(py));
IKReal x106=((((-1.00000000000000)*(x105)))+(x104));
IKReal x107=((0.0607875930996838)*(px)*(sj1));
IKReal x108=(cj1)*(cj1);
IKReal x109=x1;
IKReal x110=((0.999619858556718)*(x108)*(x109));
IKReal x111=x2;
IKReal x112=(sj1)*(sj1);
IKReal x113=((0.999619858556718)*(x111)*(x112));
IKReal x114=((0.000929753393948668)+(x113)+(x110)+(x107));
IKReal x115=((0.0607875930996838)*(cj1)*(py));
IKReal x116=((1.99923971711344)*(cj1)*(px)*(py)*(sj1));
IKReal x117=((x116)+(x115));
IKReal x118=((((-1.00000000000000)*(x117)))+(x114));
IKReal x119=((IKabs(x118) != 0)?((IKReal)1/(x118)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x119)*(((((x102)*(x95)))+(((-1.00000000000000)*(x106)*(x99)))))), ((x119)*(((((x102)*(x106)))+(((x95)*(x99)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(3);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.vfree.resize(0);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x120=((0.0194972162957103)*(pz));
IKReal x121=((0.0194972162957103)*(j0));
IKReal x122=((((-1.00000000000000)*(x121)))+(x120));
IKReal x123=((0.999619858556718)*(px)*(pz)*(sj1));
IKReal x124=((0.0303937965498419)*(pz));
IKReal x125=((0.999619858556718)*(cj1)*(j0)*(py));
IKReal x126=((0.000161162688967503)+(x124)+(x125)+(x123));
IKReal x127=((0.00237003954363976)*(py)*(sj1));
IKReal x128=((0.00237003954363976)*(cj1)*(px));
IKReal x129=((0.0303937965498419)*(j0));
IKReal x130=((0.999619858556718)*(j0)*(px)*(sj1));
IKReal x131=((0.999619858556718)*(cj1)*(py)*(pz));
IKReal x132=((x131)+(x130)+(x127)+(x128)+(x129));
IKReal x133=((x126)+(((-1.00000000000000)*(x132))));
IKReal x134=((IKabs(x133) != 0)?((IKReal)1/(x133)):(IKReal)1.0e30);
j2array[0]=IKatan2(((-1.00000000000000)*(x134)*(((0.000303241797185762)+(((0.000496377467435229)*(px)*(sj1)))+(((x122)*(((0.000277675772691384)+(((-0.00408346724546153)*(py)*(sj1)))+(((0.999801572239199)*(j0)))+(((-0.00408346724546153)*(cj1)*(px)))+(((-0.999801572239199)*(pz)))))))+(((-0.000496377467435229)*(cj1)*(py)))))), ((x134)*(((0.00369409906157064)+(((0.121533721843228)*(px)*(sj1)))+(((-0.121533721843228)*(cj1)*(py)))+(((x122)*(((0.0679865069122655)+(((-0.999801572239199)*(cj1)*(px)))+(((-0.999801572239199)*(py)*(sj1)))+(((0.00408346724546153)*(pz)))+(((-0.00408346724546153)*(j0)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(3);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.vfree.resize(0);
}
}

}

}
    }

} else
{
}
}
}
return vsolutions.size()>0;
}

/// Durand-Kerner polynomial root finding method
static void polyroots6(IKReal rawcoeffs[6+1], IKReal rawroots[6], int& numroots)
{
    using std::complex;
    assert(rawcoeffs[0] != 0);
    const IKReal tol = 128.0*std::numeric_limits<IKReal>::epsilon();
    complex<IKReal> coeffs[6];
    const int maxsteps = 50;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IKReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IKReal> roots[6];
    IKReal err[6];
    roots[0] = complex<IKReal>(1,0);
    roots[1] = complex<IKReal>(0.4,0.9); // any complex number not a root of unity is works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IKReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }
    numroots = 0;
    for(int i = 0; i < 6; ++i) {
        if( IKabs(imag(roots[i])) < std::numeric_limits<IKReal>::epsilon() ) {
            rawroots[numroots++] = real(roots[i]);
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
IKSolver solver;
return solver.ik(eetrans,eerot,pfree,vsolutions);
}

IKFAST_API const char* getKinematicsHash() { return "da61455279f74c4a21f17e52faf0abba"; }

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\n");
    }
    return 0;
}

#endif
