#define IKFAST_NAMESPACE ik_katana5d
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 67 generated on 2013-07-25 16:21:56.983927
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==67);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
#ifndef isfinite
#define isfinite _isfinite
#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20;
x0=IKcos(j[0]);
x1=IKsin(j[1]);
x2=IKcos(j[1]);
x3=IKsin(j[2]);
x4=IKcos(j[2]);
x5=IKsin(j[3]);
x6=IKsin(j[0]);
x7=IKcos(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=((0.139)*x3);
x11=((0.273)*x0);
x12=((0.273)*x6);
x13=((1.0)*x5);
x14=((1.0)*x7);
x15=((0.19)*x1);
x16=(x0*x2);
x17=(x1*x3);
x18=(x2*x4);
x19=(x1*x4);
x20=(x2*x3);
eetrans[0]=((((0.139)*x0*x19))+((x0*x15))+((x7*((((x11*x20))+((x11*x19))))))+((x5*(((((-1.0)*x11*x18))+((x11*x17))))))+((x10*x16)));
IkReal x21=((1.0)*x6);
IkReal x22=((1.0)*x12);
eetrans[1]=(((x5*(((((-1.0)*x17*x22))+((x12*x18))))))+(((-0.139)*x19*x6))+(((-1.0)*x10*x2*x21))+((x7*(((((-1.0)*x19*x22))+(((-1.0)*x20*x22))))))+(((-1.0)*x15*x21)));
eetrans[2]=((0.2015)+((x7*(((((-0.273)*x17))+(((0.273)*x18))))))+(((-1.0)*x1*x10))+(((0.19)*x2))+(((0.139)*x18))+((x5*(((((0.273)*x20))+(((0.273)*x19)))))));
eerot[0]=(((x9*((((x7*(((((-1.0)*x0*x17))+((x16*x4))))))+((x5*((((x0*x19))+((x16*x3))))))))))+((x6*x8)));
eerot[1]=(((x0*x8))+(((-1.0)*x9*((((x14*((((x18*x6))+(((-1.0)*x17*x6))))))+((x13*((((x19*x6))+((x20*x6)))))))))));
eerot[2]=((-1.0)*x9*((((x13*(((((-1.0)*x18))+x17))))+((x14*((x19+x20)))))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=r00;
new_px=px;
new_r01=((-1.0)*r01);
new_py=((-1.0)*py);
new_r02=((-1.0)*r02);
new_pz=((0.2015)+(((-1.0)*pz)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x24 = IKatan2WithCheck(((-1.0)*py),px,IKFAST_ATAN2_MAGTHRESH);
if(!x24.valid){
continue;
}
IkReal x23=x24.value;
j0array[0]=((-1.0)*x23);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x23)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

IkReal op[4+1], zeror[4];
int numroots;
IkReal x25=r00*r00;
IkReal x26=py*py;
IkReal x27=pz*pz;
IkReal x28=r01*r01;
IkReal x29=pz*pz*pz;
IkReal x30=px*px;
IkReal x31=r02*r02;
IkReal x32=(py*sj0);
IkReal x33=((9.63538693604066)*pp);
IkReal x34=(px*r00);
IkReal x35=((3.66144703569545)*r02);
IkReal x36=(r01*sj0);
IkReal x37=((19.2707738720813)*r02);
IkReal x38=(cj0*px);
IkReal x39=((3.66144703569545)*pz);
IkReal x40=(cj0*r00);
IkReal x41=((0.272883986123346)*r02);
IkReal x42=(pp*pz);
IkReal x43=(py*r01);
IkReal x44=((0.556443595556348)*x31);
IkReal x45=((19.2707738720813)*x28);
IkReal x46=((1.43623150591235)*pz*r02);
IkReal x47=((19.2707738720813)*x25);
IkReal x48=((19.2707738720813)*x27);
IkReal x49=(x36*x41);
IkReal x50=(x40*x41);
IkReal x51=(x40*x43);
IkReal x52=((0.879787910356)*x28*x32);
IkReal x53=(x40*x46);
IkReal x54=(x36*x46);
IkReal x55=((0.879787910356)*x25*x38);
IkReal x56=((0.879787910356)*x34*x36);
IkReal x57=((0.879787910356)*x51);
IkReal x58=(x38*x44);
IkReal x59=(pp*x35*x36);
IkReal x60=(pp*x35*x40);
IkReal x61=(x32*x44);
IkReal x62=(x27*x35*x40);
IkReal x63=(x25*x38*x39);
IkReal x64=(x38*x47*(px*px));
IkReal x65=(x35*x38*x43);
IkReal x66=(x31*x38*x39);
IkReal x67=(x30*x35*x40);
IkReal x68=(x34*x36*x39);
IkReal x69=(x32*x34*x35);
IkReal x70=(x27*x35*x36);
IkReal x71=(x39*x51);
IkReal x72=(x31*x32*x33);
IkReal x73=(x29*x36*x37);
IkReal x74=(x29*x37*x40);
IkReal x75=(x31*x32*x39);
IkReal x76=(x32*x45*(py*py));
IkReal x77=(x26*x35*x36);
IkReal x78=(x31*x33*x38);
IkReal x79=(x28*x32*x39);
IkReal x80=(x36*x37*x42);
IkReal x81=(x28*x32*x33);
IkReal x82=(x37*x40*x42);
IkReal x83=(x33*x51);
IkReal x84=(x25*x33*x38);
IkReal x85=(x33*x34*x36);
IkReal x86=(x27*x38*x47);
IkReal x87=(pz*x26*x36*x37);
IkReal x88=((38.5415477441626)*x26*x34*x36);
IkReal x89=(pz*x32*x34*x37);
IkReal x90=(x30*x32*x47);
IkReal x91=(x34*x36*x48);
IkReal x92=(x27*x32*x45);
IkReal x93=((38.5415477441626)*x30*x51);
IkReal x94=(x48*x51);
IkReal x95=(pz*x37*x38*x43);
IkReal x96=(pz*x30*x37*x40);
IkReal x97=(x26*x38*x45);
IkReal x98=(x59+x60);
IkReal x99=(x58+x61+x82+x83+x80+x81+x84+x85);
IkReal x100=(x77+x75+x71+x70+x79+x49+x50+x62+x63+x65+x66+x67+x68+x69);
IkReal x101=(x76+x74+x73+x72+x78+x55+x54+x57+x56+x53+x52+x64+x88+x89+x86+x87+x91+x90+x93+x92+x95+x94+x97+x96);
op[0]=((((9.63538693604066)*r01*r02*(py*py*py)*(sj0*sj0)))+(((-50.7125628212666)*py*r01*r02*(pz*pz*pz)))+(((0.484507825194381)*cj0*pp*r00*r01*sj0))+(((9.63538693604066)*r00*r02*(cj0*cj0)*(px*px*px)))+(((25.3562814106333)*cj0*pp*py*pz*r00*r02*sj0))+(((0.366398266383651)*cj0*px*pz*r01*r02*sj0))+(((9.63538693604066)*(pz*pz*pz)*(r02*r02)))+(((-50.7125628212666)*pz*r00*r02*(cj0*cj0)*(px*px*px)))+(((25.3562814106333)*pp*(cj0*cj0)*(px*px)*(r00*r00)))+(((-1.83072351784773)*px*py*r00*r01))+(((-6.33907035265833)*(pp*pp)*(r02*r02)))+(((-0.850906091578033)*cj0*r00*r01*sj0*(pz*pz)))+(((-0.484507825194381)*px*py*r00*r01*(sj0*sj0)))+(((-25.3562814106333)*(py*py*py*py)*(r01*r01)*(sj0*sj0)))+(((-6.33907035265833)*(cj0*cj0)*(pp*pp)*(r00*r00)))+(((-9.63538693604066)*px*py*pz*r00*r01*(sj0*sj0)))+(((-25.3562814106333)*(py*py)*(pz*pz)*(r01*r01)))+(((9.63538693604066)*cj0*pp*pz*r00*r01*sj0))+(((-9.63538693604066)*px*py*pz*r00*r01*(cj0*cj0)))+(((-9.63538693604066)*px*r00*r02*(cj0*cj0)*(pz*pz)))+(((-9.63538693604066)*cj0*py*r00*r02*sj0*(pz*pz)))+(((0.366398266383651)*px*pz*r00*r02*(cj0*cj0)))+(((-9.63538693604066)*py*r01*r02*(pz*pz)*(sj0*sj0)))+(((-9.63538693604066)*cj0*pz*r00*r01*sj0*(py*py)))+(((-101.425125642533)*cj0*r00*r01*sj0*(px*px)*(py*py)))+(((-25.3562814106333)*(py*py)*(pz*pz)*(r02*r02)*(sj0*sj0)))+(((-9.63538693604066)*pz*(py*py)*(r01*r01)*(sj0*sj0)))+(((-25.3562814106333)*(pz*pz*pz*pz)*(r02*r02)))+(((25.3562814106333)*pp*px*py*r00*r01*(sj0*sj0)))+(((0.366398266383651)*py*pz*r01*r02*(sj0*sj0)))+(((-9.63538693604066)*pz*(cj0*cj0)*(px*px)*(r00*r00)))+(((-0.484507825194381)*(py*py)*(r01*r01)*(sj0*sj0)))+(((25.3562814106333)*cj0*pp*r00*r01*sj0*(py*py)))+(((-4.81769346802033)*pp*px*r00*r02*(cj0*cj0)))+(((25.3562814106333)*cj0*pp*px*pz*r01*r02*sj0))+(((0.439893955178)*pz*(r02*r02)))+(((-6.33907035265833)*(pp*pp)*(r01*r01)*(sj0*sj0)))+(((-9.63538693604066)*cj0*pz*r00*r01*sj0*(px*px)))+(((4.81769346802033)*pp*pz*(cj0*cj0)*(r00*r00)))+(((-0.425453045789016)*(cj0*cj0)*(px*px)*(r02*r02)))+(((-25.3562814106333)*(cj0*cj0)*(px*px*px*px)*(r00*r00)))+(((-101.425125642533)*cj0*py*pz*r00*r02*sj0*(px*px)))+(((25.3562814106333)*pp*py*pz*r01*r02*(sj0*sj0)))+(((25.3562814106333)*cj0*pp*px*py*sj0*(r00*r00)))+(((-4.81769346802033)*pp*pz*(r02*r02)))+(((-0.278221797778174)*pz*(r01*r01)*(sj0*sj0)))+(((0.278221797778174)*py*r01*r02*(sj0*sj0)))+(((-50.7125628212666)*cj0*px*py*sj0*(pz*pz)*(r02*r02)))+(((-0.556443595556348)*cj0*pz*r00*r01*sj0))+(((25.3562814106333)*pp*(pz*pz)*(r02*r02)))+(((-0.850906091578033)*cj0*px*py*sj0*(r02*r02)))+(((-0.425453045789016)*(pz*pz)*(r01*r01)*(sj0*sj0)))+(((-50.7125628212666)*cj0*py*sj0*(px*px*px)*(r00*r00)))+(((-9.63538693604066)*cj0*px*py*pz*sj0*(r00*r00)))+(((-0.278221797778174)*pz*(cj0*cj0)*(r00*r00)))+(((25.3562814106333)*pp*px*py*r00*r01*(cj0*cj0)))+(((-0.0528497858676222)*(r02*r02)))+(((-12.6781407053167)*cj0*r00*r01*sj0*(pp*pp)))+(((-50.7125628212666)*px*py*r00*r01*(pz*pz)))+(((9.63538693604066)*px*r00*r02*(py*py)*(sj0*sj0)))+(((-0.484507825194381)*cj0*r00*r01*sj0*(py*py)))+(((9.63538693604066)*pz*(py*py)*(r01*r01)))+(((0.439893955178)*px*r00*r02))+(((-3.23059310196597)*(pz*pz)*(r02*r02)))+(((-4.81769346802033)*cj0*pp*py*r00*r02*sj0))+(((-4.81769346802033)*pp*px*r00*r02))+(((-0.915361758923863)*(py*py)*(r01*r01)))+(((-25.3562814106333)*(cj0*cj0)*(px*px)*(pz*pz)*(r02*r02)))+(((1.15761567152105)*pp*(r02*r02)))+(((9.63538693604066)*py*r01*r02*(cj0*cj0)*(px*px)))+(((19.2707738720813)*cj0*py*r00*r02*sj0*(px*px)))+(((25.3562814106333)*pp*px*pz*r00*r02))+(((19.2707738720813)*px*py*pz*r00*r01))+(((19.2707738720813)*cj0*px*r01*r02*sj0*(py*py)))+(((25.3562814106333)*pp*px*pz*r00*r02*(cj0*cj0)))+(((4.81769346802033)*pp*pz*(r01*r01)*(sj0*sj0)))+(((0.0153712106632144)*(r01*r01)*(sj0*sj0)))+(((25.3562814106333)*cj0*pp*r00*r01*sj0*(px*px)))+(((-50.7125628212666)*pz*r01*r02*(py*py*py)*(sj0*sj0)))+(((0.0153712106632144)*(cj0*cj0)*(r00*r00)))+(((0.242253912597191)*pp*(r01*r01)*(sj0*sj0)))+(((0.0307424213264288)*cj0*r00*r01*sj0))+(((-50.7125628212666)*cj0*px*sj0*(py*py*py)*(r01*r01)))+(((25.3562814106333)*pp*(py*py)*(r01*r01)*(sj0*sj0)))+(((25.3562814106333)*pp*py*pz*r01*r02))+(((-4.81769346802033)*pp*py*r01*r02))+(((0.366398266383651)*cj0*py*pz*r00*r02*sj0))+(((-9.63538693604066)*cj0*px*r01*r02*sj0*(pz*pz)))+(((-4.14595486088983)*py*pz*r01*r02))+(((-25.3562814106333)*(px*px)*(pz*pz)*(r00*r00)))+(((0.278221797778174)*cj0*px*r01*r02*sj0))+(((-0.425453045789016)*(py*py)*(r02*r02)*(sj0*sj0)))+(((-4.14595486088983)*px*pz*r00*r02))+(((-50.7125628212666)*py*pz*r01*r02*(cj0*cj0)*(px*px)))+(((-50.7125628212666)*px*r00*r02*(pz*pz*pz)))+(((9.63538693604066)*pz*(cj0*cj0)*(px*px)*(r02*r02)))+(((19.2707738720813)*py*r01*r02*(pz*pz)))+(((-25.3562814106333)*(cj0*cj0)*(px*px)*(py*py)*(r01*r01)))+(((-4.81769346802033)*pp*py*r01*r02*(sj0*sj0)))+(((-0.484507825194381)*px*py*r00*r01*(cj0*cj0)))+(((-101.425125642533)*cj0*px*pz*r01*r02*sj0*(py*py)))+(((-50.7125628212666)*px*pz*r00*r02*(py*py)*(sj0*sj0)))+(((-50.7125628212666)*py*r00*r01*(cj0*cj0)*(px*px*px)))+(((0.278221797778174)*cj0*py*r00*r02*sj0))+(((-4.81769346802033)*cj0*pp*px*r01*r02*sj0))+(((0.278221797778174)*px*r00*r02*(cj0*cj0)))+(((9.63538693604066)*pz*(py*py)*(r02*r02)*(sj0*sj0)))+(((19.2707738720813)*cj0*px*py*pz*sj0*(r02*r02)))+(((-0.915361758923863)*(px*px)*(r00*r00)))+(((-0.484507825194381)*cj0*r00*r01*sj0*(px*px)))+(((-0.484507825194381)*cj0*px*py*sj0*(r00*r00)))+(((19.2707738720813)*px*r00*r02*(pz*pz)))+(((0.242253912597191)*pp*(cj0*cj0)*(r00*r00)))+(((-50.7125628212666)*px*r00*r01*(py*py*py)*(sj0*sj0)))+(((-25.3562814106333)*(px*px)*(py*py)*(r00*r00)*(sj0*sj0)))+(((-9.63538693604066)*cj0*px*py*pz*sj0*(r01*r01)))+(((-0.425453045789016)*(cj0*cj0)*(pz*pz)*(r00*r00)))+(((25.3562814106333)*cj0*pp*px*py*sj0*(r01*r01)))+(((-0.484507825194381)*cj0*px*py*sj0*(r01*r01)))+(((9.63538693604066)*pz*(px*px)*(r00*r00)))+(((0.439893955178)*py*r01*r02))+(((-0.484507825194381)*(cj0*cj0)*(px*px)*(r00*r00))));
op[1]=((((-1.0)*x100))+x101+x98+(((-1.0)*x99)));
op[2]=((((-8.29190972177966)*(py*py)*(r01*r01)*(sj0*sj0)))+(((-50.7125628212666)*(py*py*py*py)*(r01*r01)*(sj0*sj0)))+(((-50.7125628212666)*(px*px)*(py*py)*(r00*r00)*(sj0*sj0)))+(((50.7125628212666)*cj0*pp*px*py*sj0*(r00*r00)))+(((-6.5900975386236)*cj0*px*pz*r01*r02*sj0))+(((-1.83072351784773)*(py*py)*(r01*r01)))+(((-101.425125642533)*pz*r00*r02*(cj0*cj0)*(px*px*px)))+(((8.29190972177966)*cj0*pp*r00*r01*sj0))+(((-50.7125628212666)*(cj0*cj0)*(px*px)*(py*py)*(r01*r01)))+(((-101.425125642533)*py*r01*r02*(pz*pz*pz)))+(((-0.242141564796917)*(cj0*cj0)*(r00*r00)))+(((-12.6781407053167)*(pp*pp)*(r01*r01)*(sj0*sj0)))+(((-50.7125628212666)*(pz*pz*pz*pz)*(r02*r02)))+(((4.14595486088983)*pp*(cj0*cj0)*(r00*r00)))+(((4.14595486088983)*pp*(r01*r01)*(sj0*sj0)))+(((-0.850906091578033)*(cj0*cj0)*(px*px)*(r02*r02)))+(((-202.850251285066)*cj0*py*pz*r00*r02*sj0*(px*px)))+(((-101.425125642533)*cj0*px*sj0*(py*py*py)*(r01*r01)))+(((-0.969015650388763)*py*pz*r01*r02))+(((-202.850251285066)*cj0*px*pz*r01*r02*sj0*(py*py)))+(((-101.425125642533)*px*pz*r00*r02*(py*py)*(sj0*sj0)))+(((50.7125628212666)*pp*(py*py)*(r01*r01)*(sj0*sj0)))+(((-101.425125642533)*px*py*r00*r01*(pz*pz)))+(((-101.425125642533)*cj0*px*py*sj0*(pz*pz)*(r02*r02)))+(((-202.850251285066)*cj0*r00*r01*sj0*(px*px)*(py*py)))+(((-3.66144703569545)*px*py*r00*r01))+(((-0.484283129593835)*cj0*r00*r01*sj0))+(((-50.7125628212666)*(py*py)*(pz*pz)*(r02*r02)*(sj0*sj0)))+(((-0.242141564796917)*(r01*r01)*(sj0*sj0)))+(((50.7125628212666)*pp*px*pz*r00*r02*(cj0*cj0)))+(((-1.70181218315607)*cj0*px*py*sj0*(r02*r02)))+(((50.7125628212666)*cj0*pp*r00*r01*sj0*(py*py)))+(((50.7125628212666)*pp*px*py*r00*r01*(sj0*sj0)))+(((-0.850906091578033)*(pz*pz)*(r01*r01)*(sj0*sj0)))+(((50.7125628212666)*pp*py*pz*r01*r02))+(((-25.3562814106333)*cj0*r00*r01*sj0*(pp*pp)))+(((-50.7125628212666)*(cj0*cj0)*(px*px)*(pz*pz)*(r02*r02)))+(((-8.29190972177966)*cj0*r00*r01*sj0*(py*py)))+(((50.7125628212666)*pp*(pz*pz)*(r02*r02)))+(((-8.29190972177966)*cj0*r00*r01*sj0*(px*px)))+(((0.167184414388102)*(r02*r02)))+(((-50.7125628212666)*(py*py)*(pz*pz)*(r01*r01)))+(((-101.425125642533)*px*r00*r02*(pz*pz*pz)))+(((-50.7125628212666)*(cj0*cj0)*(px*px*px*px)*(r00*r00)))+(((-8.29190972177966)*(cj0*cj0)*(px*px)*(r00*r00)))+(((-8.29190972177966)*px*py*r00*r01*(sj0*sj0)))+(((-1.34621569265334)*pp*(r02*r02)))+(((-1.83072351784773)*(px*px)*(r00*r00)))+(((-8.29190972177966)*cj0*px*py*sj0*(r01*r01)))+(((50.7125628212666)*cj0*pp*r00*r01*sj0*(px*px)))+(((50.7125628212666)*pp*px*py*r00*r01*(cj0*cj0)))+(((-6.5900975386236)*py*pz*r01*r02*(sj0*sj0)))+(((-50.7125628212666)*(px*px)*(pz*pz)*(r00*r00)))+(((-6.5900975386236)*px*pz*r00*r02*(cj0*cj0)))+(((-8.29190972177966)*cj0*px*py*sj0*(r00*r00)))+(((50.7125628212666)*pp*py*pz*r01*r02*(sj0*sj0)))+(((-0.969015650388763)*px*pz*r00*r02))+(((50.7125628212666)*pp*px*pz*r00*r02))+(((-101.425125642533)*px*r00*r01*(py*py*py)*(sj0*sj0)))+(((-101.425125642533)*py*pz*r01*r02*(cj0*cj0)*(px*px)))+(((-8.29190972177966)*px*py*r00*r01*(cj0*cj0)))+(((-6.5900975386236)*cj0*py*pz*r00*r02*sj0))+(((-101.425125642533)*cj0*py*sj0*(px*px*px)*(r00*r00)))+(((50.7125628212666)*cj0*pp*px*pz*r01*r02*sj0))+(((-0.850906091578033)*(cj0*cj0)*(pz*pz)*(r00*r00)))+(((-101.425125642533)*py*r00*r01*(cj0*cj0)*(px*px*px)))+(((-0.850906091578033)*(py*py)*(r02*r02)*(sj0*sj0)))+(((-12.6781407053167)*(pp*pp)*(r02*r02)))+(((0.861707867458962)*(pz*pz)*(r02*r02)))+(((50.7125628212666)*pp*(cj0*cj0)*(px*px)*(r00*r00)))+(((-1.70181218315607)*cj0*r00*r01*sj0*(pz*pz)))+(((-12.6781407053167)*(cj0*cj0)*(pp*pp)*(r00*r00)))+(((-101.425125642533)*pz*r01*r02*(py*py*py)*(sj0*sj0)))+(((50.7125628212666)*cj0*pp*py*pz*r00*r02*sj0))+(((50.7125628212666)*cj0*pp*px*py*sj0*(r01*r01))));
op[3]=(x100+x101+(((-1.0)*x98))+(((-1.0)*x99)));
op[4]=((((-9.63538693604066)*pz*(px*px)*(r00*r00)))+(((-50.7125628212666)*py*r01*r02*(pz*pz*pz)))+(((0.484507825194381)*cj0*pp*r00*r01*sj0))+(((25.3562814106333)*cj0*pp*py*pz*r00*r02*sj0))+(((0.366398266383651)*cj0*px*pz*r01*r02*sj0))+(((-19.2707738720813)*cj0*py*r00*r02*sj0*(px*px)))+(((-50.7125628212666)*pz*r00*r02*(cj0*cj0)*(px*px*px)))+(((25.3562814106333)*pp*(cj0*cj0)*(px*px)*(r00*r00)))+(((-1.83072351784773)*px*py*r00*r01))+(((-9.63538693604066)*px*r00*r02*(py*py)*(sj0*sj0)))+(((-6.33907035265833)*(pp*pp)*(r02*r02)))+(((-0.850906091578033)*cj0*r00*r01*sj0*(pz*pz)))+(((-0.484507825194381)*px*py*r00*r01*(sj0*sj0)))+(((-25.3562814106333)*(py*py*py*py)*(r01*r01)*(sj0*sj0)))+(((-6.33907035265833)*(cj0*cj0)*(pp*pp)*(r00*r00)))+(((-25.3562814106333)*(py*py)*(pz*pz)*(r01*r01)))+(((0.278221797778174)*pz*(r01*r01)*(sj0*sj0)))+(((-9.63538693604066)*pz*(cj0*cj0)*(px*px)*(r02*r02)))+(((-9.63538693604066)*pz*(py*py)*(r02*r02)*(sj0*sj0)))+(((0.366398266383651)*px*pz*r00*r02*(cj0*cj0)))+(((-4.81769346802033)*pp*pz*(r01*r01)*(sj0*sj0)))+(((-101.425125642533)*cj0*r00*r01*sj0*(px*px)*(py*py)))+(((-25.3562814106333)*(py*py)*(pz*pz)*(r02*r02)*(sj0*sj0)))+(((-25.3562814106333)*(pz*pz*pz*pz)*(r02*r02)))+(((25.3562814106333)*pp*px*py*r00*r01*(sj0*sj0)))+(((0.366398266383651)*py*pz*r01*r02*(sj0*sj0)))+(((9.63538693604066)*cj0*py*r00*r02*sj0*(pz*pz)))+(((9.63538693604066)*cj0*px*py*pz*sj0*(r00*r00)))+(((-0.484507825194381)*(py*py)*(r01*r01)*(sj0*sj0)))+(((25.3562814106333)*cj0*pp*r00*r01*sj0*(py*py)))+(((-0.278221797778174)*cj0*px*r01*r02*sj0))+(((-0.439893955178)*pz*(r02*r02)))+(((25.3562814106333)*cj0*pp*px*pz*r01*r02*sj0))+(((9.63538693604066)*cj0*pz*r00*r01*sj0*(px*px)))+(((-6.33907035265833)*(pp*pp)*(r01*r01)*(sj0*sj0)))+(((-9.63538693604066)*(pz*pz*pz)*(r02*r02)))+(((-0.425453045789016)*(cj0*cj0)*(px*px)*(r02*r02)))+(((-19.2707738720813)*cj0*px*r01*r02*sj0*(py*py)))+(((-9.63538693604066)*r01*r02*(py*py*py)*(sj0*sj0)))+(((-25.3562814106333)*(cj0*cj0)*(px*px*px*px)*(r00*r00)))+(((-101.425125642533)*cj0*py*pz*r00*r02*sj0*(px*px)))+(((25.3562814106333)*pp*py*pz*r01*r02*(sj0*sj0)))+(((25.3562814106333)*cj0*pp*px*py*sj0*(r00*r00)))+(((-19.2707738720813)*py*r01*r02*(pz*pz)))+(((-50.7125628212666)*cj0*px*py*sj0*(pz*pz)*(r02*r02)))+(((25.3562814106333)*pp*(pz*pz)*(r02*r02)))+(((-0.850906091578033)*cj0*px*py*sj0*(r02*r02)))+(((-0.425453045789016)*(pz*pz)*(r01*r01)*(sj0*sj0)))+(((-9.63538693604066)*r00*r02*(cj0*cj0)*(px*px*px)))+(((-0.278221797778174)*px*r00*r02*(cj0*cj0)))+(((4.81769346802033)*cj0*pp*px*r01*r02*sj0))+(((-19.2707738720813)*px*py*pz*r00*r01))+(((4.81769346802033)*pp*px*r00*r02*(cj0*cj0)))+(((-50.7125628212666)*cj0*py*sj0*(px*px*px)*(r00*r00)))+(((4.81769346802033)*cj0*pp*py*r00*r02*sj0))+(((25.3562814106333)*pp*px*py*r00*r01*(cj0*cj0)))+(((-0.0528497858676222)*(r02*r02)))+(((9.63538693604066)*cj0*px*py*pz*sj0*(r01*r01)))+(((-12.6781407053167)*cj0*r00*r01*sj0*(pp*pp)))+(((-50.7125628212666)*px*py*r00*r01*(pz*pz)))+(((9.63538693604066)*px*py*pz*r00*r01*(cj0*cj0)))+(((9.63538693604066)*pz*(py*py)*(r01*r01)*(sj0*sj0)))+(((-0.484507825194381)*cj0*r00*r01*sj0*(py*py)))+(((4.81769346802033)*pp*py*r01*r02))+(((-0.439893955178)*py*r01*r02))+(((-19.2707738720813)*cj0*px*py*pz*sj0*(r02*r02)))+(((-3.23059310196597)*(pz*pz)*(r02*r02)))+(((9.63538693604066)*py*r01*r02*(pz*pz)*(sj0*sj0)))+(((-0.915361758923863)*(py*py)*(r01*r01)))+(((-25.3562814106333)*(cj0*cj0)*(px*px)*(pz*pz)*(r02*r02)))+(((-0.439893955178)*px*r00*r02))+(((1.15761567152105)*pp*(r02*r02)))+(((25.3562814106333)*pp*px*pz*r00*r02))+(((-9.63538693604066)*pz*(py*py)*(r01*r01)))+(((0.278221797778174)*pz*(cj0*cj0)*(r00*r00)))+(((9.63538693604066)*px*py*pz*r00*r01*(sj0*sj0)))+(((25.3562814106333)*pp*px*pz*r00*r02*(cj0*cj0)))+(((-19.2707738720813)*px*r00*r02*(pz*pz)))+(((0.0153712106632144)*(r01*r01)*(sj0*sj0)))+(((9.63538693604066)*cj0*px*r01*r02*sj0*(pz*pz)))+(((25.3562814106333)*cj0*pp*r00*r01*sj0*(px*px)))+(((-50.7125628212666)*pz*r01*r02*(py*py*py)*(sj0*sj0)))+(((0.0153712106632144)*(cj0*cj0)*(r00*r00)))+(((0.242253912597191)*pp*(r01*r01)*(sj0*sj0)))+(((0.0307424213264288)*cj0*r00*r01*sj0))+(((-50.7125628212666)*cj0*px*sj0*(py*py*py)*(r01*r01)))+(((25.3562814106333)*pp*(py*py)*(r01*r01)*(sj0*sj0)))+(((25.3562814106333)*pp*py*pz*r01*r02))+(((4.81769346802033)*pp*pz*(r02*r02)))+(((0.366398266383651)*cj0*py*pz*r00*r02*sj0))+(((-4.14595486088983)*py*pz*r01*r02))+(((-25.3562814106333)*(px*px)*(pz*pz)*(r00*r00)))+(((-0.425453045789016)*(py*py)*(r02*r02)*(sj0*sj0)))+(((-4.14595486088983)*px*pz*r00*r02))+(((-50.7125628212666)*py*pz*r01*r02*(cj0*cj0)*(px*px)))+(((-50.7125628212666)*px*r00*r02*(pz*pz*pz)))+(((-25.3562814106333)*(cj0*cj0)*(px*px)*(py*py)*(r01*r01)))+(((-4.81769346802033)*pp*pz*(cj0*cj0)*(r00*r00)))+(((-0.484507825194381)*px*py*r00*r01*(cj0*cj0)))+(((-101.425125642533)*cj0*px*pz*r01*r02*sj0*(py*py)))+(((9.63538693604066)*pz*(cj0*cj0)*(px*px)*(r00*r00)))+(((0.556443595556348)*cj0*pz*r00*r01*sj0))+(((-0.278221797778174)*py*r01*r02*(sj0*sj0)))+(((-50.7125628212666)*px*pz*r00*r02*(py*py)*(sj0*sj0)))+(((-50.7125628212666)*py*r00*r01*(cj0*cj0)*(px*px*px)))+(((-9.63538693604066)*cj0*pp*pz*r00*r01*sj0))+(((-0.278221797778174)*cj0*py*r00*r02*sj0))+(((-9.63538693604066)*py*r01*r02*(cj0*cj0)*(px*px)))+(((9.63538693604066)*px*r00*r02*(cj0*cj0)*(pz*pz)))+(((-0.915361758923863)*(px*px)*(r00*r00)))+(((4.81769346802033)*pp*py*r01*r02*(sj0*sj0)))+(((-0.484507825194381)*cj0*r00*r01*sj0*(px*px)))+(((-0.484507825194381)*cj0*px*py*sj0*(r00*r00)))+(((0.242253912597191)*pp*(cj0*cj0)*(r00*r00)))+(((-50.7125628212666)*px*r00*r01*(py*py*py)*(sj0*sj0)))+(((-25.3562814106333)*(px*px)*(py*py)*(r00*r00)*(sj0*sj0)))+(((9.63538693604066)*cj0*pz*r00*r01*sj0*(py*py)))+(((-0.425453045789016)*(cj0*cj0)*(pz*pz)*(r00*r00)))+(((25.3562814106333)*cj0*pp*px*py*sj0*(r01*r01)))+(((4.81769346802033)*pp*px*r00*r02))+(((-0.484507825194381)*cj0*px*py*sj0*(r01*r01)))+(((-0.484507825194381)*(cj0*cj0)*(px*px)*(r00*r00))));
polyroots4(op,zeror,numroots);
IkReal j1array[4], cj1array[4], sj1array[4], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[4]={true,true,true,true};
_nj1 = 4;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
sj4array[0]=(((r00*sj0))+(((-1.0)*cj0*r01)));
if( sj4array[0] >= -1-IKFAST_SINCOS_THRESH && sj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKasin(sj4array[0]);
    cj4array[0] = IKcos(j4array[0]);
    sj4array[1] = sj4array[0];
    j4array[1] = j4array[0] > 0 ? (IKPI-j4array[0]) : (-IKPI-j4array[0]);
    cj4array[1] = -cj4array[0];
}
else if( isnan(sj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal dummyeval[1];
IkReal gconst0;
gconst0=IKsign(cj4);
dummyeval[0]=cj4;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj4;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[9];
bool bgotonextstatement = true;
do
{
IkReal x102=pz*pz;
IkReal x103=py*py;
IkReal x104=px*px;
IkReal x105=(r01*sj0);
IkReal x106=((0.19)*cj1);
IkReal x107=(pp*sj1);
IkReal x108=((1.0)*r02);
IkReal x109=((0.38)*pz);
IkReal x110=((1.0)*pz);
IkReal x111=(py*r01);
IkReal x112=(px*sj0);
IkReal x113=(cj0*r00);
IkReal x114=((1.0)*cj1);
IkReal x115=((0.0361)*sj1);
IkReal x116=((2.0)*sj1);
IkReal x117=((0.0361)*cj1);
IkReal x118=((2.0)*cj1);
IkReal x119=(py*r00);
IkReal x120=((0.19)*sj1);
IkReal x121=(cj0*px);
IkReal x122=(px*r00);
IkReal x123=(py*r02*sj0);
IkReal x124=(pz*x118);
IkReal x125=(r02*x121);
IkReal x126=(pz*x116);
IkReal x127=(r02*x102);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x112))+((cj0*py)));
evalcond[2]=((1.0)+(((-1.0)*r00*sj0))+((cj0*r01)));
evalcond[3]=(((sj1*x113))+((sj1*x105))+(((-1.0)*cj1*x108)));
evalcond[4]=((((-1.0)*x113*x114))+(((-1.0)*x105*x114))+(((-1.0)*sj1*x108)));
evalcond[5]=((((-1.0)*pz*x108))+((x113*x120))+((x105*x120))+(((-1.0)*r02*x106))+(((-1.0)*x122))+(((-1.0)*x111)));
evalcond[6]=((((-1.0)*x110*x113))+x125+x123+(((-1.0)*r02*x120))+(((-1.0)*x106*x113))+(((-1.0)*x105*x110))+(((-1.0)*x105*x106)));
evalcond[7]=((((-1.0)*x104*x113*x116))+((r02*x109))+(((-1.0)*x123*x126))+((x111*x124))+((r02*x117))+(((-1.0)*x111*x116*x121))+(((-1.0)*cj1*pp*x108))+(((-1.0)*x113*x115))+(((-1.0)*x103*x105*x116))+((x122*x124))+(((-1.0)*x112*x116*x119))+(((-1.0)*x125*x126))+((x105*x107))+(((-1.0)*x105*x115))+((x118*x127))+(((0.38)*x111))+(((0.38)*x122))+((x107*x113)));
evalcond[8]=(((x104*x113*x118))+((x111*x126))+((x112*x118*x119))+((x103*x105*x118))+(((-1.0)*x113*x117))+(((-1.0)*x107*x108))+(((-1.0)*pp*x113*x114))+((x122*x126))+(((-1.0)*pp*x105*x114))+(((-1.0)*x109*x113))+((x123*x124))+((x124*x125))+((x116*x127))+(((-1.0)*r02*x115))+(((-1.0)*x105*x117))+(((-1.0)*x105*x109))+(((0.38)*x125))+(((0.38)*x123))+((x111*x118*x121)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst7;
gconst7=((-0.602)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst8;
gconst8=((-0.056)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst9;
IkReal x128=((1.0)*cj1);
gconst9=((((-1.0)*py*sj0*x128))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x128)));
IkReal gconst10;
gconst10=-0.546;
IkReal gconst11;
IkReal x129=((1.0)*cj1);
gconst11=((((-1.0)*py*sj0*x129))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x129)));
IkReal gconst12;
gconst12=((-0.602)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst13;
gconst13=((-0.056)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst14;
IkReal x130=((1.0)*cj1);
gconst14=((((-1.0)*py*sj0*x130))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x130)));
IkReal gconst15;
gconst15=-0.546;
IkReal gconst16;
IkReal x131=((1.0)*cj1);
gconst16=((((-1.0)*py*sj0*x131))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x131)));
IkReal gconst17;
gconst17=-1.092;
IkReal gconst18;
gconst18=0.824;
IkReal gconst19;
gconst19=-0.268;
IkReal gconst20;
gconst20=-1.092;
IkReal gconst21;
gconst21=0.824;
IkReal gconst22;
gconst22=-0.268;
IkReal gconst23;
gconst23=((0.222)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst24;
gconst24=((-0.324)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst25;
IkReal x132=((1.0)*cj1);
gconst25=((((-1.0)*py*sj0*x132))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x132)));
IkReal gconst26;
gconst26=0.546;
IkReal gconst27;
IkReal x133=((1.0)*cj1);
gconst27=((((-1.0)*py*sj0*x133))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x133)));
IkReal gconst28;
gconst28=((0.222)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst29;
gconst29=((-0.324)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst30;
IkReal x134=((1.0)*cj1);
gconst30=((((-1.0)*py*sj0*x134))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x134)));
IkReal gconst31;
gconst31=0.546;
IkReal gconst32;
IkReal x135=((1.0)*cj1);
gconst32=((((-1.0)*py*sj0*x135))+(((-1.0)*pz*sj1))+(((-1.0)*cj0*px*x135)));
IkReal x136=((1.0)*gconst24);
IkReal x137=(gconst29*gconst30);
IkReal x138=(gconst23*gconst27);
IkReal x139=(gconst28*gconst32);
dummyeval[0]=(((x137*x138))+(((-1.0)*x138*x139))+(((-1.0)*gconst26*gconst28*gconst31*x136))+((gconst24*gconst25*x139))+(((-1.0)*gconst25*x136*x137)));
if( IKabs(dummyeval[0]) < 0.0000001000000000  )
{
continue;

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x140=(gconst18*gconst8);
IkReal x141=(gconst28*gconst32);
IkReal x142=(gconst20*gconst24);
IkReal x143=(gconst14*gconst26);
IkReal x144=(gconst13*gconst23);
IkReal x145=(gconst21*gconst27);
IkReal x146=((1.0)*gconst30);
IkReal x147=(gconst25*gconst8);
IkReal x148=(gconst11*gconst14);
IkReal x149=(gconst10*gconst21);
IkReal x150=(gconst24*gconst9);
IkReal x151=((1.0)*gconst23);
IkReal x152=(gconst12*gconst32);
IkReal x153=(gconst12*gconst22);
IkReal x154=(gconst13*gconst7);
IkReal x155=((1.0)*gconst10);
IkReal x156=(gconst12*gconst24);
IkReal x157=(gconst28*gconst31);
IkReal x158=(gconst11*gconst30);
IkReal x159=(gconst24*gconst25);
IkReal x160=(gconst11*gconst17);
IkReal x161=(gconst19*gconst28);
IkReal x162=(gconst8*gconst9);
IkReal x163=((1.0)*gconst7);
IkReal x164=(gconst12*gconst16);
IkReal x165=(gconst18*gconst24);
IkReal x166=(gconst21*gconst29);
IkReal x167=(gconst19*gconst21);
IkReal x168=(gconst11*gconst21);
IkReal x169=(gconst16*gconst28);
IkReal x170=(gconst10*gconst14);
IkReal x171=(gconst20*gconst8);
IkReal x172=(gconst15*gconst28);
IkReal x173=(gconst29*gconst7);
IkReal x174=(gconst14*gconst19);
IkReal x175=(gconst22*gconst28);
IkReal x176=(gconst27*gconst30);
IkReal x177=(gconst15*gconst17);
IkReal x178=(gconst19*gconst23);
IkReal x179=(gconst23*gconst29);
IkReal x180=((1.0)*gconst14);
IkReal x181=(gconst14*gconst27);
IkReal x182=(gconst12*gconst19);
IkReal x183=((1.0)*gconst26);
IkReal x184=(gconst12*gconst31);
IkReal x185=((1.0)*gconst21);
IkReal x186=(gconst21*gconst26);
IkReal x187=(gconst17*gconst19);
IkReal x188=(gconst26*gconst30);
IkReal x189=(gconst19*gconst30);
IkReal x190=(gconst10*gconst30);
IkReal x191=(gconst12*gconst15);
IkReal x192=(gconst17*gconst27);
IkReal x193=(gconst29*x181);
IkReal x194=(gconst8*x183);
IkReal x195=((1.0)*gconst17*gconst20);
IkReal x196=(x163*x182);
op[0]=(((x176*x179))+(((-1.0)*gconst27*x141*x151))+(((-1.0)*gconst29*x146*x159))+(((-1.0)*gconst24*x157*x183))+((x141*x159)));
op[1]=((((-1.0)*gconst27*x151*x175))+(((-1.0)*gconst19*x141*x151))+((x141*x165))+(((-1.0)*gconst29*x146*x165))+((x145*x179))+((gconst29*gconst30*x178))+(((-1.0)*x159*x166))+((x159*x175))+((x142*x188))+((x157*x192)));
op[2]=(((x157*x187))+((x144*x176))+(((-1.0)*gconst11*x141*x151))+(((-1.0)*gconst24*x155*x157))+(((-1.0)*gconst29*x146*x150))+((x179*x181))+(((-1.0)*gconst27*x141*x163))+(((-1.0)*gconst29*x146*x147))+((x152*x159))+((x173*x176))+((x141*x150))+((x166*x178))+((x141*x147))+(((-1.0)*gconst24*x172*x183))+(((-1.0)*gconst22*x151*x161))+((x165*x175))+(((-1.0)*gconst31*x156*x183))+(((-1.0)*x157*x194))+(((-1.0)*gconst13*x146*x159))+((x142*x186))+((x158*x179))+(((-1.0)*gconst27*x151*x152))+((x159*x169))+(((-1.0)*gconst29*x159*x180))+(((-1.0)*gconst27*x151*x169))+(((-1.0)*x165*x166))+(((-1.0)*gconst20*x146*x192)));
op[3]=((((-1.0)*gconst19*x151*x152))+((x153*x159))+((x144*x189))+((x140*x141))+(((-1.0)*gconst13*x146*x165))+((x142*x143))+(((-1.0)*x150*x166))+(((-1.0)*gconst16*x151*x161))+((x157*x160))+((x173*x189))+((x144*x145))+((x172*x192))+((x152*x165))+(((-1.0)*x145*x195))+(((-1.0)*gconst13*x159*x185))+(((-1.0)*gconst27*x163*x175))+((x184*x192))+((x150*x175))+((x174*x179))+((x145*x173))+((x171*x188))+((x147*x175))+((gconst11*gconst23*x166))+(((-1.0)*x147*x166))+((x165*x169))+(((-1.0)*gconst29*x165*x180))+(((-1.0)*gconst11*x151*x175))+(((-1.0)*gconst27*x151*x153))+((x142*x190))+(((-1.0)*gconst20*x146*x187))+(((-1.0)*gconst19*x141*x163))+(((-1.0)*gconst29*x140*x146)));
op[4]=((((-1.0)*gconst27*x152*x163))+(((-1.0)*gconst19*x151*x153))+((x144*x181))+(((-1.0)*gconst22*x161*x163))+((x142*x149))+((x161*x177))+((x144*x167))+(((-1.0)*gconst8*x155*x157))+(((-1.0)*gconst29*x150*x180))+((x173*x181))+((x144*x158))+(((-1.0)*gconst11*x141*x163))+((x150*x152))+((x140*x175))+(((-1.0)*gconst24*x155*x172))+((gconst16*gconst25*x156))+(((-1.0)*gconst13*x159*x180))+(((-1.0)*gconst15*x156*x183))+(((-1.0)*gconst27*x163*x169))+((x150*x169))+((x141*x162))+(((-1.0)*gconst13*x165*x185))+(((-1.0)*gconst29*x146*x162))+((x147*x169))+(((-1.0)*gconst20*x180*x192))+(((-1.0)*x184*x194))+((x148*x179))+((x171*x186))+(((-1.0)*gconst20*x146*x160))+(((-1.0)*gconst11*x151*x152))+((x147*x152))+((gconst17*gconst31*x182))+((x154*x176))+(((-1.0)*gconst11*x151*x169))+(((-1.0)*x140*x166))+(((-1.0)*x172*x194))+((gconst19*gconst7*x166))+(((-1.0)*gconst29*x147*x180))+(((-1.0)*gconst13*x146*x150))+(((-1.0)*x167*x195))+((x158*x173))+(((-1.0)*gconst13*x146*x147))+(((-1.0)*gconst27*x151*x164))+((x153*x165))+(((-1.0)*gconst31*x155*x156)));
op[5]=((((-1.0)*gconst20*x160*x185))+((x143*x171))+((x144*x174))+(((-1.0)*gconst11*x163*x175))+((x140*x152))+(((-1.0)*gconst13*x150*x185))+(((-1.0)*gconst19*x152*x163))+((x144*x168))+(((-1.0)*gconst16*x161*x163))+((x162*x175))+((x140*x169))+(((-1.0)*gconst13*x147*x185))+((x150*x153))+((x173*x174))+((gconst12*gconst27*x177))+((x145*x154))+(((-1.0)*gconst13*x165*x180))+((x154*x189))+((gconst16*gconst18*x156))+(((-1.0)*gconst27*x153*x163))+(((-1.0)*x162*x166))+(((-1.0)*gconst11*x151*x153))+((x171*x190))+((x147*x153))+((gconst11*gconst7*x166))+(((-1.0)*x174*x195))+(((-1.0)*gconst29*x140*x180))+(((-1.0)*gconst19*x151*x164))+(((-1.0)*gconst13*x140*x146))+((x142*x170))+((x160*x172))+((x160*x184)));
op[6]=((((-1.0)*gconst11*x163*x169))+((x177*x182))+(((-1.0)*gconst19*x153*x163))+(((-1.0)*gconst13*x146*x162))+(((-1.0)*gconst29*x162*x180))+((x140*x153))+(((-1.0)*gconst13*x150*x180))+(((-1.0)*x191*x194))+((x149*x171))+(((-1.0)*gconst13*x147*x180))+((x144*x148))+((x152*x162))+((x162*x169))+(((-1.0)*gconst8*x155*x184))+(((-1.0)*gconst27*x163*x164))+((x150*x164))+(((-1.0)*gconst13*x140*x185))+((x147*x164))+((x154*x181))+((x154*x158))+(((-1.0)*x148*x195))+((x148*x173))+((x154*x167))+(((-1.0)*gconst11*x152*x163))+(((-1.0)*gconst11*x151*x164))+(((-1.0)*gconst15*x155*x156))+(((-1.0)*gconst8*x155*x172)));
op[7]=((((-1.0)*gconst13*x162*x185))+((x160*x191))+(((-1.0)*gconst11*x153*x163))+((x140*x164))+(((-1.0)*gconst13*x140*x180))+(((-1.0)*gconst19*x163*x164))+((x154*x168))+((x170*x171))+((x154*x174))+((x153*x162)));
op[8]=((((-1.0)*gconst11*x163*x164))+(((-1.0)*gconst13*x162*x180))+(((-1.0)*gconst8*x155*x191))+((x162*x164))+((x148*x154)));
polyroots8(op,zeror,numroots);
IkReal j2array[8], cj2array[8], sj2array[8], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[8]={true,true,true,true,true,true,true,true};
_nj2 = 8;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal dummyeval[1];
IkReal gconst49;
gconst49=IKsign(((((273.0)*(sj2*sj2)))+(((273.0)*(cj2*cj2)))));
dummyeval[0]=((sj2*sj2)+(cj2*cj2));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst50;
gconst50=IKsign(((((273.0)*(sj2*sj2)))+(((273.0)*(cj2*cj2)))));
dummyeval[0]=((sj2*sj2)+(cj2*cj2));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x197=(cj1*r00);
IkReal x198=((1000.0)*sj2);
IkReal x199=(cj0*sj1);
IkReal x200=(sj0*sj1);
IkReal x201=(cj1*pz);
IkReal x202=((1000.0)*cj2);
IkReal x203=(pz*r00);
IkReal x204=(px*r02);
IkReal x205=(pz*r01);
IkReal x206=(py*x202);
IkReal x207=(cj1*px*r01);
CheckValue<IkReal> x208 = IKatan2WithCheck((gconst50*((((py*x198*x200))+(((-190.0)*sj2))+(((-1.0)*x197*x206))+((x199*x202*x205))+((x200*x202*x204))+((px*x198*x199))+(((-1.0)*x198*x201))+((x202*x207))+(((-1.0)*x200*x202*x203))+(((-1.0)*r02*x199*x206))))),(gconst50*(((((-139.0)*(sj2*sj2)))+(((-1.0)*x201*x202))+(((-1.0)*x198*x200*x204))+((x200*x206))+(((-190.0)*cj2))+(((-1.0)*x198*x207))+((py*r02*x198*x199))+((px*x199*x202))+((x198*x200*x203))+((py*x197*x198))+(((-1.0)*x198*x199*x205))+(((-139.0)*(cj2*cj2)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x208.valid){
continue;
}
j3array[0]=x208.value;
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x209=IKcos(j3);
IkReal x210=IKsin(j3);
IkReal x211=((0.139)*sj2);
IkReal x212=((0.139)*cj2);
IkReal x213=(px*sj1);
IkReal x214=(py*sj1);
IkReal x215=((1.0)*r00);
IkReal x216=(cj1*sj0);
IkReal x217=((1.0)*px);
IkReal x218=((1.0)*pz);
IkReal x219=(pz*sj1);
IkReal x220=(cj0*r01);
IkReal x221=(cj0*cj1);
IkReal x222=((0.273)*x209);
IkReal x223=((0.273)*x210);
IkReal x224=(sj2*x222);
IkReal x225=(cj2*x223);
IkReal x226=(sj2*x223);
IkReal x227=(cj2*x222);
IkReal x228=(x211+x224);
IkReal x229=(x212+x227+x226);
evalcond[0]=((-0.19)+((cj0*x213))+(((-1.0)*cj1*x218))+((sj0*x214))+(((-1.0)*x229)));
evalcond[1]=((((-1.0)*py*x216))+(((-1.0)*sj1*x218))+x228+(((-1.0)*x217*x221))+(((-1.0)*x225)));
evalcond[2]=(((r02*sj0*x213))+(((-1.0)*cj0*r02*x214))+((x219*x220))+x228+(((-1.0)*cj1*py*x215))+((cj1*px*r01))+(((-1.0)*x225))+(((-1.0)*sj0*x215*x219)));
evalcond[3]=((((-0.19)*x220))+x229+((py*r02*x221))+(((-1.0)*cj1*x218*x220))+(((0.19)*r00*sj0))+(((-1.0)*x214*x215))+((r01*x213))+(((-1.0)*r02*x216*x217))+((pz*r00*x216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x230=((1000.0)*sj2);
IkReal x231=(cj0*px);
IkReal x232=((1000.0)*cj2);
IkReal x233=(cj1*pz);
IkReal x234=(pz*sj1);
IkReal x235=(cj1*py*sj0);
IkReal x236=(py*sj0*sj1);
CheckValue<IkReal> x237 = IKatan2WithCheck((gconst49*(((((-1.0)*cj1*x231*x232))+(((-190.0)*sj2))+(((-1.0)*x230*x233))+((x230*x236))+((sj1*x230*x231))+(((-1.0)*x232*x234))+(((-1.0)*x232*x235))))),(gconst49*((((cj1*x230*x231))+(((-139.0)*(sj2*sj2)))+((x232*x236))+(((-190.0)*cj2))+((x230*x234))+((x230*x235))+((sj1*x231*x232))+(((-1.0)*x232*x233))+(((-139.0)*(cj2*cj2)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x237.valid){
continue;
}
j3array[0]=x237.value;
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x238=IKcos(j3);
IkReal x239=IKsin(j3);
IkReal x240=((0.139)*sj2);
IkReal x241=((0.139)*cj2);
IkReal x242=(px*sj1);
IkReal x243=(py*sj1);
IkReal x244=((1.0)*r00);
IkReal x245=(cj1*sj0);
IkReal x246=((1.0)*px);
IkReal x247=((1.0)*pz);
IkReal x248=(pz*sj1);
IkReal x249=(cj0*r01);
IkReal x250=(cj0*cj1);
IkReal x251=((0.273)*x238);
IkReal x252=((0.273)*x239);
IkReal x253=(sj2*x251);
IkReal x254=(cj2*x252);
IkReal x255=(sj2*x252);
IkReal x256=(cj2*x251);
IkReal x257=(x253+x240);
IkReal x258=(x255+x256+x241);
evalcond[0]=((-0.19)+((cj0*x242))+(((-1.0)*cj1*x247))+((sj0*x243))+(((-1.0)*x258)));
evalcond[1]=((((-1.0)*sj1*x247))+(((-1.0)*py*x245))+(((-1.0)*x246*x250))+x257+(((-1.0)*x254)));
evalcond[2]=(((r02*sj0*x242))+(((-1.0)*cj1*py*x244))+((x248*x249))+(((-1.0)*sj0*x244*x248))+x257+(((-1.0)*cj0*r02*x243))+((cj1*px*r01))+(((-1.0)*x254)));
evalcond[3]=((((-1.0)*cj1*x247*x249))+(((-1.0)*x243*x244))+x258+(((-1.0)*r02*x245*x246))+(((0.19)*r00*sj0))+((py*r02*x250))+((pz*r00*x245))+((r01*x242))+(((-0.19)*x249)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x259=pz*pz;
IkReal x260=py*py;
IkReal x261=px*px;
IkReal x262=(r01*sj0);
IkReal x263=((0.19)*cj1);
IkReal x264=(pp*sj1);
IkReal x265=((1.0)*r02);
IkReal x266=((0.38)*pz);
IkReal x267=((1.0)*pz);
IkReal x268=(py*r01);
IkReal x269=(px*sj0);
IkReal x270=(cj0*r00);
IkReal x271=((1.0)*cj1);
IkReal x272=((0.0361)*sj1);
IkReal x273=((2.0)*sj1);
IkReal x274=((0.0361)*cj1);
IkReal x275=((2.0)*cj1);
IkReal x276=(py*r00);
IkReal x277=((0.19)*sj1);
IkReal x278=(cj0*px);
IkReal x279=(px*r00);
IkReal x280=(py*r02*sj0);
IkReal x281=(pz*x275);
IkReal x282=(r02*x278);
IkReal x283=(pz*x273);
IkReal x284=(r02*x259);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x269))+((cj0*py)));
evalcond[2]=((-1.0)+(((-1.0)*r00*sj0))+((cj0*r01)));
evalcond[3]=((((-1.0)*cj1*x265))+((sj1*x262))+((sj1*x270)));
evalcond[4]=((((-1.0)*x262*x271))+(((-1.0)*sj1*x265))+(((-1.0)*x270*x271)));
evalcond[5]=((((-1.0)*x268))+(((-1.0)*x279))+((x262*x277))+((x270*x277))+(((-1.0)*r02*x263))+(((-1.0)*pz*x265)));
evalcond[6]=((((-1.0)*x262*x267))+(((-1.0)*x262*x263))+(((-1.0)*x263*x270))+x282+x280+(((-1.0)*r02*x277))+(((-1.0)*x267*x270)));
evalcond[7]=(((x268*x281))+((x279*x281))+(((-1.0)*x262*x272))+((r02*x274))+(((0.38)*x279))+(((0.38)*x268))+((r02*x266))+((x262*x264))+(((-1.0)*x280*x283))+(((-1.0)*x261*x270*x273))+((x264*x270))+(((-1.0)*cj1*pp*x265))+(((-1.0)*x282*x283))+((x275*x284))+(((-1.0)*x260*x262*x273))+(((-1.0)*x270*x272))+(((-1.0)*x268*x273*x278))+(((-1.0)*x269*x273*x276)));
evalcond[8]=(((x268*x283))+(((-1.0)*x262*x266))+((x268*x275*x278))+((x279*x283))+(((-1.0)*x262*x274))+((x260*x262*x275))+((x269*x275*x276))+((x273*x284))+((x261*x270*x275))+(((-1.0)*pp*x270*x271))+(((-1.0)*r02*x272))+(((-1.0)*x266*x270))+(((-1.0)*pp*x262*x271))+(((-1.0)*x270*x274))+((x280*x281))+(((0.38)*x280))+(((0.38)*x282))+(((-1.0)*x264*x265))+((x281*x282)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst51;
gconst51=((-0.602)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst52;
gconst52=((-0.056)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst53;
IkReal x285=((1.0)*cj1);
gconst53=((((-1.0)*py*sj0*x285))+(((-1.0)*cj0*px*x285))+(((-1.0)*pz*sj1)));
IkReal gconst54;
gconst54=-0.546;
IkReal gconst55;
IkReal x286=((1.0)*cj1);
gconst55=((((-1.0)*py*sj0*x286))+(((-1.0)*cj0*px*x286))+(((-1.0)*pz*sj1)));
IkReal gconst56;
gconst56=((-0.602)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst57;
gconst57=((-0.056)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst58;
IkReal x287=((1.0)*cj1);
gconst58=((((-1.0)*py*sj0*x287))+(((-1.0)*cj0*px*x287))+(((-1.0)*pz*sj1)));
IkReal gconst59;
gconst59=-0.546;
IkReal gconst60;
IkReal x288=((1.0)*cj1);
gconst60=((((-1.0)*py*sj0*x288))+(((-1.0)*cj0*px*x288))+(((-1.0)*pz*sj1)));
IkReal gconst61;
gconst61=-1.092;
IkReal gconst62;
gconst62=0.824;
IkReal gconst63;
gconst63=-0.268;
IkReal gconst64;
gconst64=-1.092;
IkReal gconst65;
gconst65=0.824;
IkReal gconst66;
gconst66=-0.268;
IkReal gconst67;
gconst67=((0.222)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst68;
gconst68=((-0.324)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst69;
IkReal x289=((1.0)*cj1);
gconst69=((((-1.0)*py*sj0*x289))+(((-1.0)*cj0*px*x289))+(((-1.0)*pz*sj1)));
IkReal gconst70;
gconst70=0.546;
IkReal gconst71;
IkReal x290=((1.0)*cj1);
gconst71=((((-1.0)*cj0*px*x290))+(((-1.0)*py*sj0*x290))+(((-1.0)*pz*sj1)));
IkReal gconst72;
gconst72=((0.222)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst73;
gconst73=((-0.324)+(((-1.0)*cj1*pz))+((cj0*px*sj1))+((py*sj0*sj1)));
IkReal gconst74;
IkReal x291=((1.0)*cj1);
gconst74=((((-1.0)*cj0*px*x291))+(((-1.0)*py*sj0*x291))+(((-1.0)*pz*sj1)));
IkReal gconst75;
gconst75=0.546;
IkReal gconst76;
IkReal x292=((1.0)*cj1);
gconst76=((((-1.0)*cj0*px*x292))+(((-1.0)*py*sj0*x292))+(((-1.0)*pz*sj1)));
IkReal x293=(gconst68*gconst69);
IkReal x294=(gconst72*gconst76);
IkReal x295=(gconst73*gconst74);
IkReal x296=(gconst67*gconst71);
dummyeval[0]=((((-1.0)*x293*x295))+(((-1.0)*gconst68*gconst70*gconst72*gconst75))+(((-1.0)*x294*x296))+((x295*x296))+((x293*x294)));
if( IKabs(dummyeval[0]) < 0.0000001000000000  )
{
continue;

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x297=(gconst52*gconst56);
IkReal x298=(gconst53*gconst60);
IkReal x299=(gconst66*gconst72);
IkReal x300=(gconst53*gconst68);
IkReal x301=(gconst57*gconst65);
IkReal x302=(gconst63*gconst67);
IkReal x303=(gconst68*gconst70);
IkReal x304=(gconst64*gconst65);
IkReal x305=(gconst57*gconst58);
IkReal x306=(gconst52*gconst69);
IkReal x307=((1.0)*gconst75);
IkReal x308=(gconst67*gconst71);
IkReal x309=(gconst57*gconst74);
IkReal x310=(gconst60*gconst71);
IkReal x311=(gconst66*gconst69);
IkReal x312=(gconst58*gconst73);
IkReal x313=(gconst55*gconst67);
IkReal x314=(gconst65*gconst73);
IkReal x315=(gconst55*gconst76);
IkReal x316=((1.0)*gconst60);
IkReal x317=(gconst52*gconst62);
IkReal x318=((1.0)*gconst56);
IkReal x319=(gconst54*gconst59);
IkReal x320=(gconst56*gconst68);
IkReal x321=(gconst62*gconst66);
IkReal x322=(gconst51*gconst55);
IkReal x323=(gconst72*gconst76);
IkReal x324=(gconst52*gconst70);
IkReal x325=(gconst58*gconst64);
IkReal x326=(gconst51*gconst63);
IkReal x327=(gconst54*gconst68);
IkReal x328=(gconst64*gconst74);
IkReal x329=((1.0)*gconst61);
IkReal x330=(gconst73*gconst74);
IkReal x331=(gconst52*gconst54);
IkReal x332=(gconst68*gconst72);
IkReal x333=(gconst60*gconst72);
IkReal x334=(gconst51*gconst71);
IkReal x335=(gconst68*gconst69);
IkReal x336=(gconst60*gconst69);
IkReal x337=(gconst69*gconst76);
IkReal x338=(gconst61*gconst72);
IkReal x339=(gconst60*gconst62);
IkReal x340=(gconst52*gconst72);
IkReal x341=(gconst52*gconst53);
IkReal x342=(gconst71*gconst75);
IkReal x343=(gconst56*gconst61);
IkReal x344=(gconst62*gconst68);
IkReal x345=(gconst63*gconst75);
IkReal x346=(gconst62*gconst76);
IkReal x347=(gconst55*gconst75);
IkReal x348=(gconst73*x308);
IkReal x349=((1.0)*x344);
IkReal x350=((1.0)*gconst51*gconst72);
IkReal x351=((1.0)*gconst59*gconst72);
IkReal x352=((1.0)*x335);
IkReal x353=(gconst59*x343);
IkReal x354=((1.0)*x341);
IkReal x355=((1.0)*gconst69*x305);
op[0]=((((-1.0)*gconst72*x303*x307))+(((-1.0)*x330*x352))+((x308*x330))+((x323*x335))+(((-1.0)*x308*x323)));
op[1]=((((-1.0)*x314*x352))+(((-1.0)*x330*x349))+(((-1.0)*x302*x323))+((x308*x314))+((x303*x328))+((x302*x330))+(((-1.0)*x299*x308))+((x299*x335))+((x323*x344))+((x338*x342)));
op[2]=(((x302*x314))+(((-1.0)*x309*x352))+(((-1.0)*gconst56*x303*x307))+((x330*x334))+(((-1.0)*x314*x349))+((x332*x336))+(((-1.0)*x313*x323))+((x303*x304))+((x308*x312))+((x299*x344))+(((-1.0)*x306*x330))+((x320*x337))+(((-1.0)*x299*x302))+((x308*x309))+(((-1.0)*x323*x334))+(((-1.0)*gconst72*x308*x316))+((x338*x345))+(((-1.0)*gconst71*x328*x329))+(((-1.0)*gconst72*x307*x324))+(((-1.0)*gconst72*x307*x327))+((x306*x323))+(((-1.0)*x300*x330))+((x313*x330))+((x300*x323))+(((-1.0)*x312*x352))+(((-1.0)*gconst76*x308*x318))+(((-1.0)*x303*x351)));
op[3]=(((x301*x308))+(((-1.0)*x309*x349))+(((-1.0)*gconst71*x304*x329))+((x302*x312))+(((-1.0)*x323*x326))+((x327*x328))+(((-1.0)*x300*x314))+(((-1.0)*gconst76*x302*x318))+(((-1.0)*x299*x313))+((x332*x339))+(((-1.0)*gconst72*x302*x316))+((x303*x325))+(((-1.0)*x299*x334))+((x299*x306))+((x299*x300))+(((-1.0)*gconst63*x328*x329))+((x324*x328))+(((-1.0)*x301*x352))+(((-1.0)*x317*x330))+((x317*x323))+((x302*x309))+((x314*x334))+(((-1.0)*x306*x314))+(((-1.0)*x312*x349))+((x338*x347))+((gconst59*gconst71*x338))+(((-1.0)*gconst66*x308*x318))+((x311*x320))+((x326*x330))+((x320*x346))+((x342*x343))+((x313*x314)));
op[4]=(((x301*x302))+(((-1.0)*gconst54*x307*x320))+(((-1.0)*gconst59*x303*x318))+(((-1.0)*x330*x354))+((x312*x313))+(((-1.0)*x299*x326))+((gconst56*gconst76*x300))+(((-1.0)*x300*x312))+((x320*x321))+((x304*x327))+((x304*x324))+(((-1.0)*gconst66*x302*x318))+(((-1.0)*x301*x349))+(((-1.0)*x315*x350))+((x299*x317))+(((-1.0)*x319*x332))+(((-1.0)*x314*x317))+(((-1.0)*gconst55*x328*x329))+((x309*x313))+(((-1.0)*gconst56*x308*x316))+((x314*x326))+((x320*x336))+(((-1.0)*gconst76*x313*x318))+(((-1.0)*gconst72*x307*x331))+((gconst59*gconst63*x338))+(((-1.0)*gconst70*x297*x307))+(((-1.0)*x300*x309))+((x323*x341))+(((-1.0)*gconst72*x313*x316))+(((-1.0)*x306*x309))+((x305*x308))+((x298*x332))+(((-1.0)*gconst71*x325*x329))+(((-1.0)*x306*x312))+(((-1.0)*gconst63*x304*x329))+((x297*x337))+(((-1.0)*gconst76*x318*x334))+(((-1.0)*x310*x350))+((x322*x330))+((x312*x334))+(((-1.0)*x305*x352))+((x306*x333))+((x343*x345))+(((-1.0)*x324*x351))+((x309*x334)));
op[5]=((((-1.0)*x314*x354))+((x325*x327))+(((-1.0)*x299*x322))+((x297*x311))+(((-1.0)*gconst66*x313*x318))+((x301*x313))+(((-1.0)*gconst55*x304*x329))+(((-1.0)*x312*x317))+((x297*x346))+((x312*x326))+(((-1.0)*gconst66*x318*x334))+((x299*x341))+(((-1.0)*x309*x317))+((x317*x333))+((x314*x322))+((x320*x339))+((x324*x325))+(((-1.0)*x301*x306))+(((-1.0)*gconst72*x316*x326))+(((-1.0)*x305*x349))+(((-1.0)*gconst63*x325*x329))+(((-1.0)*x300*x301))+((gconst56*gconst66*x300))+((x309*x326))+((x302*x305))+((x328*x331))+(((-1.0)*gconst56*x302*x316))+(((-1.0)*gconst76*x318*x326))+((x343*x347))+((x301*x334))+((gconst71*x353))+((gconst55*gconst59*x338)));
op[6]=(((x305*x313))+(((-1.0)*gconst54*x297*x307))+((x301*x326))+(((-1.0)*x309*x354))+(((-1.0)*gconst59*gconst70*x297))+(((-1.0)*x301*x317))+(((-1.0)*gconst51*x315*x318))+((gconst63*x353))+(((-1.0)*gconst51*x310*x318))+((x312*x322))+(((-1.0)*gconst55*x325*x329))+((x305*x334))+((x298*x340))+(((-1.0)*gconst68*x318*x319))+(((-1.0)*x305*x306))+((x304*x331))+(((-1.0)*gconst72*x316*x322))+((x297*x321))+(((-1.0)*x300*x305))+((x309*x322))+((x298*x320))+(((-1.0)*gconst56*x313*x316))+(((-1.0)*gconst66*x318*x326))+((x297*x336))+((gconst53*gconst76*x297))+(((-1.0)*x312*x354))+(((-1.0)*x319*x340)));
op[7]=(((x301*x322))+(((-1.0)*gconst56*x316*x326))+((gconst53*gconst66*x297))+((x305*x326))+(((-1.0)*x301*x354))+(((-1.0)*gconst66*x318*x322))+((x297*x339))+((x325*x331))+((gconst55*x353))+(((-1.0)*x305*x317)));
op[8]=((((-1.0)*x297*x319))+(((-1.0)*gconst56*x316*x322))+((x305*x322))+((x297*x298))+(((-1.0)*x305*x354)));
polyroots8(op,zeror,numroots);
IkReal j2array[8], cj2array[8], sj2array[8], tempj2array[1];
int numsolutions = 0;
for(int ij2 = 0; ij2 < numroots; ++ij2)
{
IkReal htj2 = zeror[ij2];
tempj2array[0]=((2.0)*(atan(htj2)));
for(int kj2 = 0; kj2 < 1; ++kj2)
{
j2array[numsolutions] = tempj2array[kj2];
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
numsolutions++;
}
}
bool j2valid[8]={true,true,true,true,true,true,true,true};
_nj2 = 8;
for(int ij2 = 0; ij2 < numsolutions; ++ij2)
    {
if( !j2valid[ij2] )
{
    continue;
}
    j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
htj2 = IKtan(j2/2);

_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < numsolutions; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
{
IkReal dummyeval[1];
IkReal gconst93;
gconst93=IKsign(((((273.0)*(sj2*sj2)))+(((273.0)*(cj2*cj2)))));
dummyeval[0]=((sj2*sj2)+(cj2*cj2));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst94;
gconst94=IKsign(((((273.0)*(sj2*sj2)))+(((273.0)*(cj2*cj2)))));
dummyeval[0]=((sj2*sj2)+(cj2*cj2));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x356=(cj1*r00);
IkReal x357=((1000.0)*sj2);
IkReal x358=(cj0*sj1);
IkReal x359=(sj0*sj1);
IkReal x360=(cj1*pz);
IkReal x361=(px*r02);
IkReal x362=((1000.0)*cj2);
IkReal x363=(pz*r00);
IkReal x364=(pz*r01);
IkReal x365=(py*x362);
IkReal x366=(cj1*px*r01);
CheckValue<IkReal> x367 = IKatan2WithCheck((gconst94*(((((-190.0)*sj2))+(((-1.0)*x362*x366))+((x356*x365))+(((-1.0)*x358*x362*x364))+((px*x357*x358))+((py*x357*x359))+(((-1.0)*x357*x360))+(((-1.0)*x359*x361*x362))+((r02*x358*x365))+((x359*x362*x363))))),(gconst94*(((((-139.0)*(sj2*sj2)))+((px*x358*x362))+(((-1.0)*py*x356*x357))+(((-1.0)*x360*x362))+(((-190.0)*cj2))+((x359*x365))+((x357*x359*x361))+(((-1.0)*x357*x359*x363))+(((-1.0)*py*r02*x357*x358))+((x357*x366))+(((-139.0)*(cj2*cj2)))+((x357*x358*x364))))),IKFAST_ATAN2_MAGTHRESH);
if(!x367.valid){
continue;
}
j3array[0]=x367.value;
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x368=IKcos(j3);
IkReal x369=IKsin(j3);
IkReal x370=((0.139)*sj2);
IkReal x371=((0.139)*cj2);
IkReal x372=(px*sj1);
IkReal x373=(py*sj1);
IkReal x374=((1.0)*r00);
IkReal x375=(cj1*sj0);
IkReal x376=((1.0)*px);
IkReal x377=((1.0)*pz);
IkReal x378=(pz*sj1);
IkReal x379=(cj0*r01);
IkReal x380=(cj0*cj1);
IkReal x381=((0.273)*x368);
IkReal x382=((0.273)*x369);
IkReal x383=(cj2*x382);
IkReal x384=(sj2*x381);
IkReal x385=(sj2*x382);
IkReal x386=(cj2*x381);
IkReal x387=(x384+x370);
IkReal x388=(x386+x385+x371);
evalcond[0]=((-0.19)+(((-1.0)*cj1*x377))+((sj0*x373))+(((-1.0)*x388))+((cj0*x372)));
evalcond[1]=((((-1.0)*py*x375))+(((-1.0)*x376*x380))+(((-1.0)*sj1*x377))+x387+(((-1.0)*x383)));
evalcond[2]=((((-1.0)*sj0*x374*x378))+x383+((x378*x379))+(((-1.0)*cj0*r02*x373))+(((-1.0)*cj1*py*x374))+(((-1.0)*x387))+((r02*sj0*x372))+((cj1*px*r01)));
evalcond[3]=(((pz*r00*x375))+((py*r02*x380))+((r01*x372))+(((-1.0)*r02*x375*x376))+(((-0.19)*x379))+(((-1.0)*x373*x374))+(((-1.0)*cj1*x377*x379))+(((-1.0)*x388))+(((0.19)*r00*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x389=((1000.0)*sj2);
IkReal x390=(cj0*px);
IkReal x391=(py*sj0);
IkReal x392=(cj1*pz);
IkReal x393=((1000.0)*cj2*sj1);
IkReal x394=((1000.0)*cj1*cj2);
CheckValue<IkReal> x395 = IKatan2WithCheck((gconst93*(((((-190.0)*sj2))+((sj1*x389*x391))+((sj1*x389*x390))+(((-1.0)*x389*x392))+(((-1.0)*x391*x394))+(((-1.0)*pz*x393))+(((-1.0)*x390*x394))))),(gconst93*(((((-139.0)*(sj2*sj2)))+(((-190.0)*cj2))+((x391*x393))+((cj1*x389*x391))+((cj1*x389*x390))+((x390*x393))+(((-139.0)*(cj2*cj2)))+((pz*sj1*x389))+(((-1000.0)*cj2*x392))))),IKFAST_ATAN2_MAGTHRESH);
if(!x395.valid){
continue;
}
j3array[0]=x395.value;
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x396=IKcos(j3);
IkReal x397=IKsin(j3);
IkReal x398=((0.139)*sj2);
IkReal x399=((0.139)*cj2);
IkReal x400=(px*sj1);
IkReal x401=(py*sj1);
IkReal x402=((1.0)*r00);
IkReal x403=(cj1*sj0);
IkReal x404=((1.0)*px);
IkReal x405=((1.0)*pz);
IkReal x406=(pz*sj1);
IkReal x407=(cj0*r01);
IkReal x408=(cj0*cj1);
IkReal x409=((0.273)*x396);
IkReal x410=((0.273)*x397);
IkReal x411=(cj2*x410);
IkReal x412=(sj2*x409);
IkReal x413=(sj2*x410);
IkReal x414=(cj2*x409);
IkReal x415=(x398+x412);
IkReal x416=(x399+x413+x414);
evalcond[0]=((-0.19)+(((-1.0)*cj1*x405))+((sj0*x401))+((cj0*x400))+(((-1.0)*x416)));
evalcond[1]=((((-1.0)*py*x403))+x415+(((-1.0)*x404*x408))+(((-1.0)*x411))+(((-1.0)*sj1*x405)));
evalcond[2]=((((-1.0)*sj0*x402*x406))+(((-1.0)*cj0*r02*x401))+((x406*x407))+((r02*sj0*x400))+x411+((cj1*px*r01))+(((-1.0)*x415))+(((-1.0)*cj1*py*x402)));
evalcond[3]=((((-1.0)*r02*x403*x404))+((py*r02*x408))+(((-1.0)*cj1*x405*x407))+(((-1.0)*x401*x402))+((pz*r00*x403))+((r01*x400))+(((-0.19)*x407))+(((0.19)*r00*sj0))+(((-1.0)*x416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x417=(sj0*sj1);
IkReal x418=(cj0*sj1);
CheckValue<IkReal> x419=IKPowWithIntegerCheck(cj4,-1);
if(!x419.valid){
continue;
}
if( IKabs(((0.00719424460431655)*(x419.value)*(((((1000.0)*pz*r02))+(((1000.0)*py*r01))+(((-190.0)*r00*x418))+(((-190.0)*r01*x417))+(((190.0)*cj1*r02))+(((1000.0)*px*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.76092971776425)+(((13.1762721690779)*pp))+(((-5.00698342424961)*py*x417))+(((5.00698342424961)*cj1*pz))+(((-5.00698342424961)*px*x418)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00719424460431655)*(x419.value)*(((((1000.0)*pz*r02))+(((1000.0)*py*r01))+(((-190.0)*r00*x418))+(((-190.0)*r01*x417))+(((190.0)*cj1*r02))+(((1000.0)*px*r00))))))+IKsqr(((-0.76092971776425)+(((13.1762721690779)*pp))+(((-5.00698342424961)*py*x417))+(((5.00698342424961)*cj1*pz))+(((-5.00698342424961)*px*x418))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.00719424460431655)*(x419.value)*(((((1000.0)*pz*r02))+(((1000.0)*py*r01))+(((-190.0)*r00*x418))+(((-190.0)*r01*x417))+(((190.0)*cj1*r02))+(((1000.0)*px*r00))))), ((-0.76092971776425)+(((13.1762721690779)*pp))+(((-5.00698342424961)*py*x417))+(((5.00698342424961)*cj1*pz))+(((-5.00698342424961)*px*x418))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x420=IKcos(j3);
IkReal x421=(r01*sj0);
IkReal x422=((0.19)*cj1);
IkReal x423=(py*r02);
IkReal x424=((0.38)*cj1);
IkReal x425=(r00*sj0);
IkReal x426=(cj0*r01);
IkReal x427=((1.0)*pz);
IkReal x428=((1.0)*pp);
IkReal x429=(cj0*r00);
IkReal x430=((0.19)*sj1);
IkReal x431=((0.139)*cj4);
IkReal x432=((2.0)*pz);
IkReal x433=(px*r02);
IkReal x434=((2.0)*px*py);
IkReal x435=((0.38)*py*sj1);
IkReal x436=((0.075894)*x420);
IkReal x437=((0.38)*px*sj1);
evalcond[0]=((0.05775)+((sj0*x435))+(((-1.0)*x428))+((cj0*x437))+x436+(((-1.0)*pz*x424)));
evalcond[1]=(((x429*x430))+((x431*(IKsin(j3))))+((x421*x430))+(((-1.0)*px*r00))+(((-1.0)*r02*x422))+(((-1.0)*r02*x427))+(((-1.0)*py*r01)));
evalcond[2]=((((-1.0)*x422*x429))+(((-1.0)*x421*x427))+(((-1.0)*x421*x422))+(((-1.0)*x427*x429))+(((-1.0)*x420*x431))+((cj0*x433))+(((-1.0)*r02*x430))+(((-0.273)*cj4))+((sj0*x423)));
evalcond[3]=(((sj0*x432*x433))+((sj4*x436))+((x421*x434))+(((-1.0)*cj0*x423*x424))+(((0.0361)*x426))+((pp*x426))+(((-1.0)*pz*x424*x425))+(((-1.0)*cj0*x423*x432))+(((0.09385)*sj4))+(((-1.0)*x429*x434))+((sj0*x424*x433))+(((-1.0)*x425*x428))+((r00*x435))+(((2.0)*x425*(px*px)))+(((-1.0)*r01*x437))+((pz*x424*x426))+(((-0.0361)*x425))+(((-2.0)*x426*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst1;
gconst1=IKsign((((cj4*(sj3*sj3)))+((cj4*(cj3*cj3)))));
dummyeval[0]=(((cj4*(sj3*sj3)))+((cj4*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst2;
IkReal x438=((273.0)*cj4);
gconst2=IKsign(((((-139.0)*cj3*cj4))+(((-1.0)*x438*(cj3*cj3)))+(((-1.0)*x438*(sj3*sj3)))));
IkReal x439=((1.96402877697842)*cj4);
dummyeval[0]=((((-1.0)*cj3*cj4))+(((-1.0)*x439*(cj3*cj3)))+(((-1.0)*x439*(sj3*sj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[11];
bool bgotonextstatement = true;
do
{
IkReal x440=((0.075894)*cj3);
IkReal x441=py*py;
IkReal x442=px*px;
IkReal x443=pz*pz;
IkReal x444=(r01*sj0);
IkReal x445=((2.0)*px);
IkReal x446=((0.19)*cj1);
IkReal x447=(r00*sj1);
IkReal x448=((0.0361)*cj0);
IkReal x449=(py*r02);
IkReal x450=(cj0*cj1);
IkReal x451=((0.38)*pz);
IkReal x452=(pz*r02);
IkReal x453=((2.0)*sj0);
IkReal x454=(cj0*r01);
IkReal x455=((0.38)*py);
IkReal x456=(pz*sj1);
IkReal x457=((1.0)*sj0);
IkReal x458=(pp*r00);
IkReal x459=((0.19)*sj1);
IkReal x460=((0.0361)*sj1);
IkReal x461=((2.0)*cj0);
IkReal x462=(r00*sj0);
IkReal x463=((1.0)*r00);
IkReal x464=(cj1*r00);
IkReal x465=(cj1*r02);
IkReal x466=(cj0*r00);
IkReal x467=(cj0*sj1);
IkReal x468=((0.38)*px);
IkReal x469=(cj1*pz);
IkReal x470=((1.0)*pp);
IkReal x471=(cj0*r02);
IkReal x472=(py*r01);
IkReal x473=((1.0)*r02*sj1);
IkReal x474=(r00*x442);
IkReal x475=((2.0)*x472);
IkReal x476=((2.0)*x441);
IkReal x477=((2.0)*x443);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=(((cj0*py))+(((-1.0)*px*x457)));
evalcond[2]=((1.0)+(((-1.0)*r00*x457))+x454);
evalcond[3]=((0.05775)+(((-1.0)*x470))+((sj0*sj1*x455))+(((-1.0)*cj1*x451))+x440+((x467*x468)));
evalcond[4]=(((sj1*x444))+(((-1.0)*x465))+((cj0*x447)));
evalcond[5]=((((-1.0)*x473))+(((-1.0)*cj1*x444))+(((-1.0)*x450*x463)));
evalcond[6]=((((0.19)*cj0*x447))+(((-1.0)*x452))+(((-1.0)*x472))+(((-1.0)*r02*x446))+(((-1.0)*px*x463))+((x444*x459)));
evalcond[7]=(((sj0*x449))+(((-1.0)*x444*x446))+(((-1.0)*x446*x466))+(((-1.0)*pz*x444))+(((-1.0)*r02*x459))+(((-1.0)*cj0*pz*x463))+((px*x471)));
evalcond[8]=((0.09385)+((x453*x474))+(((-1.0)*py*x445*x466))+((sj0*x465*x468))+(((-0.0361)*x462))+((r01*x450*x451))+(((-1.0)*cj1*x451*x462))+(((-1.0)*pz*x449*x461))+((x447*x455))+((py*x444*x445))+x440+((r01*x448))+(((-1.0)*x454*x476))+(((-1.0)*r01*sj1*x468))+(((-1.0)*x457*x458))+((sj0*x445*x452))+((pp*x454))+(((-0.38)*x449*x450)));
evalcond[9]=(((cj0*pp*x447))+((x469*x475))+(((-1.0)*x449*x453*x456))+(((-1.0)*sj1*x444*x476))+((x465*x477))+(((-1.0)*x445*x452*x467))+((pz*x445*x464))+(((-1.0)*py*sj1*x445*x454))+(((0.0361)*x465))+(((-1.0)*py*sj0*x445*x447))+(((-1.0)*x447*x448))+((r02*x451))+((pp*sj1*x444))+((r00*x468))+((r01*x455))+(((-1.0)*x465*x470))+(((-1.0)*x442*x447*x461))+(((-1.0)*x444*x460)));
evalcond[10]=((((-1.0)*x448*x464))+(((-0.0361)*cj1*x444))+((x449*x453*x469))+((x445*x450*x452))+(((-1.0)*cj1*x444*x470))+(((2.0)*x450*x474))+(((-1.0)*r02*sj1*x470))+((cj1*x444*x476))+(((-1.0)*x450*x458))+(((0.38)*sj0*x449))+(((-1.0)*x451*x466))+(((-1.0)*r02*x460))+((x456*x475))+((cj1*py*x445*x462))+(((-1.0)*x444*x451))+((x468*x471))+((pz*x445*x447))+((r02*sj1*x477))+((x445*x450*x472)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst3;
gconst3=IKsign(((-19321.0)+(((-74529.0)*(cj3*cj3)))+(((-74529.0)*(sj3*sj3)))+(((-75894.0)*cj3))));
dummyeval[0]=((-1.0)+(((-3.92805755395683)*cj3))+(((-3.85740903679934)*(sj3*sj3)))+(((-3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst4;
gconst4=IKsign(((19321.0)+(((75894.0)*cj3))+(((74529.0)*(sj3*sj3)))+(((74529.0)*(cj3*cj3)))));
dummyeval[0]=((1.0)+(((3.92805755395683)*cj3))+(((3.85740903679934)*(sj3*sj3)))+(((3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x478=(cj1*py);
IkReal x479=(pz*sj1);
IkReal x480=((139000.0)*sj0);
IkReal x481=((273000.0)*cj3);
IkReal x482=(py*sj1);
IkReal x483=((273000.0)*sj3);
IkReal x484=(cj1*pz);
IkReal x485=((139000.0)*cj0);
IkReal x486=(cj0*r02);
IkReal x487=(r00*x483);
IkReal x488=((273000.0)*cj0*r01);
IkReal x489=(px*r02*sj1);
IkReal x490=(cj1*px*r01);
IkReal x491=((273000.0)*cj0*px*sj1);
CheckValue<IkReal> x492 = IKatan2WithCheck((gconst4*(((((139000.0)*r00*x478))+((r00*x479*x480))+(((-1.0)*x483*x484))+((cj0*px*sj1*x483))+(((-139000.0)*x490))+(((-1.0)*sj0*x481*x489))+(((-1.0)*cj0*r01*x479*x481))+((r00*x478*x481))+(((-51870.0)*sj3))+((r00*sj0*x479*x481))+((x481*x482*x486))+(((-1.0)*x480*x489))+(((-1.0)*r01*x479*x485))+((r02*x482*x485))+((sj0*x482*x483))+(((-1.0)*x481*x490))))),(gconst4*(((-26410.0)+((sj0*x481*x482))+(((-139000.0)*x484))+((cj0*px*sj1*x481))+((x483*x490))+(((-1.0)*x482*x483*x486))+(((-1.0)*sj0*x479*x487))+((sj0*x483*x489))+(((-1.0)*x481*x484))+((px*sj1*x485))+((cj0*r01*x479*x483))+((x480*x482))+(((-51870.0)*cj3))+(((-1.0)*x478*x487))))),IKFAST_ATAN2_MAGTHRESH);
if(!x492.valid){
continue;
}
j2array[0]=x492.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x493=IKcos(j2);
IkReal x494=IKsin(j2);
IkReal x495=(px*sj1);
IkReal x496=((0.273)*cj3);
IkReal x497=(py*sj1);
IkReal x498=((1.0)*r00);
IkReal x499=(cj1*sj0);
IkReal x500=((1.0)*px);
IkReal x501=((1.0)*pz);
IkReal x502=(cj0*r01);
IkReal x503=(pz*sj1);
IkReal x504=((0.273)*sj3);
IkReal x505=(cj0*cj1);
IkReal x506=((0.139)*x494);
IkReal x507=((0.139)*x493);
IkReal x508=(x494*x496);
IkReal x509=(x493*x504);
IkReal x510=(x494*x504);
IkReal x511=(x493*x496);
IkReal x512=(x508+x506);
IkReal x513=(x507+x511+x510);
evalcond[0]=((-0.19)+((cj0*x495))+((sj0*x497))+(((-1.0)*x513))+(((-1.0)*cj1*x501)));
evalcond[1]=((((-1.0)*sj1*x501))+(((-1.0)*x509))+(((-1.0)*py*x499))+x512+(((-1.0)*x500*x505)));
evalcond[2]=(((r02*sj0*x495))+(((-1.0)*x509))+(((-1.0)*sj0*x498*x503))+(((-1.0)*cj1*py*x498))+(((-1.0)*cj0*r02*x497))+x512+((x502*x503))+((cj1*px*r01)));
evalcond[3]=((((-1.0)*cj1*x501*x502))+(((-1.0)*x497*x498))+((pz*r00*x499))+x513+(((-0.19)*x502))+(((0.19)*r00*sj0))+(((-1.0)*r02*x499*x500))+((r01*x495))+((py*r02*x505)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x514=((139000.0)*cj1);
IkReal x515=(py*sj0);
IkReal x516=(cj0*px);
IkReal x517=((273000.0)*cj3);
IkReal x518=((139000.0)*sj1);
IkReal x519=((273000.0)*cj1*sj3);
IkReal x520=((273000.0)*sj1*sj3);
CheckValue<IkReal> x521 = IKatan2WithCheck((gconst3*(((((-1.0)*cj1*x516*x517))+(((-1.0)*x514*x515))+(((-1.0)*x514*x516))+(((-1.0)*cj1*x515*x517))+((pz*x519))+(((51870.0)*sj3))+(((-1.0)*x515*x520))+(((-1.0)*x516*x520))+(((-1.0)*pz*x518))+(((-1.0)*pz*sj1*x517))))),(gconst3*(((26410.0)+(((-1.0)*sj1*x515*x517))+((pz*x520))+((cj1*pz*x517))+(((-1.0)*sj1*x516*x517))+((pz*x514))+(((51870.0)*cj3))+(((-1.0)*x516*x518))+(((-1.0)*x515*x518))+((x516*x519))+((x515*x519))))),IKFAST_ATAN2_MAGTHRESH);
if(!x521.valid){
continue;
}
j2array[0]=x521.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x522=IKcos(j2);
IkReal x523=IKsin(j2);
IkReal x524=(px*sj1);
IkReal x525=((0.273)*cj3);
IkReal x526=(py*sj1);
IkReal x527=((1.0)*r00);
IkReal x528=(cj1*sj0);
IkReal x529=((1.0)*px);
IkReal x530=((1.0)*pz);
IkReal x531=(cj0*r01);
IkReal x532=(pz*sj1);
IkReal x533=((0.273)*sj3);
IkReal x534=(cj0*cj1);
IkReal x535=((0.139)*x523);
IkReal x536=((0.139)*x522);
IkReal x537=(x523*x525);
IkReal x538=(x522*x533);
IkReal x539=(x523*x533);
IkReal x540=(x522*x525);
IkReal x541=(x535+x537);
IkReal x542=(x540+x536+x539);
evalcond[0]=((-0.19)+((sj0*x526))+((cj0*x524))+(((-1.0)*cj1*x530))+(((-1.0)*x542)));
evalcond[1]=((((-1.0)*sj1*x530))+(((-1.0)*py*x528))+(((-1.0)*x529*x534))+(((-1.0)*x538))+x541);
evalcond[2]=((((-1.0)*cj0*r02*x526))+((r02*sj0*x524))+(((-1.0)*cj1*py*x527))+((x531*x532))+(((-1.0)*x538))+(((-1.0)*sj0*x527*x532))+x541+((cj1*px*r01)));
evalcond[3]=(((pz*r00*x528))+(((-1.0)*x526*x527))+((py*r02*x534))+x542+(((-1.0)*r02*x528*x529))+(((0.19)*r00*sj0))+(((-1.0)*cj1*x530*x531))+(((-0.19)*x531))+((r01*x524)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x543=((0.075894)*cj3);
IkReal x544=py*py;
IkReal x545=px*px;
IkReal x546=pz*pz;
IkReal x547=(r01*sj0);
IkReal x548=((2.0)*px);
IkReal x549=((0.19)*cj1);
IkReal x550=(r00*sj1);
IkReal x551=((0.0361)*cj0);
IkReal x552=(py*r02);
IkReal x553=(cj0*cj1);
IkReal x554=((0.38)*pz);
IkReal x555=(pz*r02);
IkReal x556=((2.0)*sj0);
IkReal x557=(cj0*r01);
IkReal x558=((0.38)*py);
IkReal x559=(pz*sj1);
IkReal x560=((1.0)*sj0);
IkReal x561=(pp*r00);
IkReal x562=((0.19)*sj1);
IkReal x563=((0.0361)*sj1);
IkReal x564=((2.0)*cj0);
IkReal x565=(r00*sj0);
IkReal x566=((1.0)*r00);
IkReal x567=(cj1*r00);
IkReal x568=(cj1*r02);
IkReal x569=(cj0*r00);
IkReal x570=(cj0*sj1);
IkReal x571=((0.38)*px);
IkReal x572=(cj1*pz);
IkReal x573=((1.0)*pp);
IkReal x574=(cj0*r02);
IkReal x575=(py*r01);
IkReal x576=((1.0)*r02*sj1);
IkReal x577=(r00*x545);
IkReal x578=((2.0)*x575);
IkReal x579=((2.0)*x544);
IkReal x580=((2.0)*x546);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=(((cj0*py))+(((-1.0)*px*x560)));
evalcond[2]=((-1.0)+x557+(((-1.0)*r00*x560)));
evalcond[3]=((0.05775)+((sj0*sj1*x558))+(((-1.0)*cj1*x554))+(((-1.0)*x573))+x543+((x570*x571)));
evalcond[4]=(((cj0*x550))+((sj1*x547))+(((-1.0)*x568)));
evalcond[5]=((((-1.0)*x576))+(((-1.0)*cj1*x547))+(((-1.0)*x553*x566)));
evalcond[6]=((((-1.0)*x555))+(((0.19)*cj0*x550))+(((-1.0)*r02*x549))+(((-1.0)*x575))+((x547*x562))+(((-1.0)*px*x566)));
evalcond[7]=((((-1.0)*x549*x569))+(((-1.0)*pz*x547))+((px*x574))+(((-1.0)*x547*x549))+(((-1.0)*r02*x562))+(((-1.0)*cj0*pz*x566))+((sj0*x552)));
evalcond[8]=((-0.09385)+((pp*x557))+(((-1.0)*r01*sj1*x571))+(((-1.0)*x557*x579))+(((-0.38)*x552*x553))+(((-1.0)*pz*x552*x564))+(((-0.0361)*x565))+((r01*x553*x554))+(((-1.0)*x543))+((py*x547*x548))+(((-1.0)*py*x548*x569))+((sj0*x548*x555))+(((-1.0)*cj1*x554*x565))+(((-1.0)*x560*x561))+((x550*x558))+((sj0*x568*x571))+((r01*x551))+((x556*x577)));
evalcond[9]=(((cj0*pp*x550))+((r00*x571))+((pp*sj1*x547))+((r02*x554))+(((0.0361)*x568))+(((-1.0)*x545*x550*x564))+(((-1.0)*x550*x551))+(((-1.0)*sj1*x547*x579))+(((-1.0)*x548*x555*x570))+(((-1.0)*x552*x556*x559))+(((-1.0)*x568*x573))+(((-1.0)*py*sj1*x548*x557))+(((-1.0)*x547*x563))+((r01*x558))+((x568*x580))+((x572*x578))+(((-1.0)*py*sj0*x548*x550))+((pz*x548*x567)));
evalcond[10]=(((x559*x578))+((x571*x574))+((r02*sj1*x580))+(((-0.0361)*cj1*x547))+((x552*x556*x572))+((x548*x553*x575))+(((-1.0)*x553*x561))+(((-1.0)*x547*x554))+(((0.38)*sj0*x552))+((pz*x548*x550))+(((2.0)*x553*x577))+(((-1.0)*r02*sj1*x573))+(((-1.0)*x554*x569))+(((-1.0)*cj1*x547*x573))+((cj1*x547*x579))+((x548*x553*x555))+(((-1.0)*x551*x567))+(((-1.0)*r02*x563))+((cj1*py*x548*x565)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst5;
gconst5=IKsign(((-19321.0)+(((-74529.0)*(cj3*cj3)))+(((-74529.0)*(sj3*sj3)))+(((-75894.0)*cj3))));
dummyeval[0]=((-1.0)+(((-3.92805755395683)*cj3))+(((-3.85740903679934)*(sj3*sj3)))+(((-3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst6;
gconst6=IKsign(((19321.0)+(((75894.0)*cj3))+(((74529.0)*(sj3*sj3)))+(((74529.0)*(cj3*cj3)))));
dummyeval[0]=((1.0)+(((3.92805755395683)*cj3))+(((3.85740903679934)*(sj3*sj3)))+(((3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x581=((273000.0)*sj3);
IkReal x582=(pz*sj1);
IkReal x583=((139000.0)*sj0);
IkReal x584=(px*sj1);
IkReal x585=(r02*sj0);
IkReal x586=((273000.0)*cj3);
IkReal x587=(py*sj1);
IkReal x588=(cj1*pz);
IkReal x589=((139000.0)*cj0);
IkReal x590=(r00*sj0);
IkReal x591=(cj1*py*r00);
IkReal x592=(cj0*x586);
IkReal x593=(cj1*px*r01);
CheckValue<IkReal> x594 = IKatan2WithCheck((gconst6*(((((-1.0)*x586*x591))+(((-139000.0)*x591))+(((-1.0)*r02*x587*x589))+((r01*x582*x592))+(((-51870.0)*sj3))+((cj0*x581*x584))+((x584*x585*x586))+(((139000.0)*x593))+((r02*x583*x584))+(((-1.0)*x582*x586*x590))+((sj0*x581*x587))+(((-1.0)*r00*x582*x583))+(((-1.0)*r02*x587*x592))+((r01*x582*x589))+((x586*x593))+(((-1.0)*x581*x588))))),(gconst6*(((-26410.0)+((x584*x589))+((x583*x587))+((cj0*r02*x581*x587))+(((-1.0)*x581*x584*x585))+(((-1.0)*x586*x588))+((x581*x582*x590))+((x581*x591))+(((-1.0)*x581*x593))+((x584*x592))+(((-139000.0)*x588))+((sj0*x586*x587))+(((-1.0)*cj0*r01*x581*x582))+(((-51870.0)*cj3))))),IKFAST_ATAN2_MAGTHRESH);
if(!x594.valid){
continue;
}
j2array[0]=x594.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x595=IKcos(j2);
IkReal x596=IKsin(j2);
IkReal x597=(px*sj1);
IkReal x598=((0.273)*cj3);
IkReal x599=(py*sj1);
IkReal x600=((1.0)*r00);
IkReal x601=(cj1*sj0);
IkReal x602=((1.0)*px);
IkReal x603=((1.0)*pz);
IkReal x604=(cj0*r01);
IkReal x605=(pz*sj1);
IkReal x606=((0.273)*sj3);
IkReal x607=(cj0*cj1);
IkReal x608=((0.139)*x596);
IkReal x609=((0.139)*x595);
IkReal x610=(x595*x606);
IkReal x611=(x596*x598);
IkReal x612=(x596*x606);
IkReal x613=(x595*x598);
IkReal x614=(x608+x611);
IkReal x615=(x609+x612+x613);
evalcond[0]=((-0.19)+(((-1.0)*cj1*x603))+(((-1.0)*x615))+((sj0*x599))+((cj0*x597)));
evalcond[1]=((((-1.0)*x602*x607))+(((-1.0)*py*x601))+(((-1.0)*sj1*x603))+(((-1.0)*x610))+x614);
evalcond[2]=(((x604*x605))+(((-1.0)*cj0*r02*x599))+(((-1.0)*sj0*x600*x605))+(((-1.0)*cj1*py*x600))+(((-1.0)*x614))+x610+((r02*sj0*x597))+((cj1*px*r01)));
evalcond[3]=(((r01*x597))+((pz*r00*x601))+((py*r02*x607))+(((-1.0)*x599*x600))+(((-1.0)*cj1*x603*x604))+(((-1.0)*x615))+(((0.19)*r00*sj0))+(((-0.19)*x604))+(((-1.0)*r02*x601*x602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x616=((139000.0)*cj1);
IkReal x617=(py*sj0);
IkReal x618=(cj0*px);
IkReal x619=((273000.0)*cj3);
IkReal x620=((139000.0)*sj1);
IkReal x621=((273000.0)*cj1*sj3);
IkReal x622=((273000.0)*sj1*sj3);
CheckValue<IkReal> x623 = IKatan2WithCheck((gconst5*(((((-1.0)*pz*x620))+((pz*x621))+(((51870.0)*sj3))+(((-1.0)*pz*sj1*x619))+(((-1.0)*x617*x622))+(((-1.0)*cj1*x618*x619))+(((-1.0)*x618*x622))+(((-1.0)*cj1*x617*x619))+(((-1.0)*x616*x618))+(((-1.0)*x616*x617))))),(gconst5*(((26410.0)+((pz*x622))+((x617*x621))+((x618*x621))+(((-1.0)*x617*x620))+(((-1.0)*sj1*x617*x619))+((cj1*pz*x619))+(((51870.0)*cj3))+((pz*x616))+(((-1.0)*sj1*x618*x619))+(((-1.0)*x618*x620))))),IKFAST_ATAN2_MAGTHRESH);
if(!x623.valid){
continue;
}
j2array[0]=x623.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x624=IKcos(j2);
IkReal x625=IKsin(j2);
IkReal x626=(px*sj1);
IkReal x627=((0.273)*cj3);
IkReal x628=(py*sj1);
IkReal x629=((1.0)*r00);
IkReal x630=(cj1*sj0);
IkReal x631=((1.0)*px);
IkReal x632=((1.0)*pz);
IkReal x633=(cj0*r01);
IkReal x634=(pz*sj1);
IkReal x635=((0.273)*sj3);
IkReal x636=(cj0*cj1);
IkReal x637=((0.139)*x625);
IkReal x638=((0.139)*x624);
IkReal x639=(x624*x635);
IkReal x640=(x625*x627);
IkReal x641=(x625*x635);
IkReal x642=(x624*x627);
IkReal x643=(x640+x637);
IkReal x644=(x642+x641+x638);
evalcond[0]=((-0.19)+(((-1.0)*cj1*x632))+(((-1.0)*x644))+((cj0*x626))+((sj0*x628)));
evalcond[1]=((((-1.0)*py*x630))+(((-1.0)*x631*x636))+(((-1.0)*x639))+x643+(((-1.0)*sj1*x632)));
evalcond[2]=((((-1.0)*cj0*r02*x628))+(((-1.0)*x643))+((r02*sj0*x626))+x639+(((-1.0)*cj1*py*x629))+((cj1*px*r01))+((x633*x634))+(((-1.0)*sj0*x629*x634)));
evalcond[3]=((((-1.0)*r02*x630*x631))+(((-1.0)*x628*x629))+((py*r02*x636))+(((-1.0)*x644))+(((-0.19)*x633))+((r01*x626))+(((-1.0)*cj1*x632*x633))+(((0.19)*r00*sj0))+((pz*r00*x630)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x645=((139.0)*sj1);
IkReal x646=(cj0*r00);
IkReal x647=((1000.0)*cj4);
IkReal x648=(cj1*cj3);
IkReal x649=((273.0)*r02);
IkReal x650=(cj1*sj3);
IkReal x651=((190.0)*cj4);
IkReal x652=((273.0)*r01);
IkReal x653=(cj3*sj1);
IkReal x654=(cj0*px);
IkReal x655=(sj1*sj3);
IkReal x656=(sj0*x655);
CheckValue<IkReal> x657 = IKatan2WithCheck((gconst2*(((((273.0)*x646*x653))+(((-1.0)*py*x647*x656))+((sj0*x652*x653))+(((-1.0)*x647*x654*x655))+((sj3*x651))+((pz*x647*x650))+((x645*x646))+(((-1.0)*x648*x649))+(((-139.0)*cj1*r02))+((r01*sj0*x645))))),(gconst2*(((((-273.0)*x646*x655))+(((-1.0)*x647*x653*x654))+((x649*x650))+((cj3*x651))+(((-1.0)*py*sj0*x647*x653))+((pz*x647*x648))+(((-1.0)*x652*x656))))),IKFAST_ATAN2_MAGTHRESH);
if(!x657.valid){
continue;
}
j2array[0]=x657.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x658=IKcos(j2);
IkReal x659=IKsin(j2);
IkReal x660=pz*pz;
IkReal x661=py*py;
IkReal x662=px*px;
IkReal x663=(px*sj1);
IkReal x664=(sj0*sj1);
IkReal x665=((0.055208)*sj3);
IkReal x666=(pp*r01);
IkReal x667=(cj1*sj0);
IkReal x668=(pz*r01);
IkReal x669=((0.38)*sj0);
IkReal x670=((1.0)*sj1);
IkReal x671=(py*r00);
IkReal x672=(pz*r02);
IkReal x673=((2.0)*cj0);
IkReal x674=((2.0)*py);
IkReal x675=(pz*r00);
IkReal x676=(pp*r02);
IkReal x677=((1.0)*cj1);
IkReal x678=(cj0*r00);
IkReal x679=((0.0361)*cj1);
IkReal x680=(py*r02);
IkReal x681=((0.0361)*r01);
IkReal x682=((0.0361)*sj1);
IkReal x683=(py*r01);
IkReal x684=((2.0)*px);
IkReal x685=(cj1*px);
IkReal x686=((0.09385)*cj3);
IkReal x687=((0.38)*cj0);
IkReal x688=(px*r02);
IkReal x689=(cj4*x659);
IkReal x690=(cj4*x658);
IkReal x691=((0.273)*sj3*sj4);
IkReal x692=((0.139)*x659);
IkReal x693=((0.139)*x658);
IkReal x694=(r00*x662);
IkReal x695=((0.273)*x658);
IkReal x696=((0.273)*cj3*x659);
IkReal x697=(x672*x674);
IkReal x698=((2.0)*r01*x661);
IkReal x699=((2.0)*r02*x660);
evalcond[0]=((((-1.0)*r02*x677))+((r01*x664))+(((-1.0)*sj3*x690))+((sj1*x678))+((cj3*x689)));
evalcond[1]=((((-1.0)*r02*x670))+((sj3*x689))+((cj3*x690))+(((-1.0)*x677*x678))+(((-1.0)*r01*x667)));
evalcond[2]=((-0.19)+((cj0*x663))+(((-1.0)*pz*x677))+(((-1.0)*cj3*x695))+((py*x664))+(((-0.273)*sj3*x659))+(((-1.0)*x693)));
evalcond[3]=((((-1.0)*sj3*x695))+(((-1.0)*py*x667))+(((-1.0)*pz*x670))+x696+x692+(((-1.0)*cj0*px*x677)));
evalcond[4]=(((r02*sj0*x663))+(((-1.0)*x658*x691))+((sj4*x696))+((sj4*x692))+(((-1.0)*x664*x675))+((cj0*sj1*x668))+(((-1.0)*cj0*x670*x680))+(((-1.0)*x671*x677))+((r01*x685)));
evalcond[5]=(((r01*x663))+((cj3*sj4*x695))+((sj4*x693))+(((-1.0)*x670*x671))+(((-0.19)*cj0*r01))+((x667*x675))+((cj0*cj1*x680))+(((0.19)*r00*sj0))+(((-1.0)*cj0*x668*x677))+((x659*x691))+(((-1.0)*x667*x688)));
evalcond[6]=(((pp*sj1*x678))+((r02*x679))+((cj1*x668*x674))+((x686*x689))+(((-1.0)*sj1*x673*x694))+(((-1.0)*x663*x673*x683))+(((0.075894)*x689))+(((0.38)*x683))+((x664*x666))+((cj1*x699))+(((-1.0)*x664*x681))+((cj1*x675*x684))+(((0.38)*x672))+(((-1.0)*x678*x682))+(((0.38)*px*r00))+(((-1.0)*x663*x672*x673))+(((-1.0)*x665*x690))+(((-1.0)*x676*x677))+(((-1.0)*x664*x698))+(((-1.0)*x664*x697))+(((-2.0)*sj0*x663*x671)));
evalcond[7]=(((x669*x680))+(((2.0)*x663*x675))+(((-1.0)*x667*x681))+((x687*x688))+(((-1.0)*x678*x679))+((cj1*x673*x694))+(((-1.0)*pp*x677*x678))+((x686*x690))+((sj1*x699))+((sj1*x668*x674))+((x673*x683*x685))+(((-1.0)*x675*x687))+((x672*x673*x685))+(((-1.0)*r02*x682))+(((-1.0)*x666*x667))+(((-1.0)*x670*x676))+(((0.075894)*x690))+(((-1.0)*x668*x669))+((x667*x671*x684))+((x667*x697))+((x667*x698))+((x665*x689)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x700=((1.0)*sj1);
IkReal x701=(cj1*sj3);
IkReal x702=(cj0*r00);
IkReal x703=(cj3*r02);
IkReal x704=(r01*sj0);
IkReal x705=(sj1*sj3);
IkReal x706=(cj3*x704);
CheckValue<IkReal> x707 = IKatan2WithCheck((gconst1*((((x701*x704))+((x701*x702))+(((-1.0)*cj3*x700*x702))+((r02*x705))+((cj1*x703))+(((-1.0)*x700*x706))))),(gconst1*((((x702*x705))+((x704*x705))+((sj1*x703))+((cj1*cj3*x702))+((cj1*x706))+(((-1.0)*r02*x701))))),IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
j2array[0]=x707.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x708=IKcos(j2);
IkReal x709=IKsin(j2);
IkReal x710=pz*pz;
IkReal x711=py*py;
IkReal x712=px*px;
IkReal x713=(px*sj1);
IkReal x714=(sj0*sj1);
IkReal x715=((0.055208)*sj3);
IkReal x716=(pp*r01);
IkReal x717=(cj1*sj0);
IkReal x718=(pz*r01);
IkReal x719=((0.38)*sj0);
IkReal x720=((1.0)*sj1);
IkReal x721=(py*r00);
IkReal x722=(pz*r02);
IkReal x723=((2.0)*cj0);
IkReal x724=((2.0)*py);
IkReal x725=(pz*r00);
IkReal x726=(pp*r02);
IkReal x727=((1.0)*cj1);
IkReal x728=(cj0*r00);
IkReal x729=((0.0361)*cj1);
IkReal x730=(py*r02);
IkReal x731=((0.0361)*r01);
IkReal x732=((0.0361)*sj1);
IkReal x733=(py*r01);
IkReal x734=((2.0)*px);
IkReal x735=(cj1*px);
IkReal x736=((0.09385)*cj3);
IkReal x737=((0.38)*cj0);
IkReal x738=(px*r02);
IkReal x739=(cj4*x709);
IkReal x740=(cj4*x708);
IkReal x741=((0.273)*sj3*sj4);
IkReal x742=((0.139)*x709);
IkReal x743=((0.139)*x708);
IkReal x744=(r00*x712);
IkReal x745=((0.273)*x708);
IkReal x746=((0.273)*cj3*x709);
IkReal x747=(x722*x724);
IkReal x748=((2.0)*r01*x711);
IkReal x749=((2.0)*r02*x710);
evalcond[0]=((((-1.0)*sj3*x740))+(((-1.0)*r02*x727))+((r01*x714))+((cj3*x739))+((sj1*x728)));
evalcond[1]=((((-1.0)*x727*x728))+(((-1.0)*r02*x720))+((sj3*x739))+((cj3*x740))+(((-1.0)*r01*x717)));
evalcond[2]=((-0.19)+(((-1.0)*cj3*x745))+((cj0*x713))+(((-1.0)*x743))+((py*x714))+(((-0.273)*sj3*x709))+(((-1.0)*pz*x727)));
evalcond[3]=((((-1.0)*py*x717))+(((-1.0)*cj0*px*x727))+x746+x742+(((-1.0)*pz*x720))+(((-1.0)*sj3*x745)));
evalcond[4]=(((sj4*x742))+((sj4*x746))+(((-1.0)*cj0*x720*x730))+(((-1.0)*x708*x741))+((r02*sj0*x713))+((r01*x735))+(((-1.0)*x721*x727))+(((-1.0)*x714*x725))+((cj0*sj1*x718)));
evalcond[5]=(((sj4*x743))+((cj3*sj4*x745))+((x709*x741))+((r01*x713))+((cj0*cj1*x730))+((x717*x725))+(((-0.19)*cj0*r01))+(((-1.0)*x717*x738))+(((-1.0)*x720*x721))+(((0.19)*r00*sj0))+(((-1.0)*cj0*x718*x727)));
evalcond[6]=(((x714*x716))+(((0.075894)*x739))+((cj1*x725*x734))+((cj1*x749))+((x736*x739))+((cj1*x718*x724))+(((-1.0)*x713*x723*x733))+(((-2.0)*sj0*x713*x721))+(((-1.0)*x714*x747))+(((-1.0)*x714*x748))+(((-1.0)*x715*x740))+(((0.38)*px*r00))+(((-1.0)*x713*x722*x723))+((pp*sj1*x728))+((r02*x729))+(((-1.0)*sj1*x723*x744))+(((0.38)*x722))+(((-1.0)*x714*x731))+(((-1.0)*x726*x727))+(((0.38)*x733))+(((-1.0)*x728*x732)));
evalcond[7]=((((-1.0)*r02*x732))+((cj1*x723*x744))+(((-1.0)*x725*x737))+((x723*x733*x735))+(((-1.0)*x717*x731))+(((0.075894)*x740))+((sj1*x749))+(((2.0)*x713*x725))+((x717*x721*x734))+(((-1.0)*x720*x726))+(((-1.0)*x718*x719))+((sj1*x718*x724))+((x717*x747))+((x717*x748))+((x719*x730))+((x722*x723*x735))+(((-1.0)*pp*x727*x728))+((x715*x739))+((x737*x738))+(((-1.0)*x716*x717))+(((-1.0)*x728*x729))+((x736*x740)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x750=((1000.0)*r02);
IkReal x751=((1000.0)*r00);
IkReal x752=((1000.0)*r01);
IkReal x753=((190.0)*r02);
IkReal x754=((190.0)*r01*sj0);
IkReal x755=((190.0)*cj0*r00);
CheckValue<IkReal> x756 = IKatan2WithCheck((gconst0*((((py*x752))+(((-1.0)*sj1*x755))+(((-1.0)*sj1*x754))+((cj1*x753))+((pz*x750))+((px*x751))))),(gconst0*(((((-1.0)*sj1*x753))+((cj0*px*x750))+(((-1.0)*pz*sj0*x752))+(((-1.0)*cj0*pz*x751))+((py*sj0*x750))+(((-1.0)*cj1*x754))+(((-1.0)*cj1*x755))+(((-273.0)*cj4))))),IKFAST_ATAN2_MAGTHRESH);
if(!x756.valid){
continue;
}
j3array[0]=x756.value;
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x757=IKcos(j3);
IkReal x758=(r01*sj0);
IkReal x759=((0.19)*cj1);
IkReal x760=(py*r02);
IkReal x761=((0.38)*cj1);
IkReal x762=(r00*sj0);
IkReal x763=(cj0*r01);
IkReal x764=((1.0)*pz);
IkReal x765=((1.0)*pp);
IkReal x766=(cj0*r00);
IkReal x767=((0.19)*sj1);
IkReal x768=((0.139)*cj4);
IkReal x769=((2.0)*pz);
IkReal x770=(px*r02);
IkReal x771=((2.0)*px*py);
IkReal x772=((0.38)*py*sj1);
IkReal x773=((0.075894)*x757);
IkReal x774=((0.38)*px*sj1);
evalcond[0]=((0.05775)+(((-1.0)*x765))+((sj0*x772))+x773+((cj0*x774))+(((-1.0)*pz*x761)));
evalcond[1]=((((-1.0)*px*r00))+(((-1.0)*r02*x759))+((x758*x767))+((x766*x767))+(((-1.0)*py*r01))+(((-1.0)*r02*x764))+((x768*(IKsin(j3)))));
evalcond[2]=((((-1.0)*x758*x764))+((sj0*x760))+(((-1.0)*x764*x766))+(((-1.0)*x757*x768))+((cj0*x770))+(((-1.0)*r02*x767))+(((-1.0)*x758*x759))+(((-0.273)*cj4))+(((-1.0)*x759*x766)));
evalcond[3]=((((-1.0)*cj0*x760*x761))+(((-1.0)*cj0*x760*x769))+((sj4*x773))+(((-1.0)*x762*x765))+(((0.0361)*x763))+(((2.0)*x762*(px*px)))+(((0.09385)*sj4))+((x758*x771))+((sj0*x769*x770))+(((-1.0)*x766*x771))+(((-1.0)*r01*x774))+(((-2.0)*x763*(py*py)))+((r00*x772))+(((-1.0)*pz*x761*x762))+((pz*x761*x763))+(((-0.0361)*x762))+((pp*x763))+((sj0*x761*x770)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst1;
gconst1=IKsign((((cj4*(sj3*sj3)))+((cj4*(cj3*cj3)))));
dummyeval[0]=(((cj4*(sj3*sj3)))+((cj4*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst2;
IkReal x775=((273.0)*cj4);
gconst2=IKsign(((((-139.0)*cj3*cj4))+(((-1.0)*x775*(cj3*cj3)))+(((-1.0)*x775*(sj3*sj3)))));
IkReal x776=((1.96402877697842)*cj4);
dummyeval[0]=((((-1.0)*x776*(sj3*sj3)))+(((-1.0)*cj3*cj4))+(((-1.0)*x776*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[11];
bool bgotonextstatement = true;
do
{
IkReal x777=((0.075894)*cj3);
IkReal x778=py*py;
IkReal x779=px*px;
IkReal x780=pz*pz;
IkReal x781=(r01*sj0);
IkReal x782=((2.0)*px);
IkReal x783=((0.19)*cj1);
IkReal x784=(r00*sj1);
IkReal x785=((0.0361)*cj0);
IkReal x786=(py*r02);
IkReal x787=(cj0*cj1);
IkReal x788=((0.38)*pz);
IkReal x789=(pz*r02);
IkReal x790=((2.0)*sj0);
IkReal x791=(cj0*r01);
IkReal x792=((0.38)*py);
IkReal x793=(pz*sj1);
IkReal x794=((1.0)*sj0);
IkReal x795=(pp*r00);
IkReal x796=((0.19)*sj1);
IkReal x797=((0.0361)*sj1);
IkReal x798=((2.0)*cj0);
IkReal x799=(r00*sj0);
IkReal x800=((1.0)*r00);
IkReal x801=(cj1*r00);
IkReal x802=(cj1*r02);
IkReal x803=(cj0*r00);
IkReal x804=(cj0*sj1);
IkReal x805=((0.38)*px);
IkReal x806=(cj1*pz);
IkReal x807=((1.0)*pp);
IkReal x808=(cj0*r02);
IkReal x809=(py*r01);
IkReal x810=((1.0)*r02*sj1);
IkReal x811=(r00*x779);
IkReal x812=((2.0)*x809);
IkReal x813=((2.0)*x778);
IkReal x814=((2.0)*x780);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*px*x794))+((cj0*py)));
evalcond[2]=((1.0)+(((-1.0)*r00*x794))+x791);
evalcond[3]=((0.05775)+((x804*x805))+(((-1.0)*cj1*x788))+x777+((sj0*sj1*x792))+(((-1.0)*x807)));
evalcond[4]=((((-1.0)*x802))+((sj1*x781))+((cj0*x784)));
evalcond[5]=((((-1.0)*x787*x800))+(((-1.0)*x810))+(((-1.0)*cj1*x781)));
evalcond[6]=((((-1.0)*x809))+((x781*x796))+(((-1.0)*px*x800))+(((0.19)*cj0*x784))+(((-1.0)*x789))+(((-1.0)*r02*x783)));
evalcond[7]=((((-1.0)*x781*x783))+((sj0*x786))+(((-1.0)*cj0*pz*x800))+((px*x808))+(((-1.0)*pz*x781))+(((-1.0)*r02*x796))+(((-1.0)*x783*x803)));
evalcond[8]=((0.09385)+((sj0*x782*x789))+((pp*x791))+(((-1.0)*x794*x795))+((r01*x785))+(((-0.38)*x786*x787))+(((-1.0)*py*x782*x803))+((r01*x787*x788))+((x784*x792))+((py*x781*x782))+(((-1.0)*cj1*x788*x799))+(((-1.0)*pz*x786*x798))+(((-1.0)*r01*sj1*x805))+((x790*x811))+x777+(((-0.0361)*x799))+((sj0*x802*x805))+(((-1.0)*x791*x813)));
evalcond[9]=((((-1.0)*x786*x790*x793))+((r01*x792))+((pz*x782*x801))+(((-1.0)*x781*x797))+((x802*x814))+(((-1.0)*x782*x789*x804))+((r02*x788))+(((-1.0)*py*sj1*x782*x791))+((cj0*pp*x784))+(((-1.0)*x784*x785))+((pp*sj1*x781))+((r00*x805))+((x806*x812))+(((-1.0)*py*sj0*x782*x784))+(((-1.0)*x802*x807))+(((0.0361)*x802))+(((-1.0)*x779*x784*x798))+(((-1.0)*sj1*x781*x813)));
evalcond[10]=((((-1.0)*x785*x801))+((x782*x787*x809))+((r02*sj1*x814))+(((-1.0)*cj1*x781*x807))+(((-1.0)*r02*sj1*x807))+(((2.0)*x787*x811))+((cj1*x781*x813))+((pz*x782*x784))+(((-1.0)*x781*x788))+((cj1*py*x782*x799))+(((-0.0361)*cj1*x781))+((x805*x808))+((x782*x787*x789))+(((-1.0)*x788*x803))+(((-1.0)*x787*x795))+((x793*x812))+((x786*x790*x806))+(((0.38)*sj0*x786))+(((-1.0)*r02*x797)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst3;
gconst3=IKsign(((-19321.0)+(((-74529.0)*(cj3*cj3)))+(((-74529.0)*(sj3*sj3)))+(((-75894.0)*cj3))));
dummyeval[0]=((-1.0)+(((-3.92805755395683)*cj3))+(((-3.85740903679934)*(sj3*sj3)))+(((-3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst4;
gconst4=IKsign(((19321.0)+(((75894.0)*cj3))+(((74529.0)*(sj3*sj3)))+(((74529.0)*(cj3*cj3)))));
dummyeval[0]=((1.0)+(((3.92805755395683)*cj3))+(((3.85740903679934)*(sj3*sj3)))+(((3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x815=(cj1*py);
IkReal x816=(pz*sj1);
IkReal x817=((139000.0)*sj0);
IkReal x818=((273000.0)*cj3);
IkReal x819=(py*sj1);
IkReal x820=((273000.0)*sj3);
IkReal x821=(cj1*pz);
IkReal x822=((139000.0)*cj0);
IkReal x823=(cj0*r02);
IkReal x824=(r00*x820);
IkReal x825=((273000.0)*cj0*r01);
IkReal x826=(px*r02*sj1);
IkReal x827=(cj1*px*r01);
IkReal x828=((273000.0)*cj0*px*sj1);
CheckValue<IkReal> x829 = IKatan2WithCheck((gconst4*((((r00*sj0*x816*x818))+(((-1.0)*x818*x827))+(((-1.0)*sj0*x818*x826))+((r00*x815*x818))+(((-139000.0)*x827))+(((-1.0)*x817*x826))+(((-51870.0)*sj3))+((r00*x816*x817))+(((139000.0)*r00*x815))+(((-1.0)*r01*x816*x822))+((cj0*px*sj1*x820))+((x818*x819*x823))+((r02*x819*x822))+(((-1.0)*x820*x821))+(((-1.0)*cj0*r01*x816*x818))+((sj0*x819*x820))))),(gconst4*(((-26410.0)+((px*sj1*x822))+(((-1.0)*sj0*x816*x824))+((x820*x827))+(((-1.0)*x818*x821))+((cj0*r01*x816*x820))+(((-1.0)*x815*x824))+(((-139000.0)*x821))+((x817*x819))+((cj0*px*sj1*x818))+((sj0*x820*x826))+((sj0*x818*x819))+(((-1.0)*x819*x820*x823))+(((-51870.0)*cj3))))),IKFAST_ATAN2_MAGTHRESH);
if(!x829.valid){
continue;
}
j2array[0]=x829.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x830=IKcos(j2);
IkReal x831=IKsin(j2);
IkReal x832=(px*sj1);
IkReal x833=((0.273)*cj3);
IkReal x834=(py*sj1);
IkReal x835=((1.0)*r00);
IkReal x836=(cj1*sj0);
IkReal x837=((1.0)*px);
IkReal x838=((1.0)*pz);
IkReal x839=(cj0*r01);
IkReal x840=(pz*sj1);
IkReal x841=((0.273)*sj3);
IkReal x842=(cj0*cj1);
IkReal x843=((0.139)*x831);
IkReal x844=((0.139)*x830);
IkReal x845=(x831*x833);
IkReal x846=(x830*x841);
IkReal x847=(x831*x841);
IkReal x848=(x830*x833);
IkReal x849=(x843+x845);
IkReal x850=(x844+x847+x848);
evalcond[0]=((-0.19)+(((-1.0)*x850))+((cj0*x832))+(((-1.0)*cj1*x838))+((sj0*x834)));
evalcond[1]=((((-1.0)*sj1*x838))+(((-1.0)*x837*x842))+(((-1.0)*x846))+x849+(((-1.0)*py*x836)));
evalcond[2]=((((-1.0)*cj0*r02*x834))+((x839*x840))+((r02*sj0*x832))+(((-1.0)*sj0*x835*x840))+(((-1.0)*cj1*py*x835))+(((-1.0)*x846))+x849+((cj1*px*r01)));
evalcond[3]=((((-1.0)*r02*x836*x837))+(((-1.0)*x834*x835))+((r01*x832))+(((-1.0)*cj1*x838*x839))+(((0.19)*r00*sj0))+x850+(((-0.19)*x839))+((pz*r00*x836))+((py*r02*x842)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x851=((139000.0)*cj1);
IkReal x852=(py*sj0);
IkReal x853=(cj0*px);
IkReal x854=((273000.0)*cj3);
IkReal x855=((139000.0)*sj1);
IkReal x856=((273000.0)*cj1*sj3);
IkReal x857=((273000.0)*sj1*sj3);
CheckValue<IkReal> x858 = IKatan2WithCheck((gconst3*(((((-1.0)*cj1*x852*x854))+(((-1.0)*x853*x857))+(((-1.0)*x852*x857))+(((-1.0)*pz*sj1*x854))+(((-1.0)*cj1*x853*x854))+(((51870.0)*sj3))+(((-1.0)*pz*x855))+(((-1.0)*x851*x853))+(((-1.0)*x851*x852))+((pz*x856))))),(gconst3*(((26410.0)+(((-1.0)*sj1*x853*x854))+(((-1.0)*x853*x855))+((cj1*pz*x854))+(((-1.0)*x852*x855))+(((-1.0)*sj1*x852*x854))+(((51870.0)*cj3))+((x852*x856))+((x853*x856))+((pz*x857))+((pz*x851))))),IKFAST_ATAN2_MAGTHRESH);
if(!x858.valid){
continue;
}
j2array[0]=x858.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x859=IKcos(j2);
IkReal x860=IKsin(j2);
IkReal x861=(px*sj1);
IkReal x862=((0.273)*cj3);
IkReal x863=(py*sj1);
IkReal x864=((1.0)*r00);
IkReal x865=(cj1*sj0);
IkReal x866=((1.0)*px);
IkReal x867=((1.0)*pz);
IkReal x868=(cj0*r01);
IkReal x869=(pz*sj1);
IkReal x870=((0.273)*sj3);
IkReal x871=(cj0*cj1);
IkReal x872=((0.139)*x860);
IkReal x873=((0.139)*x859);
IkReal x874=(x860*x862);
IkReal x875=(x859*x870);
IkReal x876=(x860*x870);
IkReal x877=(x859*x862);
IkReal x878=(x872+x874);
IkReal x879=(x873+x876+x877);
evalcond[0]=((-0.19)+((cj0*x861))+((sj0*x863))+(((-1.0)*cj1*x867))+(((-1.0)*x879)));
evalcond[1]=((((-1.0)*x866*x871))+(((-1.0)*sj1*x867))+(((-1.0)*py*x865))+x878+(((-1.0)*x875)));
evalcond[2]=(((x868*x869))+(((-1.0)*sj0*x864*x869))+(((-1.0)*cj1*py*x864))+x878+((r02*sj0*x861))+((cj1*px*r01))+(((-1.0)*cj0*r02*x863))+(((-1.0)*x875)));
evalcond[3]=((((-1.0)*cj1*x867*x868))+((r01*x861))+(((-0.19)*x868))+(((-1.0)*r02*x865*x866))+((py*r02*x871))+((pz*r00*x865))+(((0.19)*r00*sj0))+x879+(((-1.0)*x863*x864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x880=((0.075894)*cj3);
IkReal x881=py*py;
IkReal x882=px*px;
IkReal x883=pz*pz;
IkReal x884=(r01*sj0);
IkReal x885=((2.0)*px);
IkReal x886=((0.19)*cj1);
IkReal x887=(r00*sj1);
IkReal x888=((0.0361)*cj0);
IkReal x889=(py*r02);
IkReal x890=(cj0*cj1);
IkReal x891=((0.38)*pz);
IkReal x892=(pz*r02);
IkReal x893=((2.0)*sj0);
IkReal x894=(cj0*r01);
IkReal x895=((0.38)*py);
IkReal x896=(pz*sj1);
IkReal x897=((1.0)*sj0);
IkReal x898=(pp*r00);
IkReal x899=((0.19)*sj1);
IkReal x900=((0.0361)*sj1);
IkReal x901=((2.0)*cj0);
IkReal x902=(r00*sj0);
IkReal x903=((1.0)*r00);
IkReal x904=(cj1*r00);
IkReal x905=(cj1*r02);
IkReal x906=(cj0*r00);
IkReal x907=(cj0*sj1);
IkReal x908=((0.38)*px);
IkReal x909=(cj1*pz);
IkReal x910=((1.0)*pp);
IkReal x911=(cj0*r02);
IkReal x912=(py*r01);
IkReal x913=((1.0)*r02*sj1);
IkReal x914=(r00*x882);
IkReal x915=((2.0)*x912);
IkReal x916=((2.0)*x881);
IkReal x917=((2.0)*x883);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*px*x897))+((cj0*py)));
evalcond[2]=((-1.0)+x894+(((-1.0)*r00*x897)));
evalcond[3]=((0.05775)+((x907*x908))+(((-1.0)*x910))+x880+(((-1.0)*cj1*x891))+((sj0*sj1*x895)));
evalcond[4]=(((sj1*x884))+((cj0*x887))+(((-1.0)*x905)));
evalcond[5]=((((-1.0)*x890*x903))+(((-1.0)*cj1*x884))+(((-1.0)*x913)));
evalcond[6]=(((x884*x899))+(((-1.0)*px*x903))+(((-1.0)*x892))+(((-1.0)*x912))+(((0.19)*cj0*x887))+(((-1.0)*r02*x886)));
evalcond[7]=(((sj0*x889))+((px*x911))+(((-1.0)*x886*x906))+(((-1.0)*pz*x884))+(((-1.0)*r02*x899))+(((-1.0)*cj0*pz*x903))+(((-1.0)*x884*x886)));
evalcond[8]=((-0.09385)+((r01*x890*x891))+(((-1.0)*pz*x889*x901))+(((-1.0)*r01*sj1*x908))+((x893*x914))+((sj0*x885*x892))+(((-1.0)*x894*x916))+((r01*x888))+(((-1.0)*x880))+((py*x884*x885))+(((-1.0)*cj1*x891*x902))+((pp*x894))+(((-1.0)*x897*x898))+((sj0*x905*x908))+(((-0.38)*x889*x890))+(((-1.0)*py*x885*x906))+(((-0.0361)*x902))+((x887*x895)));
evalcond[9]=(((r02*x891))+((r00*x908))+(((-1.0)*x887*x888))+((x909*x915))+((r01*x895))+(((-1.0)*sj1*x884*x916))+(((-1.0)*x882*x887*x901))+(((-1.0)*x884*x900))+(((-1.0)*x885*x892*x907))+(((-1.0)*x889*x893*x896))+(((-1.0)*py*sj1*x885*x894))+((pp*sj1*x884))+((cj0*pp*x887))+((pz*x885*x904))+(((-1.0)*x905*x910))+(((-1.0)*py*sj0*x885*x887))+(((0.0361)*x905))+((x905*x917)));
evalcond[10]=((((-1.0)*x891*x906))+(((-1.0)*x884*x891))+(((-1.0)*r02*sj1*x910))+(((-1.0)*x888*x904))+((x885*x890*x892))+(((-0.0361)*cj1*x884))+((cj1*x884*x916))+((r02*sj1*x917))+(((-1.0)*cj1*x884*x910))+((x889*x893*x909))+((cj1*py*x885*x902))+(((0.38)*sj0*x889))+(((2.0)*x890*x914))+(((-1.0)*r02*x900))+((x908*x911))+(((-1.0)*x890*x898))+((x896*x915))+((pz*x885*x887))+((x885*x890*x912)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst5;
gconst5=IKsign(((-19321.0)+(((-74529.0)*(cj3*cj3)))+(((-74529.0)*(sj3*sj3)))+(((-75894.0)*cj3))));
dummyeval[0]=((-1.0)+(((-3.92805755395683)*cj3))+(((-3.85740903679934)*(sj3*sj3)))+(((-3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst6;
gconst6=IKsign(((19321.0)+(((75894.0)*cj3))+(((74529.0)*(sj3*sj3)))+(((74529.0)*(cj3*cj3)))));
dummyeval[0]=((1.0)+(((3.92805755395683)*cj3))+(((3.85740903679934)*(sj3*sj3)))+(((3.85740903679934)*(cj3*cj3))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x918=((273000.0)*sj3);
IkReal x919=(pz*sj1);
IkReal x920=((139000.0)*sj0);
IkReal x921=(px*sj1);
IkReal x922=(r02*sj0);
IkReal x923=((273000.0)*cj3);
IkReal x924=(py*sj1);
IkReal x925=(cj1*pz);
IkReal x926=((139000.0)*cj0);
IkReal x927=(r00*sj0);
IkReal x928=(cj1*py*r00);
IkReal x929=(cj0*x923);
IkReal x930=(cj1*px*r01);
CheckValue<IkReal> x931 = IKatan2WithCheck((gconst6*(((((-139000.0)*x928))+((r02*x920*x921))+(((-1.0)*r02*x924*x926))+(((-1.0)*r02*x924*x929))+(((-51870.0)*sj3))+((sj0*x918*x924))+((r01*x919*x929))+((r01*x919*x926))+((cj0*x918*x921))+(((-1.0)*r00*x919*x920))+(((139000.0)*x930))+(((-1.0)*x918*x925))+((x923*x930))+((x921*x922*x923))+(((-1.0)*x919*x923*x927))+(((-1.0)*x923*x928))))),(gconst6*(((-26410.0)+((x918*x928))+(((-139000.0)*x925))+((x920*x924))+(((-1.0)*x918*x921*x922))+((cj0*r02*x918*x924))+((x921*x929))+((x921*x926))+((sj0*x923*x924))+(((-1.0)*x918*x930))+((x918*x919*x927))+(((-1.0)*cj0*r01*x918*x919))+(((-1.0)*x923*x925))+(((-51870.0)*cj3))))),IKFAST_ATAN2_MAGTHRESH);
if(!x931.valid){
continue;
}
j2array[0]=x931.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x932=IKcos(j2);
IkReal x933=IKsin(j2);
IkReal x934=(px*sj1);
IkReal x935=((0.273)*cj3);
IkReal x936=(py*sj1);
IkReal x937=((1.0)*r00);
IkReal x938=(cj1*sj0);
IkReal x939=((1.0)*px);
IkReal x940=((1.0)*pz);
IkReal x941=(cj0*r01);
IkReal x942=(pz*sj1);
IkReal x943=((0.273)*sj3);
IkReal x944=(cj0*cj1);
IkReal x945=((0.139)*x933);
IkReal x946=((0.139)*x932);
IkReal x947=(x932*x943);
IkReal x948=(x933*x935);
IkReal x949=(x933*x943);
IkReal x950=(x932*x935);
IkReal x951=(x948+x945);
IkReal x952=(x950+x949+x946);
evalcond[0]=((-0.19)+(((-1.0)*cj1*x940))+((sj0*x936))+((cj0*x934))+(((-1.0)*x952)));
evalcond[1]=((((-1.0)*x947))+(((-1.0)*x939*x944))+(((-1.0)*py*x938))+x951+(((-1.0)*sj1*x940)));
evalcond[2]=((((-1.0)*cj1*py*x937))+(((-1.0)*cj0*r02*x936))+((x941*x942))+(((-1.0)*sj0*x937*x942))+((r02*sj0*x934))+(((-1.0)*x951))+((cj1*px*r01))+x947);
evalcond[3]=(((pz*r00*x938))+(((-1.0)*cj1*x940*x941))+(((-1.0)*r02*x938*x939))+((py*r02*x944))+(((0.19)*r00*sj0))+(((-1.0)*x936*x937))+((r01*x934))+(((-1.0)*x952))+(((-0.19)*x941)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x953=((139000.0)*cj1);
IkReal x954=(py*sj0);
IkReal x955=(cj0*px);
IkReal x956=((273000.0)*cj3);
IkReal x957=((139000.0)*sj1);
IkReal x958=((273000.0)*cj1*sj3);
IkReal x959=((273000.0)*sj1*sj3);
CheckValue<IkReal> x960 = IKatan2WithCheck((gconst5*(((((-1.0)*pz*x957))+(((-1.0)*cj1*x954*x956))+(((-1.0)*cj1*x955*x956))+(((51870.0)*sj3))+((pz*x958))+(((-1.0)*pz*sj1*x956))+(((-1.0)*x953*x955))+(((-1.0)*x953*x954))+(((-1.0)*x954*x959))+(((-1.0)*x955*x959))))),(gconst5*(((26410.0)+((x955*x958))+(((51870.0)*cj3))+((pz*x953))+((pz*x959))+(((-1.0)*sj1*x955*x956))+(((-1.0)*sj1*x954*x956))+(((-1.0)*x954*x957))+(((-1.0)*x955*x957))+((cj1*pz*x956))+((x954*x958))))),IKFAST_ATAN2_MAGTHRESH);
if(!x960.valid){
continue;
}
j2array[0]=x960.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x961=IKcos(j2);
IkReal x962=IKsin(j2);
IkReal x963=(px*sj1);
IkReal x964=((0.273)*cj3);
IkReal x965=(py*sj1);
IkReal x966=((1.0)*r00);
IkReal x967=(cj1*sj0);
IkReal x968=((1.0)*px);
IkReal x969=((1.0)*pz);
IkReal x970=(cj0*r01);
IkReal x971=(pz*sj1);
IkReal x972=((0.273)*sj3);
IkReal x973=(cj0*cj1);
IkReal x974=((0.139)*x962);
IkReal x975=((0.139)*x961);
IkReal x976=(x961*x972);
IkReal x977=(x962*x964);
IkReal x978=(x962*x972);
IkReal x979=(x961*x964);
IkReal x980=(x974+x977);
IkReal x981=(x975+x979+x978);
evalcond[0]=((-0.19)+(((-1.0)*x981))+((cj0*x963))+(((-1.0)*cj1*x969))+((sj0*x965)));
evalcond[1]=((((-1.0)*sj1*x969))+(((-1.0)*py*x967))+x980+(((-1.0)*x968*x973))+(((-1.0)*x976)));
evalcond[2]=((((-1.0)*x980))+(((-1.0)*cj0*r02*x965))+(((-1.0)*cj1*py*x966))+((x970*x971))+((cj1*px*r01))+x976+((r02*sj0*x963))+(((-1.0)*sj0*x966*x971)));
evalcond[3]=((((-1.0)*x981))+(((-1.0)*x965*x966))+(((-1.0)*r02*x967*x968))+((r01*x963))+((pz*r00*x967))+(((0.19)*r00*sj0))+(((-0.19)*x970))+(((-1.0)*cj1*x969*x970))+((py*r02*x973)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x982=((139.0)*sj1);
IkReal x983=(cj0*r00);
IkReal x984=((1000.0)*cj4);
IkReal x985=(cj1*cj3);
IkReal x986=((273.0)*r02);
IkReal x987=(cj1*sj3);
IkReal x988=((190.0)*cj4);
IkReal x989=((273.0)*r01);
IkReal x990=(cj3*sj1);
IkReal x991=(cj0*px);
IkReal x992=(sj1*sj3);
IkReal x993=(sj0*x992);
CheckValue<IkReal> x994 = IKatan2WithCheck((gconst2*(((((273.0)*x983*x990))+((r01*sj0*x982))+((sj0*x989*x990))+(((-1.0)*py*x984*x993))+((x982*x983))+(((-1.0)*x984*x991*x992))+((sj3*x988))+((pz*x984*x987))+(((-139.0)*cj1*r02))+(((-1.0)*x985*x986))))),(gconst2*(((((-1.0)*py*sj0*x984*x990))+(((-273.0)*x983*x992))+((x986*x987))+((cj3*x988))+(((-1.0)*x989*x993))+((pz*x984*x985))+(((-1.0)*x984*x990*x991))))),IKFAST_ATAN2_MAGTHRESH);
if(!x994.valid){
continue;
}
j2array[0]=x994.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x995=IKcos(j2);
IkReal x996=IKsin(j2);
IkReal x997=pz*pz;
IkReal x998=py*py;
IkReal x999=px*px;
IkReal x1000=(px*sj1);
IkReal x1001=(sj0*sj1);
IkReal x1002=((0.055208)*sj3);
IkReal x1003=(pp*r01);
IkReal x1004=(cj1*sj0);
IkReal x1005=(pz*r01);
IkReal x1006=((0.38)*sj0);
IkReal x1007=((1.0)*sj1);
IkReal x1008=(py*r00);
IkReal x1009=(pz*r02);
IkReal x1010=((2.0)*cj0);
IkReal x1011=((2.0)*py);
IkReal x1012=(pz*r00);
IkReal x1013=(pp*r02);
IkReal x1014=((1.0)*cj1);
IkReal x1015=(cj0*r00);
IkReal x1016=((0.0361)*cj1);
IkReal x1017=(py*r02);
IkReal x1018=((0.0361)*r01);
IkReal x1019=((0.0361)*sj1);
IkReal x1020=(py*r01);
IkReal x1021=((2.0)*px);
IkReal x1022=(cj1*px);
IkReal x1023=((0.09385)*cj3);
IkReal x1024=((0.38)*cj0);
IkReal x1025=(px*r02);
IkReal x1026=(cj4*x996);
IkReal x1027=(cj4*x995);
IkReal x1028=((0.273)*sj3*sj4);
IkReal x1029=((0.139)*x996);
IkReal x1030=((0.139)*x995);
IkReal x1031=(r00*x999);
IkReal x1032=((0.273)*x995);
IkReal x1033=((0.273)*cj3*x996);
IkReal x1034=(x1009*x1011);
IkReal x1035=((2.0)*r01*x998);
IkReal x1036=((2.0)*r02*x997);
evalcond[0]=(((r01*x1001))+((sj1*x1015))+(((-1.0)*r02*x1014))+(((-1.0)*sj3*x1027))+((cj3*x1026)));
evalcond[1]=((((-1.0)*x1014*x1015))+(((-1.0)*r01*x1004))+(((-1.0)*r02*x1007))+((sj3*x1026))+((cj3*x1027)));
evalcond[2]=((-0.19)+(((-1.0)*x1030))+(((-1.0)*pz*x1014))+((cj0*x1000))+((py*x1001))+(((-1.0)*cj3*x1032))+(((-0.273)*sj3*x996)));
evalcond[3]=((((-1.0)*cj0*px*x1014))+(((-1.0)*pz*x1007))+x1033+x1029+(((-1.0)*py*x1004))+(((-1.0)*sj3*x1032)));
evalcond[4]=(((r01*x1022))+((sj4*x1033))+((cj0*sj1*x1005))+((sj4*x1029))+(((-1.0)*x1008*x1014))+(((-1.0)*x1001*x1012))+((r02*sj0*x1000))+(((-1.0)*cj0*x1007*x1017))+(((-1.0)*x1028*x995)));
evalcond[5]=(((r01*x1000))+(((-1.0)*cj0*x1005*x1014))+((x1028*x996))+((sj4*x1030))+(((-0.19)*cj0*r01))+(((-1.0)*x1007*x1008))+((cj3*sj4*x1032))+(((-1.0)*x1004*x1025))+(((0.19)*r00*sj0))+((x1004*x1012))+((cj0*cj1*x1017)));
evalcond[6]=(((cj1*x1012*x1021))+((cj1*x1005*x1011))+(((0.075894)*x1026))+(((0.38)*x1020))+((r02*x1016))+(((-1.0)*x1015*x1019))+(((0.38)*x1009))+((x1023*x1026))+(((0.38)*px*r00))+(((-2.0)*sj0*x1000*x1008))+(((-1.0)*x1001*x1018))+((pp*sj1*x1015))+(((-1.0)*x1000*x1010*x1020))+(((-1.0)*x1013*x1014))+(((-1.0)*x1002*x1027))+(((-1.0)*x1000*x1009*x1010))+(((-1.0)*x1001*x1034))+(((-1.0)*x1001*x1035))+((cj1*x1036))+((x1001*x1003))+(((-1.0)*sj1*x1010*x1031)));
evalcond[7]=((((-1.0)*x1003*x1004))+(((0.075894)*x1027))+(((-1.0)*x1004*x1018))+(((2.0)*x1000*x1012))+(((-1.0)*r02*x1019))+(((-1.0)*x1015*x1016))+((sj1*x1036))+((x1023*x1027))+((x1002*x1026))+((x1009*x1010*x1022))+(((-1.0)*x1005*x1006))+((x1004*x1008*x1021))+((sj1*x1005*x1011))+((x1004*x1034))+((x1004*x1035))+((x1006*x1017))+((x1010*x1020*x1022))+(((-1.0)*pp*x1014*x1015))+((cj1*x1010*x1031))+((x1024*x1025))+(((-1.0)*x1007*x1013))+(((-1.0)*x1012*x1024)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1037=((1.0)*sj1);
IkReal x1038=(cj1*sj3);
IkReal x1039=(cj0*r00);
IkReal x1040=(cj3*r02);
IkReal x1041=(r01*sj0);
IkReal x1042=(sj1*sj3);
IkReal x1043=(cj3*x1041);
CheckValue<IkReal> x1044 = IKatan2WithCheck((gconst1*((((x1038*x1039))+((r02*x1042))+((x1038*x1041))+((cj1*x1040))+(((-1.0)*x1037*x1043))+(((-1.0)*cj3*x1037*x1039))))),(gconst1*((((x1039*x1042))+((x1041*x1042))+((cj1*x1043))+(((-1.0)*r02*x1038))+((sj1*x1040))+((cj1*cj3*x1039))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1044.valid){
continue;
}
j2array[0]=x1044.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x1045=IKcos(j2);
IkReal x1046=IKsin(j2);
IkReal x1047=pz*pz;
IkReal x1048=py*py;
IkReal x1049=px*px;
IkReal x1050=(px*sj1);
IkReal x1051=(sj0*sj1);
IkReal x1052=((0.055208)*sj3);
IkReal x1053=(pp*r01);
IkReal x1054=(cj1*sj0);
IkReal x1055=(pz*r01);
IkReal x1056=((0.38)*sj0);
IkReal x1057=((1.0)*sj1);
IkReal x1058=(py*r00);
IkReal x1059=(pz*r02);
IkReal x1060=((2.0)*cj0);
IkReal x1061=((2.0)*py);
IkReal x1062=(pz*r00);
IkReal x1063=(pp*r02);
IkReal x1064=((1.0)*cj1);
IkReal x1065=(cj0*r00);
IkReal x1066=((0.0361)*cj1);
IkReal x1067=(py*r02);
IkReal x1068=((0.0361)*r01);
IkReal x1069=((0.0361)*sj1);
IkReal x1070=(py*r01);
IkReal x1071=((2.0)*px);
IkReal x1072=(cj1*px);
IkReal x1073=((0.09385)*cj3);
IkReal x1074=((0.38)*cj0);
IkReal x1075=(px*r02);
IkReal x1076=(cj4*x1046);
IkReal x1077=(cj4*x1045);
IkReal x1078=((0.273)*sj3*sj4);
IkReal x1079=((0.139)*x1046);
IkReal x1080=((0.139)*x1045);
IkReal x1081=(r00*x1049);
IkReal x1082=((0.273)*x1045);
IkReal x1083=((0.273)*cj3*x1046);
IkReal x1084=(x1059*x1061);
IkReal x1085=((2.0)*r01*x1048);
IkReal x1086=((2.0)*r02*x1047);
evalcond[0]=((((-1.0)*r02*x1064))+((cj3*x1076))+(((-1.0)*sj3*x1077))+((r01*x1051))+((sj1*x1065)));
evalcond[1]=((((-1.0)*r01*x1054))+(((-1.0)*r02*x1057))+((sj3*x1076))+((cj3*x1077))+(((-1.0)*x1064*x1065)));
evalcond[2]=((-0.19)+((cj0*x1050))+((py*x1051))+(((-1.0)*pz*x1064))+(((-0.273)*sj3*x1046))+(((-1.0)*x1080))+(((-1.0)*cj3*x1082)));
evalcond[3]=((((-1.0)*sj3*x1082))+(((-1.0)*py*x1054))+x1079+x1083+(((-1.0)*pz*x1057))+(((-1.0)*cj0*px*x1064)));
evalcond[4]=(((r02*sj0*x1050))+((cj0*sj1*x1055))+(((-1.0)*x1045*x1078))+(((-1.0)*x1058*x1064))+(((-1.0)*cj0*x1057*x1067))+(((-1.0)*x1051*x1062))+((sj4*x1083))+((sj4*x1079))+((r01*x1072)));
evalcond[5]=(((x1054*x1062))+(((-1.0)*cj0*x1055*x1064))+(((-0.19)*cj0*r01))+((r01*x1050))+((cj0*cj1*x1067))+((cj3*sj4*x1082))+(((0.19)*r00*sj0))+((x1046*x1078))+((sj4*x1080))+(((-1.0)*x1057*x1058))+(((-1.0)*x1054*x1075)));
evalcond[6]=((((-1.0)*x1063*x1064))+(((-1.0)*x1050*x1060*x1070))+((cj1*x1086))+((cj1*x1062*x1071))+(((-1.0)*sj1*x1060*x1081))+(((-1.0)*x1050*x1059*x1060))+(((-1.0)*x1051*x1084))+(((-1.0)*x1051*x1085))+(((0.38)*px*r00))+((x1051*x1053))+(((0.075894)*x1076))+(((-2.0)*sj0*x1050*x1058))+((x1073*x1076))+((cj1*x1055*x1061))+(((0.38)*x1070))+(((-1.0)*x1051*x1068))+(((0.38)*x1059))+((pp*sj1*x1065))+((r02*x1066))+(((-1.0)*x1065*x1069))+(((-1.0)*x1052*x1077)));
evalcond[7]=(((x1056*x1067))+((x1074*x1075))+((x1059*x1060*x1072))+(((-1.0)*r02*x1069))+((x1054*x1058*x1071))+((x1060*x1070*x1072))+(((-1.0)*pp*x1064*x1065))+(((-1.0)*x1062*x1074))+((x1052*x1076))+(((-1.0)*x1057*x1063))+((cj1*x1060*x1081))+(((0.075894)*x1077))+((sj1*x1055*x1061))+(((-1.0)*x1055*x1056))+((x1073*x1077))+(((-1.0)*x1053*x1054))+((sj1*x1086))+(((-1.0)*x1054*x1068))+(((2.0)*x1050*x1062))+((x1054*x1085))+((x1054*x1084))+(((-1.0)*x1065*x1066)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
    }
}
}
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "ab9d03903279e44bc692e896791bcd05"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
