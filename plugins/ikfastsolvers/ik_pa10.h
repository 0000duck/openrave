/// autogenerated analytical inverse kinematics code from ikfast program
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// generated 2011-01-12 19:08:15.014184
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object:
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -shared -Wl,-soname,ik.so -o ik.so ik.cpp
#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifdef BOOST_ASSERT
#define IKFAST_ASSERT BOOST_ASSERT
#else

#include <stdexcept>
#include <sstream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                IKFAST_ASSERT(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline float IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

IKFAST_API int getNumFreeParameters() { return 1; }
IKFAST_API int* getFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int getNumJoints() { return 7; }

IKFAST_API int getIKRealSize() { return sizeof(IKReal); }

IKFAST_API int getIKType() { return 1; }

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {
IKReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13;
x0=IKcos(j[0]);
x1=IKsin(j[3]);
x2=IKsin(j[1]);
x3=IKsin(j[6]);
x4=IKsin(j[5]);
x5=IKcos(j[3]);
x6=IKcos(j[4]);
x7=IKcos(j[5]);
x8=IKcos(j[1]);
x9=IKsin(j[2]);
x10=IKsin(j[4]);
x11=IKcos(j[6]);
x12=IKsin(j[0]);
x13=IKcos(j[2]);
eerot[0]=((((0.707106781186547)*(x11)*(x12)*(x5)*(x6)*(x7)*(x9)))+(((-0.707106781186548)*(x0)*(x13)*(x3)*(x5)*(x6)*(x7)*(x8)))+(((0.707106781186547)*(x0)*(x1)*(x11)*(x2)*(x6)*(x7)))+(((0.707106781186548)*(x0)*(x1)*(x13)*(x3)*(x4)*(x8)))+(((0.707106781186547)*(x0)*(x1)*(x11)*(x13)*(x4)*(x8)))+(((0.707106781186548)*(x12)*(x3)*(x5)*(x6)*(x7)*(x9)))+(((0.707106781186547)*(x0)*(x11)*(x2)*(x4)*(x5)))+(((0.707106781186548)*(x0)*(x1)*(x2)*(x3)*(x6)*(x7)))+(((-0.707106781186547)*(x0)*(x1)*(x10)*(x2)*(x3)))+(((-0.707106781186547)*(x0)*(x11)*(x13)*(x5)*(x6)*(x7)*(x8)))+(((0.707106781186547)*(x0)*(x10)*(x11)*(x7)*(x8)*(x9)))+(((0.707106781186548)*(x0)*(x1)*(x10)*(x11)*(x2)))+(((-0.707106781186548)*(x11)*(x12)*(x13)*(x6)))+(((-0.707106781186548)*(x0)*(x11)*(x6)*(x8)*(x9)))+(((0.707106781186547)*(x0)*(x3)*(x6)*(x8)*(x9)))+(((0.707106781186548)*(x10)*(x11)*(x12)*(x5)*(x9)))+(((0.707106781186547)*(x12)*(x13)*(x3)*(x6)))+(((-0.707106781186548)*(x0)*(x10)*(x11)*(x13)*(x5)*(x8)))+(((0.707106781186548)*(x0)*(x2)*(x3)*(x4)*(x5)))+(((0.707106781186548)*(x0)*(x10)*(x3)*(x7)*(x8)*(x9)))+(((0.707106781186548)*(x10)*(x12)*(x13)*(x3)*(x7)))+(((-0.707106781186547)*(x1)*(x11)*(x12)*(x4)*(x9)))+(((0.707106781186547)*(x10)*(x11)*(x12)*(x13)*(x7)))+(((-0.707106781186547)*(x10)*(x12)*(x3)*(x5)*(x9)))+(((0.707106781186547)*(x0)*(x10)*(x13)*(x3)*(x5)*(x8)))+(((-0.707106781186548)*(x1)*(x12)*(x3)*(x4)*(x9))));
eerot[1]=((((0.707106781186548)*(x0)*(x1)*(x11)*(x2)*(x6)*(x7)))+(((0.707106781186547)*(x0)*(x11)*(x6)*(x8)*(x9)))+(((0.707106781186548)*(x12)*(x13)*(x3)*(x6)))+(((-0.707106781186547)*(x0)*(x1)*(x2)*(x3)*(x6)*(x7)))+(((0.707106781186548)*(x0)*(x3)*(x6)*(x8)*(x9)))+(((0.707106781186548)*(x11)*(x12)*(x5)*(x6)*(x7)*(x9)))+(((-0.707106781186548)*(x10)*(x12)*(x3)*(x5)*(x9)))+(((-0.707106781186548)*(x0)*(x11)*(x13)*(x5)*(x6)*(x7)*(x8)))+(((0.707106781186548)*(x0)*(x10)*(x11)*(x7)*(x8)*(x9)))+(((-0.707106781186547)*(x10)*(x11)*(x12)*(x5)*(x9)))+(((-0.707106781186547)*(x0)*(x2)*(x3)*(x4)*(x5)))+(((0.707106781186547)*(x0)*(x13)*(x3)*(x5)*(x6)*(x7)*(x8)))+(((0.707106781186548)*(x0)*(x11)*(x2)*(x4)*(x5)))+(((-0.707106781186547)*(x10)*(x12)*(x13)*(x3)*(x7)))+(((-0.707106781186547)*(x12)*(x3)*(x5)*(x6)*(x7)*(x9)))+(((0.707106781186547)*(x11)*(x12)*(x13)*(x6)))+(((-0.707106781186548)*(x1)*(x11)*(x12)*(x4)*(x9)))+(((-0.707106781186547)*(x0)*(x1)*(x13)*(x3)*(x4)*(x8)))+(((0.707106781186548)*(x0)*(x10)*(x13)*(x3)*(x5)*(x8)))+(((0.707106781186547)*(x1)*(x12)*(x3)*(x4)*(x9)))+(((-0.707106781186547)*(x0)*(x10)*(x3)*(x7)*(x8)*(x9)))+(((0.707106781186547)*(x0)*(x10)*(x11)*(x13)*(x5)*(x8)))+(((0.707106781186548)*(x0)*(x1)*(x11)*(x13)*(x4)*(x8)))+(((-0.707106781186548)*(x0)*(x1)*(x10)*(x2)*(x3)))+(((-0.707106781186547)*(x0)*(x1)*(x10)*(x11)*(x2)))+(((0.707106781186548)*(x10)*(x11)*(x12)*(x13)*(x7))));
eerot[2]=((((-1.00000000000000)*(x0)*(x1)*(x2)*(x4)*(x6)))+(((x0)*(x1)*(x13)*(x7)*(x8)))+(((-1.00000000000000)*(x0)*(x10)*(x4)*(x8)*(x9)))+(((x0)*(x2)*(x5)*(x7)))+(((x0)*(x13)*(x4)*(x5)*(x6)*(x8)))+(((-1.00000000000000)*(x1)*(x12)*(x7)*(x9)))+(((-1.00000000000000)*(x10)*(x12)*(x13)*(x4)))+(((-1.00000000000000)*(x12)*(x4)*(x5)*(x6)*(x9))));
eetrans[0]=((((-0.0850000000000002)*(x0)*(x10)*(x4)*(x8)*(x9)))+(((-0.0850000000000002)*(x1)*(x12)*(x7)*(x9)))+(((0.500000000000000)*(x0)*(x2)*(x5)))+(((-0.0850000000000002)*(x0)*(x1)*(x2)*(x4)*(x6)))+(((-0.500000000000000)*(x1)*(x12)*(x9)))+(((0.450000000000000)*(x0)*(x2)))+(((0.0850000000000002)*(x0)*(x13)*(x4)*(x5)*(x6)*(x8)))+(((-0.0850000000000002)*(x10)*(x12)*(x13)*(x4)))+(((0.500000000000000)*(x0)*(x1)*(x13)*(x8)))+(((-0.0850000000000002)*(x12)*(x4)*(x5)*(x6)*(x9)))+(((0.0850000000000002)*(x0)*(x2)*(x5)*(x7)))+(((0.0850000000000002)*(x0)*(x1)*(x13)*(x7)*(x8))));
eerot[3]=((((-0.707106781186547)*(x0)*(x10)*(x11)*(x13)*(x7)))+(((0.707106781186548)*(x12)*(x2)*(x3)*(x4)*(x5)))+(((0.707106781186548)*(x0)*(x1)*(x3)*(x4)*(x9)))+(((-0.707106781186547)*(x11)*(x12)*(x13)*(x5)*(x6)*(x7)*(x8)))+(((0.707106781186548)*(x1)*(x10)*(x11)*(x12)*(x2)))+(((-0.707106781186547)*(x1)*(x10)*(x12)*(x2)*(x3)))+(((0.707106781186547)*(x11)*(x12)*(x2)*(x4)*(x5)))+(((-0.707106781186548)*(x10)*(x11)*(x12)*(x13)*(x5)*(x8)))+(((-0.707106781186548)*(x11)*(x12)*(x6)*(x8)*(x9)))+(((0.707106781186547)*(x1)*(x11)*(x12)*(x13)*(x4)*(x8)))+(((0.707106781186548)*(x0)*(x11)*(x13)*(x6)))+(((0.707106781186547)*(x1)*(x11)*(x12)*(x2)*(x6)*(x7)))+(((-0.707106781186547)*(x0)*(x11)*(x5)*(x6)*(x7)*(x9)))+(((-0.707106781186548)*(x0)*(x10)*(x11)*(x5)*(x9)))+(((0.707106781186547)*(x10)*(x12)*(x13)*(x3)*(x5)*(x8)))+(((0.707106781186547)*(x10)*(x11)*(x12)*(x7)*(x8)*(x9)))+(((0.707106781186547)*(x0)*(x10)*(x3)*(x5)*(x9)))+(((-0.707106781186548)*(x0)*(x10)*(x13)*(x3)*(x7)))+(((0.707106781186548)*(x10)*(x12)*(x3)*(x7)*(x8)*(x9)))+(((0.707106781186548)*(x1)*(x12)*(x13)*(x3)*(x4)*(x8)))+(((0.707106781186548)*(x1)*(x12)*(x2)*(x3)*(x6)*(x7)))+(((0.707106781186547)*(x12)*(x3)*(x6)*(x8)*(x9)))+(((-0.707106781186548)*(x0)*(x3)*(x5)*(x6)*(x7)*(x9)))+(((-0.707106781186547)*(x0)*(x13)*(x3)*(x6)))+(((0.707106781186547)*(x0)*(x1)*(x11)*(x4)*(x9)))+(((-0.707106781186548)*(x12)*(x13)*(x3)*(x5)*(x6)*(x7)*(x8))));
eerot[4]=((((-0.707106781186547)*(x1)*(x12)*(x13)*(x3)*(x4)*(x8)))+(((0.707106781186547)*(x0)*(x10)*(x11)*(x5)*(x9)))+(((-0.707106781186547)*(x0)*(x11)*(x13)*(x6)))+(((0.707106781186548)*(x11)*(x12)*(x2)*(x4)*(x5)))+(((0.707106781186548)*(x0)*(x1)*(x11)*(x4)*(x9)))+(((0.707106781186548)*(x1)*(x11)*(x12)*(x13)*(x4)*(x8)))+(((-0.707106781186548)*(x11)*(x12)*(x13)*(x5)*(x6)*(x7)*(x8)))+(((-0.707106781186548)*(x0)*(x13)*(x3)*(x6)))+(((0.707106781186548)*(x10)*(x12)*(x13)*(x3)*(x5)*(x8)))+(((-0.707106781186547)*(x1)*(x12)*(x2)*(x3)*(x6)*(x7)))+(((-0.707106781186548)*(x0)*(x11)*(x5)*(x6)*(x7)*(x9)))+(((0.707106781186547)*(x0)*(x3)*(x5)*(x6)*(x7)*(x9)))+(((0.707106781186548)*(x1)*(x11)*(x12)*(x2)*(x6)*(x7)))+(((0.707106781186548)*(x10)*(x11)*(x12)*(x7)*(x8)*(x9)))+(((-0.707106781186547)*(x12)*(x2)*(x3)*(x4)*(x5)))+(((-0.707106781186547)*(x1)*(x10)*(x11)*(x12)*(x2)))+(((0.707106781186547)*(x0)*(x10)*(x13)*(x3)*(x7)))+(((0.707106781186548)*(x12)*(x3)*(x6)*(x8)*(x9)))+(((-0.707106781186548)*(x1)*(x10)*(x12)*(x2)*(x3)))+(((0.707106781186548)*(x0)*(x10)*(x3)*(x5)*(x9)))+(((-0.707106781186547)*(x0)*(x1)*(x3)*(x4)*(x9)))+(((0.707106781186547)*(x12)*(x13)*(x3)*(x5)*(x6)*(x7)*(x8)))+(((0.707106781186547)*(x11)*(x12)*(x6)*(x8)*(x9)))+(((0.707106781186547)*(x10)*(x11)*(x12)*(x13)*(x5)*(x8)))+(((-0.707106781186547)*(x10)*(x12)*(x3)*(x7)*(x8)*(x9)))+(((-0.707106781186548)*(x0)*(x10)*(x11)*(x13)*(x7))));
eerot[5]=((((x12)*(x2)*(x5)*(x7)))+(((x0)*(x1)*(x7)*(x9)))+(((-1.00000000000000)*(x1)*(x12)*(x2)*(x4)*(x6)))+(((x0)*(x4)*(x5)*(x6)*(x9)))+(((x12)*(x13)*(x4)*(x5)*(x6)*(x8)))+(((x0)*(x10)*(x13)*(x4)))+(((-1.00000000000000)*(x10)*(x12)*(x4)*(x8)*(x9)))+(((x1)*(x12)*(x13)*(x7)*(x8))));
eetrans[1]=((((0.0850000000000002)*(x0)*(x1)*(x7)*(x9)))+(((-0.0850000000000002)*(x10)*(x12)*(x4)*(x8)*(x9)))+(((-0.0850000000000002)*(x1)*(x12)*(x2)*(x4)*(x6)))+(((0.0850000000000002)*(x0)*(x4)*(x5)*(x6)*(x9)))+(((0.0850000000000002)*(x1)*(x12)*(x13)*(x7)*(x8)))+(((0.0850000000000002)*(x12)*(x13)*(x4)*(x5)*(x6)*(x8)))+(((0.450000000000000)*(x12)*(x2)))+(((0.500000000000000)*(x12)*(x2)*(x5)))+(((0.500000000000000)*(x0)*(x1)*(x9)))+(((0.500000000000000)*(x1)*(x12)*(x13)*(x8)))+(((0.0850000000000002)*(x0)*(x10)*(x13)*(x4)))+(((0.0850000000000002)*(x12)*(x2)*(x5)*(x7))));
eerot[6]=((((-0.707106781186547)*(x1)*(x11)*(x13)*(x2)*(x4)))+(((-0.707106781186547)*(x10)*(x11)*(x2)*(x7)*(x9)))+(((-0.707106781186548)*(x10)*(x2)*(x3)*(x7)*(x9)))+(((0.707106781186547)*(x1)*(x11)*(x6)*(x7)*(x8)))+(((-0.707106781186547)*(x2)*(x3)*(x6)*(x9)))+(((0.707106781186548)*(x1)*(x10)*(x11)*(x8)))+(((0.707106781186548)*(x1)*(x3)*(x6)*(x7)*(x8)))+(((0.707106781186548)*(x10)*(x11)*(x13)*(x2)*(x5)))+(((0.707106781186548)*(x3)*(x4)*(x5)*(x8)))+(((0.707106781186547)*(x11)*(x4)*(x5)*(x8)))+(((-0.707106781186548)*(x1)*(x13)*(x2)*(x3)*(x4)))+(((0.707106781186548)*(x13)*(x2)*(x3)*(x5)*(x6)*(x7)))+(((0.707106781186548)*(x11)*(x2)*(x6)*(x9)))+(((0.707106781186547)*(x11)*(x13)*(x2)*(x5)*(x6)*(x7)))+(((-0.707106781186547)*(x1)*(x10)*(x3)*(x8)))+(((-0.707106781186547)*(x10)*(x13)*(x2)*(x3)*(x5))));
eerot[7]=((((0.707106781186548)*(x11)*(x13)*(x2)*(x5)*(x6)*(x7)))+(((0.707106781186547)*(x10)*(x2)*(x3)*(x7)*(x9)))+(((-0.707106781186547)*(x13)*(x2)*(x3)*(x5)*(x6)*(x7)))+(((-0.707106781186547)*(x1)*(x3)*(x6)*(x7)*(x8)))+(((-0.707106781186548)*(x1)*(x10)*(x3)*(x8)))+(((0.707106781186548)*(x1)*(x11)*(x6)*(x7)*(x8)))+(((-0.707106781186547)*(x1)*(x10)*(x11)*(x8)))+(((-0.707106781186548)*(x10)*(x13)*(x2)*(x3)*(x5)))+(((-0.707106781186547)*(x10)*(x11)*(x13)*(x2)*(x5)))+(((-0.707106781186547)*(x11)*(x2)*(x6)*(x9)))+(((-0.707106781186548)*(x1)*(x11)*(x13)*(x2)*(x4)))+(((-0.707106781186548)*(x10)*(x11)*(x2)*(x7)*(x9)))+(((0.707106781186547)*(x1)*(x13)*(x2)*(x3)*(x4)))+(((0.707106781186548)*(x11)*(x4)*(x5)*(x8)))+(((-0.707106781186547)*(x3)*(x4)*(x5)*(x8)))+(((-0.707106781186548)*(x2)*(x3)*(x6)*(x9))));
eerot[8]=((((-1.00000000000000)*(x1)*(x4)*(x6)*(x8)))+(((x10)*(x2)*(x4)*(x9)))+(((x5)*(x7)*(x8)))+(((-1.00000000000000)*(x13)*(x2)*(x4)*(x5)*(x6)))+(((-1.00000000000000)*(x1)*(x13)*(x2)*(x7))));
eetrans[2]=((0.315000000000000)+(((-0.500000000000000)*(x1)*(x13)*(x2)))+(((0.0850000000000002)*(x5)*(x7)*(x8)))+(((0.500000000000000)*(x5)*(x8)))+(((-0.0850000000000002)*(x13)*(x2)*(x4)*(x5)*(x6)))+(((-0.0850000000000002)*(x1)*(x4)*(x6)*(x8)))+(((0.0850000000000002)*(x10)*(x2)*(x4)*(x9)))+(((-0.0850000000000002)*(x1)*(x13)*(x2)*(x7)))+(((0.450000000000000)*(x8))));
}

class IKSolver {
public:
IKReal j0, cj0, sj0,
j1, cj1, sj1,
j3, cj3, sj3,
j4, cj4, sj4,
j5, cj5, sj5,
j6, cj6, sj6,
j2, cj2, sj2,
new_r00, r00,
new_r01, r01,
new_r02, r02,
new_r10, r10,
new_r11, r11,
new_r12, r12,
new_r20, r20,
new_r21, r21,
new_r22, r22,
new_px, new_py, new_pz, px, py, pz;

bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
vsolutions.resize(0); vsolutions.reserve(8);
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((((-0.707106781186547)*(r00)))+(((-0.707106781186548)*(r01))));
new_r01=((((-0.707106781186547)*(r01)))+(((0.707106781186548)*(r00))));
new_r02=r02;
new_px=((px)+(((-0.0850000000000002)*(r02))));
new_r10=((((-0.707106781186547)*(r10)))+(((-0.707106781186548)*(r11))));
new_r11=((((-0.707106781186547)*(r11)))+(((0.707106781186548)*(r10))));
new_r12=r12;
new_py=((py)+(((-0.0850000000000002)*(r12))));
new_r20=((((-0.707106781186547)*(r20)))+(((-0.707106781186548)*(r21))));
new_r21=((((-0.707106781186547)*(r21)))+(((0.707106781186548)*(r20))));
new_r22=r22;
new_pz=((-0.315000000000000)+(pz)+(((-0.0850000000000002)*(r22))));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
{
if( 1 )
{
{
IKReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
cj3array[0]=((-1.00555555555556)+(((2.22222222222222)*((pz)*(pz))))+(((2.22222222222222)*((px)*(px))))+(((2.22222222222222)*((py)*(py)))));
if( cj3array[0] >= -1.0001 && cj3array[0] <= 1.0001 )
{
    j3valid[0] = j3valid[1] = true;
    j3array[0] = IKacos(cj3array[0]);
    sj3array[0] = IKsin(j3array[0]);
    cj3array[1] = cj3array[0];
    j3array[1] = -j3array[0];
    sj3array[1] = -sj3array[0];
}
else if( isnan(cj3array[0]) )
{
    // probably any value will work
    j3valid[0] = true;
    cj3array[0] = 1; sj3array[0] = 0; j3array[0] = 0;
}
if( j3valid[0] && j3valid[1] && IKabs(cj3array[0]-cj3array[1]) < 0.0001 && IKabs(sj3array[0]-sj3array[1]) < 0.0001 )
    j3valid[1]=false;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] ) { continue; }
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IKReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
IKReal x0=(px)*(px);
IKReal x1=(py)*(py);
IKReal x2=((x1)+(x0));
if( (x2) < (IKReal)-0.00001 )
    continue;
IKReal x3=IKsqrt(x2);
IKReal x4=IKabs(x3);
IKReal x5=((IKabs(x4) != 0)?((IKReal)1/(x4)):(IKReal)1.0e30);
IKReal x6=((0.500000000000000)*(sj2)*(sj3)*(x5));
if( (x6) < -1.0001 || (x6) > 1.0001 )
    continue;
IKReal x7=IKasin(x6);
IKReal x8=((-1.00000000000000)*(py));
IKReal x9=IKatan2(x8, px);
j0array[0]=((((-1.00000000000000)*(x7)))+(((-1.00000000000000)*(x9))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(x7)+(((-1.00000000000000)*(x9))));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
    j0array[0]-=IK2PI;
else if( j0array[0] < -IKPI )
    j0array[0]+=IK2PI;
j0valid[0] = true;
if( j0array[1] > IKPI )
    j0array[1]-=IK2PI;
else if( j0array[1] < -IKPI )
    j0array[1]+=IK2PI;
j0valid[1] = true;
if( j0valid[0] && j0valid[1] && IKabs(cj0array[0]-cj0array[1]) < 0.0001 && IKabs(sj0array[0]-sj0array[1]) < 0.0001 )
    j0valid[1]=false;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] ) { continue; }
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IKReal dummyeval[1];
dummyeval[0]=((((-0.500000000000000)*(cj3)*(pz)))+(((0.500000000000000)*(cj0)*(cj2)*(px)*(sj3)))+(((-0.450000000000000)*(pz)))+(((0.500000000000000)*(cj2)*(py)*(sj0)*(sj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.202500000000000)+(((0.250000000000000)*((cj3)*(cj3))))+(((0.250000000000000)*((cj2)*(cj2))*((sj3)*(sj3))))+(((0.450000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.500000000000000)*(cj3)*(py)*(sj0)))+(((0.500000000000000)*(cj0)*(cj3)*(px)))+(((0.450000000000000)*(cj0)*(px)))+(((0.450000000000000)*(py)*(sj0)))+(((0.500000000000000)*(cj2)*(pz)*(sj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[4];
IKReal x10=((0.500000000000000)*(sj3));
IKReal x11=((px)*(sj0));
IKReal x12=((x11)+(x10));
IKReal x13=((cj0)*(py));
IKReal x14=((((-1.00000000000000)*(x13)))+(x12));
evalcond[0]=((IKabs(pz))+(IKabs(((IKfmod(((((0.500000000000000)*(3.14159265358979)))+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979)))))));
evalcond[1]=x14;
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x14;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.450000000000000)*(cj0)))+(((0.500000000000000)*(cj0)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.500000000000000)*(cj3)*(sj0)))+(((0.450000000000000)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[8];
IKReal x15=x11;
IKReal x16=((0.217944947177033)+(x15));
IKReal x17=x13;
IKReal x18=((((-1.00000000000000)*(x17)))+(x16));
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x18;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=((((-1.00000000000000)*(py)*(sj0)))+(((-1.00000000000000)*(cj0)*(px))));
evalcond[5]=((((-0.217944947177033)*(sj0)))+(((-1.00000000000000)*(px))));
evalcond[6]=((((0.217944947177033)*(cj0)))+(((-1.00000000000000)*(py))));
evalcond[7]=x18;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(cj0)*(px)))+(((0.900000000000000)*(py)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.435889894354067)*(py)*(sj0)))+(((0.435889894354067)*(cj0)*(px))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(py)*(sj0)))+(((0.900000000000000)*(cj0)*(px))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x19=((0.900000000000000)*(py)*(sj0));
IKReal x20=((0.900000000000000)*(cj0)*(px));
IKReal x21=((x19)+(x20));
IKReal x22=((IKabs(x21) != 0)?((IKReal)1/(x21)):(IKReal)1.0e30);
sj1array[0]=((((0.435889894354067)*(cj0)*(py)*(x22)))+(((-0.435889894354067)*(px)*(sj0)*(x22)))+(((-0.0949999999999998)*(x22))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x63=((0.435889894354067)*(py)*(sj0));
IKReal x64=((0.435889894354067)*(cj0)*(px));
IKReal x65=((x63)+(x64));
IKReal x66=((IKabs(x65) != 0)?((IKReal)1/(x65)):(IKReal)1.0e30);
sj1array[0]=((((0.900000000000000)*(px)*(sj0)*(x66)))+(((-0.900000000000000)*(cj0)*(py)*(x66)))+(((0.196150452459330)*(x66))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x67=((0.900000000000000)*(cj0)*(px));
IKReal x68=((0.900000000000000)*(py)*(sj0));
IKReal x69=((x67)+(x68));
IKReal x70=((IKabs(x69) != 0)?((IKReal)1/(x69)):(IKReal)1.0e30);
sj1array[0]=((((x70)*((py)*(py))))+(((-0.0474999999999999)*(x70)))+(((x70)*((px)*(px)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x71=x11;
IKReal x72=((-0.217944947177033)+(x71));
IKReal x73=x13;
IKReal x74=((((-1.00000000000000)*(x73)))+(x72));
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x74;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=((((-1.00000000000000)*(py)*(sj0)))+(((-1.00000000000000)*(cj0)*(px))));
evalcond[5]=((((0.217944947177033)*(sj0)))+(((-1.00000000000000)*(px))));
evalcond[6]=((((-0.217944947177033)*(cj0)))+(((-1.00000000000000)*(py))));
evalcond[7]=x74;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(cj0)*(px)))+(((0.900000000000000)*(py)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((-0.435889894354067)*(cj0)*(px)))+(((-0.435889894354067)*(py)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(py)*(sj0)))+(((0.900000000000000)*(cj0)*(px))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x75=((0.900000000000000)*(py)*(sj0));
IKReal x76=((0.900000000000000)*(cj0)*(px));
IKReal x77=((x76)+(x75));
IKReal x78=((IKabs(x77) != 0)?((IKReal)1/(x77)):(IKReal)1.0e30);
sj1array[0]=((((0.435889894354067)*(px)*(sj0)*(x78)))+(((-0.0949999999999998)*(x78)))+(((-0.435889894354067)*(cj0)*(py)*(x78))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x79=((0.435889894354067)*(py)*(sj0));
IKReal x80=((0.435889894354067)*(cj0)*(px));
IKReal x81=((x79)+(x80));
IKReal x82=((-1.00000000000000)*(x81));
IKReal x83=((IKabs(x82) != 0)?((IKReal)1/(x82)):(IKReal)1.0e30);
sj1array[0]=((((0.900000000000000)*(px)*(sj0)*(x83)))+(((-0.900000000000000)*(cj0)*(py)*(x83)))+(((-0.196150452459330)*(x83))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x84=((0.900000000000000)*(cj0)*(px));
IKReal x85=((0.900000000000000)*(py)*(sj0));
IKReal x86=((x84)+(x85));
IKReal x87=((IKabs(x86) != 0)?((IKReal)1/(x86)):(IKReal)1.0e30);
sj1array[0]=((((-0.0474999999999999)*(x87)))+(((x87)*((px)*(px))))+(((x87)*((py)*(py)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x88=x10;
IKReal x89=((x88)+(((-1.00000000000000)*(py))));
evalcond[0]=((IKfmod(((3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x89;
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x89;
evalcond[4]=x89;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[8];
IKReal x90=((-1.00000000000000)*(px));
IKReal x91=((0.217944947177033)+(((-1.00000000000000)*(py))));
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x91;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x90;
evalcond[5]=x90;
evalcond[6]=x91;
evalcond[7]=x91;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x92=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((1.11111111111111)*(x92)*((py)*(py))))+(((-0.0527777777777776)*(x92)))+(((1.11111111111111)*(px))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x93=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.484322104837852)*(py)*(x93)))+(((-0.105555555555555)*(x93))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x94=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.450000000000000)*(x94)))+(((-2.06474160483506)*(py)*(x94))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x95=((-1.00000000000000)*(px));
IKReal x96=((-0.217944947177033)+(((-1.00000000000000)*(py))));
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x96;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x95;
evalcond[5]=x95;
evalcond[6]=x96;
evalcond[7]=x96;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x97=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.0527777777777776)*(x97)))+(((1.11111111111111)*(px)))+(((1.11111111111111)*(x97)*((py)*(py)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x98=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.105555555555555)*(x98)))+(((-0.484322104837852)*(py)*(x98))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x99=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.450000000000000)*(x99)))+(((2.06474160483506)*(py)*(x99))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x100=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((1.11111111111111)*(x100)*((py)*(py))))+(((1.11111111111111)*(px)))+(((-0.0527777777777776)*(x100))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x101=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.500000000000000)*(cj3)*(x101)))+(((0.450000000000000)*(x101))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((px)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x102=x10;
IKReal x103=((x102)+(py));
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x103;
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(x103));
evalcond[4]=x103;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[7];
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((0.217944947177033)+(py));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=px;
evalcond[5]=((-1.00000000000000)*(px));
evalcond[6]=((-0.217944947177033)+(((-1.00000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x104=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.0527777777777776)*(x104)))+(((-1.11111111111111)*(x104)*((py)*(py))))+(((-1.11111111111111)*(px))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x105=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.105555555555555)*(x105)))+(((0.484322104837852)*(py)*(x105))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x106=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-2.06474160483506)*(py)*(x106)))+(((-0.450000000000000)*(x106))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((-0.217944947177033)+(py));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=px;
evalcond[5]=((-1.00000000000000)*(px));
evalcond[6]=((0.217944947177033)+(((-1.00000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x107=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.0527777777777776)*(x107)))+(((-1.11111111111111)*(px)))+(((-1.11111111111111)*(x107)*((py)*(py)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x108=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.105555555555555)*(x108)))+(((-0.484322104837852)*(py)*(x108))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x109=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((2.06474160483506)*(py)*(x109)))+(((-0.450000000000000)*(x109))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x110=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.0527777777777776)*(x110)))+(((-1.11111111111111)*(px)))+(((-1.11111111111111)*(x110)*((py)*(py)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x111=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.500000000000000)*(cj3)*(x111)))+(((-0.450000000000000)*(x111))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.00000000000000)*(px)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x112=x10;
IKReal x113=((x112)+(px));
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x113;
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(x113));
evalcond[4]=x113;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[7];
IKReal x114=x8;
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((0.217944947177033)+(px));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x114;
evalcond[5]=((-0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[6]=x114;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x115=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((1.11111111111111)*(x115)*((px)*(px))))+(((1.11111111111111)*(py)))+(((-0.0527777777777776)*(x115))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x116=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.105555555555555)*(x116)))+(((-0.484322104837852)*(px)*(x116))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x117=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((2.06474160483506)*(px)*(x117)))+(((0.450000000000000)*(x117))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x118=x8;
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((-0.217944947177033)+(px));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x118;
evalcond[5]=((0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[6]=x118;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x119=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((1.11111111111111)*(x119)*((px)*(px))))+(((1.11111111111111)*(py)))+(((-0.0527777777777776)*(x119))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x120=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.484322104837852)*(px)*(x120)))+(((-0.105555555555555)*(x120))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x121=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.450000000000000)*(x121)))+(((-2.06474160483506)*(px)*(x121))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x122=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.0527777777777776)*(x122)))+(((1.11111111111111)*(py)))+(((1.11111111111111)*(x122)*((px)*(px)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x123=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.450000000000000)*(x123)))+(((0.500000000000000)*(cj3)*(x123))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((py)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x124=x10;
IKReal x125=((x124)+(((-1.00000000000000)*(px))));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x125;
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x125;
evalcond[4]=x125;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[8];
IKReal x126=((0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x126;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=py;
evalcond[5]=x126;
evalcond[6]=((-1.00000000000000)*(py));
evalcond[7]=x126;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x127=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.0527777777777776)*(x127)))+(((-1.11111111111111)*(py)))+(((-1.11111111111111)*(x127)*((px)*(px)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x128=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.484322104837852)*(px)*(x128)))+(((0.105555555555555)*(x128))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x129=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.450000000000000)*(x129)))+(((2.06474160483506)*(px)*(x129))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x130=((-0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x130;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=py;
evalcond[5]=x130;
evalcond[6]=((-1.00000000000000)*(py));
evalcond[7]=x130;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x131=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(py)))+(((0.0527777777777776)*(x131)))+(((-1.11111111111111)*(x131)*((px)*(px)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x132=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.484322104837852)*(px)*(x132)))+(((0.105555555555555)*(x132))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x133=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-2.06474160483506)*(px)*(x133)))+(((-0.450000000000000)*(x133))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x134=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(x134)*((px)*(px))))+(((-1.11111111111111)*(py)))+(((0.0527777777777776)*(x134))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x135=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.450000000000000)*(x135)))+(((-0.500000000000000)*(cj3)*(x135))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.00000000000000)*(py)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x136=((0.500000000000000)*(cj3)*(sj0));
IKReal x137=((0.450000000000000)*(sj0));
IKReal x138=((x137)+(x136));
IKReal x139=((IKabs(x138) != 0)?((IKReal)1/(x138)):(IKReal)1.0e30);
sj1array[0]=((((py)*(x139)))+(((-0.500000000000000)*(cj0)*(sj3)*(x139))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x140=((0.450000000000000)*(cj0));
IKReal x141=((0.500000000000000)*(cj0)*(cj3));
IKReal x142=((x140)+(x141));
IKReal x143=((IKabs(x142) != 0)?((IKReal)1/(x142)):(IKReal)1.0e30);
sj1array[0]=((((0.500000000000000)*(sj0)*(sj3)*(x143)))+(((px)*(x143))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x144=((0.500000000000000)*(cj3));
IKReal x145=((0.450000000000000)+(x144));
IKReal x146=((IKabs(x145) != 0)?((IKReal)1/(x145)):(IKReal)1.0e30);
sj1array[0]=((((cj0)*(px)*(x146)))+(((py)*(sj0)*(x146))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x147=((0.500000000000000)*(sj3));
IKReal x148=((cj0)*(py));
IKReal x149=((x147)+(x148));
IKReal x150=((px)*(sj0));
evalcond[0]=((IKabs(pz))+(IKabs(((IKfmod(((((1.50000000000000)*(3.14159265358979)))+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979)))))));
evalcond[1]=((((-1.00000000000000)*(x149)))+(x150));
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((((-1.00000000000000)*(x150)))+(x149));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.450000000000000)*(cj0)))+(((0.500000000000000)*(cj0)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.500000000000000)*(cj3)*(sj0)))+(((0.450000000000000)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[8];
IKReal x151=x148;
IKReal x152=x150;
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((-0.217944947177033)+(((-1.00000000000000)*(x151)))+(x152));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=((((-1.00000000000000)*(py)*(sj0)))+(((-1.00000000000000)*(cj0)*(px))));
evalcond[5]=((((0.217944947177033)*(sj0)))+(((-1.00000000000000)*(px))));
evalcond[6]=((((-0.217944947177033)*(cj0)))+(((-1.00000000000000)*(py))));
evalcond[7]=((0.217944947177033)+(((-1.00000000000000)*(x152)))+(x151));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(cj0)*(px)))+(((0.900000000000000)*(py)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.435889894354067)*(py)*(sj0)))+(((0.435889894354067)*(cj0)*(px))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(py)*(sj0)))+(((0.900000000000000)*(cj0)*(px))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x153=((0.900000000000000)*(py)*(sj0));
IKReal x154=((0.900000000000000)*(cj0)*(px));
IKReal x155=((x154)+(x153));
IKReal x156=((IKabs(x155) != 0)?((IKReal)1/(x155)):(IKReal)1.0e30);
sj1array[0]=((((0.435889894354067)*(px)*(sj0)*(x156)))+(((-0.435889894354067)*(cj0)*(py)*(x156)))+(((-0.0949999999999998)*(x156))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x157=((0.435889894354067)*(py)*(sj0));
IKReal x158=((0.435889894354067)*(cj0)*(px));
IKReal x159=((x157)+(x158));
IKReal x160=((IKabs(x159) != 0)?((IKReal)1/(x159)):(IKReal)1.0e30);
sj1array[0]=((((-0.900000000000000)*(px)*(sj0)*(x160)))+(((0.900000000000000)*(cj0)*(py)*(x160)))+(((0.196150452459330)*(x160))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x161=((0.900000000000000)*(cj0)*(px));
IKReal x162=((0.900000000000000)*(py)*(sj0));
IKReal x163=((x162)+(x161));
IKReal x164=((IKabs(x163) != 0)?((IKReal)1/(x163)):(IKReal)1.0e30);
sj1array[0]=((((x164)*((py)*(py))))+(((x164)*((px)*(px))))+(((-0.0474999999999999)*(x164))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x165=x148;
IKReal x166=x150;
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((0.217944947177033)+(((-1.00000000000000)*(x165)))+(x166));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=((((-1.00000000000000)*(py)*(sj0)))+(((-1.00000000000000)*(cj0)*(px))));
evalcond[5]=((((-0.217944947177033)*(sj0)))+(((-1.00000000000000)*(px))));
evalcond[6]=((((0.217944947177033)*(cj0)))+(((-1.00000000000000)*(py))));
evalcond[7]=((-0.217944947177033)+(((-1.00000000000000)*(x166)))+(x165));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(cj0)*(px)))+(((0.900000000000000)*(py)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((-0.435889894354067)*(cj0)*(px)))+(((-0.435889894354067)*(py)*(sj0))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((0.900000000000000)*(py)*(sj0)))+(((0.900000000000000)*(cj0)*(px))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x167=((0.900000000000000)*(py)*(sj0));
IKReal x168=((0.900000000000000)*(cj0)*(px));
IKReal x169=((x168)+(x167));
IKReal x170=((IKabs(x169) != 0)?((IKReal)1/(x169)):(IKReal)1.0e30);
sj1array[0]=((((0.435889894354067)*(cj0)*(py)*(x170)))+(((-0.435889894354067)*(px)*(sj0)*(x170)))+(((-0.0949999999999998)*(x170))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x171=((0.435889894354067)*(py)*(sj0));
IKReal x172=((0.435889894354067)*(cj0)*(px));
IKReal x173=((x171)+(x172));
IKReal x174=((-1.00000000000000)*(x173));
IKReal x175=((IKabs(x174) != 0)?((IKReal)1/(x174)):(IKReal)1.0e30);
sj1array[0]=((((-0.900000000000000)*(px)*(sj0)*(x175)))+(((0.900000000000000)*(cj0)*(py)*(x175)))+(((-0.196150452459330)*(x175))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x176=((0.900000000000000)*(cj0)*(px));
IKReal x177=((0.900000000000000)*(py)*(sj0));
IKReal x178=((x177)+(x176));
IKReal x179=((IKabs(x178) != 0)?((IKReal)1/(x178)):(IKReal)1.0e30);
sj1array[0]=((((x179)*((px)*(px))))+(((x179)*((py)*(py))))+(((-0.0474999999999999)*(x179))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x180=x147;
IKReal x181=((x180)+(py));
IKReal x182=((-1.00000000000000)*(x181));
evalcond[0]=((IKfmod(((3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x182;
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x182;
evalcond[4]=x181;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[8];
IKReal x183=((-1.00000000000000)*(px));
IKReal x184=((-0.217944947177033)+(((-1.00000000000000)*(py))));
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x184;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x183;
evalcond[5]=x183;
evalcond[6]=x184;
evalcond[7]=((0.217944947177033)+(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x185=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((1.11111111111111)*(x185)*((py)*(py))))+(((-0.0527777777777776)*(x185)))+(((1.11111111111111)*(px))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x186=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.484322104837852)*(py)*(x186)))+(((-0.105555555555555)*(x186))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x187=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((2.06474160483506)*(py)*(x187)))+(((0.450000000000000)*(x187))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x188=((-1.00000000000000)*(px));
IKReal x189=((0.217944947177033)+(((-1.00000000000000)*(py))));
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x189;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x188;
evalcond[5]=x188;
evalcond[6]=x189;
evalcond[7]=((-0.217944947177033)+(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x190=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.0527777777777776)*(x190)))+(((1.11111111111111)*(x190)*((py)*(py))))+(((1.11111111111111)*(px))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x191=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.484322104837852)*(py)*(x191)))+(((-0.105555555555555)*(x191))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x192=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.450000000000000)*(x192)))+(((-2.06474160483506)*(py)*(x192))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x193=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.0527777777777776)*(x193)))+(((1.11111111111111)*(x193)*((py)*(py))))+(((1.11111111111111)*(px))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x194=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.450000000000000)*(x194)))+(((0.500000000000000)*(cj3)*(x194))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((px)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x195=x147;
IKReal x196=((x195)+(((-1.00000000000000)*(py))));
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(x195)))+(py));
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x196;
evalcond[4]=x196;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[7];
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((-0.217944947177033)+(py));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=px;
evalcond[5]=((-1.00000000000000)*(px));
evalcond[6]=((0.217944947177033)+(((-1.00000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x197=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(x197)*((py)*(py))))+(((-1.11111111111111)*(px)))+(((0.0527777777777776)*(x197))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x198=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.484322104837852)*(py)*(x198)))+(((0.105555555555555)*(x198))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x199=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.450000000000000)*(x199)))+(((2.06474160483506)*(py)*(x199))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((0.217944947177033)+(py));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=px;
evalcond[5]=((-1.00000000000000)*(px));
evalcond[6]=((-0.217944947177033)+(((-1.00000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=px;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x200=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(x200)*((py)*(py))))+(((-1.11111111111111)*(px)))+(((0.0527777777777776)*(x200))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x201=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((0.484322104837852)*(py)*(x201)))+(((0.105555555555555)*(x201))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x202=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-2.06474160483506)*(py)*(x202)))+(((-0.450000000000000)*(x202))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x203=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(x203)*((py)*(py))))+(((-1.11111111111111)*(px)))+(((0.0527777777777776)*(x203))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x204=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
sj1array[0]=((((-0.450000000000000)*(x204)))+(((-0.500000000000000)*(cj3)*(x204))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.00000000000000)*(px)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x205=x147;
IKReal x206=((x205)+(((-1.00000000000000)*(px))));
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(x205)))+(px));
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x206;
evalcond[4]=x206;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[7];
IKReal x207=x8;
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((-0.217944947177033)+(px));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x207;
evalcond[5]=((0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[6]=x207;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x208=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.0527777777777776)*(x208)))+(((1.11111111111111)*(x208)*((px)*(px))))+(((1.11111111111111)*(py))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x209=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.484322104837852)*(px)*(x209)))+(((-0.105555555555555)*(x209))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x210=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.450000000000000)*(x210)))+(((-2.06474160483506)*(px)*(x210))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x211=x8;
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((0.217944947177033)+(px));
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=x211;
evalcond[5]=((-0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[6]=x211;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x212=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((1.11111111111111)*(x212)*((px)*(px))))+(((1.11111111111111)*(py)))+(((-0.0527777777777776)*(x212))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x213=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.484322104837852)*(px)*(x213)))+(((-0.105555555555555)*(x213))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x214=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((2.06474160483506)*(px)*(x214)))+(((0.450000000000000)*(x214))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x215=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((1.11111111111111)*(x215)*((px)*(px))))+(((1.11111111111111)*(py)))+(((-0.0527777777777776)*(x215))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x216=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.500000000000000)*(cj3)*(x216)))+(((0.450000000000000)*(x216))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((py)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x217=x147;
IKReal x218=((x217)+(px));
IKReal x219=((-1.00000000000000)*(x218));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x219;
evalcond[2]=((0.452500000000000)+(((0.450000000000000)*(cj3)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x219;
evalcond[4]=x218;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((0.450000000000000)+(((0.500000000000000)*(cj3))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal evalcond[8];
IKReal x220=((-0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[0]=((IKfmod(((-2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x220;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=py;
evalcond[5]=x220;
evalcond[6]=((-1.00000000000000)*(py));
evalcond[7]=((0.217944947177033)+(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x221=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(py)))+(((0.0527777777777776)*(x221)))+(((-1.11111111111111)*(x221)*((px)*(px)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x222=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((0.105555555555555)*(x222)))+(((0.484322104837852)*(px)*(x222))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x223=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.450000000000000)*(x223)))+(((-2.06474160483506)*(px)*(x223))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x224=((0.217944947177033)+(((-1.00000000000000)*(px))));
evalcond[0]=((IKfmod(((2.69056584179353)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x224;
evalcond[2]=((0.0474999999999999)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=0;
evalcond[4]=py;
evalcond[5]=x224;
evalcond[6]=((-1.00000000000000)*(py));
evalcond[7]=((-0.217944947177033)+(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  && IKabs(evalcond[6]) < 0.000010  && IKabs(evalcond[7]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[1];
dummyeval[0]=py;
if( IKabs(dummyeval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x225=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(x225)*((px)*(px))))+(((-1.11111111111111)*(py)))+(((0.0527777777777776)*(x225))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x226=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.484322104837852)*(px)*(x226)))+(((0.105555555555555)*(x226))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x227=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.450000000000000)*(x227)))+(((2.06474160483506)*(px)*(x227))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x228=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-1.11111111111111)*(py)))+(((0.0527777777777776)*(x228)))+(((-1.11111111111111)*(x228)*((px)*(px)))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x229=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
sj1array[0]=((((-0.500000000000000)*(cj3)*(x229)))+(((-0.450000000000000)*(x229))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.00000000000000)*(py)*(((IKabs(((0.450000000000000)+(((0.500000000000000)*(cj3))))) != 0)?((IKReal)1/(((0.450000000000000)+(((0.500000000000000)*(cj3)))))):(IKReal)1.0e30)));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}
}
}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x230=((0.500000000000000)*(cj3)*(sj0));
IKReal x231=((0.450000000000000)*(sj0));
IKReal x232=((x230)+(x231));
IKReal x233=((IKabs(x232) != 0)?((IKReal)1/(x232)):(IKReal)1.0e30);
sj1array[0]=((((py)*(x233)))+(((0.500000000000000)*(cj0)*(sj3)*(x233))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x234=((0.450000000000000)*(cj0));
IKReal x235=((0.500000000000000)*(cj0)*(cj3));
IKReal x236=((x234)+(x235));
IKReal x237=((IKabs(x236) != 0)?((IKReal)1/(x236)):(IKReal)1.0e30);
sj1array[0]=((((px)*(x237)))+(((-0.500000000000000)*(sj0)*(sj3)*(x237))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
IKReal x238=((0.500000000000000)*(cj3));
IKReal x239=((0.450000000000000)+(x238));
IKReal x240=((IKabs(x239) != 0)?((IKReal)1/(x239)):(IKReal)1.0e30);
sj1array[0]=((((py)*(sj0)*(x240)))+(((cj0)*(px)*(x240))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKabs(((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))))))+(IKabs(pz)));
evalcond[1]=((((-1.00000000000000)*(cj0)*(py)))+(((px)*(sj0))));
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj0;
dummyeval[1]=((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))));
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=sj0;
dummyeval[1]=((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))));
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
IKReal x241=x8;
evalcond[0]=((IKfmod(((3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x241;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x241;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=px;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[6];
IKReal x242=x8;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x242;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x242;
evalcond[4]=x242;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x243=x8;
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x243;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x243;
evalcond[4]=py;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x244=x8;
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x244;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x244;
evalcond[4]=x244;
evalcond[5]=x244;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x245=x8;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x245;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x245;
evalcond[4]=py;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x246=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
j1array[0]=IKatan2(((0.950000000000000)*(x246)), ((cj2)*(py)*(x246)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((1.05263157894737)*(px)), ((-1.00000000000000)*(py)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((1.05263157894737)*(px)), ((cj2)*(py)*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=px;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=py;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=py;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x247=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
j1array[0]=IKatan2(((-0.950000000000000)*(x247)), ((cj2)*(py)*(x247)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-1.05263157894737)*(px)), ((-1.00000000000000)*(py)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-1.05263157894737)*(px)), ((cj2)*(py)*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x248=((px)*(sj0));
IKReal x249=((cj0)*(py));
IKReal x250=((x248)+(((-1.00000000000000)*(x249))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x250;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x250;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((((1.05263157894737)*(py)*(sj0)))+(((1.05263157894737)*(cj0)*(px))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x251=((cj0)*(py));
IKReal x252=((px)*(sj0));
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((x252)+(((-1.00000000000000)*(x251))));
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((x251)+(((-1.00000000000000)*(x252))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((((1.05263157894737)*(py)*(sj0)))+(((1.05263157894737)*(cj0)*(px))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=px;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=py;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=cj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=px;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=px;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x253=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
j1array[0]=IKatan2(((0.950000000000000)*(x253)), ((px)*(sj2)*(x253)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((1.05263157894737)*(py)), ((-1.00000000000000)*(cj2)*(px)*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((1.05263157894737)*(py)), ((px)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x254=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x254;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x254;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=py;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=cj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[6];
IKReal x255=x254;
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x255;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x255;
evalcond[4]=x255;
evalcond[5]=x255;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x256=x254;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x256;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x256;
evalcond[4]=px;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x257=x254;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x257;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x257;
evalcond[4]=x257;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x258=x254;
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x258;
evalcond[2]=((0.902500000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x258;
evalcond[4]=px;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-1.05263157894737)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x259=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
j1array[0]=IKatan2(((-0.950000000000000)*(x259)), ((px)*(sj2)*(x259)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-1.05263157894737)*(py)), ((-1.00000000000000)*(cj2)*(px)*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-1.05263157894737)*(py)), ((px)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((1.05263157894737)*(py)*(((IKabs(sj0) != 0)?((IKReal)1/(sj0)):(IKReal)1.0e30))), ((((IKabs(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))))) != 0)?((IKReal)1/(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2)))))):(IKReal)1.0e30))*(((((-1.00000000000000)*(cj2)*(px)*(sj0)))+(((cj0)*(cj2)*(py)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((1.05263157894737)*(px)*(((IKabs(cj0) != 0)?((IKReal)1/(cj0)):(IKReal)1.0e30))), ((((IKabs(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))))) != 0)?((IKReal)1/(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2)))))):(IKReal)1.0e30))*(((((-1.00000000000000)*(cj2)*(px)*(sj0)))+(((cj0)*(cj2)*(py)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((((1.05263157894737)*(py)*(sj0)))+(((1.05263157894737)*(cj0)*(px)))), ((((IKabs(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))))) != 0)?((IKReal)1/(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2)))))):(IKReal)1.0e30))*(((((-1.00000000000000)*(cj2)*(px)*(sj0)))+(((cj0)*(cj2)*(py)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKabs(((IKfmod(j3, ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))))))+(IKabs(pz)));
evalcond[1]=((((-1.00000000000000)*(cj0)*(py)))+(((px)*(sj0))));
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal dummyeval[1];
dummyeval[0]=((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))));
if( IKabs(dummyeval[0]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj0;
dummyeval[1]=((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))));
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=sj0;
dummyeval[1]=((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))));
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
IKReal x260=x8;
evalcond[0]=((IKfmod(((3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x260;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x260;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=px;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[6];
IKReal x261=x8;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x261;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x261;
evalcond[4]=x261;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x262=x8;
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x262;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x262;
evalcond[4]=py;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x263=x8;
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x263;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x263;
evalcond[4]=x263;
evalcond[5]=py;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x264=x8;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x264;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x264;
evalcond[4]=py;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x265=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
j1array[0]=IKatan2(((-0.0499999999999999)*(x265)), ((cj2)*(py)*(x265)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-20.0000000000000)*(px)), ((-1.00000000000000)*(py)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-20.0000000000000)*(px)), ((cj2)*(py)*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=px;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=px;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=py;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=py;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(px));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x266=((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30);
j1array[0]=IKatan2(((0.0499999999999999)*(x266)), ((cj2)*(py)*(x266)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((20.0000000000000)*(px)), ((-1.00000000000000)*(py)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((20.0000000000000)*(px)), ((cj2)*(py)*(((IKabs(px) != 0)?((IKReal)1/(px)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x267=((px)*(sj0));
IKReal x268=((cj0)*(py));
IKReal x269=((x267)+(((-1.00000000000000)*(x268))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x269;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x269;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((((-20.0000000000000)*(cj0)*(px)))+(((-20.0000000000000)*(py)*(sj0))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x270=((cj0)*(py));
IKReal x271=((px)*(sj0));
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((x271)+(((-1.00000000000000)*(x270))));
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((x270)+(((-1.00000000000000)*(x271))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((((-20.0000000000000)*(cj0)*(px)))+(((-20.0000000000000)*(py)*(sj0))));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=px;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=py;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=cj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=px;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=px;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((-20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x272=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
j1array[0]=IKatan2(((-0.0499999999999999)*(x272)), ((px)*(sj2)*(x272)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-20.0000000000000)*(py)), ((-1.00000000000000)*(cj2)*(px)*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-20.0000000000000)*(py)), ((px)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x273=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j0)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x273;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x273;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal dummyeval[2];
dummyeval[0]=cj2;
dummyeval[1]=py;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=sj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal dummyeval[2];
dummyeval[0]=py;
dummyeval[1]=cj2;
if( IKabs(dummyeval[0]) < 0.000001  || IKabs(dummyeval[1]) < 0.000001  )
{
{
IKReal evalcond[6];
IKReal x274=x273;
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x274;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x274;
evalcond[4]=x274;
evalcond[5]=px;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  && IKabs(evalcond[5]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x275=x273;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x275;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x275;
evalcond[4]=px;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x276=x273;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x276;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x276;
evalcond[4]=x276;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x277=x273;
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x277;
evalcond[2]=((0.00250000000000000)+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py)))));
evalcond[3]=x277;
evalcond[4]=px;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
sj1array[0]=((20.0000000000000)*(py));
if( sj1array[0] >= -1.0001 && sj1array[0] <= 1.0001 )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKasin(sj1array[0]);
    cj1array[0] = IKcos(j1array[0]);
    sj1array[1] = sj1array[0];
    j1array[1] = j1array[0] > 0 ? (IKPI-j1array[0]) : (-IKPI-j1array[0]);
    cj1array[1] = -cj1array[0];
}
else if( isnan(sj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
if( j1valid[0] && j1valid[1] && IKabs(cj1array[0]-cj1array[1]) < 0.0001 && IKabs(sj1array[0]-sj1array[1]) < 0.0001 )
    j1valid[1]=false;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x278=((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30);
j1array[0]=IKatan2(((0.0499999999999999)*(x278)), ((px)*(sj2)*(x278)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((20.0000000000000)*(py)), ((-1.00000000000000)*(cj2)*(px)*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((20.0000000000000)*(py)), ((px)*(sj2)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((IKabs(py) != 0)?((IKReal)1/(py)):(IKReal)1.0e30))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-20.0000000000000)*(py)*(((IKabs(sj0) != 0)?((IKReal)1/(sj0)):(IKReal)1.0e30))), ((((IKabs(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))))) != 0)?((IKReal)1/(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2)))))):(IKReal)1.0e30))*(((((-1.00000000000000)*(cj2)*(px)*(sj0)))+(((cj0)*(cj2)*(py)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((-20.0000000000000)*(px)*(((IKabs(cj0) != 0)?((IKReal)1/(cj0)):(IKReal)1.0e30))), ((((IKabs(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))))) != 0)?((IKReal)1/(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2)))))):(IKReal)1.0e30))*(((((-1.00000000000000)*(cj2)*(px)*(sj0)))+(((cj0)*(cj2)*(py)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
j1array[0]=IKatan2(((((-20.0000000000000)*(cj0)*(px)))+(((-20.0000000000000)*(py)*(sj0)))), ((((IKabs(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2))))) != 0)?((IKReal)1/(((((cj0)*(px)*(sj2)))+(((py)*(sj0)*(sj2)))))):(IKReal)1.0e30))*(((((-1.00000000000000)*(cj2)*(px)*(sj0)))+(((cj0)*(cj2)*(py)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x279=((0.500000000000000)*(cj3)*(py)*(sj0));
IKReal x280=((0.500000000000000)*(cj0)*(cj3)*(px));
IKReal x281=((0.450000000000000)*(cj0)*(px));
IKReal x282=((0.450000000000000)*(py)*(sj0));
IKReal x283=((0.500000000000000)*(cj2)*(pz)*(sj3));
IKReal x284=((x279)+(x283)+(x282)+(x281)+(x280));
IKReal x285=((IKabs(x284) != 0)?((IKReal)1/(x284)):(IKReal)1.0e30);
IKReal x286=((0.500000000000000)*(cj3));
IKReal x287=((0.450000000000000)+(x286));
j1array[0]=IKatan2(((x285)*(((((-1.00000000000000)*((pz)*(pz))))+((x287)*(x287))))), ((x285)*(((((-1.00000000000000)*(pz)*(((((-1.00000000000000)*(py)*(sj0)))+(((-1.00000000000000)*(cj0)*(px)))))))+(((0.500000000000000)*(cj2)*(sj3)*(x287)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x288=(cj3)*(cj3);
IKReal x289=((0.250000000000000)*(x288));
IKReal x290=(cj2)*(cj2);
IKReal x291=(sj3)*(sj3);
IKReal x292=((0.250000000000000)*(x290)*(x291));
IKReal x293=((0.450000000000000)*(cj3));
IKReal x294=((0.202500000000000)+(x292)+(x293)+(x289));
IKReal x295=((IKabs(x294) != 0)?((IKReal)1/(x294)):(IKReal)1.0e30);
IKReal x296=((cj0)*(px));
IKReal x297=((py)*(sj0));
IKReal x298=((x296)+(x297));
IKReal x299=((-1.00000000000000)*(x298));
IKReal x300=((0.500000000000000)*(cj3));
IKReal x301=((0.450000000000000)+(x300));
j1array[0]=IKatan2(((-1.00000000000000)*(x295)*(((((x299)*(x301)))+(((0.500000000000000)*(cj2)*(pz)*(sj3)))))), ((-1.00000000000000)*(x295)*(((((0.500000000000000)*(cj2)*(sj3)*(x299)))+(((-1.00000000000000)*(pz)*(x301)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
IKReal x302=((0.500000000000000)*(cj0)*(cj2)*(px)*(sj3));
IKReal x303=((0.500000000000000)*(cj2)*(py)*(sj0)*(sj3));
IKReal x304=((x302)+(x303));
IKReal x305=((0.450000000000000)*(pz));
IKReal x306=((0.500000000000000)*(cj3)*(pz));
IKReal x307=((x306)+(x305));
IKReal x308=((x304)+(((-1.00000000000000)*(x307))));
IKReal x309=((IKabs(x308) != 0)?((IKReal)1/(x308)):(IKReal)1.0e30);
j1array[0]=IKatan2(((x309)*(((((pz)*(((((-1.00000000000000)*(py)*(sj0)))+(((-1.00000000000000)*(cj0)*(px)))))))+(((0.500000000000000)*(cj2)*(sj3)*(((0.450000000000000)+(((0.500000000000000)*(cj3)))))))))), ((x309)*(((((-1.00000000000000)*((pz)*(pz))))+(((0.250000000000000)*((cj2)*(cj2))*((sj3)*(sj3))))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
    j1array[0]-=IK2PI;
else if( j1array[0] < -IKPI )
    j1array[0]+=IK2PI;
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] ) { continue; }
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

rotationfunction0(vsolutions);
}
}

}

}
}
}
}
}

} else
{
}
}
}
return vsolutions.size()>0;
}
inline void rotationfunction0(std::vector<IKSolution>& vsolutions) {
IKReal x23=((cj1)*(sj3));
IKReal x24=((cj2)*(cj3)*(sj1));
IKReal x25=((x24)+(x23));
IKReal x26=((-1.00000000000000)*(x25));
IKReal x27=((cj0)*(cj1)*(cj2)*(cj3));
IKReal x28=((cj3)*(sj0)*(sj2));
IKReal x29=((cj0)*(sj1)*(sj3));
IKReal x30=((x28)+(x29));
IKReal x31=((((-1.00000000000000)*(x30)))+(x27));
IKReal x32=((cj0)*(cj3)*(sj2));
IKReal x33=((cj1)*(cj2)*(cj3)*(sj0));
IKReal x34=((x33)+(x32));
IKReal x35=((sj0)*(sj1)*(sj3));
IKReal x36=((((-1.00000000000000)*(x35)))+(x34));
IKReal x37=((cj0)*(cj2));
IKReal x38=((cj1)*(sj0)*(sj2));
IKReal x39=((((-1.00000000000000)*(x38)))+(x37));
IKReal x40=((cj2)*(sj0));
IKReal x41=((cj0)*(cj1)*(sj2));
IKReal x42=((x40)+(x41));
IKReal x43=((-1.00000000000000)*(x42));
IKReal x44=((cj1)*(cj3));
IKReal x45=((cj2)*(sj1)*(sj3));
IKReal x46=((((-1.00000000000000)*(x45)))+(x44));
IKReal x47=((cj0)*(cj3)*(sj1));
IKReal x48=((x23)*(x37));
IKReal x49=((x48)+(x47));
IKReal x50=((sj0)*(sj2)*(sj3));
IKReal x51=((x49)+(((-1.00000000000000)*(x50))));
IKReal x52=((x23)*(x40));
IKReal x53=((cj3)*(sj0)*(sj1));
IKReal x54=((cj0)*(sj2)*(sj3));
IKReal x55=((x54)+(x53)+(x52));
new_r00=((((r00)*(x31)))+(((r10)*(x36)))+(((r20)*(x26))));
new_r01=((((r01)*(x31)))+(((r21)*(x26)))+(((r11)*(x36))));
new_r02=((((r22)*(x26)))+(((r02)*(x31)))+(((r12)*(x36))));
new_r10=((((r00)*(x43)))+(((r10)*(x39)))+(((r20)*(sj1)*(sj2))));
new_r11=((((r01)*(x43)))+(((r21)*(sj1)*(sj2)))+(((r11)*(x39))));
new_r12=((((r02)*(x43)))+(((r22)*(sj1)*(sj2)))+(((r12)*(x39))));
new_r20=((((r20)*(x46)))+(((r10)*(x55)))+(((r00)*(x51))));
new_r21=((((r11)*(x55)))+(((r01)*(x51)))+(((r21)*(x46))));
new_r22=((((r02)*(x51)))+(((r22)*(x46)))+(((r12)*(x55))));
{
IKReal j5eval;
j5eval=new_r22;
if( j5eval >= -1.000010 && j5eval <= -0.999990 )
{
{
j5 = 3.141593; sj5 = 0.000000; cj5 = -1.000000;
IKReal j4mul = 1;
j4=0;
IKReal j6mul=1.00000000000000;
j6=((-1.00000000000000)*(IKatan2(((-1.00000000000000)*(new_r10)), new_r11)));
vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(7);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[4].fmul = j4mul;
solution.basesol[4].freeind = 0;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[6].fmul = j6mul;
solution.basesol[6].freeind = 0;
solution.vfree.resize(1);
solution.vfree[0] = 4;
}

} else
if( j5eval >= 0.999990 && j5eval <= 1.000010 )
{
{
j5 = 0.000000; sj5 = 0.000000; cj5 = 1.000000;
IKReal j4mul = 1;
j4=0;
IKReal j6mul=-1.00000000000000;
j6=((((-1.00000000000000)*(IKatan2(new_r10, ((-1.00000000000000)*(new_r11))))))+(((-1.00000000000000)*(3.14159265358979))));
vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(7);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[4].fmul = j4mul;
solution.basesol[4].freeind = 0;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[6].fmul = j6mul;
solution.basesol[6].freeind = 0;
solution.vfree.resize(1);
solution.vfree[0] = 4;
}

} else
{
{
IKReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
j4array[0]=IKatan2(new_r12, new_r02);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1] = j4array[0] > 0 ? j4array[0]-IKPI : j4array[0]+IKPI;
sj4array[1] = -sj4array[0];
cj4array[1] = -cj4array[0];
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
if( j4array[1] > IKPI )
    j4array[1]-=IK2PI;
else if( j4array[1] < -IKPI )
    j4array[1]+=IK2PI;
j4valid[1] = true;
if( j4valid[0] && j4valid[1] && IKabs(cj4array[0]-cj4array[1]) < 0.0001 && IKabs(sj4array[0]-sj4array[1]) < 0.0001 )
    j4valid[1]=false;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IKReal evalcond[1];
evalcond[0]=IKsin(j4);
if( IKabs(evalcond[0]) < 0.000010  )
{
{
IKReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
j5array[0]=IKatan2(((new_r02)*(((IKabs(IKcos(j4)) != 0)?((IKReal)1/(IKcos(j4))):(IKReal)1.0e30))), new_r22);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
    j5array[0]-=IK2PI;
else if( j5array[0] < -IKPI )
    j5array[0]+=IK2PI;
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] ) { continue; }
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IKReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
IKReal x56=IKcos(j4);
IKReal x57=((IKabs(x56) != 0)?((IKReal)1/(x56)):(IKReal)1.0e30);
j6array[0]=IKatan2(((new_r10)*(x57)), ((new_r11)*(x57)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
    j6array[0]-=IK2PI;
else if( j6array[0] < -IKPI )
    j6array[0]+=IK2PI;
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] ) { continue; }
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(7);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.vfree.resize(0);
}
}
}
}

} else
{
if( 1 )
{
{
IKReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
j5array[0]=IKatan2(((new_r12)*(((IKabs(sj4) != 0)?((IKReal)1/(sj4)):(IKReal)1.0e30))), new_r22);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
    j5array[0]-=IK2PI;
else if( j5array[0] < -IKPI )
    j5array[0]+=IK2PI;
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] ) { continue; }
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IKReal evalcond[1];
evalcond[0]=IKsin(j5);
if( IKabs(evalcond[0]) < 0.000010  )
{
{
IKReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
IKReal x58=IKcos(j4);
IKReal x59=IKcos(j5);
IKReal x60=((IKabs(x59) != 0)?((IKReal)1/(x59)):(IKReal)1.0e30);
IKReal x61=IKsin(j4);
j6array[0]=IKatan2(((((new_r10)*(x58)))+(((-1.00000000000000)*(new_r00)*(x61)))), ((((new_r00)*(x58)*(x60)))+(((new_r10)*(x60)*(x61)))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
    j6array[0]-=IK2PI;
else if( j6array[0] < -IKPI )
    j6array[0]+=IK2PI;
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] ) { continue; }
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(7);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.vfree.resize(0);
}
}

} else
{
if( 1 )
{
{
IKReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
IKReal x62=((IKabs(sj5) != 0)?((IKReal)1/(sj5)):(IKReal)1.0e30);
j6array[0]=IKatan2(((new_r21)*(x62)), ((-1.00000000000000)*(new_r20)*(x62)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
    j6array[0]-=IK2PI;
else if( j6array[0] < -IKPI )
    j6array[0]+=IK2PI;
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] ) { continue; }
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(7);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.vfree.resize(0);
}
}

} else
{
}
}
}
}
}

} else
{
}
}
}
}
}

}
}
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
IKSolver solver;
return solver.ik(eetrans,eerot,pfree,vsolutions);
}

IKFAST_API const char* getKinematicsHash() { return "197f863f13f8bc481b0d92a11d69c607"; }

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\n");
    }
    return 0;
}

#endif
