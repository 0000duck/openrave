/// autogenerated analytical inverse kinematics code from ikfast program
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// generated 2010-12-08 14:13:20.979767
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object:
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -shared -Wl,-soname,ik.so -o ik.so ik.cpp
#include <cmath>
#include <cassert>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                assert(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

inline float IKasin(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline float IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

IKFAST_API int getNumFreeParameters() { return 2; }
IKFAST_API int* getFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int getNumJoints() { return 8; }

IKFAST_API int getIKRealSize() { return sizeof(IKReal); }

IKFAST_API int getIKType() { return 1; }

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {
IKReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13;
x0=IKcos(j[4]);
x1=IKsin(j[5]);
x2=IKsin(j[7]);
x3=IKcos(j[1]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKsin(j[1]);
x7=IKsin(j[6]);
x8=IKsin(j[4]);
x9=IKcos(j[7]);
x10=IKcos(j[3]);
x11=IKcos(j[2]);
x12=IKcos(j[6]);
x13=IKcos(j[5]);
eerot[0]=((((-1.77635683940025e-15)*(x0)*(x13)*(x5)*(x6)*(x7)))+(((-1.00000000000000)*(x0)*(x10)*(x12)*(x13)*(x3)*(x4)*(x9)))+(((-1.77635683940025e-15)*(x10)*(x12)*(x3)*(x4)*(x8)))+(((-1.00000000000000)*(x0)*(x11)*(x3)*(x7)*(x9)))+(((x1)*(x12)*(x3)*(x4)*(x5)*(x9)))+(((-1.77635683940025e-15)*(x1)*(x10)*(x6)*(x7)))+(((x0)*(x1)*(x2)*(x5)*(x6)))+(((-1.77635683940025e-15)*(x11)*(x13)*(x3)*(x7)*(x8)))+(((-1.77635683940025e-15)*(x0)*(x10)*(x13)*(x3)*(x4)*(x7)))+(((x0)*(x1)*(x10)*(x2)*(x3)*(x4)))+(((1.77635683940025e-15)*(x1)*(x3)*(x4)*(x5)*(x7)))+(((x13)*(x2)*(x3)*(x4)*(x5)))+(((x10)*(x3)*(x4)*(x7)*(x8)*(x9)))+(((x5)*(x6)*(x7)*(x8)*(x9)))+(((-1.77635683940025e-15)*(x12)*(x5)*(x6)*(x8)))+(((-1.00000000000000)*(x11)*(x12)*(x13)*(x3)*(x8)*(x9)))+(((x1)*(x11)*(x2)*(x3)*(x8)))+(((1.77635683940025e-15)*(x0)*(x11)*(x12)*(x3)))+(((-1.00000000000000)*(x0)*(x12)*(x13)*(x5)*(x6)*(x9)))+(((-1.00000000000000)*(x1)*(x10)*(x12)*(x6)*(x9)))+(((-1.00000000000000)*(x10)*(x13)*(x2)*(x6))));
eerot[1]=((((-1.00000000000000)*(x1)*(x12)*(x2)*(x3)*(x4)*(x5)))+(((x11)*(x12)*(x13)*(x2)*(x3)*(x8)))+(((-1.00000000000000)*(x2)*(x5)*(x6)*(x7)*(x8)))+(((-1.00000000000000)*(x10)*(x2)*(x3)*(x4)*(x7)*(x8)))+(((x0)*(x12)*(x13)*(x2)*(x5)*(x6)))+(((x0)*(x1)*(x5)*(x6)*(x9)))+(((x13)*(x3)*(x4)*(x5)*(x9)))+(((x1)*(x11)*(x3)*(x8)*(x9)))+(((x0)*(x11)*(x2)*(x3)*(x7)))+(((-1.00000000000000)*(x10)*(x13)*(x6)*(x9)))+(((x1)*(x10)*(x12)*(x2)*(x6)))+(((x0)*(x1)*(x10)*(x3)*(x4)*(x9)))+(((x0)*(x10)*(x12)*(x13)*(x2)*(x3)*(x4))));
eerot[2]=((((-1.77635683940025e-15)*(x0)*(x1)*(x10)*(x2)*(x3)*(x4)))+(((-1.77635683940025e-15)*(x1)*(x12)*(x3)*(x4)*(x5)*(x9)))+(((-1.00000000000000)*(x0)*(x10)*(x13)*(x3)*(x4)*(x7)))+(((-1.00000000000000)*(x10)*(x12)*(x3)*(x4)*(x8)))+(((-1.00000000000000)*(x12)*(x5)*(x6)*(x8)))+(((-1.77635683940025e-15)*(x0)*(x1)*(x2)*(x5)*(x6)))+(((1.77635683940025e-15)*(x1)*(x10)*(x12)*(x6)*(x9)))+(((-1.77635683940025e-15)*(x10)*(x3)*(x4)*(x7)*(x8)*(x9)))+(((x0)*(x11)*(x12)*(x3)))+(((-1.77635683940025e-15)*(x5)*(x6)*(x7)*(x8)*(x9)))+(((-1.00000000000000)*(x0)*(x13)*(x5)*(x6)*(x7)))+(((-1.00000000000000)*(x1)*(x10)*(x6)*(x7)))+(((1.77635683940025e-15)*(x10)*(x13)*(x2)*(x6)))+(((1.77635683940025e-15)*(x0)*(x12)*(x13)*(x5)*(x6)*(x9)))+(((-1.00000000000000)*(x11)*(x13)*(x3)*(x7)*(x8)))+(((1.77635683940025e-15)*(x0)*(x11)*(x3)*(x7)*(x9)))+(((1.77635683940025e-15)*(x0)*(x10)*(x12)*(x13)*(x3)*(x4)*(x9)))+(((-1.77635683940025e-15)*(x1)*(x11)*(x2)*(x3)*(x8)))+(((1.77635683940025e-15)*(x11)*(x12)*(x13)*(x3)*(x8)*(x9)))+(((-1.77635683940025e-15)*(x13)*(x2)*(x3)*(x4)*(x5)))+(((x1)*(x3)*(x4)*(x5)*(x7))));
eetrans[0]=((-0.0500000000000000)+(((-0.321000000000000)*(x5)*(x6)*(x8)))+(((-0.180000000000000)*(x12)*(x5)*(x6)*(x8)))+(((-0.180000000000000)*(x0)*(x10)*(x13)*(x3)*(x4)*(x7)))+(((-0.180000000000000)*(x1)*(x10)*(x6)*(x7)))+(((0.180000000000000)*(x1)*(x3)*(x4)*(x5)*(x7)))+(((0.100000000000000)*(x3)))+(((-0.180000000000000)*(x0)*(x13)*(x5)*(x6)*(x7)))+(((-0.321000000000000)*(x10)*(x3)*(x4)*(x8)))+(((0.321000000000000)*(x0)*(x11)*(x3)))+(((0.180000000000000)*(x0)*(x11)*(x12)*(x3)))+(((-0.180000000000000)*(x11)*(x13)*(x3)*(x7)*(x8)))+(((-0.180000000000000)*(x10)*(x12)*(x3)*(x4)*(x8)))+(((0.400000000000000)*(x11)*(x3))));
eerot[3]=((((x1)*(x12)*(x4)*(x5)*(x6)*(x9)))+(((1.77635683940025e-15)*(x0)*(x13)*(x3)*(x5)*(x7)))+(((x1)*(x11)*(x2)*(x6)*(x8)))+(((1.77635683940025e-15)*(x12)*(x3)*(x5)*(x8)))+(((x0)*(x1)*(x10)*(x2)*(x4)*(x6)))+(((-1.77635683940025e-15)*(x0)*(x10)*(x13)*(x4)*(x6)*(x7)))+(((-1.00000000000000)*(x3)*(x5)*(x7)*(x8)*(x9)))+(((-1.77635683940025e-15)*(x10)*(x12)*(x4)*(x6)*(x8)))+(((1.77635683940025e-15)*(x1)*(x10)*(x3)*(x7)))+(((-1.00000000000000)*(x0)*(x1)*(x2)*(x3)*(x5)))+(((-1.77635683940025e-15)*(x11)*(x13)*(x6)*(x7)*(x8)))+(((-1.00000000000000)*(x11)*(x12)*(x13)*(x6)*(x8)*(x9)))+(((-1.00000000000000)*(x0)*(x10)*(x12)*(x13)*(x4)*(x6)*(x9)))+(((x1)*(x10)*(x12)*(x3)*(x9)))+(((1.77635683940025e-15)*(x1)*(x4)*(x5)*(x6)*(x7)))+(((x10)*(x4)*(x6)*(x7)*(x8)*(x9)))+(((-1.00000000000000)*(x0)*(x11)*(x6)*(x7)*(x9)))+(((1.77635683940025e-15)*(x0)*(x11)*(x12)*(x6)))+(((x10)*(x13)*(x2)*(x3)))+(((x0)*(x12)*(x13)*(x3)*(x5)*(x9)))+(((x13)*(x2)*(x4)*(x5)*(x6))));
eerot[4]=((((x0)*(x10)*(x12)*(x13)*(x2)*(x4)*(x6)))+(((x2)*(x3)*(x5)*(x7)*(x8)))+(((-1.00000000000000)*(x1)*(x12)*(x2)*(x4)*(x5)*(x6)))+(((-1.00000000000000)*(x1)*(x10)*(x12)*(x2)*(x3)))+(((x0)*(x1)*(x10)*(x4)*(x6)*(x9)))+(((x11)*(x12)*(x13)*(x2)*(x6)*(x8)))+(((-1.00000000000000)*(x0)*(x1)*(x3)*(x5)*(x9)))+(((x10)*(x13)*(x3)*(x9)))+(((-1.00000000000000)*(x10)*(x2)*(x4)*(x6)*(x7)*(x8)))+(((-1.00000000000000)*(x0)*(x12)*(x13)*(x2)*(x3)*(x5)))+(((x13)*(x4)*(x5)*(x6)*(x9)))+(((x0)*(x11)*(x2)*(x6)*(x7)))+(((x1)*(x11)*(x6)*(x8)*(x9))));
eerot[5]=((((-1.77635683940025e-15)*(x1)*(x12)*(x4)*(x5)*(x6)*(x9)))+(((-1.77635683940025e-15)*(x1)*(x11)*(x2)*(x6)*(x8)))+(((x1)*(x10)*(x3)*(x7)))+(((-1.77635683940025e-15)*(x0)*(x1)*(x10)*(x2)*(x4)*(x6)))+(((1.77635683940025e-15)*(x11)*(x12)*(x13)*(x6)*(x8)*(x9)))+(((-1.77635683940025e-15)*(x10)*(x4)*(x6)*(x7)*(x8)*(x9)))+(((x1)*(x4)*(x5)*(x6)*(x7)))+(((1.77635683940025e-15)*(x3)*(x5)*(x7)*(x8)*(x9)))+(((x0)*(x11)*(x12)*(x6)))+(((1.77635683940025e-15)*(x0)*(x1)*(x2)*(x3)*(x5)))+(((1.77635683940025e-15)*(x0)*(x11)*(x6)*(x7)*(x9)))+(((-1.00000000000000)*(x11)*(x13)*(x6)*(x7)*(x8)))+(((-1.77635683940025e-15)*(x1)*(x10)*(x12)*(x3)*(x9)))+(((x0)*(x13)*(x3)*(x5)*(x7)))+(((-1.00000000000000)*(x10)*(x12)*(x4)*(x6)*(x8)))+(((1.77635683940025e-15)*(x0)*(x10)*(x12)*(x13)*(x4)*(x6)*(x9)))+(((-1.00000000000000)*(x0)*(x10)*(x13)*(x4)*(x6)*(x7)))+(((-1.77635683940025e-15)*(x0)*(x12)*(x13)*(x3)*(x5)*(x9)))+(((-1.77635683940025e-15)*(x10)*(x13)*(x2)*(x3)))+(((-1.77635683940025e-15)*(x13)*(x2)*(x4)*(x5)*(x6)))+(((x12)*(x3)*(x5)*(x8))));
eetrans[1]=((-0.188000000000000)+(((-0.321000000000000)*(x10)*(x4)*(x6)*(x8)))+(((0.180000000000000)*(x12)*(x3)*(x5)*(x8)))+(((-0.180000000000000)*(x11)*(x13)*(x6)*(x7)*(x8)))+(((0.321000000000000)*(x3)*(x5)*(x8)))+(((0.180000000000000)*(x1)*(x10)*(x3)*(x7)))+(((0.180000000000000)*(x1)*(x4)*(x5)*(x6)*(x7)))+(((0.100000000000000)*(x6)))+(((0.321000000000000)*(x0)*(x11)*(x6)))+(((-0.180000000000000)*(x0)*(x10)*(x13)*(x4)*(x6)*(x7)))+(((0.180000000000000)*(x0)*(x11)*(x12)*(x6)))+(((-0.180000000000000)*(x10)*(x12)*(x4)*(x6)*(x8)))+(((0.400000000000000)*(x11)*(x6)))+(((0.180000000000000)*(x0)*(x13)*(x3)*(x5)*(x7))));
eerot[6]=((((1.77635683940025e-15)*(x13)*(x4)*(x7)*(x8)))+(((x10)*(x11)*(x7)*(x8)*(x9)))+(((-1.77635683940025e-15)*(x10)*(x11)*(x12)*(x8)))+(((-1.77635683940025e-15)*(x0)*(x12)*(x4)))+(((-1.00000000000000)*(x0)*(x10)*(x11)*(x12)*(x13)*(x9)))+(((x12)*(x13)*(x4)*(x8)*(x9)))+(((-1.77635683940025e-15)*(x0)*(x10)*(x11)*(x13)*(x7)))+(((x0)*(x1)*(x10)*(x11)*(x2)))+(((x0)*(x4)*(x7)*(x9)))+(((1.77635683940025e-15)*(x1)*(x11)*(x5)*(x7)))+(((x11)*(x13)*(x2)*(x5)))+(((-1.00000000000000)*(x1)*(x2)*(x4)*(x8)))+(((x1)*(x11)*(x12)*(x5)*(x9))));
eerot[7]=((((x11)*(x13)*(x5)*(x9)))+(((x0)*(x10)*(x11)*(x12)*(x13)*(x2)))+(((-1.00000000000000)*(x0)*(x2)*(x4)*(x7)))+(((-1.00000000000000)*(x1)*(x4)*(x8)*(x9)))+(((x0)*(x1)*(x10)*(x11)*(x9)))+(((-1.00000000000000)*(x12)*(x13)*(x2)*(x4)*(x8)))+(((-1.00000000000000)*(x10)*(x11)*(x2)*(x7)*(x8)))+(((-1.00000000000000)*(x1)*(x11)*(x12)*(x2)*(x5))));
eerot[8]=((((x1)*(x11)*(x5)*(x7)))+(((1.77635683940025e-15)*(x1)*(x2)*(x4)*(x8)))+(((-1.00000000000000)*(x0)*(x12)*(x4)))+(((-1.77635683940025e-15)*(x0)*(x1)*(x10)*(x11)*(x2)))+(((-1.00000000000000)*(x10)*(x11)*(x12)*(x8)))+(((x13)*(x4)*(x7)*(x8)))+(((-1.77635683940025e-15)*(x0)*(x4)*(x7)*(x9)))+(((-1.77635683940025e-15)*(x10)*(x11)*(x7)*(x8)*(x9)))+(((1.77635683940025e-15)*(x0)*(x10)*(x11)*(x12)*(x13)*(x9)))+(((-1.77635683940025e-15)*(x1)*(x11)*(x12)*(x5)*(x9)))+(((-1.77635683940025e-15)*(x11)*(x13)*(x2)*(x5)))+(((-1.77635683940025e-15)*(x12)*(x13)*(x4)*(x8)*(x9)))+(((-1.00000000000000)*(x0)*(x10)*(x11)*(x13)*(x7))));
eetrans[2]=((0.739680000000000)+(((0.180000000000000)*(x13)*(x4)*(x7)*(x8)))+(((-0.180000000000000)*(x0)*(x12)*(x4)))+(((-0.180000000000000)*(x0)*(x10)*(x11)*(x13)*(x7)))+(((0.180000000000000)*(x1)*(x11)*(x5)*(x7)))+(((-0.180000000000000)*(x10)*(x11)*(x12)*(x8)))+(((-0.321000000000000)*(x10)*(x11)*(x8)))+(((-0.321000000000000)*(x0)*(x4)))+(j[0])+(((-0.400000000000000)*(x4))));
}

class IKSolver {
public:
IKReal j1, cj1, sj1,
j2, cj2, sj2,
j4, cj4, sj4,
j5, cj5, sj5,
j6, cj6, sj6,
j7, cj7, sj7,
j0, cj0, sj0,
j3, cj3, sj3,
new_r00, r00,
new_r01, r01,
new_r02, r02,
new_r10, r10,
new_r11, r11,
new_r12, r12,
new_r20, r20,
new_r21, r21,
new_r22, r22,
new_px, new_py, new_pz, px, py, pz;

bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
vsolutions.resize(0); vsolutions.reserve(8);
j0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]);
j3=pfree[1]; cj3=cos(pfree[1]); sj3=sin(pfree[1]);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((((1.77635683940025e-15)*(r00)))+(((1.00000000000000)*(r02))));
new_r01=r01;
new_r02=((((1.77635683940025e-15)*(r02)))+(((-1.00000000000000)*(r00))));
new_px=((0.0500000000000000)+(((-0.180000000000000)*(r02)))+(px)+(((-3.19189119579733e-16)*(r00))));
new_r10=((((1.77635683940025e-15)*(r10)))+(((1.00000000000000)*(r12))));
new_r11=r11;
new_r12=((((1.77635683940025e-15)*(r12)))+(((-1.00000000000000)*(r10))));
new_py=((0.188000000000000)+(((-0.180000000000000)*(r12)))+(py)+(((-3.19189119579733e-16)*(r10))));
new_r20=((((1.00000000000000)*(r22)))+(((1.77635683940025e-15)*(r20))));
new_r21=r21;
new_r22=((((-1.00000000000000)*(r20)))+(((1.77635683940025e-15)*(r22))));
new_pz=((-0.739680000000000)+(((-0.180000000000000)*(r22)))+(pz)+(((-3.19189119579733e-16)*(r20))));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
{
if( 1 )
{
IKReal coniccoeffs[6], j1array[4];
int numsolutions;
IKReal x0=(px)*(px);
IKReal x1=(sj3)*(sj3);
IKReal x2=(py)*(py);
IKReal x3=(pz)*(pz);
IKReal x4=(j0)*(j0);
IKReal x5=((0.0164865600000000)*(x0));
coniccoeffs[0]=((x5)+(((-0.0164865600000000)*(x2)))+(((-0.00103041000000000)*(x0)*(x1)))+(((0.00103041000000000)*(x1)*(x2))));
coniccoeffs[1]=((((-0.00103041000000000)*(px)*(py)*(x1)))+(((0.0164865600000000)*(px)*(py))));
coniccoeffs[2]=((((0.00515205000000000)*(px)*(x1)*(x3)))+(((0.00515205000000000)*(px)*(x1)*(x2)))+(((0.00515205000000000)*(px)*(x1)*(x4)))+(((0.00515205000000000)*(px)*(x0)*(x1)))+(((-0.00130367988405000)*(px)*(x1)))+(((-0.0103041000000000)*(j0)*(px)*(pz)*(x1))));
coniccoeffs[3]=0;
coniccoeffs[4]=((((0.00515205000000000)*(py)*(x1)*(x2)))+(((0.00515205000000000)*(py)*(x1)*(x3)))+(((0.00515205000000000)*(py)*(x1)*(x4)))+(((0.00515205000000000)*(py)*(x0)*(x1)))+(((-0.0103041000000000)*(j0)*(py)*(pz)*(x1)))+(((-0.00130367988405000)*(py)*(x1))));
coniccoeffs[5]=((((-0.154561500000000)*(x1)*(x3)*(x4)))+(((-0.0257602500000000)*(x1)*((x4)*(x4))))+(((-0.0257602500000000)*(x1)*((x0)*(x0))))+(((-0.0515205000000000)*(x1)*(x2)*(x4)))+(((-0.0515205000000000)*(x1)*(x2)*(x3)))+(((-0.0257602500000000)*(x1)*((x2)*(x2))))+(((-0.0515205000000000)*(x0)*(x1)*(x3)))+(((-0.0515205000000000)*(x0)*(x1)*(x2)))+(((-0.0515205000000000)*(x0)*(x1)*(x4)))+(((-0.0257602500000000)*(x1)*((x3)*(x3))))+(((-1.00000000000000)*(x5)))+(((0.0130367988405000)*(x1)*(x3)))+(((0.0130367988405000)*(x1)*(x4)))+(((4.93693212605198e-5)*(x1)))+(((0.0130367988405000)*(x0)*(x1)))+(((0.103041000000000)*(j0)*(pz)*(x0)*(x1)))+(((-0.0260735976810000)*(j0)*(pz)*(x1)))+(((0.103041000000000)*(j0)*(pz)*(x1)*(x4)))+(((0.103041000000000)*(j0)*(pz)*(x1)*(x2)))+(((0.103041000000000)*(j0)*(pz)*(x1)*(x3)))+(((0.0120063888405000)*(x1)*(x2))));
conicsolver(coniccoeffs,j1array,numsolutions);
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
{
    j1 = j1array[ij1]; cj1 = IKcos(j1); sj1 = IKsin(j1);

{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((1.60000000000000)*(j0)*(pz)*(sj3)))+(((0.160000000000000)*(cj1)*(px)*(sj3)))+(((-0.800000000000000)*(sj3)*((pz)*(pz))))+(((-1.60000000000000)*(cj1)*(px)*(py)*(sj1)*(sj3)))+(((0.160000000000000)*(py)*(sj1)*(sj3)))+(((-0.00800000000000000)*(sj3)))+(((-0.800000000000000)*(sj3)*((cj1)*(cj1))*((px)*(px))))+(((-0.800000000000000)*(sj3)*((j0)*(j0))))+(((-0.800000000000000)*(sj3)*((py)*(py))*((sj1)*(sj1)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[3];
IKReal x6=((px)*(sj1));
IKReal x7=((cj1)*(py));
IKReal x8=((x6)+(((-1.00000000000000)*(x7))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x8;
evalcond[2]=x8;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
cj4array[0]=((-0.985362149532710)+(((-7.78816199376947)*(j0)*(pz)))+(((3.89408099688473)*((j0)*(j0))))+(((3.89408099688473)*((pz)*(pz))))+(((3.89408099688473)*((px)*(px))))+(((-0.778816199376947)*(py)*(sj1)))+(((3.89408099688473)*((py)*(py))))+(((-0.778816199376947)*(cj1)*(px))));
if( cj4array[0] >= -1.0001 && cj4array[0] <= 1.0001 )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
if( j4valid[0] && j4valid[1] && IKabs(cj4array[0]-cj4array[1]) < 0.0001 && IKabs(sj4array[0]-sj4array[1]) < 0.0001 )
    j4valid[1]=false;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.160000000000000)*(cj1)))+(((-0.256800000000000)*(cj1)*(cj4)))+(((-0.103041000000000)*(cj1)*((sj4)*(sj4))))+(((-0.103041000000000)*(cj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.103041000000000)*(sj1)*((sj4)*(sj4))))+(((-0.256800000000000)*(cj4)*(sj1)))+(((-0.160000000000000)*(sj1)))+(((-0.103041000000000)*(sj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x9=((-1.00000000000000)*(py));
evalcond[0]=((IKfmod(((3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x9;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(px)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x9;
evalcond[4]=x9;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(px)))+(((-0.321000000000000)*(cj4)*(px)))+(((-0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(px)*(sj4)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x10=((((-1.00000000000000)*(pz)))+(j0));
IKReal x11=((0.400000000000000)*(pz));
IKReal x12=((0.0321000000000000)*(sj4));
IKReal x13=((0.321000000000000)*(cj4)*(pz));
IKReal x14=((x11)+(x13)+(x12));
IKReal x15=((0.400000000000000)*(j0));
IKReal x16=((0.321000000000000)*(cj4)*(j0));
IKReal x17=((0.321000000000000)*(px)*(sj4));
IKReal x18=((x15)+(x17)+(x16));
IKReal x19=((((-1.00000000000000)*(x18)))+(x14));
IKReal x20=((IKabs(x19) != 0)?((IKReal)1/(x19)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x20)*(((((-1.00000000000000)*((x10)*(x10))))+(((0.103041000000000)*((sj4)*(sj4))))))), ((x20)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x10)*(((0.100000000000000)+(((-1.00000000000000)*(px)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x61=((0.100000000000000)+(((-1.00000000000000)*(px))));
IKReal x62=((0.321000000000000)*(j0)*(sj4));
IKReal x63=((0.0321000000000000)*(cj4));
IKReal x64=((0.0400000000000000)+(x62)+(x63));
IKReal x65=((0.400000000000000)*(px));
IKReal x66=((0.321000000000000)*(pz)*(sj4));
IKReal x67=((0.321000000000000)*(cj4)*(px));
IKReal x68=((x65)+(x66)+(x67));
IKReal x69=((x64)+(((-1.00000000000000)*(x68))));
IKReal x70=((IKabs(x69) != 0)?((IKReal)1/(x69)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x70)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x61)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x70)*(((((-1.00000000000000)*((x61)*(x61))))+(((0.103041000000000)*((sj4)*(sj4))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x71=((0.256800000000000)*(cj4));
IKReal x72=(sj4)*(sj4);
IKReal x73=((0.103041000000000)*(x72));
IKReal x74=(cj4)*(cj4);
IKReal x75=((0.103041000000000)*(x74));
IKReal x76=((0.160000000000000)+(x75)+(x73)+(x71));
IKReal x77=((IKabs(x76) != 0)?((IKReal)1/(x76)):(IKReal)1.0e30);
IKReal x78=((((-1.00000000000000)*(pz)))+(j0));
IKReal x79=((0.321000000000000)*(cj4));
IKReal x80=((0.400000000000000)+(x79));
IKReal x81=((0.100000000000000)+(((-1.00000000000000)*(px))));
j2array[0]=IKatan2(((-1.00000000000000)*(x77)*(((((-0.321000000000000)*(sj4)*(x81)))+(((-1.00000000000000)*(x78)*(x80)))))), ((-1.00000000000000)*(x77)*(((((x80)*(x81)))+(((-0.321000000000000)*(sj4)*(x78)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(px)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(pz)*(sj4)))+(((0.400000000000000)*(px)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(cj4)*(px)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz)))+(((0.321000000000000)*(px)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x82=((((-1.00000000000000)*(pz)))+(j0));
IKReal x83=((0.400000000000000)*(pz));
IKReal x84=((0.0321000000000000)*(sj4));
IKReal x85=((0.321000000000000)*(cj4)*(pz));
IKReal x86=((0.321000000000000)*(px)*(sj4));
IKReal x87=((x83)+(x86)+(x84)+(x85));
IKReal x88=((0.400000000000000)*(j0));
IKReal x89=((0.321000000000000)*(cj4)*(j0));
IKReal x90=((x88)+(x89));
IKReal x91=((x87)+(((-1.00000000000000)*(x90))));
IKReal x92=((IKabs(x91) != 0)?((IKReal)1/(x91)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x92)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x82)*(x82))))))), ((x92)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x82)*(((0.100000000000000)+(px)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x93=((0.100000000000000)+(px));
IKReal x94=((0.400000000000000)*(px));
IKReal x95=((0.321000000000000)*(j0)*(sj4));
IKReal x96=((0.321000000000000)*(cj4)*(px));
IKReal x97=((0.0321000000000000)*(cj4));
IKReal x98=((0.0400000000000000)+(x95)+(x94)+(x97)+(x96));
IKReal x99=((0.321000000000000)*(pz)*(sj4));
IKReal x100=((x98)+(((-1.00000000000000)*(x99))));
IKReal x101=((IKabs(x100) != 0)?((IKReal)1/(x100)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x101)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x93)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x101)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x93)*(x93))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x102=((0.256800000000000)*(cj4));
IKReal x103=(sj4)*(sj4);
IKReal x104=((0.103041000000000)*(x103));
IKReal x105=(cj4)*(cj4);
IKReal x106=((0.103041000000000)*(x105));
IKReal x107=((0.160000000000000)+(x104)+(x106)+(x102));
IKReal x108=((IKabs(x107) != 0)?((IKReal)1/(x107)):(IKReal)1.0e30);
IKReal x109=((((-1.00000000000000)*(pz)))+(j0));
IKReal x110=((0.100000000000000)+(px));
IKReal x111=((0.321000000000000)*(cj4));
IKReal x112=((0.400000000000000)+(x111));
j2array[0]=IKatan2(((-1.00000000000000)*(x108)*(((((-0.321000000000000)*(sj4)*(x110)))+(((-1.00000000000000)*(x109)*(x112)))))), ((-1.00000000000000)*(x108)*(((((-0.321000000000000)*(sj4)*(x109)))+(((x110)*(x112)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(py)))+(((-0.321000000000000)*(cj4)*(py)))+(((-0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(py)*(sj4)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x113=((((-1.00000000000000)*(pz)))+(j0));
IKReal x114=((0.400000000000000)*(pz));
IKReal x115=((0.0321000000000000)*(sj4));
IKReal x116=((0.321000000000000)*(cj4)*(pz));
IKReal x117=((x116)+(x115)+(x114));
IKReal x118=((0.400000000000000)*(j0));
IKReal x119=((0.321000000000000)*(py)*(sj4));
IKReal x120=((0.321000000000000)*(cj4)*(j0));
IKReal x121=((x120)+(x119)+(x118));
IKReal x122=((((-1.00000000000000)*(x121)))+(x117));
IKReal x123=((IKabs(x122) != 0)?((IKReal)1/(x122)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x123)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x113)*(x113))))))), ((x123)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x113)*(((0.100000000000000)+(((-1.00000000000000)*(py)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x124=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x125=((0.321000000000000)*(j0)*(sj4));
IKReal x126=((0.0321000000000000)*(cj4));
IKReal x127=((0.0400000000000000)+(x126)+(x125));
IKReal x128=((0.400000000000000)*(py));
IKReal x129=((0.321000000000000)*(pz)*(sj4));
IKReal x130=((0.321000000000000)*(cj4)*(py));
IKReal x131=((x130)+(x128)+(x129));
IKReal x132=((x127)+(((-1.00000000000000)*(x131))));
IKReal x133=((IKabs(x132) != 0)?((IKReal)1/(x132)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x133)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x124)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x133)*(((((-1.00000000000000)*((x124)*(x124))))+(((0.103041000000000)*((sj4)*(sj4))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x134=((0.256800000000000)*(cj4));
IKReal x135=(sj4)*(sj4);
IKReal x136=((0.103041000000000)*(x135));
IKReal x137=(cj4)*(cj4);
IKReal x138=((0.103041000000000)*(x137));
IKReal x139=((0.160000000000000)+(x134)+(x136)+(x138));
IKReal x140=((IKabs(x139) != 0)?((IKReal)1/(x139)):(IKReal)1.0e30);
IKReal x141=((((-1.00000000000000)*(pz)))+(j0));
IKReal x142=((0.321000000000000)*(cj4));
IKReal x143=((0.400000000000000)+(x142));
IKReal x144=((0.100000000000000)+(((-1.00000000000000)*(py))));
j2array[0]=IKatan2(((-1.00000000000000)*(x140)*(((((-1.00000000000000)*(x141)*(x143)))+(((-0.321000000000000)*(sj4)*(x144)))))), ((-1.00000000000000)*(x140)*(((((-0.321000000000000)*(sj4)*(x141)))+(((x143)*(x144)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x145=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x145;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(py)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x145;
evalcond[4]=x145;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(pz)*(sj4)))+(((0.400000000000000)*(py)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(cj4)*(py)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.321000000000000)*(py)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x146=((((-1.00000000000000)*(pz)))+(j0));
IKReal x147=((0.321000000000000)*(py)*(sj4));
IKReal x148=((0.400000000000000)*(pz));
IKReal x149=((0.0321000000000000)*(sj4));
IKReal x150=((0.321000000000000)*(cj4)*(pz));
IKReal x151=((x150)+(x147)+(x148)+(x149));
IKReal x152=((0.400000000000000)*(j0));
IKReal x153=((0.321000000000000)*(cj4)*(j0));
IKReal x154=((x153)+(x152));
IKReal x155=((((-1.00000000000000)*(x154)))+(x151));
IKReal x156=((IKabs(x155) != 0)?((IKReal)1/(x155)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x156)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x146)*(x146))))))), ((x156)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x146)*(((0.100000000000000)+(py)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x157=((0.100000000000000)+(py));
IKReal x158=((0.400000000000000)*(py));
IKReal x159=((0.321000000000000)*(j0)*(sj4));
IKReal x160=((0.321000000000000)*(cj4)*(py));
IKReal x161=((0.0321000000000000)*(cj4));
IKReal x162=((0.0400000000000000)+(x160)+(x161)+(x159)+(x158));
IKReal x163=((0.321000000000000)*(pz)*(sj4));
IKReal x164=((((-1.00000000000000)*(x163)))+(x162));
IKReal x165=((IKabs(x164) != 0)?((IKReal)1/(x164)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x165)*(((((x157)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))), ((x165)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x157)*(x157))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x166=((0.256800000000000)*(cj4));
IKReal x167=(sj4)*(sj4);
IKReal x168=((0.103041000000000)*(x167));
IKReal x169=(cj4)*(cj4);
IKReal x170=((0.103041000000000)*(x169));
IKReal x171=((0.160000000000000)+(x170)+(x168)+(x166));
IKReal x172=((IKabs(x171) != 0)?((IKReal)1/(x171)):(IKReal)1.0e30);
IKReal x173=((0.100000000000000)+(py));
IKReal x174=((0.321000000000000)*(cj4));
IKReal x175=((0.400000000000000)+(x174));
IKReal x176=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x172)*(((((-1.00000000000000)*(x175)*(x176)))+(((-0.321000000000000)*(sj4)*(x173)))))), ((-1.00000000000000)*(x172)*(((((x173)*(x175)))+(((-0.321000000000000)*(sj4)*(x176)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x177=((0.100000000000000)*(sj1));
IKReal x178=((x177)+(((-1.00000000000000)*(py))));
IKReal x179=(cj4)*(cj4);
IKReal x180=((0.103041000000000)*(sj1)*(x179));
IKReal x181=(sj4)*(sj4);
IKReal x182=((0.103041000000000)*(sj1)*(x181));
IKReal x183=((0.256800000000000)*(cj4)*(sj1));
IKReal x184=((0.160000000000000)*(sj1));
IKReal x185=((x184)+(x180)+(x182)+(x183));
IKReal x186=((-1.00000000000000)*(x185));
IKReal x187=((IKabs(x186) != 0)?((IKReal)1/(x186)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x187)*(((((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(sj1)))+(((0.321000000000000)*(cj4)*(sj1)))))))+(((-0.321000000000000)*(sj4)*(x178)))))), ((x187)*(((((x178)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((-0.321000000000000)*(sj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x188=((0.100000000000000)*(cj1));
IKReal x189=((x188)+(((-1.00000000000000)*(px))));
IKReal x190=((0.256800000000000)*(cj1)*(cj4));
IKReal x191=(sj4)*(sj4);
IKReal x192=((0.103041000000000)*(cj1)*(x191));
IKReal x193=((0.160000000000000)*(cj1));
IKReal x194=(cj4)*(cj4);
IKReal x195=((0.103041000000000)*(cj1)*(x194));
IKReal x196=((x193)+(x192)+(x190)+(x195));
IKReal x197=((-1.00000000000000)*(x196));
IKReal x198=((IKabs(x197) != 0)?((IKReal)1/(x197)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x198)*(((((-0.321000000000000)*(sj4)*(x189)))+(((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(cj1)))+(((0.321000000000000)*(cj1)*(cj4)))))))))), ((x198)*(((((x189)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((-0.321000000000000)*(cj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x199=((0.256800000000000)*(cj4));
IKReal x200=(sj4)*(sj4);
IKReal x201=((0.103041000000000)*(x200));
IKReal x202=(cj4)*(cj4);
IKReal x203=((0.103041000000000)*(x202));
IKReal x204=((0.160000000000000)+(x199)+(x203)+(x201));
IKReal x205=((IKabs(x204) != 0)?((IKReal)1/(x204)):(IKReal)1.0e30);
IKReal x206=((0.321000000000000)*(cj4));
IKReal x207=((0.400000000000000)+(x206));
IKReal x208=((cj1)*(px));
IKReal x209=((py)*(sj1));
IKReal x210=((x209)+(x208));
IKReal x211=((0.100000000000000)+(((-1.00000000000000)*(x210))));
IKReal x212=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x205)*(((((-1.00000000000000)*(x207)*(x212)))+(((-0.321000000000000)*(sj4)*(x211)))))), ((-1.00000000000000)*(x205)*(((((x207)*(x211)))+(((-0.321000000000000)*(sj4)*(x212)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}
}
}

} else
{
IKReal x213=((cj1)*(py));
IKReal x214=((px)*(sj1));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-3.14159265358979)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((x214)+(((-1.00000000000000)*(x213))));
evalcond[2]=((x213)+(((-1.00000000000000)*(x214))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
cj4array[0]=((-0.985362149532710)+(((-7.78816199376947)*(j0)*(pz)))+(((3.89408099688473)*((j0)*(j0))))+(((3.89408099688473)*((pz)*(pz))))+(((3.89408099688473)*((px)*(px))))+(((-0.778816199376947)*(py)*(sj1)))+(((3.89408099688473)*((py)*(py))))+(((-0.778816199376947)*(cj1)*(px))));
if( cj4array[0] >= -1.0001 && cj4array[0] <= 1.0001 )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
if( j4valid[0] && j4valid[1] && IKabs(cj4array[0]-cj4array[1]) < 0.0001 && IKabs(sj4array[0]-sj4array[1]) < 0.0001 )
    j4valid[1]=false;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.160000000000000)*(cj1)))+(((-0.256800000000000)*(cj1)*(cj4)))+(((-0.103041000000000)*(cj1)*((sj4)*(sj4))))+(((-0.103041000000000)*(cj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.103041000000000)*(sj1)*((sj4)*(sj4))))+(((-0.256800000000000)*(cj4)*(sj1)))+(((-0.160000000000000)*(sj1)))+(((-0.103041000000000)*(sj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x215=((-1.00000000000000)*(py));
evalcond[0]=((IKfmod(((3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x215;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(px)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x215;
evalcond[4]=py;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(px)))+(((-0.321000000000000)*(cj4)*(px)))+(((-0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.321000000000000)*(cj4)*(pz)))+(((0.321000000000000)*(px)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x216=((((-1.00000000000000)*(pz)))+(j0));
IKReal x217=((0.400000000000000)*(pz));
IKReal x218=((0.321000000000000)*(cj4)*(pz));
IKReal x219=((0.321000000000000)*(px)*(sj4));
IKReal x220=((x217)+(x218)+(x219));
IKReal x221=((0.400000000000000)*(j0));
IKReal x222=((0.321000000000000)*(cj4)*(j0));
IKReal x223=((0.0321000000000000)*(sj4));
IKReal x224=((x221)+(x223)+(x222));
IKReal x225=((x220)+(((-1.00000000000000)*(x224))));
IKReal x226=((IKabs(x225) != 0)?((IKReal)1/(x225)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x226)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x216)*(x216))))))), ((x226)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x216)*(((0.100000000000000)+(((-1.00000000000000)*(px)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x227=((0.100000000000000)+(((-1.00000000000000)*(px))));
IKReal x228=((0.321000000000000)*(pz)*(sj4));
IKReal x229=((0.0321000000000000)*(cj4));
IKReal x230=((0.0400000000000000)+(x229)+(x228));
IKReal x231=((0.400000000000000)*(px));
IKReal x232=((0.321000000000000)*(j0)*(sj4));
IKReal x233=((0.321000000000000)*(cj4)*(px));
IKReal x234=((x232)+(x233)+(x231));
IKReal x235=((((-1.00000000000000)*(x234)))+(x230));
IKReal x236=((IKabs(x235) != 0)?((IKReal)1/(x235)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x236)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x227)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x236)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x227)*(x227))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x237=((0.256800000000000)*(cj4));
IKReal x238=(sj4)*(sj4);
IKReal x239=((0.103041000000000)*(x238));
IKReal x240=(cj4)*(cj4);
IKReal x241=((0.103041000000000)*(x240));
IKReal x242=((0.160000000000000)+(x239)+(x237)+(x241));
IKReal x243=((IKabs(x242) != 0)?((IKReal)1/(x242)):(IKReal)1.0e30);
IKReal x244=((((-1.00000000000000)*(pz)))+(j0));
IKReal x245=((0.321000000000000)*(cj4));
IKReal x246=((0.400000000000000)+(x245));
IKReal x247=((0.100000000000000)+(((-1.00000000000000)*(px))));
j2array[0]=IKatan2(((-1.00000000000000)*(x243)*(((((0.321000000000000)*(sj4)*(x247)))+(((-1.00000000000000)*(x244)*(x246)))))), ((-1.00000000000000)*(x243)*(((((0.321000000000000)*(sj4)*(x244)))+(((x246)*(x247)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(px)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(j0)*(sj4)))+(((0.400000000000000)*(px)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(cj4)*(px)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(px)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x248=((((-1.00000000000000)*(pz)))+(j0));
IKReal x249=((0.400000000000000)*(pz));
IKReal x250=((0.321000000000000)*(cj4)*(pz));
IKReal x251=((x250)+(x249));
IKReal x252=((0.400000000000000)*(j0));
IKReal x253=((0.321000000000000)*(cj4)*(j0));
IKReal x254=((0.0321000000000000)*(sj4));
IKReal x255=((0.321000000000000)*(px)*(sj4));
IKReal x256=((x254)+(x255)+(x252)+(x253));
IKReal x257=((x251)+(((-1.00000000000000)*(x256))));
IKReal x258=((IKabs(x257) != 0)?((IKReal)1/(x257)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x258)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x248)*(x248))))))), ((x258)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x248)*(((0.100000000000000)+(px)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x259=((0.100000000000000)+(px));
IKReal x260=((0.400000000000000)*(px));
IKReal x261=((0.321000000000000)*(pz)*(sj4));
IKReal x262=((0.321000000000000)*(cj4)*(px));
IKReal x263=((0.0321000000000000)*(cj4));
IKReal x264=((0.0400000000000000)+(x261)+(x260)+(x263)+(x262));
IKReal x265=((0.321000000000000)*(j0)*(sj4));
IKReal x266=((x264)+(((-1.00000000000000)*(x265))));
IKReal x267=((IKabs(x266) != 0)?((IKReal)1/(x266)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x267)*(((((x259)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))), ((x267)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x259)*(x259))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x268=((0.256800000000000)*(cj4));
IKReal x269=(sj4)*(sj4);
IKReal x270=((0.103041000000000)*(x269));
IKReal x271=(cj4)*(cj4);
IKReal x272=((0.103041000000000)*(x271));
IKReal x273=((0.160000000000000)+(x268)+(x272)+(x270));
IKReal x274=((IKabs(x273) != 0)?((IKReal)1/(x273)):(IKReal)1.0e30);
IKReal x275=((0.100000000000000)+(px));
IKReal x276=((0.321000000000000)*(cj4));
IKReal x277=((0.400000000000000)+(x276));
IKReal x278=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x274)*(((((-1.00000000000000)*(x277)*(x278)))+(((0.321000000000000)*(sj4)*(x275)))))), ((-1.00000000000000)*(x274)*(((((x275)*(x277)))+(((0.321000000000000)*(sj4)*(x278)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(py)))+(((-0.321000000000000)*(cj4)*(py)))+(((-0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.321000000000000)*(py)*(sj4)))+(((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x279=((((-1.00000000000000)*(pz)))+(j0));
IKReal x280=((0.321000000000000)*(py)*(sj4));
IKReal x281=((0.400000000000000)*(pz));
IKReal x282=((0.321000000000000)*(cj4)*(pz));
IKReal x283=((x282)+(x281)+(x280));
IKReal x284=((0.400000000000000)*(j0));
IKReal x285=((0.321000000000000)*(cj4)*(j0));
IKReal x286=((0.0321000000000000)*(sj4));
IKReal x287=((x286)+(x285)+(x284));
IKReal x288=((x283)+(((-1.00000000000000)*(x287))));
IKReal x289=((IKabs(x288) != 0)?((IKReal)1/(x288)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x289)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x279)*(x279))))))), ((x289)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x279)*(((0.100000000000000)+(((-1.00000000000000)*(py)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x290=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x291=((0.321000000000000)*(pz)*(sj4));
IKReal x292=((0.0321000000000000)*(cj4));
IKReal x293=((0.0400000000000000)+(x291)+(x292));
IKReal x294=((0.400000000000000)*(py));
IKReal x295=((0.321000000000000)*(j0)*(sj4));
IKReal x296=((0.321000000000000)*(cj4)*(py));
IKReal x297=((x294)+(x295)+(x296));
IKReal x298=((((-1.00000000000000)*(x297)))+(x293));
IKReal x299=((IKabs(x298) != 0)?((IKReal)1/(x298)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x299)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x290)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x299)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x290)*(x290))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x300=((0.256800000000000)*(cj4));
IKReal x301=(sj4)*(sj4);
IKReal x302=((0.103041000000000)*(x301));
IKReal x303=(cj4)*(cj4);
IKReal x304=((0.103041000000000)*(x303));
IKReal x305=((0.160000000000000)+(x304)+(x302)+(x300));
IKReal x306=((IKabs(x305) != 0)?((IKReal)1/(x305)):(IKReal)1.0e30);
IKReal x307=((0.321000000000000)*(cj4));
IKReal x308=((0.400000000000000)+(x307));
IKReal x309=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x310=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x306)*(((((-1.00000000000000)*(x308)*(x310)))+(((0.321000000000000)*(sj4)*(x309)))))), ((-1.00000000000000)*(x306)*(((((0.321000000000000)*(sj4)*(x310)))+(((x308)*(x309)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x311=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x311;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(py)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x311;
evalcond[4]=px;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(j0)*(sj4)))+(((0.400000000000000)*(py)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(cj4)*(py)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(py)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x312=((((-1.00000000000000)*(pz)))+(j0));
IKReal x313=((0.400000000000000)*(pz));
IKReal x314=((0.321000000000000)*(cj4)*(pz));
IKReal x315=((x314)+(x313));
IKReal x316=((0.400000000000000)*(j0));
IKReal x317=((0.321000000000000)*(py)*(sj4));
IKReal x318=((0.321000000000000)*(cj4)*(j0));
IKReal x319=((0.0321000000000000)*(sj4));
IKReal x320=((x319)+(x318)+(x317)+(x316));
IKReal x321=((((-1.00000000000000)*(x320)))+(x315));
IKReal x322=((IKabs(x321) != 0)?((IKReal)1/(x321)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x322)*(((((-1.00000000000000)*((x312)*(x312))))+(((0.103041000000000)*((sj4)*(sj4))))))), ((x322)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x312)*(((0.100000000000000)+(py)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x323=((0.100000000000000)+(py));
IKReal x324=((0.400000000000000)*(py));
IKReal x325=((0.321000000000000)*(pz)*(sj4));
IKReal x326=((0.321000000000000)*(cj4)*(py));
IKReal x327=((0.0321000000000000)*(cj4));
IKReal x328=((0.0400000000000000)+(x324)+(x325)+(x326)+(x327));
IKReal x329=((0.321000000000000)*(j0)*(sj4));
IKReal x330=((((-1.00000000000000)*(x329)))+(x328));
IKReal x331=((IKabs(x330) != 0)?((IKReal)1/(x330)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x331)*(((((x323)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))), ((x331)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x323)*(x323))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x332=((0.256800000000000)*(cj4));
IKReal x333=(sj4)*(sj4);
IKReal x334=((0.103041000000000)*(x333));
IKReal x335=(cj4)*(cj4);
IKReal x336=((0.103041000000000)*(x335));
IKReal x337=((0.160000000000000)+(x332)+(x336)+(x334));
IKReal x338=((IKabs(x337) != 0)?((IKReal)1/(x337)):(IKReal)1.0e30);
IKReal x339=((0.100000000000000)+(py));
IKReal x340=((0.321000000000000)*(cj4));
IKReal x341=((0.400000000000000)+(x340));
IKReal x342=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x338)*(((((0.321000000000000)*(sj4)*(x339)))+(((-1.00000000000000)*(x341)*(x342)))))), ((-1.00000000000000)*(x338)*(((((x339)*(x341)))+(((0.321000000000000)*(sj4)*(x342)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x343=((0.100000000000000)*(sj1));
IKReal x344=((x343)+(((-1.00000000000000)*(py))));
IKReal x345=(cj4)*(cj4);
IKReal x346=((0.103041000000000)*(sj1)*(x345));
IKReal x347=(sj4)*(sj4);
IKReal x348=((0.103041000000000)*(sj1)*(x347));
IKReal x349=((0.256800000000000)*(cj4)*(sj1));
IKReal x350=((0.160000000000000)*(sj1));
IKReal x351=((x350)+(x346)+(x348)+(x349));
IKReal x352=((-1.00000000000000)*(x351));
IKReal x353=((IKabs(x352) != 0)?((IKReal)1/(x352)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x353)*(((((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(sj1)))+(((0.321000000000000)*(cj4)*(sj1)))))))+(((0.321000000000000)*(sj4)*(x344)))))), ((x353)*(((((0.321000000000000)*(sj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((x344)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x354=((0.100000000000000)*(cj1));
IKReal x355=((x354)+(((-1.00000000000000)*(px))));
IKReal x356=((0.256800000000000)*(cj1)*(cj4));
IKReal x357=(sj4)*(sj4);
IKReal x358=((0.103041000000000)*(cj1)*(x357));
IKReal x359=((0.160000000000000)*(cj1));
IKReal x360=(cj4)*(cj4);
IKReal x361=((0.103041000000000)*(cj1)*(x360));
IKReal x362=((x356)+(x359)+(x358)+(x361));
IKReal x363=((-1.00000000000000)*(x362));
IKReal x364=((IKabs(x363) != 0)?((IKReal)1/(x363)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x364)*(((((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(cj1)))+(((0.321000000000000)*(cj1)*(cj4)))))))+(((0.321000000000000)*(sj4)*(x355)))))), ((x364)*(((((0.321000000000000)*(cj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((x355)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x365=((0.256800000000000)*(cj4));
IKReal x366=(sj4)*(sj4);
IKReal x367=((0.103041000000000)*(x366));
IKReal x368=(cj4)*(cj4);
IKReal x369=((0.103041000000000)*(x368));
IKReal x370=((0.160000000000000)+(x369)+(x365)+(x367));
IKReal x371=((IKabs(x370) != 0)?((IKReal)1/(x370)):(IKReal)1.0e30);
IKReal x372=((0.321000000000000)*(cj4));
IKReal x373=((0.400000000000000)+(x372));
IKReal x374=((cj1)*(px));
IKReal x375=((py)*(sj1));
IKReal x376=((x375)+(x374));
IKReal x377=((0.100000000000000)+(((-1.00000000000000)*(x376))));
IKReal x378=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x371)*(((((-1.00000000000000)*(x373)*(x378)))+(((0.321000000000000)*(sj4)*(x377)))))), ((-1.00000000000000)*(x371)*(((((0.321000000000000)*(sj4)*(x378)))+(((x373)*(x377)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x379=x4;
IKReal x380=x3;
IKReal x381=x0;
IKReal x382=x2;
IKReal x383=((cj3)*(px)*(sj1));
IKReal x384=((cj1)*(cj3)*(py));
IKReal x385=((x383)+(((-1.00000000000000)*(x384))));
IKReal x386=((0.0669590000000000)+(x382)+(x380)+(x381)+(x379));
IKReal x387=((2.00000000000000)*(j0)*(pz));
IKReal x388=((0.200000000000000)*(cj1)*(px));
IKReal x389=((0.200000000000000)*(py)*(sj1));
IKReal x390=((x387)+(x388)+(x389));
IKReal x391=((((-1.00000000000000)*(x390)))+(x386));
IKReal x392=((1.60000000000000)*(j0)*(pz)*(sj3));
IKReal x393=((0.160000000000000)*(cj1)*(px)*(sj3));
IKReal x394=((0.160000000000000)*(py)*(sj1)*(sj3));
IKReal x395=((x394)+(x393)+(x392));
IKReal x396=((0.800000000000000)*(sj3)*(x379));
IKReal x397=((0.800000000000000)*(sj3)*(x380));
IKReal x398=(cj1)*(cj1);
IKReal x399=((0.800000000000000)*(sj3)*(x381)*(x398));
IKReal x400=((1.60000000000000)*(cj1)*(px)*(py)*(sj1)*(sj3));
IKReal x401=(sj1)*(sj1);
IKReal x402=((0.800000000000000)*(sj3)*(x382)*(x401));
IKReal x403=((0.00800000000000000)*(sj3));
IKReal x404=((x397)+(x396)+(x399)+(x400)+(x403)+(x402));
IKReal x405=((x395)+(((-1.00000000000000)*(x404))));
IKReal x406=((IKabs(x405) != 0)?((IKReal)1/(x405)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x406)*(((((x385)*(((0.0800000000000000)+(((-0.800000000000000)*(py)*(sj1)))+(((-0.800000000000000)*(cj1)*(px)))))))+(((x391)*(((((pz)*(sj3)))+(((-1.00000000000000)*(j0)*(sj3)))))))))), ((x406)*(((((x391)*(((((-1.00000000000000)*(cj1)*(px)*(sj3)))+(((-1.00000000000000)*(py)*(sj1)*(sj3)))+(((0.100000000000000)*(sj3)))))))+(((x385)*(((((0.800000000000000)*(j0)))+(((-0.800000000000000)*(pz)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((-0.103041000000000)*(cj3)*((sj2)*(sj2))))+(((-0.103041000000000)*(cj3)*((cj2)*(cj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj2;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
IKReal x407=((px)*(sj1));
IKReal x408=((cj1)*(py));
IKReal x409=((x407)+(((-1.00000000000000)*(x408))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x409;
evalcond[2]=x409;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((-0.103041000000000)*((cj2)*(cj2))))+(((-0.103041000000000)*((sj2)*(sj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((-0.103041000000000)*(cj1)*((sj2)*(sj2))))+(((-0.103041000000000)*(cj1)*((cj2)*(cj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((-1.00000000000000)*(px));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(cj2)*(pz)))+(((-3.11526479750779)*(py)*(sj2)))+(((3.11526479750779)*(cj2)*(j0)))+(((0.311526479750779)*(sj2)))), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x410=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x410;
evalcond[2]=x410;
evalcond[3]=x410;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(cj2)*(pz)))+(((3.11526479750779)*(py)*(sj2)))+(((3.11526479750779)*(cj2)*(j0)))+(((0.311526479750779)*(sj2)))), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x411=x407;
IKReal x412=x408;
IKReal x413=((x411)+(((-1.00000000000000)*(x412))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x413;
evalcond[2]=x413;
evalcond[3]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x414=x407;
IKReal x415=x408;
IKReal x416=((x414)+(((-1.00000000000000)*(x415))));
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x416;
evalcond[2]=x416;
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x417=((0.400000000000000)*(sj2));
IKReal x418=((x417)+(pz));
IKReal x419=((((-1.00000000000000)*(x418)))+(j0));
IKReal x420=((0.400000000000000)*(cj1)*(cj2));
IKReal x421=((0.100000000000000)*(cj1));
IKReal x422=((x421)+(x420));
IKReal x423=((x422)+(((-1.00000000000000)*(px))));
IKReal x424=(sj2)*(sj2);
IKReal x425=((0.103041000000000)*(cj1)*(x424));
IKReal x426=(cj2)*(cj2);
IKReal x427=((0.103041000000000)*(cj1)*(x426));
IKReal x428=((x427)+(x425));
IKReal x429=((-1.00000000000000)*(x428));
IKReal x430=((IKabs(x429) != 0)?((IKReal)1/(x429)):(IKReal)1.0e30);
j4array[0]=IKatan2(((x430)*(((((-0.321000000000000)*(sj2)*(x423)))+(((-0.321000000000000)*(cj1)*(cj2)*(x419)))))), ((x430)*(((((-0.321000000000000)*(cj1)*(sj2)*(x419)))+(((0.321000000000000)*(cj2)*(x423)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x431=((0.400000000000000)*(sj2));
IKReal x432=((x431)+(pz));
IKReal x433=((((-1.00000000000000)*(x432)))+(j0));
IKReal x434=((0.400000000000000)*(cj2));
IKReal x435=((0.100000000000000)+(x434));
IKReal x436=((cj1)*(px));
IKReal x437=((py)*(sj1));
IKReal x438=((x436)+(x437));
IKReal x439=((((-1.00000000000000)*(x438)))+(x435));
IKReal x440=(cj2)*(cj2);
IKReal x441=((0.103041000000000)*(x440));
IKReal x442=(sj2)*(sj2);
IKReal x443=((0.103041000000000)*(x442));
IKReal x444=((x441)+(x443));
IKReal x445=((-1.00000000000000)*(x444));
IKReal x446=((IKabs(x445) != 0)?((IKReal)1/(x445)):(IKReal)1.0e30);
j4array[0]=IKatan2(((x446)*(((((-0.321000000000000)*(cj2)*(x433)))+(((-0.321000000000000)*(sj2)*(x439)))))), ((x446)*(((((0.321000000000000)*(cj2)*(x439)))+(((-0.321000000000000)*(sj2)*(x433)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(cj2)*(pz)))+(((-3.11526479750779)*(cj1)*(px)*(sj2)))+(((3.11526479750779)*(cj2)*(j0)))+(((-3.11526479750779)*(py)*(sj1)*(sj2)))+(((0.311526479750779)*(sj2)))), ((9.70487475859124)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((-0.321000000000000)*(cj2)*(((((-1.00000000000000)*(cj1)*(px)*(sj2)))+(((-1.00000000000000)*(py)*(sj1)*(sj2)))+(((0.100000000000000)*(sj2)))+(((cj2)*(j0)))+(((-1.00000000000000)*(cj2)*(pz)))))))+(((0.321000000000000)*(j0)))+(((-0.321000000000000)*(pz)))+(((-0.128400000000000)*(sj2)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x447=((cj1)*(py));
IKReal x448=((px)*(sj1));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-3.14159265358979)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(x447)))+(x448));
evalcond[2]=((((-1.00000000000000)*(x448)))+(x447));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((0.103041000000000)*((cj2)*(cj2))))+(((0.103041000000000)*((sj2)*(sj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((0.103041000000000)*(cj1)*((sj2)*(sj2))))+(((0.103041000000000)*(cj1)*((cj2)*(cj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((-1.00000000000000)*(px));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(py)*(sj2)))+(((3.11526479750779)*(cj2)*(pz)))+(((-0.311526479750779)*(sj2)))+(((-3.11526479750779)*(cj2)*(j0)))), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x449=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x449;
evalcond[2]=x449;
evalcond[3]=px;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj2)*(pz)))+(((-3.11526479750779)*(py)*(sj2)))+(((-0.311526479750779)*(sj2)))+(((-3.11526479750779)*(cj2)*(j0)))), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x450=x447;
IKReal x451=x448;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(x450)))+(x451));
evalcond[2]=((((-1.00000000000000)*(x451)))+(x450));
evalcond[3]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x452=x447;
IKReal x453=x448;
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(x452)))+(x453));
evalcond[2]=((((-1.00000000000000)*(x453)))+(x452));
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x454=(sj2)*(sj2);
IKReal x455=((0.103041000000000)*(cj1)*(x454));
IKReal x456=(cj2)*(cj2);
IKReal x457=((0.103041000000000)*(cj1)*(x456));
IKReal x458=((x457)+(x455));
IKReal x459=((IKabs(x458) != 0)?((IKReal)1/(x458)):(IKReal)1.0e30);
IKReal x460=((0.400000000000000)*(cj1)*(cj2));
IKReal x461=((0.100000000000000)*(cj1));
IKReal x462=((x461)+(x460));
IKReal x463=((x462)+(((-1.00000000000000)*(px))));
IKReal x464=((0.400000000000000)*(sj2));
IKReal x465=((x464)+(pz));
IKReal x466=((((-1.00000000000000)*(x465)))+(j0));
j4array[0]=IKatan2(((x459)*(((((-0.321000000000000)*(sj2)*(x463)))+(((-0.321000000000000)*(cj1)*(cj2)*(x466)))))), ((x459)*(((((0.321000000000000)*(cj1)*(sj2)*(x466)))+(((-0.321000000000000)*(cj2)*(x463)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x467=(cj2)*(cj2);
IKReal x468=((0.103041000000000)*(x467));
IKReal x469=(sj2)*(sj2);
IKReal x470=((0.103041000000000)*(x469));
IKReal x471=((x468)+(x470));
IKReal x472=((IKabs(x471) != 0)?((IKReal)1/(x471)):(IKReal)1.0e30);
IKReal x473=((0.400000000000000)*(sj2));
IKReal x474=((x473)+(pz));
IKReal x475=((((-1.00000000000000)*(x474)))+(j0));
IKReal x476=((0.400000000000000)*(cj2));
IKReal x477=((0.100000000000000)+(x476));
IKReal x478=((cj1)*(px));
IKReal x479=((py)*(sj1));
IKReal x480=((x478)+(x479));
IKReal x481=((((-1.00000000000000)*(x480)))+(x477));
j4array[0]=IKatan2(((x472)*(((((-0.321000000000000)*(cj2)*(x475)))+(((-0.321000000000000)*(sj2)*(x481)))))), ((x472)*(((((-0.321000000000000)*(cj2)*(x481)))+(((0.321000000000000)*(sj2)*(x475)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(px)*(sj2)))+(((3.11526479750779)*(cj2)*(pz)))+(((3.11526479750779)*(py)*(sj1)*(sj2)))+(((-0.311526479750779)*(sj2)))+(((-3.11526479750779)*(cj2)*(j0)))), ((-9.70487475859124)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.321000000000000)*(cj2)*(((((-1.00000000000000)*(cj1)*(px)*(sj2)))+(((-1.00000000000000)*(py)*(sj1)*(sj2)))+(((0.100000000000000)*(sj2)))+(((cj2)*(j0)))+(((-1.00000000000000)*(cj2)*(pz)))))))+(((-0.321000000000000)*(j0)))+(((0.128400000000000)*(sj2)))+(((0.321000000000000)*(pz)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((cj3)*(px)*(sj1)))+(((-1.00000000000000)*(pz)*(sj3)))+(((j0)*(sj3)))+(((-1.00000000000000)*(cj1)*(cj3)*(py))));
evalcond[2]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj3;
j4eval[1]=cj1;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x482=((((-1.00000000000000)*(pz)))+(j0));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x482;
evalcond[2]=x482;
evalcond[3]=x482;
evalcond[4]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x483=((((-1.00000000000000)*(pz)))+(j0));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x483;
evalcond[2]=x483;
evalcond[3]=((pz)+(((-1.00000000000000)*(j0))));
evalcond[4]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(pz)*(sj3)))+(((j0)*(sj3)))+(((cj3)*(px))));
evalcond[2]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj3)*(j0)))+(((-3.11526479750779)*(px)*(sj3)))+(((-3.11526479750779)*(cj3)*(pz)))), ((-1.55763239875389)+(((3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(pz)*(sj3)))+(((-1.00000000000000)*(cj3)*(px)))+(((j0)*(sj3))));
evalcond[2]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-1.00000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj3)))+(((3.11526479750779)*(cj3)*(j0)))+(((-3.11526479750779)*(cj3)*(pz)))), ((-1.55763239875389)+(((-3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x484=((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30);
j4array[0]=IKatan2(((-3.11526479750779)*(x484)*(((pz)+(((-1.00000000000000)*(j0)))))), ((-9.70487475859124)*(x484)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((((-0.321000000000000)*(sj1)*(sj3)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((0.321000000000000)*(cj3)*(((((0.500000000000000)*(cj1)))+(((-1.00000000000000)*(px)))))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30))*(((pz)+(((-1.00000000000000)*(j0)))))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((cj3)*(px)*(sj1)))+(((-1.00000000000000)*(cj1)*(cj3)*(py)))+(((pz)*(sj3)))+(((-1.00000000000000)*(j0)*(sj3))));
evalcond[2]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj3;
j4eval[1]=cj1;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(pz)))+(j0));
evalcond[2]=((pz)+(((-1.00000000000000)*(j0))));
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(pz)))+(j0));
evalcond[2]=((pz)+(((-1.00000000000000)*(j0))));
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((pz)*(sj3)))+(((cj3)*(px)))+(((-1.00000000000000)*(j0)*(sj3))));
evalcond[2]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((-0.600000000000000)*(py)))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj3)*(pz)))+(((-3.11526479750779)*(cj3)*(j0)))+(((-3.11526479750779)*(px)*(sj3)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(cj3)*(px)))+(((pz)*(sj3)))+(((-1.00000000000000)*(j0)*(sj3))));
evalcond[2]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.600000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj3)))+(((3.11526479750779)*(cj3)*(pz)))+(((-3.11526479750779)*(cj3)*(j0)))), ((-0.934579439252337)+(((3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x485=((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30);
j4array[0]=IKatan2(((3.11526479750779)*(x485)*(((pz)+(((-1.00000000000000)*(j0)))))), ((9.70487475859124)*(x485)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((((0.321000000000000)*(sj1)*(sj3)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((0.321000000000000)*(cj3)*(((((-0.300000000000000)*(cj1)))+(((-1.00000000000000)*(px)))))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30))*(((pz)+(((-1.00000000000000)*(j0)))))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x486=((0.100000000000000)*(sj2));
IKReal x487=((cj2)*(j0));
IKReal x488=((x487)+(x486));
IKReal x489=((cj2)*(pz));
IKReal x490=((py)*(sj1)*(sj2));
IKReal x491=((cj1)*(px)*(sj2));
IKReal x492=((x489)+(x490)+(x491));
IKReal x493=((((-1.00000000000000)*(x492)))+(x488));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x493;
evalcond[2]=x493;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj1;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x494=x486;
IKReal x495=x487;
IKReal x496=((x494)+(x495));
IKReal x497=x489;
IKReal x498=((py)*(sj2));
IKReal x499=((x498)+(x497));
IKReal x500=((((-1.00000000000000)*(x499)))+(x496));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x500;
evalcond[2]=x500;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(px)), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x501=x486;
IKReal x502=x487;
IKReal x503=((py)*(sj2));
IKReal x504=((x501)+(x502)+(x503));
IKReal x505=x489;
IKReal x506=((((-1.00000000000000)*(x505)))+(x504));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x506;
evalcond[2]=x506;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(px)), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x507=((cj1)*(px));
IKReal x508=((py)*(sj1));
IKReal x509=((x508)+(x507));
IKReal x510=((0.100000000000000)+(((-1.00000000000000)*(x509))));
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x510;
evalcond[2]=x510;
evalcond[3]=x510;
evalcond[4]=((-0.0669590000000000)+(((-0.800000000000000)*(pz)))+(((0.200000000000000)*(x507)))+(((0.200000000000000)*(x508)))+(((-1.00000000000000)*((j0)*(j0))))+(((0.800000000000000)*(j0)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-1.24610591900312)+(((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x511=((cj1)*(px));
IKReal x512=((py)*(sj1));
IKReal x513=((-0.100000000000000)+(x512)+(x511));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((-1.00000000000000)*(x513));
evalcond[2]=x513;
evalcond[3]=x513;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(pz)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.800000000000000)*(j0)))+(((0.200000000000000)*(x512)))+(((0.200000000000000)*(x511))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-1.24610591900312)+(((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((9.70487475859124)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((((-0.128400000000000)*(cj1)*(cj2)))+(((-0.0321000000000000)*(cj1)))+(((-0.321000000000000)*(sj1)*(((((-1.00000000000000)*(cj1)*(py)))+(((px)*(sj1)))))))+(((0.321000000000000)*(px)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-3.11526479750779)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((0.100000000000000)+(((-1.00000000000000)*(cj1)*(px)))+(((-1.00000000000000)*(py)*(sj1)))+(((0.400000000000000)*(cj2)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-3.11526479750779)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.400000000000000)*(sj2)))+(pz)+(((-1.00000000000000)*(j0)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x514=((cj2)*(pz));
IKReal x515=((py)*(sj1)*(sj2));
IKReal x516=((cj1)*(px)*(sj2));
IKReal x517=((x516)+(x515)+(x514));
IKReal x518=((0.100000000000000)*(sj2));
IKReal x519=((cj2)*(j0));
IKReal x520=((x519)+(x518));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((x520)+(((-1.00000000000000)*(x517))));
evalcond[2]=((((-1.00000000000000)*(x520)))+(x517));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj1;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x521=x514;
IKReal x522=((py)*(sj2));
IKReal x523=((x522)+(x521));
IKReal x524=x518;
IKReal x525=x519;
IKReal x526=((x524)+(x525));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(x523)))+(x526));
evalcond[2]=((((-1.00000000000000)*(x526)))+(x523));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(px)), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x527=x514;
IKReal x528=x518;
IKReal x529=x519;
IKReal x530=((py)*(sj2));
IKReal x531=((x530)+(x528)+(x529));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(x527)))+(x531));
evalcond[2]=((((-1.00000000000000)*(x531)))+(x527));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(px)), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x532=((cj1)*(px));
IKReal x533=((py)*(sj1));
IKReal x534=((x533)+(x532));
IKReal x535=((0.100000000000000)+(((-1.00000000000000)*(x534))));
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x535;
evalcond[2]=x535;
evalcond[3]=((-0.100000000000000)+(x534));
evalcond[4]=((-0.0669590000000000)+(((-0.800000000000000)*(pz)))+(((-1.00000000000000)*((j0)*(j0))))+(((0.800000000000000)*(j0)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((0.200000000000000)*(x532)))+(((0.200000000000000)*(x533)))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-1.24610591900312)+(((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x536=((cj1)*(px));
IKReal x537=((py)*(sj1));
IKReal x538=((x537)+(x536));
IKReal x539=((0.100000000000000)+(((-1.00000000000000)*(x538))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x539;
evalcond[2]=((-0.100000000000000)+(x538));
evalcond[3]=x539;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(pz)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((0.200000000000000)*(x536)))+(((0.200000000000000)*(x537)))+(((2.00000000000000)*(j0)*(pz)))+(((-0.800000000000000)*(j0))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-1.24610591900312)+(((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-9.70487475859124)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((((0.128400000000000)*(cj1)*(cj2)))+(((0.321000000000000)*(sj1)*(((((-1.00000000000000)*(cj1)*(py)))+(((px)*(sj1)))))))+(((-0.321000000000000)*(px)))+(((0.0321000000000000)*(cj1)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-3.11526479750779)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((0.100000000000000)+(((-1.00000000000000)*(cj1)*(px)))+(((-1.00000000000000)*(py)*(sj1)))+(((0.400000000000000)*(cj2)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-3.11526479750779)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.400000000000000)*(sj2)))+(pz)+(((-1.00000000000000)*(j0)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x540=((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30);
IKReal x541=((px)*(sj1));
IKReal x542=((cj1)*(py));
j4array[0]=IKatan2(((3.11526479750779)*(x540)*(((((-1.00000000000000)*(x541)))+(x542)))), ((9.70487475859124)*(x540)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.321000000000000)*(cj2)*(cj3)*(((((-1.00000000000000)*(x542)))+(x541)))))+(((0.321000000000000)*(sj3)*(((((-0.400000000000000)*(sj2)))+(((-1.00000000000000)*(pz)))+(j0)))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x543=((0.400000000000000)*(sj2));
IKReal x544=((pz)+(x543));
IKReal x545=((((-1.00000000000000)*(x544)))+(j0));
IKReal x546=((0.400000000000000)*(cj2));
IKReal x547=((0.100000000000000)+(x546));
IKReal x548=((cj1)*(px));
IKReal x549=((py)*(sj1));
IKReal x550=((x548)+(x549));
IKReal x551=((((-1.00000000000000)*(x550)))+(x547));
IKReal x552=(sj2)*(sj2);
IKReal x553=((0.103041000000000)*(cj3)*(x552));
IKReal x554=(cj2)*(cj2);
IKReal x555=((0.103041000000000)*(cj3)*(x554));
IKReal x556=((x553)+(x555));
IKReal x557=((-1.00000000000000)*(x556));
IKReal x558=((IKabs(x557) != 0)?((IKReal)1/(x557)):(IKReal)1.0e30);
j4array[0]=IKatan2(((x558)*(((((-0.321000000000000)*(cj2)*(x545)))+(((-0.321000000000000)*(sj2)*(x551)))))), ((x558)*(((((-0.321000000000000)*(cj3)*(sj2)*(x545)))+(((0.321000000000000)*(cj2)*(cj3)*(x551)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-1.24610591900312)+(((3.11526479750779)*(cj1)*(cj2)*(px)))+(((-0.311526479750779)*(cj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((3.11526479750779)*(cj2)*(py)*(sj1)))+(((-3.11526479750779)*(pz)*(sj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-0.985362149532710)+(((3.89408099688473)*((py)*(py))))+(((3.89408099688473)*((j0)*(j0))))+(((3.89408099688473)*((pz)*(pz))))+(((-0.778816199376947)*(py)*(sj1)))+(((3.89408099688473)*((px)*(px))))+(((-0.778816199376947)*(cj1)*(px)))+(((-7.78816199376947)*(j0)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.103041000000000)*((cj4)*(cj4))))+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((0.256800000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.321000000000000)*(cj4)*(pz)))+(((-0.400000000000000)*(j0)))+(((0.0321000000000000)*(cj3)*(sj4)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(cj3)*(py)*(sj1)*(sj4)))+(((-0.321000000000000)*(cj1)*(cj3)*(px)*(sj4)))+(((0.400000000000000)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.103041000000000)*(cj1)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-0.160000000000000)*(cj1)))+(((-0.103041000000000)*(cj1)*((cj4)*(cj4))))+(((-0.256800000000000)*(cj1)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[4];
IKReal x559=((0.321000000000000)*(sj3)*(sj4));
IKReal x560=((px)+(x559));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x560;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(x560));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(py)))+(((-0.321000000000000)*(cj4)*(py)))+(((0.321000000000000)*(cj3)*(j0)*(sj4)))+(((-0.321000000000000)*(cj3)*(pz)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.400000000000000)*(j0)))+(((0.0321000000000000)*(cj3)*(sj4)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.321000000000000)*(cj4)*(pz)))+(((-0.321000000000000)*(cj3)*(py)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x561=((((-1.00000000000000)*(pz)))+(j0));
IKReal x562=((0.0321000000000000)*(cj3)*(sj4));
IKReal x563=((0.400000000000000)*(pz));
IKReal x564=((0.321000000000000)*(cj4)*(pz));
IKReal x565=((x564)+(x562)+(x563));
IKReal x566=((0.400000000000000)*(j0));
IKReal x567=((0.321000000000000)*(cj4)*(j0));
IKReal x568=((0.321000000000000)*(cj3)*(py)*(sj4));
IKReal x569=((x568)+(x566)+(x567));
IKReal x570=((x565)+(((-1.00000000000000)*(x569))));
IKReal x571=((IKabs(x570) != 0)?((IKReal)1/(x570)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x571)*(((((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-1.00000000000000)*((x561)*(x561))))))), ((x571)*(((((-0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x561)*(((0.100000000000000)+(((-1.00000000000000)*(py)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x572=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x573=((0.321000000000000)*(cj3)*(j0)*(sj4));
IKReal x574=((0.0321000000000000)*(cj4));
IKReal x575=((0.0400000000000000)+(x574)+(x573));
IKReal x576=((0.321000000000000)*(cj3)*(pz)*(sj4));
IKReal x577=((0.400000000000000)*(py));
IKReal x578=((0.321000000000000)*(cj4)*(py));
IKReal x579=((x578)+(x577)+(x576));
IKReal x580=((((-1.00000000000000)*(x579)))+(x575));
IKReal x581=((IKabs(x580) != 0)?((IKReal)1/(x580)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x581)*(((((0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x572)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x581)*(((((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-1.00000000000000)*((x572)*(x572))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x582=(cj3)*(cj3);
IKReal x583=(sj4)*(sj4);
IKReal x584=((0.103041000000000)*(x582)*(x583));
IKReal x585=((0.256800000000000)*(cj4));
IKReal x586=(cj4)*(cj4);
IKReal x587=((0.103041000000000)*(x586));
IKReal x588=((0.160000000000000)+(x584)+(x585)+(x587));
IKReal x589=((IKabs(x588) != 0)?((IKReal)1/(x588)):(IKReal)1.0e30);
IKReal x590=((((-1.00000000000000)*(pz)))+(j0));
IKReal x591=((0.321000000000000)*(cj4));
IKReal x592=((0.400000000000000)+(x591));
IKReal x593=((0.100000000000000)+(((-1.00000000000000)*(py))));
j2array[0]=IKatan2(((-1.00000000000000)*(x589)*(((((-1.00000000000000)*(x590)*(x592)))+(((-0.321000000000000)*(cj3)*(sj4)*(x593)))))), ((-1.00000000000000)*(x589)*(((((-0.321000000000000)*(cj3)*(sj4)*(x590)))+(((x592)*(x593)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x594=((0.321000000000000)*(sj3)*(sj4));
IKReal x595=((x594)+(((-1.00000000000000)*(px))));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x595;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(py)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x595;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((0.321000000000000)*(cj3)*(j0)*(sj4)))+(((0.400000000000000)*(py)))+(((-0.321000000000000)*(cj3)*(pz)*(sj4)))+(((0.321000000000000)*(cj4)*(py)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.400000000000000)*(j0)))+(((-0.0321000000000000)*(cj3)*(sj4)))+(((-0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(pz)))+(((0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(cj3)*(py)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x596=((0.100000000000000)+(py));
IKReal x597=((0.321000000000000)*(cj4));
IKReal x598=((0.400000000000000)+(x597));
IKReal x599=((0.400000000000000)*(j0));
IKReal x600=((j0)*(x597));
IKReal x601=((x599)+(x600));
IKReal x602=((0.0321000000000000)*(cj3)*(sj4));
IKReal x603=((0.400000000000000)*(pz));
IKReal x604=((0.321000000000000)*(cj3)*(py)*(sj4));
IKReal x605=((pz)*(x597));
IKReal x606=((x603)+(x602)+(x605)+(x604));
IKReal x607=((x601)+(((-1.00000000000000)*(x606))));
IKReal x608=((IKabs(x607) != 0)?((IKReal)1/(x607)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x608)*(((((-1.00000000000000)*((x596)*(x596))))+((x598)*(x598))))), ((x608)*(((((x596)*(((pz)+(((-1.00000000000000)*(j0)))))))+(((0.321000000000000)*(cj3)*(sj4)*(x598)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x609=((0.100000000000000)+(py));
IKReal x610=((0.321000000000000)*(cj3)*(j0)*(sj4));
IKReal x611=((0.400000000000000)*(py));
IKReal x612=((0.321000000000000)*(cj4)*(py));
IKReal x613=((0.0321000000000000)*(cj4));
IKReal x614=((0.0400000000000000)+(x610)+(x611)+(x612)+(x613));
IKReal x615=((0.321000000000000)*(cj3)*(pz)*(sj4));
IKReal x616=((((-1.00000000000000)*(x615)))+(x614));
IKReal x617=((IKabs(x616) != 0)?((IKReal)1/(x616)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x617)*(((((x609)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))), ((x617)*(((((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-1.00000000000000)*((x609)*(x609))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x618=(cj3)*(cj3);
IKReal x619=(sj4)*(sj4);
IKReal x620=((0.103041000000000)*(x618)*(x619));
IKReal x621=((0.256800000000000)*(cj4));
IKReal x622=(cj4)*(cj4);
IKReal x623=((0.103041000000000)*(x622));
IKReal x624=((0.160000000000000)+(x621)+(x620)+(x623));
IKReal x625=((IKabs(x624) != 0)?((IKReal)1/(x624)):(IKReal)1.0e30);
IKReal x626=((((-1.00000000000000)*(pz)))+(j0));
IKReal x627=((0.100000000000000)+(py));
IKReal x628=((0.321000000000000)*(cj4));
IKReal x629=((0.400000000000000)+(x628));
j2array[0]=IKatan2(((-1.00000000000000)*(x625)*(((((-0.321000000000000)*(cj3)*(sj4)*(x627)))+(((-1.00000000000000)*(x626)*(x629)))))), ((-1.00000000000000)*(x625)*(((((-0.321000000000000)*(cj3)*(sj4)*(x626)))+(((x627)*(x629)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x630=((0.100000000000000)*(cj1));
IKReal x631=((0.321000000000000)*(sj1)*(sj3)*(sj4));
IKReal x632=((px)+(x631));
IKReal x633=((((-1.00000000000000)*(x632)))+(x630));
IKReal x634=((0.160000000000000)*(cj1));
IKReal x635=(cj3)*(cj3);
IKReal x636=(sj4)*(sj4);
IKReal x637=((0.103041000000000)*(cj1)*(x635)*(x636));
IKReal x638=(cj4)*(cj4);
IKReal x639=((0.103041000000000)*(cj1)*(x638));
IKReal x640=((0.256800000000000)*(cj1)*(cj4));
IKReal x641=((x640)+(x637)+(x634)+(x639));
IKReal x642=((-1.00000000000000)*(x641));
IKReal x643=((IKabs(x642) != 0)?((IKReal)1/(x642)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x643)*(((((-0.321000000000000)*(cj3)*(sj4)*(x633)))+(((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(cj1)))+(((0.321000000000000)*(cj1)*(cj4)))))))))), ((x643)*(((((-0.321000000000000)*(cj1)*(cj3)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((x633)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x644=((((-1.00000000000000)*(pz)))+(j0));
IKReal x645=((0.321000000000000)*(cj4)*(pz));
IKReal x646=((0.0321000000000000)*(cj3)*(sj4));
IKReal x647=((0.400000000000000)*(pz));
IKReal x648=((x647)+(x646)+(x645));
IKReal x649=((0.321000000000000)*(cj4)*(j0));
IKReal x650=((0.400000000000000)*(j0));
IKReal x651=((0.321000000000000)*(cj1)*(cj3)*(px)*(sj4));
IKReal x652=((0.321000000000000)*(cj3)*(py)*(sj1)*(sj4));
IKReal x653=((x649)+(x650)+(x651)+(x652));
IKReal x654=((((-1.00000000000000)*(x653)))+(x648));
IKReal x655=((IKabs(x654) != 0)?((IKReal)1/(x654)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x655)*(((((-1.00000000000000)*((x644)*(x644))))+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))))), ((x655)*(((((-0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x644)*(((0.100000000000000)+(((-1.00000000000000)*(cj1)*(px)))+(((-1.00000000000000)*(py)*(sj1)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x656=(cj4)*(cj4);
IKReal x657=((0.103041000000000)*(x656));
IKReal x658=(cj3)*(cj3);
IKReal x659=(sj4)*(sj4);
IKReal x660=((0.103041000000000)*(x658)*(x659));
IKReal x661=((0.256800000000000)*(cj4));
IKReal x662=((0.160000000000000)+(x657)+(x661)+(x660));
IKReal x663=((IKabs(x662) != 0)?((IKReal)1/(x662)):(IKReal)1.0e30);
IKReal x664=((((-1.00000000000000)*(pz)))+(j0));
IKReal x665=((0.321000000000000)*(cj4));
IKReal x666=((0.400000000000000)+(x665));
IKReal x667=((cj1)*(px));
IKReal x668=((py)*(sj1));
IKReal x669=((x668)+(x667));
IKReal x670=((0.100000000000000)+(((-1.00000000000000)*(x669))));
j2array[0]=IKatan2(((-1.00000000000000)*(x663)*(((((-0.321000000000000)*(cj3)*(sj4)*(x670)))+(((-1.00000000000000)*(x664)*(x666)))))), ((-1.00000000000000)*(x663)*(((((x666)*(x670)))+(((-0.321000000000000)*(cj3)*(sj4)*(x664)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}
}
}

}

}
    }

} else
{
}
}
}
return vsolutions.size()>0;
}
inline void rotationfunction0(std::vector<IKSolution>& vsolutions) {
IKReal x21=((cj2)*(cj4)*(sj1));
IKReal x22=((cj1)*(sj3)*(sj4));
IKReal x23=((x21)+(x22));
IKReal x24=((cj3)*(sj1)*(sj2)*(sj4));
IKReal x25=((((-1.00000000000000)*(x24)))+(x23));
IKReal x26=((cj1)*(cj2)*(cj4));
IKReal x27=((sj1)*(sj3)*(sj4));
IKReal x28=((cj1)*(cj3)*(sj2)*(sj4));
IKReal x29=((x27)+(x28));
IKReal x30=((((-1.00000000000000)*(x29)))+(x26));
IKReal x31=((cj4)*(sj2));
IKReal x32=((cj2)*(cj3)*(sj4));
IKReal x33=((x32)+(x31));
IKReal x34=((-1.00000000000000)*(x33));
IKReal x35=((cj1)*(cj3));
IKReal x36=((sj1)*(sj2)*(sj3));
IKReal x37=((x36)+(x35));
IKReal x38=((cj1)*(sj2)*(sj3));
IKReal x39=((cj3)*(sj1));
IKReal x40=((((-1.00000000000000)*(x39)))+(x38));
IKReal x41=((x31)*(x39));
IKReal x42=((cj2)*(sj1)*(sj4));
IKReal x43=((x42)+(x41));
IKReal x44=((cj1)*(cj4)*(sj3));
IKReal x45=((((-1.00000000000000)*(x44)))+(x43));
IKReal x46=((cj1)*(cj2)*(sj4));
IKReal x47=((x31)*(x35));
IKReal x48=((cj4)*(sj1)*(sj3));
IKReal x49=((x48)+(x46)+(x47));
IKReal x50=((cj2)*(cj3)*(cj4));
IKReal x51=((sj2)*(sj4));
IKReal x52=((x50)+(((-1.00000000000000)*(x51))));
new_r00=((((r20)*(x34)))+(((r00)*(x30)))+(((r10)*(x25))));
new_r01=((((r01)*(x30)))+(((r11)*(x25)))+(((r21)*(x34))));
new_r02=((((r22)*(x34)))+(((r12)*(x25)))+(((r02)*(x30))));
new_r10=((((r00)*(x40)))+(((r10)*(x37)))+(((cj2)*(r20)*(sj3))));
new_r11=((((r01)*(x40)))+(((r11)*(x37)))+(((cj2)*(r21)*(sj3))));
new_r12=((((cj2)*(r22)*(sj3)))+(((r02)*(x40)))+(((r12)*(x37))));
new_r20=((((r00)*(x49)))+(((r10)*(x45)))+(((r20)*(x52))));
new_r21=((((r01)*(x49)))+(((r21)*(x52)))+(((r11)*(x45))));
new_r22=((((r22)*(x52)))+(((r02)*(x49)))+(((r12)*(x45))));
{
IKReal j6eval;
j6eval=new_r00;
if( j6eval >= -1.000010 && j6eval <= -0.999990 )
{
{
j6 = 3.141593; sj6 = 0.000000; cj6 = -1.000000;
IKReal j5mul = 1;
j5=0;
IKReal j7mul=1.00000000000000;
j7=((-1.00000000000000)*(IKatan2(new_r12, new_r11)));
vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[5].fmul = j5mul;
solution.basesol[5].freeind = 0;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.basesol[7].fmul = j7mul;
solution.basesol[7].freeind = 0;
solution.vfree.resize(1);
solution.vfree[0] = 5;
}

} else
if( j6eval >= 0.999990 && j6eval <= 1.000010 )
{
{
j6 = 0.000000; sj6 = 0.000000; cj6 = 1.000000;
IKReal j5mul = 1;
j5=0;
IKReal j7mul=-1.00000000000000;
j7=((((-1.00000000000000)*(IKatan2(new_r21, ((-1.00000000000000)*(new_r22))))))+(((-1.00000000000000)*(3.14159265358979))));
vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[5].fmul = j5mul;
solution.basesol[5].freeind = 0;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.basesol[7].fmul = j7mul;
solution.basesol[7].freeind = 0;
solution.vfree.resize(1);
solution.vfree[0] = 5;
}

} else
{
{
IKReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
j5array[0]=IKatan2(new_r10, ((-1.00000000000000)*(new_r20)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1] = j5array[0] > 0 ? j5array[0]-IKPI : j5array[0]+IKPI;
sj5array[1] = -sj5array[0];
cj5array[1] = -cj5array[0];
if( j5array[0] > IKPI )
    j5array[0]-=IK2PI;
else if( j5array[0] < -IKPI )
    j5array[0]+=IK2PI;
j5valid[0] = true;
if( j5array[1] > IKPI )
    j5array[1]-=IK2PI;
else if( j5array[1] < -IKPI )
    j5array[1]+=IK2PI;
j5valid[1] = true;
if( j5valid[0] && j5valid[1] && IKabs(cj5array[0]-cj5array[1]) < 0.0001 && IKabs(sj5array[0]-sj5array[1]) < 0.0001 )
    j5valid[1]=false;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] ) { continue; }
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IKReal evalcond[1];
evalcond[0]=IKsin(j5);
if( IKabs(evalcond[0]) < 0.000010  )
{
{
IKReal j7array[1], cj7array[1], sj7array[1];
bool j7valid[1]={false};
IKReal x53=IKcos(j5);
IKReal x54=((IKabs(x53) != 0)?((IKReal)1/(x53)):(IKReal)1.0e30);
j7array[0]=IKatan2(((-1.00000000000000)*(new_r12)*(x54)), ((new_r11)*(x54)));
sj7array[0]=IKsin(j7array[0]);
cj7array[0]=IKcos(j7array[0]);
if( j7array[0] > IKPI )
    j7array[0]-=IK2PI;
else if( j7array[0] < -IKPI )
    j7array[0]+=IK2PI;
j7valid[0] = true;
for(int ij7 = 0; ij7 < 1; ++ij7)
{
if( !j7valid[ij7] ) { continue; }
j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

{
IKReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
j6array[0]=IKatan2(((-1.00000000000000)*(new_r20)*(((IKabs(IKcos(j5)) != 0)?((IKReal)1/(IKcos(j5))):(IKReal)1.0e30))), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
    j6array[0]-=IK2PI;
else if( j6array[0] < -IKPI )
    j6array[0]+=IK2PI;
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] ) { continue; }
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.vfree.resize(0);
}
}
}
}

} else
{
if( 1 )
{
{
IKReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
j6array[0]=IKatan2(((new_r10)*(((IKabs(sj5) != 0)?((IKReal)1/(sj5)):(IKReal)1.0e30))), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
    j6array[0]-=IK2PI;
else if( j6array[0] < -IKPI )
    j6array[0]+=IK2PI;
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] ) { continue; }
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IKReal evalcond[1];
evalcond[0]=IKsin(j6);
if( IKabs(evalcond[0]) < 0.000010  )
{
{
IKReal j7array[1], cj7array[1], sj7array[1];
bool j7valid[1]={false};
IKReal x55=IKcos(j6);
IKReal x56=((IKabs(x55) != 0)?((IKReal)1/(x55)):(IKReal)1.0e30);
IKReal x57=IKcos(j5);
IKReal x58=IKsin(j5);
j7array[0]=IKatan2(((((new_r21)*(x56)*(x57)))+(((-1.00000000000000)*(new_r11)*(x56)*(x58)))), ((((new_r21)*(x58)))+(((new_r11)*(x57)))));
sj7array[0]=IKsin(j7array[0]);
cj7array[0]=IKcos(j7array[0]);
if( j7array[0] > IKPI )
    j7array[0]-=IK2PI;
else if( j7array[0] < -IKPI )
    j7array[0]+=IK2PI;
j7valid[0] = true;
for(int ij7 = 0; ij7 < 1; ++ij7)
{
if( !j7valid[ij7] ) { continue; }
j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.vfree.resize(0);
}
}

} else
{
if( 1 )
{
{
IKReal j7array[1], cj7array[1], sj7array[1];
bool j7valid[1]={false};
IKReal x59=IKsin(j6);
IKReal x60=((IKabs(x59) != 0)?((IKReal)1/(x59)):(IKReal)1.0e30);
j7array[0]=IKatan2(((new_r01)*(x60)), ((new_r02)*(x60)));
sj7array[0]=IKsin(j7array[0]);
cj7array[0]=IKcos(j7array[0]);
if( j7array[0] > IKPI )
    j7array[0]-=IK2PI;
else if( j7array[0] < -IKPI )
    j7array[0]+=IK2PI;
j7valid[0] = true;
for(int ij7 = 0; ij7 < 1; ++ij7)
{
if( !j7valid[ij7] ) { continue; }
j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.vfree.resize(0);
}
}

} else
{
}
}
}
}
}

} else
{
}
}
}
}
}

}
}
}/// Durand-Kerner polynomial root finding method
static void polyroots3(IKReal rawcoeffs[3+1], IKReal rawroots[3], int& numroots)
{
    using std::complex;
    assert(rawcoeffs[0] != 0);
    const IKReal tol = 128.0*std::numeric_limits<IKReal>::epsilon();
    complex<IKReal> coeffs[3];
    const int maxsteps = 50;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IKReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IKReal> roots[3];
    IKReal err[3];
    roots[0] = complex<IKReal>(1,0);
    roots[1] = complex<IKReal>(0.4,0.9); // any complex number not a root of unity is works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IKReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }
    numroots = 0;
    for(int i = 0; i < 3; ++i) {
        if( IKabs(imag(roots[i])) < std::numeric_limits<IKReal>::epsilon() ) {
            rawroots[numroots++] = real(roots[i]);
        }
    }
}
static void polyroots2(IKReal rawcoeffs[2+1], IKReal rawroots[2], int& numroots) {
    IKReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = 0.5*(-rawcoeffs[1]+det)/rawcoeffs[0];
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
/// intersection of a conic and the unit circle
static void conicsolver(IKReal _C0[6], IKReal roots[4], int& numroots)
{
    // have to normalize _C0
    IKReal maxval = IKabs(_C0[0]);
    for(int i = 1; i < 6; ++i) {
        if( maxval < IKabs(_C0[i]) ) {
            maxval = IKabs(_C0[i]);
        }
    }
    IKReal C0[6];
    for(int i = 0; i < 6; ++i) {
        C0[i]=_C0[i]/maxval;
    }
    IKReal rawcoeffs[4] = {-1,
                           C0[5] - C0[0] - C0[3],
                           C0[0]*C0[5] + C0[3]*C0[5] - C0[0]*C0[3] + C0[1]*C0[1] - C0[2]*C0[2] - C0[4]*C0[4],
                           C0[0]*C0[3]*C0[5] + 2*C0[1]*C0[2]*C0[4] - C0[0]*C0[4]*C0[4] - C0[3]*C0[2]*C0[2] - C0[5]*C0[1]*C0[1]};
    IKReal proots[3];
    int numproots, numyroots;
    polyroots3(rawcoeffs,proots,numproots);
    if( numproots < 1 ) {
        return;
    }
    numroots = 0;
    int iroot=0;
    IKReal a, b, c, d, e, f;
    a = C0[0]+proots[iroot]; b = C0[1]; c = C0[3]+proots[iroot]; d = C0[2]; e = C0[4]; f = C0[5]-proots[iroot];
    IKReal adjugate[9] = {c*f-e*e, -b*f+e*d, b*e-c*d, -b*f+d*e, a*f-d*d, -a*e+b*d, b*e-d*c, -a*e+d*b, a*c-b*b};
    // find the greatest absolute value of adjugate and take that column
    int maxindex = 0;
    IKReal val = IKabs(adjugate[maxindex]);
    for(int i = 1; i < 9; ++i) {
        IKReal newval = IKabs(adjugate[i]);
        if( val < newval ) {
            val = newval;
            maxindex = i;
        }
    }
    maxindex = maxindex%3;
    if( adjugate[0] > 0 || adjugate[4] > 0 || adjugate[8] > 0 || adjugate[4*maxindex] >= 0 ) {
        // according to the structure of the matrix, should be always negative if a solution exists...
        return;
    }
    IKReal bmult = 1.0/IKsqrt(-adjugate[4*maxindex]);
    IKReal p[3] = {adjugate[maxindex]*bmult, adjugate[3+maxindex]*bmult, adjugate[6+maxindex]*bmult}; // intersection point
    // C = C0 - [p_x] = 2gh^t, C is rank1
    IKReal C[9] = {a,b+p[2],d-p[1],b-p[2],c,e+p[0],d+p[1],e-p[0],f};
    maxindex = 0;
    val = IKabs(C[maxindex]);
    for(int i = 1; i < 9; ++i) {
        IKReal newval = IKabs(C[i]);
        if( val < newval ) {
            val = newval;
            maxindex = i;
        }
    }
    int row = maxindex/3;
    int col = maxindex%3;
    IKReal lineequation[3], coeffs[3], yintersections[2];
    for(int i = 0; i < 2; ++i) {
        if( i == 0 ) {
            lineequation[0] = C[3*row];
            lineequation[1] = C[3*row+1];
            lineequation[2] = C[3*row+2];
        }
        else {
            lineequation[0] = C[col];
            lineequation[1] = C[3+col];
            lineequation[2] = C[6+col];
        }

        if( IKabs(lineequation[0]) < std::numeric_limits<IKReal>::epsilon() ) {
            yintersections[0] = -lineequation[2]/lineequation[1];
            IKReal x = 1-yintersections[0]*yintersections[0];
            if( x <= 0 && x > -std::numeric_limits<IKReal>::epsilon() ) {
                roots[numroots++] = yintersections[0] > 0 ? IKPI_2 : -IKPI_2;
            }
            else {
                x = IKsqrt(x);
                roots[numroots++] = IKatan2(yintersections[0], x);
                roots[numroots] = IKPI - roots[numroots-1]; numroots++;
            }
        }
        else {
            coeffs[0] = lineequation[0]*lineequation[0]+lineequation[1]*lineequation[1];
            coeffs[1] = 2*lineequation[1]*lineequation[2];
            coeffs[2] = lineequation[2]*lineequation[2]-lineequation[0]*lineequation[0];
            polyroots2(coeffs,yintersections,numyroots);
            for(int j = 0; j < numyroots; ++j) {
                // the mathematical solution would be: IKatan2(yintersections[j],-(lineequation[1]*yintersections[j]+lineequation[2])/lineequation[0]);
                // however due to numerical imprecisions, it is better to compute sqrt(1-yintersections[j]*yintersections[j]) and choose sign 
                IKReal x = 1-yintersections[j]*yintersections[j];
                if( x <= 0 ) {
                    if( x > -std::numeric_limits<IKReal>::epsilon() ) {
                        roots[numroots++] = IKatan2(yintersections[j],-(lineequation[1]*yintersections[j]+lineequation[2])/lineequation[0]);
                    }
                }
                else {
                    x = IKsqrt(x);
                    if( (lineequation[1]*yintersections[j]+lineequation[2])/lineequation[0] > 0 ) {
                        x = -x;
                    }
                    roots[numroots++] = IKatan2(yintersections[j],x);
                }
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
IKSolver solver;
return solver.ik(eetrans,eerot,pfree,vsolutions);
}

IKFAST_API const char* getKinematicsHash() { return "f2324dbb615f48445f43ce827edef614"; }

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\n");
    }
    return 0;
}

#endif
