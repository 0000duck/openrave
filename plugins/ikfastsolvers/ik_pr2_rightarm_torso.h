/// autogenerated analytical inverse kinematics code from ikfast program
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// generated 2010-11-30 20:04:59.180509
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object:
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -shared -Wl,-soname,ik.so -o ik.so ik.cpp
#include <cmath>
#include <cassert>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IK2PI  6.28318530717959
#define IKPI  3.14159265358979
#define IKPI_2  1.57079632679490

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#endif // _MSC_VER

// defined when creating a shared object/dll
#ifdef IKFAST_CLIBRARY
#ifdef _MSC_VER
#define IKFAST_API extern "C" __declspec(dllexport)
#else
#define IKFAST_API extern "C"
#endif
#else
#define IKFAST_API
#endif

typedef double IKReal;
class IKSolution
{
public:
    /// Gets a solution given its free parameters
    /// \param pfree The free parameters required, range is in [-pi,pi]
    void GetSolution(IKReal* psolution, const IKReal* pfree) const {
        for(size_t i = 0; i < basesol.size(); ++i) {
            if( basesol[i].freeind < 0 )
                psolution[i] = basesol[i].foffset;
            else {
                assert(pfree != NULL);
                psolution[i] = pfree[basesol[i].freeind]*basesol[i].fmul + basesol[i].foffset;
                if( psolution[i] > IKPI )
                    psolution[i] -= IK2PI;
                else if( psolution[i] < -IKPI )
                    psolution[i] += IK2PI;
            }
        }
    }

    /// Gets the free parameters the solution requires to be set before a full solution can be returned
    /// \return vector of indices indicating the free parameters
    const std::vector<int>& GetFree() const { return vfree; }

    struct VARIABLE
    {
        VARIABLE() : freeind(-1), fmul(0), foffset(0) {}
        VARIABLE(int freeind, IKReal fmul, IKReal foffset) : freeind(freeind), fmul(fmul), foffset(foffset) {}
        int freeind;
        IKReal fmul, foffset; ///< joint value is fmul*sol[freeind]+foffset
    };

    std::vector<VARIABLE> basesol;       ///< solution and their offsets if joints are mimiced
    std::vector<int> vfree;
};

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

inline float IKasin(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asinf(f);
}
inline double IKasin(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline float IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
assert( f > -1.001f && f < 1.001f ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0f;
return acosf(f);
}
inline double IKacos(double f)
{
assert( f > -1.001 && f < 1.001 ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0.0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2f(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        assert(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) )
        return 0;
    return atan2(fy,fx);
}

IKFAST_API int getNumFreeParameters() { return 2; }
IKFAST_API int* getFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int getNumJoints() { return 8; }

IKFAST_API int getIKRealSize() { return sizeof(IKReal); }

IKFAST_API int getIKType() { return 1; }

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void fk(const IKReal* j, IKReal* eetrans, IKReal* eerot) {
IKReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13;
x0=IKcos(j[3]);
x1=IKsin(j[6]);
x2=IKcos(j[1]);
x3=IKcos(j[4]);
x4=IKcos(j[6]);
x5=IKsin(j[1]);
x6=IKsin(j[2]);
x7=IKsin(j[4]);
x8=IKcos(j[5]);
x9=IKsin(j[3]);
x10=IKcos(j[2]);
x11=IKsin(j[5]);
x12=IKcos(j[7]);
x13=IKsin(j[7]);
eerot[0]=((((x0)*(x2)*(x4)*(x6)*(x7)))+(((x0)*(x1)*(x11)*(x5)))+(((x4)*(x5)*(x7)*(x9)))+(((-1.00000000000000)*(x1)*(x10)*(x2)*(x7)*(x8)))+(((x1)*(x3)*(x5)*(x8)*(x9)))+(((x10)*(x2)*(x3)*(x4)))+(((-1.00000000000000)*(x1)*(x11)*(x2)*(x6)*(x9)))+(((x0)*(x1)*(x2)*(x3)*(x6)*(x8))));
eerot[1]=((((x11)*(x13)*(x2)*(x4)*(x6)*(x9)))+(((x1)*(x10)*(x13)*(x2)*(x3)))+(((x1)*(x13)*(x5)*(x7)*(x9)))+(((x10)*(x13)*(x2)*(x4)*(x7)*(x8)))+(((-1.00000000000000)*(x0)*(x11)*(x13)*(x4)*(x5)))+(((-1.00000000000000)*(x13)*(x3)*(x4)*(x5)*(x8)*(x9)))+(((x0)*(x1)*(x13)*(x2)*(x6)*(x7)))+(((-1.00000000000000)*(x11)*(x12)*(x3)*(x5)*(x9)))+(((-1.00000000000000)*(x0)*(x11)*(x12)*(x2)*(x3)*(x6)))+(((-1.00000000000000)*(x12)*(x2)*(x6)*(x8)*(x9)))+(((-1.00000000000000)*(x0)*(x13)*(x2)*(x3)*(x4)*(x6)*(x8)))+(((x0)*(x12)*(x5)*(x8)))+(((x10)*(x11)*(x12)*(x2)*(x7))));
eerot[2]=((((x0)*(x11)*(x13)*(x2)*(x3)*(x6)))+(((x11)*(x13)*(x3)*(x5)*(x9)))+(((-1.00000000000000)*(x10)*(x11)*(x13)*(x2)*(x7)))+(((-1.00000000000000)*(x0)*(x13)*(x5)*(x8)))+(((x10)*(x12)*(x2)*(x4)*(x7)*(x8)))+(((-1.00000000000000)*(x12)*(x3)*(x4)*(x5)*(x8)*(x9)))+(((-1.00000000000000)*(x0)*(x12)*(x2)*(x3)*(x4)*(x6)*(x8)))+(((x13)*(x2)*(x6)*(x8)*(x9)))+(((x0)*(x1)*(x12)*(x2)*(x6)*(x7)))+(((x1)*(x10)*(x12)*(x2)*(x3)))+(((-1.00000000000000)*(x0)*(x11)*(x12)*(x4)*(x5)))+(((x11)*(x12)*(x2)*(x4)*(x6)*(x9)))+(((x1)*(x12)*(x5)*(x7)*(x9))));
eetrans[0]=((-0.0500000000000000)+(((-0.180000000000000)*(x1)*(x10)*(x2)*(x7)*(x8)))+(((0.180000000000000)*(x0)*(x1)*(x11)*(x5)))+(((0.321000000000000)*(x5)*(x7)*(x9)))+(((0.100000000000000)*(x2)))+(((-0.180000000000000)*(x1)*(x11)*(x2)*(x6)*(x9)))+(((0.180000000000000)*(x1)*(x3)*(x5)*(x8)*(x9)))+(((0.321000000000000)*(x0)*(x2)*(x6)*(x7)))+(((0.180000000000000)*(x4)*(x5)*(x7)*(x9)))+(((0.180000000000000)*(x0)*(x2)*(x4)*(x6)*(x7)))+(((0.321000000000000)*(x10)*(x2)*(x3)))+(((0.400000000000000)*(x10)*(x2)))+(((0.180000000000000)*(x0)*(x1)*(x2)*(x3)*(x6)*(x8)))+(((0.180000000000000)*(x10)*(x2)*(x3)*(x4))));
eerot[3]=((((-1.00000000000000)*(x1)*(x2)*(x3)*(x8)*(x9)))+(((x0)*(x1)*(x3)*(x5)*(x6)*(x8)))+(((-1.00000000000000)*(x2)*(x4)*(x7)*(x9)))+(((x0)*(x4)*(x5)*(x6)*(x7)))+(((-1.00000000000000)*(x1)*(x10)*(x5)*(x7)*(x8)))+(((-1.00000000000000)*(x0)*(x1)*(x11)*(x2)))+(((x10)*(x3)*(x4)*(x5)))+(((-1.00000000000000)*(x1)*(x11)*(x5)*(x6)*(x9))));
eerot[4]=((((x0)*(x11)*(x13)*(x2)*(x4)))+(((-1.00000000000000)*(x12)*(x5)*(x6)*(x8)*(x9)))+(((-1.00000000000000)*(x1)*(x13)*(x2)*(x7)*(x9)))+(((-1.00000000000000)*(x0)*(x12)*(x2)*(x8)))+(((-1.00000000000000)*(x0)*(x11)*(x12)*(x3)*(x5)*(x6)))+(((x10)*(x11)*(x12)*(x5)*(x7)))+(((x13)*(x2)*(x3)*(x4)*(x8)*(x9)))+(((x1)*(x10)*(x13)*(x3)*(x5)))+(((x0)*(x1)*(x13)*(x5)*(x6)*(x7)))+(((x10)*(x13)*(x4)*(x5)*(x7)*(x8)))+(((x11)*(x13)*(x4)*(x5)*(x6)*(x9)))+(((-1.00000000000000)*(x0)*(x13)*(x3)*(x4)*(x5)*(x6)*(x8)))+(((x11)*(x12)*(x2)*(x3)*(x9))));
eerot[5]=((((x0)*(x1)*(x12)*(x5)*(x6)*(x7)))+(((x0)*(x11)*(x13)*(x3)*(x5)*(x6)))+(((-1.00000000000000)*(x1)*(x12)*(x2)*(x7)*(x9)))+(((x12)*(x2)*(x3)*(x4)*(x8)*(x9)))+(((x13)*(x5)*(x6)*(x8)*(x9)))+(((x0)*(x11)*(x12)*(x2)*(x4)))+(((x0)*(x13)*(x2)*(x8)))+(((x11)*(x12)*(x4)*(x5)*(x6)*(x9)))+(((-1.00000000000000)*(x11)*(x13)*(x2)*(x3)*(x9)))+(((x1)*(x10)*(x12)*(x3)*(x5)))+(((x10)*(x12)*(x4)*(x5)*(x7)*(x8)))+(((-1.00000000000000)*(x10)*(x11)*(x13)*(x5)*(x7)))+(((-1.00000000000000)*(x0)*(x12)*(x3)*(x4)*(x5)*(x6)*(x8))));
eetrans[1]=((-0.188000000000000)+(((0.180000000000000)*(x0)*(x1)*(x3)*(x5)*(x6)*(x8)))+(((-0.180000000000000)*(x0)*(x1)*(x11)*(x2)))+(((0.321000000000000)*(x10)*(x3)*(x5)))+(((-0.180000000000000)*(x1)*(x10)*(x5)*(x7)*(x8)))+(((-0.321000000000000)*(x2)*(x7)*(x9)))+(((0.321000000000000)*(x0)*(x5)*(x6)*(x7)))+(((0.100000000000000)*(x5)))+(((0.180000000000000)*(x0)*(x4)*(x5)*(x6)*(x7)))+(((0.180000000000000)*(x10)*(x3)*(x4)*(x5)))+(((-0.180000000000000)*(x1)*(x11)*(x5)*(x6)*(x9)))+(((-0.180000000000000)*(x1)*(x2)*(x3)*(x8)*(x9)))+(((-0.180000000000000)*(x2)*(x4)*(x7)*(x9)))+(((0.400000000000000)*(x10)*(x5))));
eerot[6]=((((x1)*(x6)*(x7)*(x8)))+(((x0)*(x10)*(x4)*(x7)))+(((-1.00000000000000)*(x1)*(x10)*(x11)*(x9)))+(((x0)*(x1)*(x10)*(x3)*(x8)))+(((-1.00000000000000)*(x3)*(x4)*(x6))));
eerot[7]=((((-1.00000000000000)*(x0)*(x10)*(x13)*(x3)*(x4)*(x8)))+(((-1.00000000000000)*(x1)*(x13)*(x3)*(x6)))+(((-1.00000000000000)*(x13)*(x4)*(x6)*(x7)*(x8)))+(((x10)*(x11)*(x13)*(x4)*(x9)))+(((-1.00000000000000)*(x10)*(x12)*(x8)*(x9)))+(((x0)*(x1)*(x10)*(x13)*(x7)))+(((-1.00000000000000)*(x0)*(x10)*(x11)*(x12)*(x3)))+(((-1.00000000000000)*(x11)*(x12)*(x6)*(x7))));
eerot[8]=((((x0)*(x1)*(x10)*(x12)*(x7)))+(((x11)*(x13)*(x6)*(x7)))+(((x10)*(x13)*(x8)*(x9)))+(((x10)*(x11)*(x12)*(x4)*(x9)))+(((x0)*(x10)*(x11)*(x13)*(x3)))+(((-1.00000000000000)*(x0)*(x10)*(x12)*(x3)*(x4)*(x8)))+(((-1.00000000000000)*(x1)*(x12)*(x3)*(x6)))+(((-1.00000000000000)*(x12)*(x4)*(x6)*(x7)*(x8))));
eetrans[2]=((0.739680000000000)+(((-0.180000000000000)*(x1)*(x10)*(x11)*(x9)))+(((0.321000000000000)*(x0)*(x10)*(x7)))+(((-0.180000000000000)*(x3)*(x4)*(x6)))+(((-0.321000000000000)*(x3)*(x6)))+(((0.180000000000000)*(x1)*(x6)*(x7)*(x8)))+(((0.180000000000000)*(x0)*(x10)*(x4)*(x7)))+(((0.180000000000000)*(x0)*(x1)*(x10)*(x3)*(x8)))+(j[0])+(((-0.400000000000000)*(x6))));
}

class IKSolver {
public:
IKReal j1, cj1, sj1,
j2, cj2, sj2,
j4, cj4, sj4,
j5, cj5, sj5,
j6, cj6, sj6,
j7, cj7, sj7,
j0, cj0, sj0,
j3, cj3, sj3,
new_r00, r00,
new_r01, r01,
new_r02, r02,
new_r10, r10,
new_r11, r11,
new_r12, r12,
new_r20, r20,
new_r21, r21,
new_r22, r22,
new_px, new_py, new_pz, px, py, pz;

bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
vsolutions.resize(0); vsolutions.reserve(8);
j0=pfree[0]; cj0=cos(pfree[0]); sj0=sin(pfree[0]);
j3=pfree[1]; cj3=cos(pfree[1]); sj3=sin(pfree[1]);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((0.0500000000000000)+(px)+(((-0.180000000000000)*(r00))));
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((0.188000000000000)+(py)+(((-0.180000000000000)*(r10))));
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=((-0.739680000000000)+(pz)+(((-0.180000000000000)*(r20))));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
{
if( 1 )
{
IKReal coniccoeffs[6], j1array[4];
int numsolutions;
IKReal x0=(px)*(px);
IKReal x1=(sj3)*(sj3);
IKReal x2=(py)*(py);
IKReal x3=(pz)*(pz);
IKReal x4=(j0)*(j0);
IKReal x5=((0.0164865600000000)*(x0));
coniccoeffs[0]=((x5)+(((-0.0164865600000000)*(x2)))+(((-0.00103041000000000)*(x0)*(x1)))+(((0.00103041000000000)*(x1)*(x2))));
coniccoeffs[1]=((((-0.00103041000000000)*(px)*(py)*(x1)))+(((0.0164865600000000)*(px)*(py))));
coniccoeffs[2]=((((0.00515205000000000)*(px)*(x1)*(x3)))+(((0.00515205000000000)*(px)*(x1)*(x2)))+(((0.00515205000000000)*(px)*(x1)*(x4)))+(((0.00515205000000000)*(px)*(x0)*(x1)))+(((-0.00130367988405000)*(px)*(x1)))+(((-0.0103041000000000)*(j0)*(px)*(pz)*(x1))));
coniccoeffs[3]=0;
coniccoeffs[4]=((((0.00515205000000000)*(py)*(x1)*(x2)))+(((0.00515205000000000)*(py)*(x1)*(x3)))+(((0.00515205000000000)*(py)*(x1)*(x4)))+(((0.00515205000000000)*(py)*(x0)*(x1)))+(((-0.0103041000000000)*(j0)*(py)*(pz)*(x1)))+(((-0.00130367988405000)*(py)*(x1))));
coniccoeffs[5]=((((-0.154561500000000)*(x1)*(x3)*(x4)))+(((-0.0257602500000000)*(x1)*((x4)*(x4))))+(((-0.0257602500000000)*(x1)*((x0)*(x0))))+(((-0.0515205000000000)*(x1)*(x2)*(x4)))+(((-0.0515205000000000)*(x1)*(x2)*(x3)))+(((-0.0257602500000000)*(x1)*((x2)*(x2))))+(((-0.0515205000000000)*(x0)*(x1)*(x3)))+(((-0.0515205000000000)*(x0)*(x1)*(x2)))+(((-0.0515205000000000)*(x0)*(x1)*(x4)))+(((-0.0257602500000000)*(x1)*((x3)*(x3))))+(((-1.00000000000000)*(x5)))+(((0.0130367988405000)*(x1)*(x3)))+(((0.0130367988405000)*(x1)*(x4)))+(((4.93693212605198e-5)*(x1)))+(((0.0130367988405000)*(x0)*(x1)))+(((0.103041000000000)*(j0)*(pz)*(x0)*(x1)))+(((-0.0260735976810000)*(j0)*(pz)*(x1)))+(((0.103041000000000)*(j0)*(pz)*(x1)*(x4)))+(((0.103041000000000)*(j0)*(pz)*(x1)*(x2)))+(((0.103041000000000)*(j0)*(pz)*(x1)*(x3)))+(((0.0120063888405000)*(x1)*(x2))));
conicsolver(coniccoeffs,j1array,numsolutions);
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
{
    j1 = j1array[ij1]; cj1 = IKcos(j1); sj1 = IKsin(j1);

{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((1.60000000000000)*(j0)*(pz)*(sj3)))+(((0.160000000000000)*(cj1)*(px)*(sj3)))+(((-0.800000000000000)*(sj3)*((pz)*(pz))))+(((-1.60000000000000)*(cj1)*(px)*(py)*(sj1)*(sj3)))+(((0.160000000000000)*(py)*(sj1)*(sj3)))+(((-0.00800000000000000)*(sj3)))+(((-0.800000000000000)*(sj3)*((cj1)*(cj1))*((px)*(px))))+(((-0.800000000000000)*(sj3)*((j0)*(j0))))+(((-0.800000000000000)*(sj3)*((py)*(py))*((sj1)*(sj1)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[3];
IKReal x6=((px)*(sj1));
IKReal x7=((cj1)*(py));
IKReal x8=((x6)+(((-1.00000000000000)*(x7))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x8;
evalcond[2]=x8;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
cj4array[0]=((-0.985362149532710)+(((-7.78816199376947)*(j0)*(pz)))+(((3.89408099688473)*((j0)*(j0))))+(((3.89408099688473)*((pz)*(pz))))+(((3.89408099688473)*((px)*(px))))+(((-0.778816199376947)*(py)*(sj1)))+(((3.89408099688473)*((py)*(py))))+(((-0.778816199376947)*(cj1)*(px))));
if( cj4array[0] >= -1.0001 && cj4array[0] <= 1.0001 )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
if( j4valid[0] && j4valid[1] && IKabs(cj4array[0]-cj4array[1]) < 0.0001 && IKabs(sj4array[0]-sj4array[1]) < 0.0001 )
    j4valid[1]=false;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.160000000000000)*(cj1)))+(((-0.256800000000000)*(cj1)*(cj4)))+(((-0.103041000000000)*(cj1)*((sj4)*(sj4))))+(((-0.103041000000000)*(cj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.103041000000000)*(sj1)*((sj4)*(sj4))))+(((-0.256800000000000)*(cj4)*(sj1)))+(((-0.160000000000000)*(sj1)))+(((-0.103041000000000)*(sj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x9=((-1.00000000000000)*(py));
evalcond[0]=((IKfmod(((3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x9;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(px)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x9;
evalcond[4]=x9;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(px)))+(((-0.321000000000000)*(cj4)*(px)))+(((-0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.321000000000000)*(cj4)*(pz)))+(((0.321000000000000)*(px)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x10=((((-1.00000000000000)*(pz)))+(j0));
IKReal x11=((0.400000000000000)*(pz));
IKReal x12=((0.321000000000000)*(cj4)*(pz));
IKReal x13=((0.321000000000000)*(px)*(sj4));
IKReal x14=((x11)+(x13)+(x12));
IKReal x15=((0.400000000000000)*(j0));
IKReal x16=((0.321000000000000)*(cj4)*(j0));
IKReal x17=((0.0321000000000000)*(sj4));
IKReal x18=((x15)+(x17)+(x16));
IKReal x19=((((-1.00000000000000)*(x18)))+(x14));
IKReal x20=((IKabs(x19) != 0)?((IKReal)1/(x19)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x20)*(((((-1.00000000000000)*((x10)*(x10))))+(((0.103041000000000)*((sj4)*(sj4))))))), ((x20)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x10)*(((0.100000000000000)+(((-1.00000000000000)*(px)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x62=((0.100000000000000)+(((-1.00000000000000)*(px))));
IKReal x63=((0.321000000000000)*(pz)*(sj4));
IKReal x64=((0.0321000000000000)*(cj4));
IKReal x65=((0.0400000000000000)+(x63)+(x64));
IKReal x66=((0.400000000000000)*(px));
IKReal x67=((0.321000000000000)*(j0)*(sj4));
IKReal x68=((0.321000000000000)*(cj4)*(px));
IKReal x69=((x66)+(x67)+(x68));
IKReal x70=((x65)+(((-1.00000000000000)*(x69))));
IKReal x71=((IKabs(x70) != 0)?((IKReal)1/(x70)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x71)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x62)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x71)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x62)*(x62))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x72=((0.256800000000000)*(cj4));
IKReal x73=(sj4)*(sj4);
IKReal x74=((0.103041000000000)*(x73));
IKReal x75=(cj4)*(cj4);
IKReal x76=((0.103041000000000)*(x75));
IKReal x77=((0.160000000000000)+(x76)+(x74)+(x72));
IKReal x78=((IKabs(x77) != 0)?((IKReal)1/(x77)):(IKReal)1.0e30);
IKReal x79=((((-1.00000000000000)*(pz)))+(j0));
IKReal x80=((0.321000000000000)*(cj4));
IKReal x81=((0.400000000000000)+(x80));
IKReal x82=((0.100000000000000)+(((-1.00000000000000)*(px))));
j2array[0]=IKatan2(((-1.00000000000000)*(x78)*(((((-1.00000000000000)*(x79)*(x81)))+(((0.321000000000000)*(sj4)*(x82)))))), ((-1.00000000000000)*(x78)*(((((x81)*(x82)))+(((0.321000000000000)*(sj4)*(x79)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(px)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(j0)*(sj4)))+(((0.400000000000000)*(px)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(cj4)*(px)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(px)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x83=((((-1.00000000000000)*(pz)))+(j0));
IKReal x84=((0.400000000000000)*(pz));
IKReal x85=((0.321000000000000)*(cj4)*(pz));
IKReal x86=((x84)+(x85));
IKReal x87=((0.400000000000000)*(j0));
IKReal x88=((0.321000000000000)*(cj4)*(j0));
IKReal x89=((0.0321000000000000)*(sj4));
IKReal x90=((0.321000000000000)*(px)*(sj4));
IKReal x91=((x88)+(x89)+(x87)+(x90));
IKReal x92=((x86)+(((-1.00000000000000)*(x91))));
IKReal x93=((IKabs(x92) != 0)?((IKReal)1/(x92)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x93)*(((((-1.00000000000000)*((x83)*(x83))))+(((0.103041000000000)*((sj4)*(sj4))))))), ((x93)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x83)*(((0.100000000000000)+(px)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x94=((0.100000000000000)+(px));
IKReal x95=((0.400000000000000)*(px));
IKReal x96=((0.321000000000000)*(pz)*(sj4));
IKReal x97=((0.321000000000000)*(cj4)*(px));
IKReal x98=((0.0321000000000000)*(cj4));
IKReal x99=((0.0400000000000000)+(x98)+(x95)+(x97)+(x96));
IKReal x100=((0.321000000000000)*(j0)*(sj4));
IKReal x101=((((-1.00000000000000)*(x100)))+(x99));
IKReal x102=((IKabs(x101) != 0)?((IKReal)1/(x101)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x102)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x94)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x102)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x94)*(x94))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x103=((0.256800000000000)*(cj4));
IKReal x104=(sj4)*(sj4);
IKReal x105=((0.103041000000000)*(x104));
IKReal x106=(cj4)*(cj4);
IKReal x107=((0.103041000000000)*(x106));
IKReal x108=((0.160000000000000)+(x105)+(x107)+(x103));
IKReal x109=((IKabs(x108) != 0)?((IKReal)1/(x108)):(IKReal)1.0e30);
IKReal x110=((0.100000000000000)+(px));
IKReal x111=((0.321000000000000)*(cj4));
IKReal x112=((0.400000000000000)+(x111));
IKReal x113=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x109)*(((((0.321000000000000)*(sj4)*(x110)))+(((-1.00000000000000)*(x112)*(x113)))))), ((-1.00000000000000)*(x109)*(((((0.321000000000000)*(sj4)*(x113)))+(((x110)*(x112)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(py)))+(((-0.321000000000000)*(cj4)*(py)))+(((-0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.321000000000000)*(py)*(sj4)))+(((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x114=((((-1.00000000000000)*(pz)))+(j0));
IKReal x115=((0.321000000000000)*(py)*(sj4));
IKReal x116=((0.400000000000000)*(pz));
IKReal x117=((0.321000000000000)*(cj4)*(pz));
IKReal x118=((x117)+(x116)+(x115));
IKReal x119=((0.400000000000000)*(j0));
IKReal x120=((0.321000000000000)*(cj4)*(j0));
IKReal x121=((0.0321000000000000)*(sj4));
IKReal x122=((x120)+(x121)+(x119));
IKReal x123=((((-1.00000000000000)*(x122)))+(x118));
IKReal x124=((IKabs(x123) != 0)?((IKReal)1/(x123)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x124)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x114)*(x114))))))), ((x124)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x114)*(((0.100000000000000)+(((-1.00000000000000)*(py)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x125=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x126=((0.321000000000000)*(pz)*(sj4));
IKReal x127=((0.0321000000000000)*(cj4));
IKReal x128=((0.0400000000000000)+(x126)+(x127));
IKReal x129=((0.400000000000000)*(py));
IKReal x130=((0.321000000000000)*(j0)*(sj4));
IKReal x131=((0.321000000000000)*(cj4)*(py));
IKReal x132=((x131)+(x130)+(x129));
IKReal x133=((x128)+(((-1.00000000000000)*(x132))));
IKReal x134=((IKabs(x133) != 0)?((IKReal)1/(x133)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x134)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x125)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x134)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x125)*(x125))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x135=((0.256800000000000)*(cj4));
IKReal x136=(sj4)*(sj4);
IKReal x137=((0.103041000000000)*(x136));
IKReal x138=(cj4)*(cj4);
IKReal x139=((0.103041000000000)*(x138));
IKReal x140=((0.160000000000000)+(x135)+(x137)+(x139));
IKReal x141=((IKabs(x140) != 0)?((IKReal)1/(x140)):(IKReal)1.0e30);
IKReal x142=((0.321000000000000)*(cj4));
IKReal x143=((0.400000000000000)+(x142));
IKReal x144=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x145=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x141)*(((((-1.00000000000000)*(x143)*(x145)))+(((0.321000000000000)*(sj4)*(x144)))))), ((-1.00000000000000)*(x141)*(((((0.321000000000000)*(sj4)*(x145)))+(((x143)*(x144)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x146=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x146;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(py)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x146;
evalcond[4]=x146;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(j0)*(sj4)))+(((0.400000000000000)*(py)))+(((0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(cj4)*(py)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.0321000000000000)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(py)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x147=((((-1.00000000000000)*(pz)))+(j0));
IKReal x148=((0.400000000000000)*(pz));
IKReal x149=((0.321000000000000)*(cj4)*(pz));
IKReal x150=((x148)+(x149));
IKReal x151=((0.400000000000000)*(j0));
IKReal x152=((0.321000000000000)*(py)*(sj4));
IKReal x153=((0.321000000000000)*(cj4)*(j0));
IKReal x154=((0.0321000000000000)*(sj4));
IKReal x155=((x154)+(x153)+(x152)+(x151));
IKReal x156=((((-1.00000000000000)*(x155)))+(x150));
IKReal x157=((IKabs(x156) != 0)?((IKReal)1/(x156)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x157)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x147)*(x147))))))), ((x157)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x147)*(((0.100000000000000)+(py)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x158=((0.100000000000000)+(py));
IKReal x159=((0.400000000000000)*(py));
IKReal x160=((0.321000000000000)*(pz)*(sj4));
IKReal x161=((0.321000000000000)*(cj4)*(py));
IKReal x162=((0.0321000000000000)*(cj4));
IKReal x163=((0.0400000000000000)+(x162)+(x160)+(x161)+(x159));
IKReal x164=((0.321000000000000)*(j0)*(sj4));
IKReal x165=((((-1.00000000000000)*(x164)))+(x163));
IKReal x166=((IKabs(x165) != 0)?((IKReal)1/(x165)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x166)*(((((x158)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))), ((x166)*(((((-1.00000000000000)*((x158)*(x158))))+(((0.103041000000000)*((sj4)*(sj4))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x167=((0.256800000000000)*(cj4));
IKReal x168=(sj4)*(sj4);
IKReal x169=((0.103041000000000)*(x168));
IKReal x170=(cj4)*(cj4);
IKReal x171=((0.103041000000000)*(x170));
IKReal x172=((0.160000000000000)+(x171)+(x169)+(x167));
IKReal x173=((IKabs(x172) != 0)?((IKReal)1/(x172)):(IKReal)1.0e30);
IKReal x174=((0.100000000000000)+(py));
IKReal x175=((0.321000000000000)*(cj4));
IKReal x176=((0.400000000000000)+(x175));
IKReal x177=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x173)*(((((0.321000000000000)*(sj4)*(x174)))+(((-1.00000000000000)*(x176)*(x177)))))), ((-1.00000000000000)*(x173)*(((((0.321000000000000)*(sj4)*(x177)))+(((x174)*(x176)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x178=((0.100000000000000)*(sj1));
IKReal x179=((x178)+(((-1.00000000000000)*(py))));
IKReal x180=(cj4)*(cj4);
IKReal x181=((0.103041000000000)*(sj1)*(x180));
IKReal x182=(sj4)*(sj4);
IKReal x183=((0.103041000000000)*(sj1)*(x182));
IKReal x184=((0.256800000000000)*(cj4)*(sj1));
IKReal x185=((0.160000000000000)*(sj1));
IKReal x186=((x184)+(x185)+(x181)+(x183));
IKReal x187=((-1.00000000000000)*(x186));
IKReal x188=((IKabs(x187) != 0)?((IKReal)1/(x187)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x188)*(((((0.321000000000000)*(sj4)*(x179)))+(((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(sj1)))+(((0.321000000000000)*(cj4)*(sj1)))))))))), ((x188)*(((((x179)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((0.321000000000000)*(sj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x189=((0.100000000000000)*(cj1));
IKReal x190=((x189)+(((-1.00000000000000)*(px))));
IKReal x191=((0.256800000000000)*(cj1)*(cj4));
IKReal x192=(sj4)*(sj4);
IKReal x193=((0.103041000000000)*(cj1)*(x192));
IKReal x194=((0.160000000000000)*(cj1));
IKReal x195=(cj4)*(cj4);
IKReal x196=((0.103041000000000)*(cj1)*(x195));
IKReal x197=((x193)+(x191)+(x196)+(x194));
IKReal x198=((-1.00000000000000)*(x197));
IKReal x199=((IKabs(x198) != 0)?((IKReal)1/(x198)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x199)*(((((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(cj1)))+(((0.321000000000000)*(cj1)*(cj4)))))))+(((0.321000000000000)*(sj4)*(x190)))))), ((x199)*(((((0.321000000000000)*(cj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((x190)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x200=((0.256800000000000)*(cj4));
IKReal x201=(sj4)*(sj4);
IKReal x202=((0.103041000000000)*(x201));
IKReal x203=(cj4)*(cj4);
IKReal x204=((0.103041000000000)*(x203));
IKReal x205=((0.160000000000000)+(x204)+(x202)+(x200));
IKReal x206=((IKabs(x205) != 0)?((IKReal)1/(x205)):(IKReal)1.0e30);
IKReal x207=((0.321000000000000)*(cj4));
IKReal x208=((0.400000000000000)+(x207));
IKReal x209=((cj1)*(px));
IKReal x210=((py)*(sj1));
IKReal x211=((x210)+(x209));
IKReal x212=((0.100000000000000)+(((-1.00000000000000)*(x211))));
IKReal x213=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x206)*(((((0.321000000000000)*(sj4)*(x212)))+(((-1.00000000000000)*(x208)*(x213)))))), ((-1.00000000000000)*(x206)*(((((x208)*(x212)))+(((0.321000000000000)*(sj4)*(x213)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}
}
}

} else
{
IKReal x214=((cj1)*(py));
IKReal x215=((px)*(sj1));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-3.14159265358979)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((x215)+(((-1.00000000000000)*(x214))));
evalcond[2]=((x214)+(((-1.00000000000000)*(x215))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
cj4array[0]=((-0.985362149532710)+(((-7.78816199376947)*(j0)*(pz)))+(((3.89408099688473)*((j0)*(j0))))+(((3.89408099688473)*((pz)*(pz))))+(((3.89408099688473)*((px)*(px))))+(((-0.778816199376947)*(py)*(sj1)))+(((3.89408099688473)*((py)*(py))))+(((-0.778816199376947)*(cj1)*(px))));
if( cj4array[0] >= -1.0001 && cj4array[0] <= 1.0001 )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
if( j4valid[0] && j4valid[1] && IKabs(cj4array[0]-cj4array[1]) < 0.0001 && IKabs(sj4array[0]-sj4array[1]) < 0.0001 )
    j4valid[1]=false;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.160000000000000)*(cj1)))+(((-0.256800000000000)*(cj1)*(cj4)))+(((-0.103041000000000)*(cj1)*((sj4)*(sj4))))+(((-0.103041000000000)*(cj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.103041000000000)*(sj1)*((sj4)*(sj4))))+(((-0.256800000000000)*(cj4)*(sj1)))+(((-0.160000000000000)*(sj1)))+(((-0.103041000000000)*(sj1)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x216=((-1.00000000000000)*(py));
evalcond[0]=((IKfmod(((3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x216;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(px)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x216;
evalcond[4]=py;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(px)))+(((-0.321000000000000)*(cj4)*(px)))+(((-0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(px)*(sj4)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x217=((((-1.00000000000000)*(pz)))+(j0));
IKReal x218=((0.400000000000000)*(pz));
IKReal x219=((0.0321000000000000)*(sj4));
IKReal x220=((0.321000000000000)*(cj4)*(pz));
IKReal x221=((x218)+(x219)+(x220));
IKReal x222=((0.400000000000000)*(j0));
IKReal x223=((0.321000000000000)*(cj4)*(j0));
IKReal x224=((0.321000000000000)*(px)*(sj4));
IKReal x225=((x223)+(x222)+(x224));
IKReal x226=((x221)+(((-1.00000000000000)*(x225))));
IKReal x227=((IKabs(x226) != 0)?((IKReal)1/(x226)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x227)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x217)*(x217))))))), ((x227)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x217)*(((0.100000000000000)+(((-1.00000000000000)*(px)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x228=((0.100000000000000)+(((-1.00000000000000)*(px))));
IKReal x229=((0.321000000000000)*(j0)*(sj4));
IKReal x230=((0.0321000000000000)*(cj4));
IKReal x231=((0.0400000000000000)+(x229)+(x230));
IKReal x232=((0.400000000000000)*(px));
IKReal x233=((0.321000000000000)*(pz)*(sj4));
IKReal x234=((0.321000000000000)*(cj4)*(px));
IKReal x235=((x232)+(x233)+(x234));
IKReal x236=((((-1.00000000000000)*(x235)))+(x231));
IKReal x237=((IKabs(x236) != 0)?((IKReal)1/(x236)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x237)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x228)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x237)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x228)*(x228))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x238=((0.256800000000000)*(cj4));
IKReal x239=(sj4)*(sj4);
IKReal x240=((0.103041000000000)*(x239));
IKReal x241=(cj4)*(cj4);
IKReal x242=((0.103041000000000)*(x241));
IKReal x243=((0.160000000000000)+(x238)+(x242)+(x240));
IKReal x244=((IKabs(x243) != 0)?((IKReal)1/(x243)):(IKReal)1.0e30);
IKReal x245=((((-1.00000000000000)*(pz)))+(j0));
IKReal x246=((0.321000000000000)*(cj4));
IKReal x247=((0.400000000000000)+(x246));
IKReal x248=((0.100000000000000)+(((-1.00000000000000)*(px))));
j2array[0]=IKatan2(((-1.00000000000000)*(x244)*(((((-0.321000000000000)*(sj4)*(x248)))+(((-1.00000000000000)*(x245)*(x247)))))), ((-1.00000000000000)*(x244)*(((((-0.321000000000000)*(sj4)*(x245)))+(((x247)*(x248)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=py;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(px)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(pz)*(sj4)))+(((0.400000000000000)*(px)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(cj4)*(px)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz)))+(((0.321000000000000)*(px)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x249=((((-1.00000000000000)*(pz)))+(j0));
IKReal x250=((0.400000000000000)*(pz));
IKReal x251=((0.0321000000000000)*(sj4));
IKReal x252=((0.321000000000000)*(cj4)*(pz));
IKReal x253=((0.321000000000000)*(px)*(sj4));
IKReal x254=((x250)+(x251)+(x252)+(x253));
IKReal x255=((0.400000000000000)*(j0));
IKReal x256=((0.321000000000000)*(cj4)*(j0));
IKReal x257=((x255)+(x256));
IKReal x258=((x254)+(((-1.00000000000000)*(x257))));
IKReal x259=((IKabs(x258) != 0)?((IKReal)1/(x258)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x259)*(((((-1.00000000000000)*((x249)*(x249))))+(((0.103041000000000)*((sj4)*(sj4))))))), ((x259)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x249)*(((0.100000000000000)+(px)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x260=((0.100000000000000)+(px));
IKReal x261=((0.400000000000000)*(px));
IKReal x262=((0.321000000000000)*(j0)*(sj4));
IKReal x263=((0.321000000000000)*(cj4)*(px));
IKReal x264=((0.0321000000000000)*(cj4));
IKReal x265=((0.0400000000000000)+(x264)+(x261)+(x263)+(x262));
IKReal x266=((0.321000000000000)*(pz)*(sj4));
IKReal x267=((x265)+(((-1.00000000000000)*(x266))));
IKReal x268=((IKabs(x267) != 0)?((IKReal)1/(x267)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x268)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x260)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x268)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x260)*(x260))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x269=((0.256800000000000)*(cj4));
IKReal x270=(sj4)*(sj4);
IKReal x271=((0.103041000000000)*(x270));
IKReal x272=(cj4)*(cj4);
IKReal x273=((0.103041000000000)*(x272));
IKReal x274=((0.160000000000000)+(x269)+(x273)+(x271));
IKReal x275=((IKabs(x274) != 0)?((IKReal)1/(x274)):(IKReal)1.0e30);
IKReal x276=((((-1.00000000000000)*(pz)))+(j0));
IKReal x277=((0.100000000000000)+(px));
IKReal x278=((0.321000000000000)*(cj4));
IKReal x279=((0.400000000000000)+(x278));
j2array[0]=IKatan2(((-1.00000000000000)*(x275)*(((((-0.321000000000000)*(sj4)*(x277)))+(((-1.00000000000000)*(x276)*(x279)))))), ((-1.00000000000000)*(x275)*(((((-0.321000000000000)*(sj4)*(x276)))+(((x277)*(x279)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((-1.00000000000000)*(px));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(py)))+(((-0.321000000000000)*(cj4)*(py)))+(((-0.321000000000000)*(pz)*(sj4)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((-0.321000000000000)*(py)*(sj4)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x280=((((-1.00000000000000)*(pz)))+(j0));
IKReal x281=((0.400000000000000)*(pz));
IKReal x282=((0.0321000000000000)*(sj4));
IKReal x283=((0.321000000000000)*(cj4)*(pz));
IKReal x284=((x283)+(x282)+(x281));
IKReal x285=((0.400000000000000)*(j0));
IKReal x286=((0.321000000000000)*(py)*(sj4));
IKReal x287=((0.321000000000000)*(cj4)*(j0));
IKReal x288=((x287)+(x286)+(x285));
IKReal x289=((x284)+(((-1.00000000000000)*(x288))));
IKReal x290=((IKabs(x289) != 0)?((IKReal)1/(x289)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x290)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x280)*(x280))))))), ((x290)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x280)*(((0.100000000000000)+(((-1.00000000000000)*(py)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x291=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x292=((0.321000000000000)*(j0)*(sj4));
IKReal x293=((0.0321000000000000)*(cj4));
IKReal x294=((0.0400000000000000)+(x292)+(x293));
IKReal x295=((0.400000000000000)*(py));
IKReal x296=((0.321000000000000)*(pz)*(sj4));
IKReal x297=((0.321000000000000)*(cj4)*(py));
IKReal x298=((x295)+(x296)+(x297));
IKReal x299=((((-1.00000000000000)*(x298)))+(x294));
IKReal x300=((IKabs(x299) != 0)?((IKReal)1/(x299)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x300)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x291)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x300)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x291)*(x291))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x301=((0.256800000000000)*(cj4));
IKReal x302=(sj4)*(sj4);
IKReal x303=((0.103041000000000)*(x302));
IKReal x304=(cj4)*(cj4);
IKReal x305=((0.103041000000000)*(x304));
IKReal x306=((0.160000000000000)+(x305)+(x303)+(x301));
IKReal x307=((IKabs(x306) != 0)?((IKReal)1/(x306)):(IKReal)1.0e30);
IKReal x308=((((-1.00000000000000)*(pz)))+(j0));
IKReal x309=((0.321000000000000)*(cj4));
IKReal x310=((0.400000000000000)+(x309));
IKReal x311=((0.100000000000000)+(((-1.00000000000000)*(py))));
j2array[0]=IKatan2(((-1.00000000000000)*(x307)*(((((-1.00000000000000)*(x308)*(x310)))+(((-0.321000000000000)*(sj4)*(x311)))))), ((-1.00000000000000)*(x307)*(((((x310)*(x311)))+(((-0.321000000000000)*(sj4)*(x308)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x312=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x312;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(py)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x312;
evalcond[4]=px;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((sj4)*(sj4))))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.321000000000000)*(pz)*(sj4)))+(((0.400000000000000)*(py)))+(((0.321000000000000)*(j0)*(sj4)))+(((0.321000000000000)*(cj4)*(py)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.321000000000000)*(py)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.0321000000000000)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x313=((((-1.00000000000000)*(pz)))+(j0));
IKReal x314=((0.321000000000000)*(py)*(sj4));
IKReal x315=((0.400000000000000)*(pz));
IKReal x316=((0.0321000000000000)*(sj4));
IKReal x317=((0.321000000000000)*(cj4)*(pz));
IKReal x318=((x315)+(x314)+(x317)+(x316));
IKReal x319=((0.400000000000000)*(j0));
IKReal x320=((0.321000000000000)*(cj4)*(j0));
IKReal x321=((x320)+(x319));
IKReal x322=((((-1.00000000000000)*(x321)))+(x318));
IKReal x323=((IKabs(x322) != 0)?((IKReal)1/(x322)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x323)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x313)*(x313))))))), ((x323)*(((((-0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x313)*(((0.100000000000000)+(py)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x324=((0.100000000000000)+(py));
IKReal x325=((0.400000000000000)*(py));
IKReal x326=((0.321000000000000)*(j0)*(sj4));
IKReal x327=((0.321000000000000)*(cj4)*(py));
IKReal x328=((0.0321000000000000)*(cj4));
IKReal x329=((0.0400000000000000)+(x325)+(x326)+(x327)+(x328));
IKReal x330=((0.321000000000000)*(pz)*(sj4));
IKReal x331=((x329)+(((-1.00000000000000)*(x330))));
IKReal x332=((IKabs(x331) != 0)?((IKReal)1/(x331)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x332)*(((((0.321000000000000)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x324)*(((((-1.00000000000000)*(pz)))+(j0)))))))), ((x332)*(((((0.103041000000000)*((sj4)*(sj4))))+(((-1.00000000000000)*((x324)*(x324))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x333=((0.256800000000000)*(cj4));
IKReal x334=(sj4)*(sj4);
IKReal x335=((0.103041000000000)*(x334));
IKReal x336=(cj4)*(cj4);
IKReal x337=((0.103041000000000)*(x336));
IKReal x338=((0.160000000000000)+(x333)+(x337)+(x335));
IKReal x339=((IKabs(x338) != 0)?((IKReal)1/(x338)):(IKReal)1.0e30);
IKReal x340=((0.100000000000000)+(py));
IKReal x341=((0.321000000000000)*(cj4));
IKReal x342=((0.400000000000000)+(x341));
IKReal x343=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x339)*(((((-0.321000000000000)*(sj4)*(x340)))+(((-1.00000000000000)*(x342)*(x343)))))), ((-1.00000000000000)*(x339)*(((((-0.321000000000000)*(sj4)*(x343)))+(((x340)*(x342)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x344=((0.100000000000000)*(sj1));
IKReal x345=((x344)+(((-1.00000000000000)*(py))));
IKReal x346=(cj4)*(cj4);
IKReal x347=((0.103041000000000)*(sj1)*(x346));
IKReal x348=(sj4)*(sj4);
IKReal x349=((0.103041000000000)*(sj1)*(x348));
IKReal x350=((0.256800000000000)*(cj4)*(sj1));
IKReal x351=((0.160000000000000)*(sj1));
IKReal x352=((x351)+(x350)+(x347)+(x349));
IKReal x353=((-1.00000000000000)*(x352));
IKReal x354=((IKabs(x353) != 0)?((IKReal)1/(x353)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x354)*(((((-0.321000000000000)*(sj4)*(x345)))+(((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(sj1)))+(((0.321000000000000)*(cj4)*(sj1)))))))))), ((x354)*(((((-0.321000000000000)*(sj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((x345)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x355=((0.100000000000000)*(cj1));
IKReal x356=((x355)+(((-1.00000000000000)*(px))));
IKReal x357=((0.256800000000000)*(cj1)*(cj4));
IKReal x358=(sj4)*(sj4);
IKReal x359=((0.103041000000000)*(cj1)*(x358));
IKReal x360=((0.160000000000000)*(cj1));
IKReal x361=(cj4)*(cj4);
IKReal x362=((0.103041000000000)*(cj1)*(x361));
IKReal x363=((x357)+(x359)+(x360)+(x362));
IKReal x364=((-1.00000000000000)*(x363));
IKReal x365=((IKabs(x364) != 0)?((IKReal)1/(x364)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x365)*(((((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(cj1)))+(((0.321000000000000)*(cj1)*(cj4)))))))+(((-0.321000000000000)*(sj4)*(x356)))))), ((x365)*(((((x356)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((-0.321000000000000)*(cj1)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x366=((0.256800000000000)*(cj4));
IKReal x367=(sj4)*(sj4);
IKReal x368=((0.103041000000000)*(x367));
IKReal x369=(cj4)*(cj4);
IKReal x370=((0.103041000000000)*(x369));
IKReal x371=((0.160000000000000)+(x370)+(x368)+(x366));
IKReal x372=((IKabs(x371) != 0)?((IKReal)1/(x371)):(IKReal)1.0e30);
IKReal x373=((0.321000000000000)*(cj4));
IKReal x374=((0.400000000000000)+(x373));
IKReal x375=((cj1)*(px));
IKReal x376=((py)*(sj1));
IKReal x377=((x376)+(x375));
IKReal x378=((0.100000000000000)+(((-1.00000000000000)*(x377))));
IKReal x379=((((-1.00000000000000)*(pz)))+(j0));
j2array[0]=IKatan2(((-1.00000000000000)*(x372)*(((((-1.00000000000000)*(x374)*(x379)))+(((-0.321000000000000)*(sj4)*(x378)))))), ((-1.00000000000000)*(x372)*(((((-0.321000000000000)*(sj4)*(x379)))+(((x374)*(x378)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x380=x4;
IKReal x381=x3;
IKReal x382=x0;
IKReal x383=x2;
IKReal x384=((cj3)*(px)*(sj1));
IKReal x385=((cj1)*(cj3)*(py));
IKReal x386=((x384)+(((-1.00000000000000)*(x385))));
IKReal x387=((0.0669590000000000)+(x382)+(x383)+(x380)+(x381));
IKReal x388=((2.00000000000000)*(j0)*(pz));
IKReal x389=((0.200000000000000)*(cj1)*(px));
IKReal x390=((0.200000000000000)*(py)*(sj1));
IKReal x391=((x388)+(x389)+(x390));
IKReal x392=((((-1.00000000000000)*(x391)))+(x387));
IKReal x393=((1.60000000000000)*(j0)*(pz)*(sj3));
IKReal x394=((0.160000000000000)*(cj1)*(px)*(sj3));
IKReal x395=((0.160000000000000)*(py)*(sj1)*(sj3));
IKReal x396=((x395)+(x394)+(x393));
IKReal x397=((0.800000000000000)*(sj3)*(x380));
IKReal x398=((0.800000000000000)*(sj3)*(x381));
IKReal x399=(cj1)*(cj1);
IKReal x400=((0.800000000000000)*(sj3)*(x382)*(x399));
IKReal x401=((1.60000000000000)*(cj1)*(px)*(py)*(sj1)*(sj3));
IKReal x402=(sj1)*(sj1);
IKReal x403=((0.800000000000000)*(sj3)*(x383)*(x402));
IKReal x404=((0.00800000000000000)*(sj3));
IKReal x405=((x397)+(x398)+(x401)+(x400)+(x403)+(x404));
IKReal x406=((x396)+(((-1.00000000000000)*(x405))));
IKReal x407=((IKabs(x406) != 0)?((IKReal)1/(x406)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x407)*(((((x392)*(((((pz)*(sj3)))+(((-1.00000000000000)*(j0)*(sj3)))))))+(((x386)*(((0.0800000000000000)+(((-0.800000000000000)*(py)*(sj1)))+(((-0.800000000000000)*(cj1)*(px)))))))))), ((x407)*(((((x392)*(((((-1.00000000000000)*(cj1)*(px)*(sj3)))+(((-1.00000000000000)*(py)*(sj1)*(sj3)))+(((0.100000000000000)*(sj3)))))))+(((x386)*(((((0.800000000000000)*(j0)))+(((-0.800000000000000)*(pz)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((0.103041000000000)*(cj3)*((sj2)*(sj2))))+(((0.103041000000000)*(cj3)*((cj2)*(cj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj2;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
IKReal x408=((px)*(sj1));
IKReal x409=((cj1)*(py));
IKReal x410=((x408)+(((-1.00000000000000)*(x409))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x410;
evalcond[2]=x410;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((0.103041000000000)*((cj2)*(cj2))))+(((0.103041000000000)*((sj2)*(sj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((0.103041000000000)*(cj1)*((sj2)*(sj2))))+(((0.103041000000000)*(cj1)*((cj2)*(cj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((-1.00000000000000)*(px));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(py)*(sj2)))+(((3.11526479750779)*(cj2)*(pz)))+(((-0.311526479750779)*(sj2)))+(((-3.11526479750779)*(cj2)*(j0)))), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x411=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x411;
evalcond[2]=x411;
evalcond[3]=x411;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj2)*(pz)))+(((-3.11526479750779)*(py)*(sj2)))+(((-0.311526479750779)*(sj2)))+(((-3.11526479750779)*(cj2)*(j0)))), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x412=x408;
IKReal x413=x409;
IKReal x414=((x412)+(((-1.00000000000000)*(x413))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x414;
evalcond[2]=x414;
evalcond[3]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x415=x408;
IKReal x416=x409;
IKReal x417=((x415)+(((-1.00000000000000)*(x416))));
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x417;
evalcond[2]=x417;
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x418=(sj2)*(sj2);
IKReal x419=((0.103041000000000)*(cj1)*(x418));
IKReal x420=(cj2)*(cj2);
IKReal x421=((0.103041000000000)*(cj1)*(x420));
IKReal x422=((x419)+(x421));
IKReal x423=((IKabs(x422) != 0)?((IKReal)1/(x422)):(IKReal)1.0e30);
IKReal x424=((0.400000000000000)*(cj1)*(cj2));
IKReal x425=((0.100000000000000)*(cj1));
IKReal x426=((x425)+(x424));
IKReal x427=((x426)+(((-1.00000000000000)*(px))));
IKReal x428=((0.400000000000000)*(sj2));
IKReal x429=((x428)+(pz));
IKReal x430=((((-1.00000000000000)*(x429)))+(j0));
j4array[0]=IKatan2(((x423)*(((((-0.321000000000000)*(sj2)*(x427)))+(((-0.321000000000000)*(cj1)*(cj2)*(x430)))))), ((x423)*(((((0.321000000000000)*(cj1)*(sj2)*(x430)))+(((-0.321000000000000)*(cj2)*(x427)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x431=(cj2)*(cj2);
IKReal x432=((0.103041000000000)*(x431));
IKReal x433=(sj2)*(sj2);
IKReal x434=((0.103041000000000)*(x433));
IKReal x435=((x432)+(x434));
IKReal x436=((IKabs(x435) != 0)?((IKReal)1/(x435)):(IKReal)1.0e30);
IKReal x437=((0.400000000000000)*(sj2));
IKReal x438=((x437)+(pz));
IKReal x439=((((-1.00000000000000)*(x438)))+(j0));
IKReal x440=((0.400000000000000)*(cj2));
IKReal x441=((0.100000000000000)+(x440));
IKReal x442=((cj1)*(px));
IKReal x443=((py)*(sj1));
IKReal x444=((x443)+(x442));
IKReal x445=((((-1.00000000000000)*(x444)))+(x441));
j4array[0]=IKatan2(((x436)*(((((-0.321000000000000)*(cj2)*(x439)))+(((-0.321000000000000)*(sj2)*(x445)))))), ((x436)*(((((0.321000000000000)*(sj2)*(x439)))+(((-0.321000000000000)*(cj2)*(x445)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(px)*(sj2)))+(((3.11526479750779)*(cj2)*(pz)))+(((3.11526479750779)*(py)*(sj1)*(sj2)))+(((-0.311526479750779)*(sj2)))+(((-3.11526479750779)*(cj2)*(j0)))), ((-9.70487475859124)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.321000000000000)*(cj2)*(((((-1.00000000000000)*(cj1)*(px)*(sj2)))+(((-1.00000000000000)*(py)*(sj1)*(sj2)))+(((0.100000000000000)*(sj2)))+(((cj2)*(j0)))+(((-1.00000000000000)*(cj2)*(pz)))))))+(((-0.321000000000000)*(j0)))+(((0.128400000000000)*(sj2)))+(((0.321000000000000)*(pz)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x446=((cj1)*(py));
IKReal x447=((px)*(sj1));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-3.14159265358979)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(x446)))+(x447));
evalcond[2]=((((-1.00000000000000)*(x447)))+(x446));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((-0.103041000000000)*((cj2)*(cj2))))+(((-0.103041000000000)*((sj2)*(sj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=((((-0.103041000000000)*(cj1)*((sj2)*(sj2))))+(((-0.103041000000000)*(cj1)*((cj2)*(cj2)))));
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal evalcond[5];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=px;
evalcond[2]=((-1.00000000000000)*(px));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(cj2)*(pz)))+(((-3.11526479750779)*(py)*(sj2)))+(((3.11526479750779)*(cj2)*(j0)))+(((0.311526479750779)*(sj2)))), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x448=((-1.00000000000000)*(px));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x448;
evalcond[2]=x448;
evalcond[3]=px;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(cj2)*(pz)))+(((3.11526479750779)*(py)*(sj2)))+(((3.11526479750779)*(cj2)*(j0)))+(((0.311526479750779)*(sj2)))), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x449=x446;
IKReal x450=x447;
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(x449)))+(x450));
evalcond[2]=((((-1.00000000000000)*(x450)))+(x449));
evalcond[3]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x451=x446;
IKReal x452=x447;
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(x451)))+(x452));
evalcond[2]=((((-1.00000000000000)*(x452)))+(x451));
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x453=((0.400000000000000)*(sj2));
IKReal x454=((x453)+(pz));
IKReal x455=((((-1.00000000000000)*(x454)))+(j0));
IKReal x456=((0.400000000000000)*(cj1)*(cj2));
IKReal x457=((0.100000000000000)*(cj1));
IKReal x458=((x456)+(x457));
IKReal x459=((x458)+(((-1.00000000000000)*(px))));
IKReal x460=(sj2)*(sj2);
IKReal x461=((0.103041000000000)*(cj1)*(x460));
IKReal x462=(cj2)*(cj2);
IKReal x463=((0.103041000000000)*(cj1)*(x462));
IKReal x464=((x463)+(x461));
IKReal x465=((-1.00000000000000)*(x464));
IKReal x466=((IKabs(x465) != 0)?((IKReal)1/(x465)):(IKReal)1.0e30);
j4array[0]=IKatan2(((x466)*(((((-0.321000000000000)*(sj2)*(x459)))+(((-0.321000000000000)*(cj1)*(cj2)*(x455)))))), ((x466)*(((((-0.321000000000000)*(cj1)*(sj2)*(x455)))+(((0.321000000000000)*(cj2)*(x459)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x467=((0.400000000000000)*(sj2));
IKReal x468=((x467)+(pz));
IKReal x469=((((-1.00000000000000)*(x468)))+(j0));
IKReal x470=((0.400000000000000)*(cj2));
IKReal x471=((0.100000000000000)+(x470));
IKReal x472=((cj1)*(px));
IKReal x473=((py)*(sj1));
IKReal x474=((x472)+(x473));
IKReal x475=((((-1.00000000000000)*(x474)))+(x471));
IKReal x476=(cj2)*(cj2);
IKReal x477=((0.103041000000000)*(x476));
IKReal x478=(sj2)*(sj2);
IKReal x479=((0.103041000000000)*(x478));
IKReal x480=((x477)+(x479));
IKReal x481=((-1.00000000000000)*(x480));
IKReal x482=((IKabs(x481) != 0)?((IKReal)1/(x481)):(IKReal)1.0e30);
j4array[0]=IKatan2(((x482)*(((((-0.321000000000000)*(sj2)*(x475)))+(((-0.321000000000000)*(cj2)*(x469)))))), ((x482)*(((((-0.321000000000000)*(sj2)*(x469)))+(((0.321000000000000)*(cj2)*(x475)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((-3.11526479750779)*(cj2)*(pz)))+(((-3.11526479750779)*(cj1)*(px)*(sj2)))+(((3.11526479750779)*(cj2)*(j0)))+(((-3.11526479750779)*(py)*(sj1)*(sj2)))+(((0.311526479750779)*(sj2)))), ((9.70487475859124)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((-0.321000000000000)*(cj2)*(((((-1.00000000000000)*(cj1)*(px)*(sj2)))+(((-1.00000000000000)*(py)*(sj1)*(sj2)))+(((0.100000000000000)*(sj2)))+(((cj2)*(j0)))+(((-1.00000000000000)*(cj2)*(pz)))))))+(((0.321000000000000)*(j0)))+(((-0.321000000000000)*(pz)))+(((-0.128400000000000)*(sj2)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((cj3)*(px)*(sj1)))+(((-1.00000000000000)*(pz)*(sj3)))+(((j0)*(sj3)))+(((-1.00000000000000)*(cj1)*(cj3)*(py))));
evalcond[2]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj3;
j4eval[1]=cj1;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x483=((((-1.00000000000000)*(pz)))+(j0));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x483;
evalcond[2]=x483;
evalcond[3]=x483;
evalcond[4]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x484=((((-1.00000000000000)*(pz)))+(j0));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x484;
evalcond[2]=x484;
evalcond[3]=((pz)+(((-1.00000000000000)*(j0))));
evalcond[4]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((cj1)*(px)))+(((2.00000000000000)*(j0)*(pz)))+(((py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(pz)*(sj3)))+(((j0)*(sj3)))+(((cj3)*(px))));
evalcond[2]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(py));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj3)))+(((3.11526479750779)*(cj3)*(pz)))+(((-3.11526479750779)*(cj3)*(j0)))), ((-1.55763239875389)+(((3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(pz)*(sj3)))+(((-1.00000000000000)*(cj3)*(px)))+(((j0)*(sj3))));
evalcond[2]=((-0.146959000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-1.00000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj3)*(pz)))+(((-3.11526479750779)*(cj3)*(j0)))+(((-3.11526479750779)*(px)*(sj3)))), ((-1.55763239875389)+(((-3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x485=((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30);
j4array[0]=IKatan2(((3.11526479750779)*(x485)*(((pz)+(((-1.00000000000000)*(j0)))))), ((9.70487475859124)*(x485)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((((0.321000000000000)*(sj1)*(sj3)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((-0.321000000000000)*(cj3)*(((((0.500000000000000)*(cj1)))+(((-1.00000000000000)*(px)))))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30))*(((pz)+(((-1.00000000000000)*(j0)))))), ((-1.55763239875389)+(((3.11526479750779)*(cj1)*(px)))+(((3.11526479750779)*(py)*(sj1)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
evalcond[0]=((IKfmod(((-3.14159265358979)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((cj3)*(px)*(sj1)))+(((-1.00000000000000)*(cj1)*(cj3)*(py)))+(((pz)*(sj3)))+(((-1.00000000000000)*(j0)*(sj3))));
evalcond[2]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj3;
j4eval[1]=cj1;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[4];
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(pz)))+(j0));
evalcond[2]=((pz)+(((-1.00000000000000)*(j0))));
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(pz)))+(j0));
evalcond[2]=((pz)+(((-1.00000000000000)*(j0))));
evalcond[3]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.600000000000000)*(cj1)*(px)))+(((-0.600000000000000)*(py)*(sj1))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((pz)*(sj3)))+(((cj3)*(px)))+(((-1.00000000000000)*(j0)*(sj3))));
evalcond[2]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((-0.600000000000000)*(py)))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj3)))+(((3.11526479750779)*(cj3)*(j0)))+(((-3.11526479750779)*(cj3)*(pz)))), ((-0.934579439252337)+(((-3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(cj3)*(px)))+(((pz)*(sj3)))+(((-1.00000000000000)*(j0)*(sj3))));
evalcond[2]=((0.0130410000000000)+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.600000000000000)*(py))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj3)*(j0)))+(((-3.11526479750779)*(px)*(sj3)))+(((-3.11526479750779)*(cj3)*(pz)))), ((-0.934579439252337)+(((3.11526479750779)*(py)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x486=((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30);
j4array[0]=IKatan2(((-3.11526479750779)*(x486)*(((pz)+(((-1.00000000000000)*(j0)))))), ((9.70487475859124)*(x486)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((((0.321000000000000)*(sj1)*(sj3)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((0.321000000000000)*(cj3)*(((((-0.300000000000000)*(cj1)))+(((-1.00000000000000)*(px)))))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(((IKabs(cj3) != 0)?((IKReal)1/(cj3)):(IKReal)1.0e30))*(((pz)+(((-1.00000000000000)*(j0)))))), ((-0.934579439252337)+(((-3.11526479750779)*(py)*(sj1)))+(((-3.11526479750779)*(cj1)*(px)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x487=((0.100000000000000)*(sj2));
IKReal x488=((cj2)*(j0));
IKReal x489=((x488)+(x487));
IKReal x490=((cj2)*(pz));
IKReal x491=((py)*(sj1)*(sj2));
IKReal x492=((cj1)*(px)*(sj2));
IKReal x493=((x492)+(x490)+(x491));
IKReal x494=((((-1.00000000000000)*(x493)))+(x489));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x494;
evalcond[2]=x494;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj1;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x495=x487;
IKReal x496=x488;
IKReal x497=((x496)+(x495));
IKReal x498=x490;
IKReal x499=((py)*(sj2));
IKReal x500=((x498)+(x499));
IKReal x501=((((-1.00000000000000)*(x500)))+(x497));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x501;
evalcond[2]=x501;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(px)), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x502=x487;
IKReal x503=x488;
IKReal x504=((py)*(sj2));
IKReal x505=((x502)+(x503)+(x504));
IKReal x506=x490;
IKReal x507=((((-1.00000000000000)*(x506)))+(x505));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x507;
evalcond[2]=x507;
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(px)), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x508=((cj1)*(px));
IKReal x509=((py)*(sj1));
IKReal x510=((x508)+(x509));
IKReal x511=((0.100000000000000)+(((-1.00000000000000)*(x510))));
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x511;
evalcond[2]=x511;
evalcond[3]=x511;
evalcond[4]=((-0.0669590000000000)+(((-0.800000000000000)*(pz)))+(((0.200000000000000)*(x509)))+(((0.200000000000000)*(x508)))+(((-1.00000000000000)*((j0)*(j0))))+(((0.800000000000000)*(j0)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-1.24610591900312)+(((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x512=((cj1)*(px));
IKReal x513=((py)*(sj1));
IKReal x514=((-0.100000000000000)+(x513)+(x512));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((-1.00000000000000)*(x514));
evalcond[2]=x514;
evalcond[3]=x514;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(pz)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((-0.800000000000000)*(j0)))+(((0.200000000000000)*(x512)))+(((0.200000000000000)*(x513))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-1.24610591900312)+(((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-9.70487475859124)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((((0.128400000000000)*(cj1)*(cj2)))+(((0.321000000000000)*(sj1)*(((((-1.00000000000000)*(cj1)*(py)))+(((px)*(sj1)))))))+(((-0.321000000000000)*(px)))+(((0.0321000000000000)*(cj1)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-3.11526479750779)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((0.100000000000000)+(((-1.00000000000000)*(cj1)*(px)))+(((-1.00000000000000)*(py)*(sj1)))+(((0.400000000000000)*(cj2)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(px)*(sj1)))+(((-3.11526479750779)*(cj1)*(py)))), ((-3.11526479750779)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.400000000000000)*(sj2)))+(pz)+(((-1.00000000000000)*(j0)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x515=((cj2)*(pz));
IKReal x516=((py)*(sj1)*(sj2));
IKReal x517=((cj1)*(px)*(sj2));
IKReal x518=((x517)+(x516)+(x515));
IKReal x519=((0.100000000000000)*(sj2));
IKReal x520=((cj2)*(j0));
IKReal x521=((x520)+(x519));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j3)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((x521)+(((-1.00000000000000)*(x518))));
evalcond[2]=((((-1.00000000000000)*(x521)))+(x518));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((0.200000000000000)*(cj1)*(px)))+(((0.200000000000000)*(py)*(sj1)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz)))+(((0.800000000000000)*(cj2)*(py)*(sj1)))+(((0.800000000000000)*(cj1)*(cj2)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4eval[1];
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[1];
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.000001  )
{
{
IKReal j4eval[2];
j4eval[0]=cj1;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.000001  || IKabs(j4eval[1]) < 0.000001  )
{
{
IKReal evalcond[5];
IKReal x522=x515;
IKReal x523=((py)*(sj2));
IKReal x524=((x522)+(x523));
IKReal x525=x519;
IKReal x526=x520;
IKReal x527=((x526)+(x525));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(x524)))+(x527));
evalcond[2]=((((-1.00000000000000)*(x527)))+(x524));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.800000000000000)*(cj2)*(py)))+(((-0.800000000000000)*(pz)*(sj2)))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(px)), ((-1.24610591900312)+(((3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x528=x515;
IKReal x529=x519;
IKReal x530=x520;
IKReal x531=((py)*(sj2));
IKReal x532=((x531)+(x530)+(x529));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=((((-1.00000000000000)*(x528)))+(x532));
evalcond[2]=((((-1.00000000000000)*(x532)))+(x528));
evalcond[3]=((-0.0669590000000000)+(((0.800000000000000)*(j0)*(sj2)))+(((-0.0800000000000000)*(cj2)))+(((-0.200000000000000)*(py)))+(((-1.00000000000000)*((j0)*(j0))))+(((-0.800000000000000)*(cj2)*(py)))+(((-1.00000000000000)*((px)*(px))))+(((-0.800000000000000)*(pz)*(sj2)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((3.11526479750779)*(px)), ((-1.24610591900312)+(((-3.11526479750779)*(cj2)*(py)))+(((-3.11526479750779)*(pz)*(sj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((-0.311526479750779)*(cj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x533=((cj1)*(px));
IKReal x534=((py)*(sj1));
IKReal x535=((x533)+(x534));
IKReal x536=((0.100000000000000)+(((-1.00000000000000)*(x535))));
evalcond[0]=((IKfmod(((-1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x536;
evalcond[2]=x536;
evalcond[3]=((-0.100000000000000)+(x535));
evalcond[4]=((-0.0669590000000000)+(((-0.800000000000000)*(pz)))+(((-1.00000000000000)*((j0)*(j0))))+(((0.800000000000000)*(j0)))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((0.200000000000000)*(x533)))+(((0.200000000000000)*(x534)))+(((2.00000000000000)*(j0)*(pz))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-1.24610591900312)+(((3.11526479750779)*(j0)))+(((-3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
IKReal x537=((cj1)*(px));
IKReal x538=((py)*(sj1));
IKReal x539=((x537)+(x538));
IKReal x540=((0.100000000000000)+(((-1.00000000000000)*(x539))));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((1.57079632679490)+(3.14159265358979)+(j2)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=x540;
evalcond[2]=((-0.100000000000000)+(x539));
evalcond[3]=x540;
evalcond[4]=((-0.0669590000000000)+(((0.800000000000000)*(pz)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((0.200000000000000)*(x537)))+(((0.200000000000000)*(x538)))+(((2.00000000000000)*(j0)*(pz)))+(((-0.800000000000000)*(j0))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  && IKabs(evalcond[4]) < 0.000010  )
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-1.24610591900312)+(((-3.11526479750779)*(j0)))+(((3.11526479750779)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((9.70487475859124)*(((IKabs(cj1) != 0)?((IKReal)1/(cj1)):(IKReal)1.0e30))*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((((-0.128400000000000)*(cj1)*(cj2)))+(((-0.0321000000000000)*(cj1)))+(((-0.321000000000000)*(sj1)*(((((-1.00000000000000)*(cj1)*(py)))+(((px)*(sj1)))))))+(((0.321000000000000)*(px)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-3.11526479750779)*(((IKabs(cj2) != 0)?((IKReal)1/(cj2)):(IKReal)1.0e30))*(((0.100000000000000)+(((-1.00000000000000)*(cj1)*(px)))+(((-1.00000000000000)*(py)*(sj1)))+(((0.400000000000000)*(cj2)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((((3.11526479750779)*(cj1)*(py)))+(((-3.11526479750779)*(px)*(sj1)))), ((-3.11526479750779)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.400000000000000)*(sj2)))+(pz)+(((-1.00000000000000)*(j0)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}
}
}
}
}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x541=((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30);
IKReal x542=((px)*(sj1));
IKReal x543=((cj1)*(py));
j4array[0]=IKatan2(((-3.11526479750779)*(x541)*(((((-1.00000000000000)*(x542)))+(x543)))), ((9.70487475859124)*(x541)*(((IKabs(sj2) != 0)?((IKReal)1/(sj2)):(IKReal)1.0e30))*(((((0.321000000000000)*(cj2)*(cj3)*(((((-1.00000000000000)*(x543)))+(x542)))))+(((0.321000000000000)*(sj3)*(((((-0.400000000000000)*(sj2)))+(((-1.00000000000000)*(pz)))+(j0)))))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
IKReal x544=(sj2)*(sj2);
IKReal x545=((0.103041000000000)*(cj3)*(x544));
IKReal x546=(cj2)*(cj2);
IKReal x547=((0.103041000000000)*(cj3)*(x546));
IKReal x548=((x545)+(x547));
IKReal x549=((IKabs(x548) != 0)?((IKReal)1/(x548)):(IKReal)1.0e30);
IKReal x550=((0.400000000000000)*(cj2));
IKReal x551=((0.100000000000000)+(x550));
IKReal x552=((cj1)*(px));
IKReal x553=((py)*(sj1));
IKReal x554=((x553)+(x552));
IKReal x555=((((-1.00000000000000)*(x554)))+(x551));
IKReal x556=((0.400000000000000)*(sj2));
IKReal x557=((pz)+(x556));
IKReal x558=((((-1.00000000000000)*(x557)))+(j0));
j4array[0]=IKatan2(((x549)*(((((-0.321000000000000)*(cj2)*(x558)))+(((-0.321000000000000)*(sj2)*(x555)))))), ((x549)*(((((0.321000000000000)*(cj3)*(sj2)*(x558)))+(((-0.321000000000000)*(cj2)*(cj3)*(x555)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-1.24610591900312)+(((3.11526479750779)*(cj1)*(cj2)*(px)))+(((-0.311526479750779)*(cj2)))+(((3.11526479750779)*(j0)*(sj2)))+(((3.11526479750779)*(cj2)*(py)*(sj1)))+(((-3.11526479750779)*(pz)*(sj2)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

rotationfunction0(vsolutions);
}
}

}

}
}
}

}

}

} else
{
{
IKReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
j4array[0]=IKatan2(((-3.11526479750779)*(((IKabs(sj3) != 0)?((IKReal)1/(sj3)):(IKReal)1.0e30))*(((((-1.00000000000000)*(px)*(sj1)))+(((cj1)*(py)))))), ((-0.985362149532710)+(((3.89408099688473)*((py)*(py))))+(((3.89408099688473)*((j0)*(j0))))+(((3.89408099688473)*((pz)*(pz))))+(((-0.778816199376947)*(py)*(sj1)))+(((3.89408099688473)*((px)*(px))))+(((-0.778816199376947)*(cj1)*(px)))+(((-7.78816199376947)*(j0)*(pz)))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
    j4array[0]-=IK2PI;
else if( j4array[0] < -IKPI )
    j4array[0]+=IK2PI;
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] ) { continue; }
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.103041000000000)*((cj4)*(cj4))))+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((0.256800000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.321000000000000)*(cj4)*(pz)))+(((-0.400000000000000)*(j0)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.400000000000000)*(pz)))+(((0.321000000000000)*(cj1)*(cj3)*(px)*(sj4)))+(((-0.0321000000000000)*(cj3)*(sj4)))+(((0.321000000000000)*(cj3)*(py)*(sj1)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.103041000000000)*(cj1)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-0.160000000000000)*(cj1)))+(((-0.103041000000000)*(cj1)*((cj4)*(cj4))))+(((-0.256800000000000)*(cj1)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal evalcond[4];
IKReal x559=((0.321000000000000)*(sj3)*(sj4));
evalcond[0]=((((-1.00000000000000)*(3.14159265358979)))+(IKfmod(((-1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979)))));
evalcond[1]=((((-1.00000000000000)*(x559)))+(px));
evalcond[2]=((0.253041000000000)+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((0.200000000000000)*(py)))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=((x559)+(((-1.00000000000000)*(px))));
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((-0.400000000000000)*(py)))+(((-0.321000000000000)*(cj4)*(py)))+(((0.321000000000000)*(cj3)*(pz)*(sj4)))+(((-0.321000000000000)*(cj3)*(j0)*(sj4)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((-0.0321000000000000)*(cj3)*(sj4)))+(((-0.400000000000000)*(j0)))+(((0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(j0)))+(((0.321000000000000)*(cj3)*(py)*(sj4)))+(((0.321000000000000)*(cj4)*(pz))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x560=((((-1.00000000000000)*(pz)))+(j0));
IKReal x561=((0.400000000000000)*(pz));
IKReal x562=((0.321000000000000)*(cj3)*(py)*(sj4));
IKReal x563=((0.321000000000000)*(cj4)*(pz));
IKReal x564=((x562)+(x563)+(x561));
IKReal x565=((0.400000000000000)*(j0));
IKReal x566=((0.321000000000000)*(cj4)*(j0));
IKReal x567=((0.0321000000000000)*(cj3)*(sj4));
IKReal x568=((x566)+(x567)+(x565));
IKReal x569=((x564)+(((-1.00000000000000)*(x568))));
IKReal x570=((IKabs(x569) != 0)?((IKReal)1/(x569)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x570)*(((((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-1.00000000000000)*((x560)*(x560))))))), ((x570)*(((((0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))+(((x560)*(((0.100000000000000)+(((-1.00000000000000)*(py)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x571=((0.100000000000000)+(((-1.00000000000000)*(py))));
IKReal x572=((0.321000000000000)*(cj3)*(pz)*(sj4));
IKReal x573=((0.0321000000000000)*(cj4));
IKReal x574=((0.0400000000000000)+(x573)+(x572));
IKReal x575=((0.321000000000000)*(cj3)*(j0)*(sj4));
IKReal x576=((0.400000000000000)*(py));
IKReal x577=((0.321000000000000)*(cj4)*(py));
IKReal x578=((x575)+(x577)+(x576));
IKReal x579=((((-1.00000000000000)*(x578)))+(x574));
IKReal x580=((IKabs(x579) != 0)?((IKReal)1/(x579)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x580)*(((((x571)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((-0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))), ((x580)*(((((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-1.00000000000000)*((x571)*(x571))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x581=(cj3)*(cj3);
IKReal x582=(sj4)*(sj4);
IKReal x583=((0.103041000000000)*(x581)*(x582));
IKReal x584=((0.256800000000000)*(cj4));
IKReal x585=(cj4)*(cj4);
IKReal x586=((0.103041000000000)*(x585));
IKReal x587=((0.160000000000000)+(x583)+(x584)+(x586));
IKReal x588=((IKabs(x587) != 0)?((IKReal)1/(x587)):(IKReal)1.0e30);
IKReal x589=((((-1.00000000000000)*(pz)))+(j0));
IKReal x590=((0.321000000000000)*(cj4));
IKReal x591=((0.400000000000000)+(x590));
IKReal x592=((0.100000000000000)+(((-1.00000000000000)*(py))));
j2array[0]=IKatan2(((-1.00000000000000)*(x588)*(((((-1.00000000000000)*(x589)*(x591)))+(((0.321000000000000)*(cj3)*(sj4)*(x592)))))), ((-1.00000000000000)*(x588)*(((((0.321000000000000)*(cj3)*(sj4)*(x589)))+(((x591)*(x592)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
IKReal x593=((0.321000000000000)*(sj3)*(sj4));
IKReal x594=((px)+(x593));
IKReal x595=((-1.00000000000000)*(x594));
evalcond[0]=((IKfmod(((1.57079632679490)+(3.14159265358979)+(j1)), ((2.00000000000000)*(3.14159265358979))))+(((-1.00000000000000)*(3.14159265358979))));
evalcond[1]=x595;
evalcond[2]=((0.253041000000000)+(((-0.200000000000000)*(py)))+(((0.256800000000000)*(cj4)))+(((-1.00000000000000)*((j0)*(j0))))+(((-1.00000000000000)*((px)*(px))))+(((-1.00000000000000)*((py)*(py))))+(((-1.00000000000000)*((pz)*(pz))))+(((2.00000000000000)*(j0)*(pz))));
evalcond[3]=x595;
if( IKabs(evalcond[0]) < 0.000010  && IKabs(evalcond[1]) < 0.000010  && IKabs(evalcond[2]) < 0.000010  && IKabs(evalcond[3]) < 0.000010  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.160000000000000)+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((0.256800000000000)*(cj4)))+(((0.103041000000000)*((cj4)*(cj4)))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((0.0400000000000000)+(((0.321000000000000)*(cj3)*(pz)*(sj4)))+(((0.400000000000000)*(py)))+(((-0.321000000000000)*(cj3)*(j0)*(sj4)))+(((0.321000000000000)*(cj4)*(py)))+(((0.0321000000000000)*(cj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
{
IKReal j2eval[1];
j2eval[0]=((((0.400000000000000)*(j0)))+(((-0.400000000000000)*(pz)))+(((-0.321000000000000)*(cj4)*(pz)))+(((0.321000000000000)*(cj4)*(j0)))+(((0.0321000000000000)*(cj3)*(sj4)))+(((0.321000000000000)*(cj3)*(py)*(sj4))));
if( IKabs(j2eval[0]) < 0.000001  )
{
continue;

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x596=((0.100000000000000)+(py));
IKReal x597=((0.321000000000000)*(cj4));
IKReal x598=((0.400000000000000)+(x597));
IKReal x599=((0.400000000000000)*(j0));
IKReal x600=((j0)*(x597));
IKReal x601=((0.0321000000000000)*(cj3)*(sj4));
IKReal x602=((0.321000000000000)*(cj3)*(py)*(sj4));
IKReal x603=((x599)+(x602)+(x601)+(x600));
IKReal x604=((0.400000000000000)*(pz));
IKReal x605=((pz)*(x597));
IKReal x606=((x605)+(x604));
IKReal x607=((x603)+(((-1.00000000000000)*(x606))));
IKReal x608=((IKabs(x607) != 0)?((IKReal)1/(x607)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x608)*(((((-1.00000000000000)*((x596)*(x596))))+((x598)*(x598))))), ((x608)*(((((x596)*(((pz)+(((-1.00000000000000)*(j0)))))))+(((-0.321000000000000)*(cj3)*(sj4)*(x598)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x609=((0.100000000000000)+(py));
IKReal x610=((0.321000000000000)*(cj3)*(pz)*(sj4));
IKReal x611=((0.400000000000000)*(py));
IKReal x612=((0.321000000000000)*(cj4)*(py));
IKReal x613=((0.0321000000000000)*(cj4));
IKReal x614=((0.0400000000000000)+(x610)+(x611)+(x612)+(x613));
IKReal x615=((0.321000000000000)*(cj3)*(j0)*(sj4));
IKReal x616=((((-1.00000000000000)*(x615)))+(x614));
IKReal x617=((IKabs(x616) != 0)?((IKReal)1/(x616)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x617)*(((((x609)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((-0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))), ((x617)*(((((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))+(((-1.00000000000000)*((x609)*(x609))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x618=(cj3)*(cj3);
IKReal x619=(sj4)*(sj4);
IKReal x620=((0.103041000000000)*(x618)*(x619));
IKReal x621=((0.256800000000000)*(cj4));
IKReal x622=(cj4)*(cj4);
IKReal x623=((0.103041000000000)*(x622));
IKReal x624=((0.160000000000000)+(x621)+(x620)+(x623));
IKReal x625=((IKabs(x624) != 0)?((IKReal)1/(x624)):(IKReal)1.0e30);
IKReal x626=((((-1.00000000000000)*(pz)))+(j0));
IKReal x627=((0.100000000000000)+(py));
IKReal x628=((0.321000000000000)*(cj4));
IKReal x629=((0.400000000000000)+(x628));
j2array[0]=IKatan2(((-1.00000000000000)*(x625)*(((((0.321000000000000)*(cj3)*(sj4)*(x627)))+(((-1.00000000000000)*(x626)*(x629)))))), ((-1.00000000000000)*(x625)*(((((0.321000000000000)*(cj3)*(sj4)*(x626)))+(((x627)*(x629)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
if( 1 )
{
continue;

} else
{
}
}
}
}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x630=((0.321000000000000)*(sj1)*(sj3)*(sj4));
IKReal x631=((0.100000000000000)*(cj1));
IKReal x632=((x630)+(x631));
IKReal x633=((x632)+(((-1.00000000000000)*(px))));
IKReal x634=((0.160000000000000)*(cj1));
IKReal x635=(cj3)*(cj3);
IKReal x636=(sj4)*(sj4);
IKReal x637=((0.103041000000000)*(cj1)*(x635)*(x636));
IKReal x638=(cj4)*(cj4);
IKReal x639=((0.103041000000000)*(cj1)*(x638));
IKReal x640=((0.256800000000000)*(cj1)*(cj4));
IKReal x641=((x640)+(x637)+(x634)+(x639));
IKReal x642=((-1.00000000000000)*(x641));
IKReal x643=((IKabs(x642) != 0)?((IKReal)1/(x642)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x643)*(((((((pz)+(((-1.00000000000000)*(j0)))))*(((((0.400000000000000)*(cj1)))+(((0.321000000000000)*(cj1)*(cj4)))))))+(((0.321000000000000)*(cj3)*(sj4)*(x633)))))), ((x643)*(((((0.321000000000000)*(cj1)*(cj3)*(sj4)*(((((-1.00000000000000)*(pz)))+(j0)))))+(((x633)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x644=((((-1.00000000000000)*(pz)))+(j0));
IKReal x645=((0.321000000000000)*(cj4)*(pz));
IKReal x646=((0.400000000000000)*(pz));
IKReal x647=((0.321000000000000)*(cj1)*(cj3)*(px)*(sj4));
IKReal x648=((0.321000000000000)*(cj3)*(py)*(sj1)*(sj4));
IKReal x649=((x647)+(x646)+(x645)+(x648));
IKReal x650=((0.321000000000000)*(cj4)*(j0));
IKReal x651=((0.0321000000000000)*(cj3)*(sj4));
IKReal x652=((0.400000000000000)*(j0));
IKReal x653=((x650)+(x651)+(x652));
IKReal x654=((((-1.00000000000000)*(x653)))+(x649));
IKReal x655=((IKabs(x654) != 0)?((IKReal)1/(x654)):(IKReal)1.0e30);
j2array[0]=IKatan2(((x655)*(((((-1.00000000000000)*((x644)*(x644))))+(((0.103041000000000)*((cj3)*(cj3))*((sj4)*(sj4))))))), ((x655)*(((((x644)*(((0.100000000000000)+(((-1.00000000000000)*(cj1)*(px)))+(((-1.00000000000000)*(py)*(sj1)))))))+(((0.321000000000000)*(cj3)*(sj4)*(((0.400000000000000)+(((0.321000000000000)*(cj4)))))))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}

} else
{
{
IKReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
IKReal x656=(cj4)*(cj4);
IKReal x657=((0.103041000000000)*(x656));
IKReal x658=(cj3)*(cj3);
IKReal x659=(sj4)*(sj4);
IKReal x660=((0.103041000000000)*(x658)*(x659));
IKReal x661=((0.256800000000000)*(cj4));
IKReal x662=((0.160000000000000)+(x657)+(x661)+(x660));
IKReal x663=((IKabs(x662) != 0)?((IKReal)1/(x662)):(IKReal)1.0e30);
IKReal x664=((((-1.00000000000000)*(pz)))+(j0));
IKReal x665=((0.321000000000000)*(cj4));
IKReal x666=((0.400000000000000)+(x665));
IKReal x667=((cj1)*(px));
IKReal x668=((py)*(sj1));
IKReal x669=((x668)+(x667));
IKReal x670=((0.100000000000000)+(((-1.00000000000000)*(x669))));
j2array[0]=IKatan2(((-1.00000000000000)*(x663)*(((((0.321000000000000)*(cj3)*(sj4)*(x670)))+(((-1.00000000000000)*(x664)*(x666)))))), ((-1.00000000000000)*(x663)*(((((x666)*(x670)))+(((0.321000000000000)*(cj3)*(sj4)*(x664)))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
    j2array[0]-=IK2PI;
else if( j2array[0] < -IKPI )
    j2array[0]+=IK2PI;
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] ) { continue; }
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

rotationfunction0(vsolutions);
}
}

}

}
}
}

}

}
    }

} else
{
}
}
}
return vsolutions.size()>0;
}
inline void rotationfunction0(std::vector<IKSolution>& vsolutions) {
IKReal x21=((cj1)*(cj2)*(cj4));
IKReal x22=((sj1)*(sj3)*(sj4));
IKReal x23=((cj1)*(cj3)*(sj2)*(sj4));
IKReal x24=((x21)+(x22)+(x23));
IKReal x25=((cj2)*(cj3)*(sj4));
IKReal x26=((cj4)*(sj2));
IKReal x27=((((-1.00000000000000)*(x26)))+(x25));
IKReal x28=((cj2)*(cj4)*(sj1));
IKReal x29=((cj3)*(sj1)*(sj2)*(sj4));
IKReal x30=((x28)+(x29));
IKReal x31=((cj1)*(sj3)*(sj4));
IKReal x32=((((-1.00000000000000)*(x31)))+(x30));
IKReal x33=((cj1)*(cj3));
IKReal x34=((sj1)*(sj2)*(sj3));
IKReal x35=((x33)+(x34));
IKReal x36=((-1.00000000000000)*(x35));
IKReal x37=((cj3)*(sj1));
IKReal x38=((cj1)*(sj2)*(sj3));
IKReal x39=((((-1.00000000000000)*(x38)))+(x37));
IKReal x40=((cj1)*(cj2)*(sj4));
IKReal x41=((x26)*(x33));
IKReal x42=((cj4)*(sj1)*(sj3));
IKReal x43=((x42)+(x41));
IKReal x44=((((-1.00000000000000)*(x43)))+(x40));
IKReal x45=((cj1)*(cj4)*(sj3));
IKReal x46=((cj2)*(sj1)*(sj4));
IKReal x47=((x46)+(x45));
IKReal x48=((x26)*(x37));
IKReal x49=((((-1.00000000000000)*(x48)))+(x47));
IKReal x50=((sj2)*(sj4));
IKReal x51=((cj2)*(cj3)*(cj4));
IKReal x52=((x51)+(x50));
IKReal x53=((-1.00000000000000)*(x52));
new_r00=((((r10)*(x32)))+(((r20)*(x27)))+(((r00)*(x24))));
new_r01=((((r21)*(x27)))+(((r11)*(x32)))+(((r01)*(x24))));
new_r02=((((r22)*(x27)))+(((r02)*(x24)))+(((r12)*(x32))));
new_r10=((((r00)*(x39)))+(((r10)*(x36)))+(((-1.00000000000000)*(cj2)*(r20)*(sj3))));
new_r11=((((-1.00000000000000)*(cj2)*(r21)*(sj3)))+(((r01)*(x39)))+(((r11)*(x36))));
new_r12=((((-1.00000000000000)*(cj2)*(r22)*(sj3)))+(((r02)*(x39)))+(((r12)*(x36))));
new_r20=((((r00)*(x44)))+(((r10)*(x49)))+(((r20)*(x53))));
new_r21=((((r01)*(x44)))+(((r21)*(x53)))+(((r11)*(x49))));
new_r22=((((r22)*(x53)))+(((r02)*(x44)))+(((r12)*(x49))));
{
IKReal j6eval;
j6eval=new_r00;
if( j6eval >= -1.000010 && j6eval <= -0.999990 )
{
{
j6 = 3.141593; sj6 = 0.000000; cj6 = -1.000000;
IKReal j5mul = 1;
j5=0;
IKReal j7mul=1.00000000000000;
j7=((-1.00000000000000)*(IKatan2(new_r12, new_r11)));
vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[5].fmul = j5mul;
solution.basesol[5].freeind = 0;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.basesol[7].fmul = j7mul;
solution.basesol[7].freeind = 0;
solution.vfree.resize(1);
solution.vfree[0] = 5;
}

} else
if( j6eval >= 0.999990 && j6eval <= 1.000010 )
{
{
j6 = 0.000000; sj6 = 0.000000; cj6 = 1.000000;
IKReal j5mul = 1;
j5=0;
IKReal j7mul=-1.00000000000000;
j7=((((-1.00000000000000)*(IKatan2(new_r21, ((-1.00000000000000)*(new_r22))))))+(((-1.00000000000000)*(3.14159265358979))));
vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[5].fmul = j5mul;
solution.basesol[5].freeind = 0;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.basesol[7].fmul = j7mul;
solution.basesol[7].freeind = 0;
solution.vfree.resize(1);
solution.vfree[0] = 5;
}

} else
{
{
IKReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
j5array[0]=IKatan2(new_r10, ((-1.00000000000000)*(new_r20)));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
j5array[1] = j5array[0] > 0 ? j5array[0]-IKPI : j5array[0]+IKPI;
sj5array[1] = -sj5array[0];
cj5array[1] = -cj5array[0];
if( j5array[0] > IKPI )
    j5array[0]-=IK2PI;
else if( j5array[0] < -IKPI )
    j5array[0]+=IK2PI;
j5valid[0] = true;
if( j5array[1] > IKPI )
    j5array[1]-=IK2PI;
else if( j5array[1] < -IKPI )
    j5array[1]+=IK2PI;
j5valid[1] = true;
if( j5valid[0] && j5valid[1] && IKabs(cj5array[0]-cj5array[1]) < 0.0001 && IKabs(sj5array[0]-sj5array[1]) < 0.0001 )
    j5valid[1]=false;
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] ) { continue; }
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IKReal evalcond[1];
evalcond[0]=IKsin(j5);
if( IKabs(evalcond[0]) < 0.000010  )
{
{
IKReal j7array[1], cj7array[1], sj7array[1];
bool j7valid[1]={false};
IKReal x54=IKcos(j5);
IKReal x55=((IKabs(x54) != 0)?((IKReal)1/(x54)):(IKReal)1.0e30);
j7array[0]=IKatan2(((-1.00000000000000)*(new_r12)*(x55)), ((new_r11)*(x55)));
sj7array[0]=IKsin(j7array[0]);
cj7array[0]=IKcos(j7array[0]);
if( j7array[0] > IKPI )
    j7array[0]-=IK2PI;
else if( j7array[0] < -IKPI )
    j7array[0]+=IK2PI;
j7valid[0] = true;
for(int ij7 = 0; ij7 < 1; ++ij7)
{
if( !j7valid[ij7] ) { continue; }
j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

{
IKReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
j6array[0]=IKatan2(((-1.00000000000000)*(new_r20)*(((IKabs(IKcos(j5)) != 0)?((IKReal)1/(IKcos(j5))):(IKReal)1.0e30))), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
    j6array[0]-=IK2PI;
else if( j6array[0] < -IKPI )
    j6array[0]+=IK2PI;
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] ) { continue; }
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.vfree.resize(0);
}
}
}
}

} else
{
if( 1 )
{
{
IKReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
j6array[0]=IKatan2(((new_r10)*(((IKabs(sj5) != 0)?((IKReal)1/(sj5)):(IKReal)1.0e30))), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
    j6array[0]-=IK2PI;
else if( j6array[0] < -IKPI )
    j6array[0]+=IK2PI;
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] ) { continue; }
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];

{
IKReal evalcond[1];
evalcond[0]=IKsin(j6);
if( IKabs(evalcond[0]) < 0.000010  )
{
{
IKReal j7array[1], cj7array[1], sj7array[1];
bool j7valid[1]={false};
IKReal x56=IKcos(j6);
IKReal x57=((IKabs(x56) != 0)?((IKReal)1/(x56)):(IKReal)1.0e30);
IKReal x58=IKcos(j5);
IKReal x59=IKsin(j5);
j7array[0]=IKatan2(((((new_r21)*(x57)*(x58)))+(((-1.00000000000000)*(new_r11)*(x57)*(x59)))), ((((new_r21)*(x59)))+(((new_r11)*(x58)))));
sj7array[0]=IKsin(j7array[0]);
cj7array[0]=IKcos(j7array[0]);
if( j7array[0] > IKPI )
    j7array[0]-=IK2PI;
else if( j7array[0] < -IKPI )
    j7array[0]+=IK2PI;
j7valid[0] = true;
for(int ij7 = 0; ij7 < 1; ++ij7)
{
if( !j7valid[ij7] ) { continue; }
j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.vfree.resize(0);
}
}

} else
{
if( 1 )
{
{
IKReal j7array[1], cj7array[1], sj7array[1];
bool j7valid[1]={false};
IKReal x60=IKsin(j6);
IKReal x61=((IKabs(x60) != 0)?((IKReal)1/(x60)):(IKReal)1.0e30);
j7array[0]=IKatan2(((new_r01)*(x61)), ((new_r02)*(x61)));
sj7array[0]=IKsin(j7array[0]);
cj7array[0]=IKcos(j7array[0]);
if( j7array[0] > IKPI )
    j7array[0]-=IK2PI;
else if( j7array[0] < -IKPI )
    j7array[0]+=IK2PI;
j7valid[0] = true;
for(int ij7 = 0; ij7 < 1; ++ij7)
{
if( !j7valid[ij7] ) { continue; }
j7 = j7array[ij7]; cj7 = cj7array[ij7]; sj7 = sj7array[ij7];

vsolutions.push_back(IKSolution()); IKSolution& solution = vsolutions.back();
solution.basesol.resize(8);
solution.basesol[0].foffset = j0;
solution.basesol[1].foffset = j1;
solution.basesol[2].foffset = j2;
solution.basesol[3].foffset = j3;
solution.basesol[4].foffset = j4;
solution.basesol[5].foffset = j5;
solution.basesol[6].foffset = j6;
solution.basesol[7].foffset = j7;
solution.vfree.resize(0);
}
}

} else
{
}
}
}
}
}

} else
{
}
}
}
}
}

}
}
}/// Durand-Kerner polynomial root finding method
static void polyroots3(IKReal rawcoeffs[3+1], IKReal rawroots[3], int& numroots)
{
    using std::complex;
    assert(rawcoeffs[0] != 0);
    const IKReal tol = 128.0*std::numeric_limits<IKReal>::epsilon();
    complex<IKReal> coeffs[3];
    const int maxsteps = 50;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IKReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IKReal> roots[3];
    IKReal err[3];
    roots[0] = complex<IKReal>(1,0);
    roots[1] = complex<IKReal>(0.4,0.9); // any complex number not a root of unity is works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IKReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }
    numroots = 0;
    for(int i = 0; i < 3; ++i) {
        if( IKabs(imag(roots[i])) < std::numeric_limits<IKReal>::epsilon() ) {
            rawroots[numroots++] = real(roots[i]);
        }
    }
}
static void polyroots2(IKReal rawcoeffs[2+1], IKReal rawroots[2], int& numroots) {
    IKReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = 0.5*(-rawcoeffs[1]+det)/rawcoeffs[0];
        rawroots[1] = 0.5*(-rawcoeffs[1]-det)/rawcoeffs[0];
        numroots = 2;
    }
}
/// intersection of a conic and the unit circle
static void conicsolver(IKReal _C0[6], IKReal roots[4], int& numroots)
{
    // have to normalize _C0
    IKReal maxval = IKabs(_C0[0]);
    for(int i = 1; i < 6; ++i) {
        if( maxval < IKabs(_C0[i]) ) {
            maxval = IKabs(_C0[i]);
        }
    }
    IKReal C0[6];
    for(int i = 0; i < 6; ++i) {
        C0[i]=_C0[i]/maxval;
    }
    IKReal rawcoeffs[4] = {-1,
                           C0[5] - C0[0] - C0[3],
                           C0[0]*C0[5] + C0[3]*C0[5] - C0[0]*C0[3] + C0[1]*C0[1] - C0[2]*C0[2] - C0[4]*C0[4],
                           C0[0]*C0[3]*C0[5] + 2*C0[1]*C0[2]*C0[4] - C0[0]*C0[4]*C0[4] - C0[3]*C0[2]*C0[2] - C0[5]*C0[1]*C0[1]};
    IKReal proots[3];
    int numproots, numyroots;
    polyroots3(rawcoeffs,proots,numproots);
    numroots = 0;
    int iroot=0;
    IKReal a, b, c, d, e, f;
    a = C0[0]+proots[iroot]; b = C0[1]; c = C0[3]+proots[iroot]; d = C0[2]; e = C0[4]; f = C0[5]-proots[iroot];
    IKReal adjugate[9] = {c*f-e*e, -b*f+e*d, b*e-c*d, -b*f+d*e, a*f-d*d, -a*e+b*d, b*e-d*c, -a*e+d*b, a*c-b*b};
    // find the greatest absolute value of adjugate and take that column
    int maxindex = 0;
    IKReal val = IKabs(adjugate[maxindex]);
    for(int i = 1; i < 9; ++i) {
        IKReal newval = IKabs(adjugate[i]);
        if( val < newval ) {
            val = newval;
            maxindex = i;
        }
    }
    maxindex = maxindex%3;
    if( adjugate[0] > 0 || adjugate[4] > 0 || adjugate[8] > 0 || adjugate[4*maxindex] >= 0 ) {
        // according to the structure of the matrix, should be always negative if a solution exists...
        return;
    }
    IKReal bmult = 1.0/IKsqrt(-adjugate[4*maxindex]);
    IKReal p[3] = {adjugate[maxindex]*bmult, adjugate[3+maxindex]*bmult, adjugate[6+maxindex]*bmult}; // intersection point
    // C = C0 - [p_x] = 2gh^t, C is rank1
    IKReal C[9] = {a,b+p[2],d-p[1],b-p[2],c,e+p[0],d+p[1],e-p[0],f};
    maxindex = 0;
    val = IKabs(C[maxindex]);
    for(int i = 1; i < 9; ++i) {
        IKReal newval = IKabs(C[i]);
        if( val < newval ) {
            val = newval;
            maxindex = i;
        }
    }
    int row = maxindex/3;
    int col = maxindex%3;
    IKReal lineequation[3], coeffs[3], yintersections[2];
    for(int i = 0; i < 2; ++i) {
        if( i == 0 ) {
            lineequation[0] = C[3*row];
            lineequation[1] = C[3*row+1];
            lineequation[2] = C[3*row+2];
        }
        else {
            lineequation[0] = C[col];
            lineequation[1] = C[3+col];
            lineequation[2] = C[6+col];
        }

        if( IKabs(lineequation[0]) < std::numeric_limits<IKReal>::epsilon() ) {
            yintersections[0] = -lineequation[2]/lineequation[1];
            IKReal x = 1-yintersections[0]*yintersections[0];
            if( x <= 0 && x > -std::numeric_limits<IKReal>::epsilon() ) {
                roots[numroots++] = yintersections[0] > 0 ? IKPI_2 : -IKPI_2;
            }
            else {
                x = IKsqrt(x);
                roots[numroots++] = IKatan2(yintersections[0], x);
                roots[numroots] = IKPI - roots[numroots-1]; numroots++;
            }
        }
        else {
            coeffs[0] = lineequation[0]*lineequation[0]+lineequation[1]*lineequation[1];
            coeffs[1] = 2*lineequation[1]*lineequation[2];
            coeffs[2] = lineequation[2]*lineequation[2]-lineequation[0]*lineequation[0];
            polyroots2(coeffs,yintersections,numyroots);
            for(int j = 0; j < numyroots; ++j) {
                roots[numroots++] = IKatan2(yintersections[j],-(lineequation[1]*yintersections[j]+lineequation[2])/lineequation[0]);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ik(const IKReal* eetrans, const IKReal* eerot, const IKReal* pfree, std::vector<IKSolution>& vsolutions) {
IKSolver solver;
return solver.ik(eetrans,eerot,pfree,vsolutions);
}

IKFAST_API const char* getKinematicsHash() { return "722e06820651dc812ae099b4dc24761d"; }

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
    if( argc != 12+getNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",getNumFreeParameters());
        return 1;
    }

    std::vector<IKSolution> vsolutions;
    std::vector<IKReal> vfree(getNumFreeParameters());
    IKReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ik(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, vsolutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)vsolutions.size());
    std::vector<IKReal> sol(getNumJoints());
    for(size_t i = 0; i < vsolutions.size(); ++i) {
        printf("sol%d (free=%d): ", (int)i, (int)vsolutions[i].GetFree().size());
        std::vector<IKReal> vsolfree(vsolutions[i].GetFree().size());
        vsolutions[i].GetSolution(&sol[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( size_t j = 0; j < sol.size(); ++j)
            printf("%f, ", (float)sol[j]);
        printf("\n");
    }
    return 0;
}

#endif
