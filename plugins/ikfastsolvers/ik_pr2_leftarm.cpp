#define IKFAST_NAMESPACE ik_pr2_leftarm
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 67 generated on 2013-07-25 16:07:08.613070
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==67);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
#ifndef isfinite
#define isfinite _isfinite
#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62;
x0=IKcos(j[0]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[4]);
x6=IKcos(j[4]);
x7=IKcos(j[3]);
x8=IKcos(j[1]);
x9=IKsin(j[3]);
x10=IKcos(j[6]);
x11=IKsin(j[6]);
x12=IKsin(j[5]);
x13=IKcos(j[5]);
x14=((1.0)*x12);
x15=((0.18)*x7);
x16=((0.18)*x5);
x17=((0.321)*x3);
x18=((1.0)*x1);
x19=((0.18)*x9);
x20=((1.0)*x13);
x21=((1.0)*x9);
x22=((0.18)*x6);
x23=((1.0)*x3);
x24=(x8*x9);
x25=(x0*x8);
x26=(x0*x3);
x27=(x0*x2);
x28=(x4*x7);
x29=((-1.0)*x7);
x30=(x1*x4);
x31=(x1*x8);
x32=(x2*x8);
x33=(x31*x7);
x34=(x21*x25);
x35=(x18*x24);
x36=(x23*x7*x8);
x37=(((x27*x4))+(((-1.0)*x18*x3)));
x38=(x27+(((-1.0)*x18*x3*x4)));
x39=(((x2*x30))+x26);
x40=((((-1.0)*x36))+((x4*x9)));
x41=((((-1.0)*x18*x2))+(((-1.0)*x0*x23*x4)));
x42=(x37*x5);
x43=(x38*x7);
x44=(x39*x5);
x45=(((x21*x3*x8))+(((1.0)*x28)));
x46=(x38*x9);
x47=(x41*x7);
x48=(x41*x9);
x49=(((x32*x5))+((x40*x6)));
x50=((((-1.0)*x1*x24))+x43);
x51=(((x32*x6))+((x5*(((((-1.0)*x21*x4))+x36)))));
x52=((((-1.0)*x18*x7*x8))+(((-1.0)*x21*x38)));
x53=(x13*x49);
x54=((((-1.0)*x0*x24))+x47);
x55=(x50*x6);
x56=((((-1.0)*x48))+((x25*x29)));
x57=(x54*x6);
x58=(x44+x55);
x59=(((x6*(((((-1.0)*x34))+x47))))+x42);
x60=(((x5*((((x29*x38))+x35))))+((x39*x6)));
x61=(((x5*((((x29*x41))+x34))))+((x37*x6)));
x62=(x13*x59);
eerot[0]=(((x11*x61))+((x10*((((x12*x56))+x62)))));
eerot[1]=(((x11*(((((-1.0)*x20*x59))+(((-1.0)*x14*x56))))))+((x10*x61)));
eerot[2]=(((x13*((x48+((x25*x7))))))+((x12*((x42+x57)))));
eetrans[0]=(((x9*(((((-1.0)*x0*x17*x4))+(((-0.321)*x1*x2))))))+(((0.1)*x0))+(((0.321)*x25*x7))+(((0.4)*x25))+((x12*((((x16*x37))+((x22*x54))))))+((x13*((((x19*x41))+((x15*x25)))))));
eerot[3]=(((x11*x60))+((x10*((((x13*x58))+((x12*x52)))))));
eerot[4]=(((x11*(((((-1.0)*x20*x58))+(((-1.0)*x14*x52))))))+((x10*x60)));
eerot[5]=(((x13*((x33+x46))))+((x12*((((x6*(((((-1.0)*x35))+x43))))+x44)))));
eetrans[1]=((0.188)+(((0.1)*x1))+((x13*((((x19*x38))+((x15*x31))))))+(((0.321)*x33))+(((0.4)*x31))+((x9*(((((-1.0)*x17*x30))+(((0.321)*x27))))))+((x12*((((x16*x39))+((x22*x50)))))));
eerot[6]=(((x11*x51))+((x10*((x53+((x12*x45)))))));
eerot[7]=(((x10*x51))+((x11*(((((-1.0)*x20*x49))+(((-1.0)*x14*x45)))))));
eerot[8]=(((x12*x49))+(((-1.0)*x13*x45)));
eetrans[2]=(((x13*(((((-1.0)*x19*x3*x8))+(((-1.0)*x15*x4))))))+((x12*((((x16*x32))+((x22*x40))))))+(((-1.0)*x17*x24))+(((-0.4)*x4))+(((-0.321)*x28)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j18,cj18,sj18,htj18,j18mul,j19,cj19,sj19,htj19,j19mul,j20,cj20,sj20,htj20,j20mul,j21,cj21,sj21,htj21,j21mul,j17,cj17,sj17,htj17,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij18[2], _nj18,_ij19[2], _nj19,_ij20[2], _nj20,_ij21[2], _nj21,_ij17[2], _nj17;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j18=numeric_limits<IkReal>::quiet_NaN(); _ij18[0] = -1; _ij18[1] = -1; _nj18 = -1; j19=numeric_limits<IkReal>::quiet_NaN(); _ij19[0] = -1; _ij19[1] = -1; _nj19 = -1; j20=numeric_limits<IkReal>::quiet_NaN(); _ij20[0] = -1; _ij20[1] = -1; _nj20 = -1; j21=numeric_limits<IkReal>::quiet_NaN(); _ij21[0] = -1; _ij21[1] = -1; _nj21 = -1;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j17=pfree[0]; cj17=cos(pfree[0]); sj17=sin(pfree[0]);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=((((-0.18)*r02))+px);
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=((-0.188)+(((-0.18)*r12))+py);
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=(pz+(((-0.18)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*py*r20))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*pz*r00)));
rxp0_2=((((-1.0)*px*r10))+((py*r00)));
rxp1_0=((((-1.0)*py*r21))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*pz*r01)));
rxp1_2=((((-1.0)*px*r11))+((py*r01)));
rxp2_0=((((-1.0)*py*r22))+((pz*r12)));
rxp2_1=(((px*r22))+(((-1.0)*pz*r02)));
rxp2_2=((((-1.0)*px*r12))+((py*r02)));
{
IkReal dummyeval[1];
IkReal gconst0;
gconst0=((-1.0)*py);
IkReal gconst1;
gconst1=((0.642)*sj17);
IkReal gconst2;
gconst2=((-1.0)*py);
IkReal gconst3;
gconst3=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst4;
gconst4=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst5;
gconst5=((-1.0)*py);
IkReal gconst6;
gconst6=((0.642)*sj17);
IkReal gconst7;
gconst7=((-1.0)*py);
IkReal gconst8;
gconst8=((0.509841)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst9;
gconst9=((-0.003759)+(((0.2)*px))+(((-1.0)*pp)));
IkReal gconst10;
gconst10=((2.0)*px);
IkReal gconst11;
gconst11=((2.0)*px);
IkReal gconst12;
gconst12=((0.4)*py);
IkReal gconst13;
gconst13=((0.4)*py);
IkReal gconst14;
gconst14=((2.0)*px);
IkReal gconst15;
gconst15=((2.0)*px);
IkReal gconst16;
gconst16=((0.4)*py);
IkReal gconst17;
gconst17=((0.4)*py);
IkReal gconst18;
gconst18=py;
IkReal gconst19;
gconst19=((0.642)*sj17);
IkReal gconst20;
gconst20=py;
IkReal gconst21;
gconst21=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst22;
gconst22=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst23;
gconst23=py;
IkReal gconst24;
gconst24=((0.642)*sj17);
IkReal gconst25;
gconst25=py;
IkReal gconst26;
gconst26=((0.509841)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal gconst27;
gconst27=((-0.003759)+(((-0.2)*px))+(((-1.0)*pp)));
IkReal x63=(gconst20*gconst21);
IkReal x64=(gconst23*gconst27);
IkReal x65=(gconst25*gconst26);
IkReal x66=(gconst18*gconst22);
dummyeval[0]=((((-1.0)*x64*x66))+(((-1.0)*x63*x65))+(((-1.0)*gconst19*gconst22*gconst24*gconst26))+((x63*x64))+((x65*x66)));
if( IKabs(dummyeval[0]) < 0.0000001000000000  )
{
continue;

} else
{
IkReal op[8+1], zeror[8];
int numroots;
IkReal x67=((1.0)*gconst8);
IkReal x68=(gconst3*gconst7);
IkReal x69=(gconst0*gconst8);
IkReal x70=(gconst13*gconst15);
IkReal x71=((1.0)*gconst22);
IkReal x72=(gconst19*gconst24);
IkReal x73=(gconst0*gconst9);
IkReal x74=(gconst1*gconst6);
IkReal x75=(gconst27*gconst5);
IkReal x76=(gconst2*gconst3);
IkReal x77=((1.0)*gconst4);
IkReal x78=(gconst17*gconst5);
IkReal x79=(gconst12*gconst14);
IkReal x80=(gconst2*gconst9);
IkReal x81=((1.0)*gconst16);
IkReal x82=(gconst18*gconst25);
IkReal x83=(gconst12*gconst7);
IkReal x84=(gconst18*gconst9);
IkReal x85=(gconst20*gconst27);
IkReal x86=(gconst26*gconst4);
IkReal x87=(gconst1*gconst24);
IkReal x88=(gconst11*gconst3);
IkReal x89=((1.0)*gconst26);
IkReal x90=(gconst20*gconst21);
IkReal x91=(gconst13*gconst16);
IkReal x92=(gconst18*gconst23);
IkReal x93=(gconst21*gconst25);
IkReal x94=(gconst2*gconst21);
IkReal x95=(gconst12*gconst2);
IkReal x96=(gconst5*gconst9);
IkReal x97=(gconst20*gconst3);
IkReal x98=(gconst4*gconst7);
IkReal x99=(gconst11*gconst12);
IkReal x100=(gconst14*gconst17);
IkReal x101=(gconst15*gconst4);
IkReal x102=((1.0)*gconst13);
IkReal x103=(gconst10*gconst8);
IkReal x104=(gconst0*gconst16);
IkReal x105=(gconst23*gconst27);
IkReal x106=(gconst22*gconst25);
IkReal x107=(gconst10*gconst16);
IkReal x108=(gconst19*gconst6);
IkReal x109=(gconst22*gconst7);
IkReal x110=(gconst0*gconst7);
IkReal x111=(gconst17*gconst23);
IkReal x112=(gconst10*gconst14);
IkReal x113=(gconst11*gconst21);
IkReal x114=(gconst12*gconst20);
IkReal x115=(gconst18*gconst26);
IkReal x116=(gconst14*gconst9);
IkReal x117=(gconst13*gconst7);
IkReal x118=(gconst16*gconst22);
IkReal x119=(gconst23*x90);
IkReal x120=(gconst10*gconst25*gconst26);
IkReal x121=(gconst15*gconst22*gconst26);
IkReal x122=(gconst14*gconst18*gconst27);
op[0]=((((-1.0)*gconst26*x71*x72))+(((-1.0)*gconst25*x89*x90))+((gconst22*gconst26*x82))+(((-1.0)*gconst27*x71*x92))+((gconst21*gconst23*x85)));
op[1]=((((-1.0)*x122*x71))+(((-1.0)*gconst25*x81*x90))+((gconst13*gconst26*x82))+((gconst10*gconst26*x106))+(((-1.0)*gconst11*x89*x93))+((gconst14*gconst21*x85))+(((-1.0)*gconst17*x71*x92))+(((-1.0)*gconst27*x102*x92))+(((-1.0)*gconst25*x114*x89))+(((-1.0)*gconst16*x71*x72))+(((-1.0)*gconst13*x72*x89))+((x111*x90))+((gconst15*gconst22*x115))+((x118*x82))+((x105*x113))+(((-1.0)*gconst10*x105*x71))+(((-1.0)*gconst15*x89*x90))+((gconst12*gconst23*x85)));
op[2]=((((-1.0)*gconst15*x81*x90))+(((-1.0)*gconst27*x112*x71))+((gconst15*gconst18*x118))+((x79*x85))+((x100*x90))+((x82*x91))+((x106*x107))+((x111*x114))+((x111*x113))+((x82*x86))+((gconst23*gconst3*x85))+((gconst14*gconst27*x113))+(((-1.0)*gconst22*x67*x72))+(((-1.0)*gconst17*x102*x92))+((x115*x70))+(((-1.0)*gconst25*x89*x99))+(((-1.0)*gconst25*x89*x97))+(((-1.0)*gconst25*x67*x90))+((x109*x115))+((gconst9*x119))+(((-1.0)*gconst25*x114*x81))+(((-1.0)*gconst26*x71*x87))+(((-1.0)*gconst11*x81*x93))+((gconst22*gconst8*x82))+((x75*x90))+((gconst13*x120))+((gconst0*gconst26*x106))+(((-1.0)*gconst18*x71*x75))+(((-1.0)*gconst13*x72*x81))+(((-1.0)*gconst10*x102*x105))+(((-1.0)*gconst23*x71*x84))+((gconst10*x121))+(((-1.0)*gconst7*x89*x90))+(((-1.0)*gconst2*x89*x93))+(((-1.0)*gconst0*x105*x71))+(((-1.0)*gconst15*x113*x89))+(((-1.0)*gconst10*x111*x71))+(((-1.0)*x102*x122))+((x105*x99))+((x105*x94))+(((-1.0)*gconst26*x72*x77))+(((-1.0)*gconst26*x108*x71))+(((-1.0)*gconst27*x77*x92))+(((-1.0)*gconst18*x100*x71))+(((-1.0)*gconst15*x114*x89)));
op[3]=((((-1.0)*gconst17*gconst18*gconst23*gconst4))+((gconst16*gconst18*gconst25*gconst4))+((gconst15*gconst18*gconst22*gconst8))+(((-1.0)*gconst16*gconst19*gconst22*gconst6))+((gconst11*gconst12*gconst14*gconst27))+(((-1.0)*gconst16*gconst20*gconst21*gconst7))+(((-1.0)*gconst10*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst13*gconst14*gconst27))+((gconst0*gconst16*gconst22*gconst25))+((gconst0*gconst15*gconst22*gconst26))+((gconst14*gconst2*gconst21*gconst27))+((gconst10*gconst13*gconst15*gconst26))+(((-1.0)*gconst16*gconst2*gconst21*gconst25))+((gconst11*gconst23*gconst27*gconst3))+(((-1.0)*gconst10*gconst13*gconst17*gconst23))+((gconst11*gconst14*gconst17*gconst21))+(((-1.0)*gconst15*gconst20*gconst26*gconst3))+((gconst12*gconst14*gconst17*gconst20))+(((-1.0)*gconst14*gconst18*gconst22*gconst9))+(((-1.0)*gconst13*gconst18*gconst27*gconst5))+(((-1.0)*gconst16*gconst20*gconst25*gconst3))+((gconst11*gconst21*gconst23*gconst9))+(((-1.0)*gconst11*gconst12*gconst15*gconst26))+(((-1.0)*gconst11*gconst21*gconst26*gconst7))+((gconst14*gconst20*gconst21*gconst9))+((gconst16*gconst18*gconst22*gconst7))+(((-1.0)*gconst17*gconst18*gconst22*gconst5))+(((-1.0)*gconst15*gconst2*gconst21*gconst26))+((gconst12*gconst20*gconst23*gconst9))+((gconst13*gconst18*gconst25*gconst8))+(((-1.0)*gconst13*gconst18*gconst23*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst20))+((gconst10*gconst25*gconst26*gconst4))+(((-1.0)*gconst10*gconst22*gconst27*gconst5))+((gconst14*gconst20*gconst27*gconst3))+((gconst15*gconst18*gconst26*gconst4))+((gconst13*gconst15*gconst16*gconst18))+((gconst10*gconst22*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst23))+(((-1.0)*gconst15*gconst20*gconst21*gconst8))+(((-1.0)*gconst11*gconst15*gconst16*gconst21))+(((-1.0)*gconst10*gconst14*gconst17*gconst22))+(((-1.0)*gconst11*gconst12*gconst16*gconst25))+(((-1.0)*gconst13*gconst19*gconst24*gconst8))+((gconst11*gconst12*gconst17*gconst23))+((gconst12*gconst2*gconst23*gconst27))+(((-1.0)*gconst13*gconst14*gconst17*gconst18))+((gconst17*gconst20*gconst23*gconst3))+(((-1.0)*gconst13*gconst19*gconst26*gconst6))+((gconst17*gconst20*gconst21*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst26))+((gconst10*gconst15*gconst16*gconst22))+(((-1.0)*gconst1*gconst16*gconst22*gconst24))+(((-1.0)*gconst0*gconst13*gconst23*gconst27))+((gconst11*gconst21*gconst27*gconst5))+((gconst13*gconst18*gconst26*gconst7))+((gconst17*gconst2*gconst21*gconst23))+(((-1.0)*gconst10*gconst23*gconst27*gconst4))+(((-1.0)*gconst0*gconst14*gconst22*gconst27))+((gconst0*gconst13*gconst25*gconst26))+(((-1.0)*gconst11*gconst25*gconst26*gconst3))+(((-1.0)*gconst1*gconst13*gconst24*gconst26))+((gconst10*gconst22*gconst26*gconst7))+((gconst12*gconst20*gconst27*gconst5))+(((-1.0)*gconst14*gconst18*gconst27*gconst4))+(((-1.0)*gconst12*gconst20*gconst26*gconst7))+(((-1.0)*gconst11*gconst21*gconst25*gconst8))+(((-1.0)*gconst16*gconst19*gconst24*gconst4))+((gconst10*gconst13*gconst16*gconst25))+(((-1.0)*gconst12*gconst20*gconst25*gconst8)));
op[4]=(((gconst12*gconst14*gconst2*gconst27))+(((-1.0)*gconst11*gconst15*gconst26*gconst3))+(((-1.0)*gconst10*gconst17*gconst23*gconst4))+((gconst10*gconst15*gconst22*gconst8))+(((-1.0)*gconst13*gconst17*gconst18*gconst5))+((gconst2*gconst23*gconst27*gconst3))+((gconst18*gconst22*gconst7*gconst8))+((gconst14*gconst17*gconst2*gconst21))+((gconst20*gconst27*gconst3*gconst5))+(((-1.0)*gconst2*gconst21*gconst25*gconst8))+((gconst11*gconst12*gconst14*gconst17))+(((-1.0)*gconst18*gconst27*gconst4*gconst5))+(((-1.0)*gconst10*gconst13*gconst14*gconst17))+(((-1.0)*gconst2*gconst21*gconst26*gconst7))+(((-1.0)*gconst12*gconst15*gconst2*gconst26))+((gconst10*gconst16*gconst22*gconst7))+((gconst13*gconst15*gconst18*gconst8))+((gconst12*gconst17*gconst2*gconst23))+((gconst10*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst13*gconst16*gconst24))+((gconst11*gconst14*gconst27*gconst3))+(((-1.0)*gconst0*gconst13*gconst14*gconst27))+(((-1.0)*gconst1*gconst22*gconst24*gconst8))+((gconst18*gconst25*gconst4*gconst8))+(((-1.0)*gconst12*gconst16*gconst20*gconst7))+(((-1.0)*gconst13*gconst14*gconst18*gconst9))+((gconst0*gconst13*gconst16*gconst25))+((gconst13*gconst16*gconst18*gconst7))+(((-1.0)*gconst20*gconst26*gconst3*gconst7))+((gconst11*gconst12*gconst27*gconst5))+(((-1.0)*gconst0*gconst14*gconst17*gconst22))+(((-1.0)*gconst20*gconst25*gconst3*gconst8))+(((-1.0)*gconst12*gconst15*gconst20*gconst8))+(((-1.0)*gconst19*gconst26*gconst4*gconst6))+(((-1.0)*gconst15*gconst16*gconst2*gconst21))+(((-1.0)*gconst10*gconst14*gconst22*gconst9))+((gconst10*gconst13*gconst25*gconst8))+(((-1.0)*gconst18*gconst22*gconst5*gconst9))+((gconst10*gconst13*gconst26*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst16))+((gconst0*gconst13*gconst15*gconst26))+(((-1.0)*gconst12*gconst16*gconst2*gconst25))+(((-1.0)*gconst20*gconst21*gconst7*gconst8))+(((-1.0)*gconst11*gconst12*gconst26*gconst7))+(((-1.0)*gconst2*gconst25*gconst26*gconst3))+((gconst2*gconst21*gconst27*gconst5))+(((-1.0)*gconst14*gconst17*gconst18*gconst4))+((gconst2*gconst21*gconst23*gconst9))+(((-1.0)*gconst13*gconst16*gconst19*gconst6))+(((-1.0)*gconst0*gconst22*gconst23*gconst9))+(((-1.0)*gconst10*gconst14*gconst27*gconst4))+(((-1.0)*gconst11*gconst12*gconst25*gconst8))+((gconst12*gconst14*gconst20*gconst9))+((gconst18*gconst26*gconst4*gconst7))+(((-1.0)*gconst0*gconst23*gconst27*gconst4))+((gconst20*gconst21*gconst5*gconst9))+((gconst11*gconst12*gconst23*gconst9))+(((-1.0)*gconst0*gconst22*gconst27*gconst5))+(((-1.0)*gconst10*gconst13*gconst27*gconst5))+(((-1.0)*gconst1*gconst22*gconst26*gconst6))+((gconst10*gconst15*gconst26*gconst4))+(((-1.0)*gconst10*gconst13*gconst23*gconst9))+((gconst11*gconst17*gconst23*gconst3))+(((-1.0)*gconst10*gconst17*gconst22*gconst5))+((gconst0*gconst15*gconst16*gconst22))+(((-1.0)*gconst11*gconst16*gconst21*gconst7))+((gconst0*gconst25*gconst26*gconst4))+(((-1.0)*gconst19*gconst24*gconst4*gconst8))+((gconst0*gconst22*gconst25*gconst8))+(((-1.0)*gconst18*gconst23*gconst4*gconst9))+((gconst11*gconst14*gconst21*gconst9))+(((-1.0)*gconst11*gconst16*gconst25*gconst3))+(((-1.0)*gconst11*gconst15*gconst21*gconst8))+((gconst14*gconst17*gconst20*gconst3))+((gconst12*gconst17*gconst20*gconst5))+((gconst11*gconst17*gconst21*gconst5))+(((-1.0)*gconst19*gconst22*gconst6*gconst8))+((gconst15*gconst16*gconst18*gconst4))+((gconst0*gconst22*gconst26*gconst7))+((gconst20*gconst23*gconst3*gconst9))+(((-1.0)*gconst1*gconst24*gconst26*gconst4))+((gconst10*gconst16*gconst25*gconst4))+(((-1.0)*gconst0*gconst13*gconst17*gconst23))+(((-1.0)*gconst15*gconst16*gconst20*gconst3)));
op[5]=(((gconst0*gconst13*gconst26*gconst7))+(((-1.0)*gconst16*gconst2*gconst25*gconst3))+(((-1.0)*gconst13*gconst18*gconst5*gconst9))+(((-1.0)*gconst16*gconst19*gconst4*gconst6))+((gconst17*gconst20*gconst3*gconst5))+(((-1.0)*gconst0*gconst14*gconst27*gconst4))+((gconst10*gconst15*gconst16*gconst4))+(((-1.0)*gconst0*gconst17*gconst23*gconst4))+(((-1.0)*gconst10*gconst13*gconst14*gconst9))+(((-1.0)*gconst16*gconst20*gconst3*gconst7))+((gconst12*gconst20*gconst5*gconst9))+(((-1.0)*gconst0*gconst14*gconst22*gconst9))+((gconst11*gconst14*gconst17*gconst3))+((gconst0*gconst15*gconst22*gconst8))+(((-1.0)*gconst0*gconst13*gconst14*gconst17))+(((-1.0)*gconst15*gconst2*gconst21*gconst8))+((gconst10*gconst25*gconst4*gconst8))+(((-1.0)*gconst11*gconst25*gconst3*gconst8))+(((-1.0)*gconst1*gconst16*gconst22*gconst6))+(((-1.0)*gconst15*gconst2*gconst26*gconst3))+(((-1.0)*gconst11*gconst26*gconst3*gconst7))+((gconst17*gconst2*gconst23*gconst3))+((gconst0*gconst16*gconst25*gconst4))+((gconst10*gconst26*gconst4*gconst7))+(((-1.0)*gconst11*gconst12*gconst15*gconst8))+((gconst14*gconst2*gconst21*gconst9))+(((-1.0)*gconst0*gconst13*gconst27*gconst5))+((gconst17*gconst2*gconst21*gconst5))+((gconst12*gconst14*gconst17*gconst2))+(((-1.0)*gconst16*gconst2*gconst21*gconst7))+((gconst11*gconst23*gconst3*gconst9))+((gconst10*gconst13*gconst16*gconst7))+((gconst11*gconst12*gconst17*gconst5))+(((-1.0)*gconst12*gconst2*gconst25*gconst8))+((gconst12*gconst2*gconst27*gconst5))+((gconst11*gconst21*gconst5*gconst9))+(((-1.0)*gconst13*gconst19*gconst6*gconst8))+(((-1.0)*gconst10*gconst23*gconst4*gconst9))+((gconst0*gconst13*gconst15*gconst16))+(((-1.0)*gconst1*gconst16*gconst24*gconst4))+((gconst14*gconst20*gconst3*gconst9))+(((-1.0)*gconst12*gconst15*gconst16*gconst2))+(((-1.0)*gconst0*gconst13*gconst23*gconst9))+(((-1.0)*gconst11*gconst15*gconst16*gconst3))+((gconst16*gconst18*gconst4*gconst7))+((gconst12*gconst2*gconst23*gconst9))+(((-1.0)*gconst12*gconst2*gconst26*gconst7))+((gconst10*gconst22*gconst7*gconst8))+(((-1.0)*gconst1*gconst13*gconst24*gconst8))+(((-1.0)*gconst15*gconst20*gconst3*gconst8))+(((-1.0)*gconst12*gconst20*gconst7*gconst8))+((gconst11*gconst12*gconst14*gconst9))+(((-1.0)*gconst10*gconst14*gconst17*gconst4))+((gconst13*gconst18*gconst7*gconst8))+((gconst10*gconst13*gconst15*gconst8))+(((-1.0)*gconst17*gconst18*gconst4*gconst5))+(((-1.0)*gconst10*gconst22*gconst5*gconst9))+(((-1.0)*gconst11*gconst21*gconst7*gconst8))+((gconst14*gconst2*gconst27*gconst3))+(((-1.0)*gconst1*gconst13*gconst26*gconst6))+(((-1.0)*gconst10*gconst27*gconst4*gconst5))+(((-1.0)*gconst14*gconst18*gconst4*gconst9))+((gconst0*gconst15*gconst26*gconst4))+((gconst15*gconst18*gconst4*gconst8))+(((-1.0)*gconst10*gconst13*gconst17*gconst5))+((gconst0*gconst13*gconst25*gconst8))+(((-1.0)*gconst0*gconst17*gconst22*gconst5))+(((-1.0)*gconst11*gconst12*gconst16*gconst7))+((gconst11*gconst27*gconst3*gconst5))+((gconst0*gconst16*gconst22*gconst7)));
op[6]=((((-1.0)*gconst26*x74*x77))+((x110*x86))+((x96*x97))+((x96*x99))+((x79*x80))+(((-1.0)*gconst2*x81*x83))+(((-1.0)*gconst13*x74*x81))+((x107*x98))+((x78*x88))+((gconst23*gconst9*x76))+((x100*x76))+(((-1.0)*gconst23*x73*x77))+(((-1.0)*gconst25*x67*x76))+(((-1.0)*gconst22*x67*x74))+(((-1.0)*gconst15*x76*x81))+((x78*x95))+(((-1.0)*gconst9*x112*x77))+(((-1.0)*gconst14*x102*x73))+(((-1.0)*gconst4*x108*x67))+((gconst18*gconst8*x98))+((x103*x117))+((x69*x70))+(((-1.0)*gconst5*x71*x73))+(((-1.0)*gconst10*x102*x96))+(((-1.0)*gconst20*x67*x68))+((x75*x76))+(((-1.0)*gconst2*x68*x89))+(((-1.0)*gconst10*x77*x78))+(((-1.0)*gconst0*x102*x78))+((gconst21*gconst5*x80))+((x109*x69))+(((-1.0)*gconst11*x68*x81))+((x116*x88))+(((-1.0)*gconst4*x67*x87))+(((-1.0)*gconst11*x67*x83))+(((-1.0)*gconst5*x77*x84))+(((-1.0)*gconst0*x75*x77))+(((-1.0)*gconst0*x100*x77))+((gconst25*gconst4*x69))+((x101*x103))+((x101*x104))+(((-1.0)*gconst15*x67*x88))+(((-1.0)*gconst7*x67*x94))+((x110*x91))+(((-1.0)*gconst15*x67*x95)));
op[7]=(((x101*x69))+(((-1.0)*gconst0*x77*x78))+((x103*x98))+((x116*x76))+(((-1.0)*gconst13*x67*x74))+((gconst12*gconst5*x80))+(((-1.0)*gconst2*x68*x81))+(((-1.0)*gconst11*x67*x68))+((x88*x96))+(((-1.0)*gconst16*x74*x77))+(((-1.0)*gconst14*x73*x77))+(((-1.0)*gconst2*x67*x83))+((x76*x78))+(((-1.0)*gconst15*x67*x76))+(((-1.0)*gconst10*x77*x96))+((x117*x69))+((x104*x98))+(((-1.0)*gconst5*x102*x73)));
op[8]=((((-1.0)*gconst5*x73*x77))+(((-1.0)*gconst2*x67*x68))+((x69*x98))+((x76*x96))+(((-1.0)*gconst4*x67*x74)));
polyroots8(op,zeror,numroots);
IkReal j15array[8], cj15array[8], sj15array[8], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[8]={true,true,true,true,true,true,true,true};
_nj15 = 8;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
IkReal dummyeval[1];
IkReal gconst44;
IkReal x123=((4.0)*sj17);
IkReal x124=((0.8)*sj17);
IkReal x125=(py*sj15);
IkReal x126=(cj15*px);
gconst44=IKsign(((((-8.0)*sj17*x125*x126))+(((-1.0)*x123*(x126*x126)))+(((-1.0)*x123*(pz*pz)))+(((-1.0)*x123*(x125*x125)))+((x124*x125))+((x124*x126))+(((-0.04)*sj17))));
IkReal x127=((20.0)*sj17);
IkReal x128=(cj15*px);
IkReal x129=(py*sj15);
IkReal x130=((100.0)*sj17);
dummyeval[0]=((((-1.0)*x130*(pz*pz)))+(((-200.0)*sj17*x128*x129))+(((-1.0)*x130*(x129*x129)))+(((-1.0)*sj17))+(((-1.0)*x130*(x128*x128)))+((x127*x129))+((x127*x128)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x131=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x131;
evalcond[2]=x131;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst49;
IkReal x132=((321.0)*cj18);
IkReal x133=(cj15*px);
IkReal x134=(py*sj15);
gconst49=IKsign(((40.0)+(((-321.0)*pz*sj18))+(((32.1)*cj18))+(((-400.0)*x133))+(((-400.0)*x134))+(((-1.0)*x132*x133))+(((-1.0)*x132*x134))));
IkReal x135=(cj15*px);
IkReal x136=((10.0)*cj18);
IkReal x137=(py*sj15);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x135*x136))+(((-12.4610591900312)*x137))+(((-12.4610591900312)*x135))+(((-10.0)*pz*sj18))+(((-1.0)*x136*x137))+cj18);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x138=((10.0)*sj18);
dummyeval[0]=((((-1.0)*py*sj15*x138))+(((-1.0)*cj15*px*x138))+(((10.0)*cj18*pz))+sj18+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x139=IKsin(j16);
IkReal x140=IKcos(j16);
IkReal x141=(cj15*px);
IkReal x142=(py*sj15);
IkReal x143=((1.0)*x140);
IkReal x144=((0.8)*x140);
evalcond[0]=((0.721)*x139);
evalcond[1]=((((-0.1)*x139))+((x139*x142))+((x139*x141)));
evalcond[2]=((0.721)+(((-1.0)*x142*x143))+(((0.1)*x140))+(((-1.0)*x141*x143)));
evalcond[3]=((-0.5768)+(((-0.08)*x140))+((x142*x144))+((x141*x144)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x703=IKsin(j16);
IkReal x704=IKcos(j16);
IkReal x705=(cj15*px);
IkReal x706=(py*sj15);
IkReal x707=((1.0)*x704);
IkReal x708=((0.8)*x704);
evalcond[0]=((0.079)*x703);
evalcond[1]=((((-0.1)*x703))+((x703*x705))+((x703*x706)));
evalcond[2]=((0.079)+(((-1.0)*x706*x707))+(((0.1)*x704))+(((-1.0)*x705*x707)));
evalcond[3]=((-0.0632)+((x706*x708))+((x705*x708))+(((-0.08)*x704)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x709=((321000.0)*sj18);
IkReal x710=(py*sj15);
IkReal x711=(cj15*px);
IkReal x712=((1000.0)*pz);
IkReal x713=((321.0)*sj18);
IkReal x714=(cj18*pz);
CheckValue<IkReal> x715=IKPowWithIntegerCheck(((((-1.0)*x709*x711))+(((-1.0)*x709*x710))+(((321000.0)*x714))+(((400000.0)*pz))+(((32100.0)*sj18))),-1);
if(!x715.valid){
continue;
}
CheckValue<IkReal> x716=IKPowWithIntegerCheck(((((32.1)*sj18))+(((-1.0)*x711*x713))+(((-1.0)*x710*x713))+(((321.0)*x714))+(((400.0)*pz))),-1);
if(!x716.valid){
continue;
}
if( IKabs(((x715.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x716.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x711*x712))+((x710*x712)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x715.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x716.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x711*x712))+((x710*x712))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x715.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))), ((x716.value)*(((((-103.041)*cj18*sj18))+(((-100.0)*pz))+(((-128.4)*sj18))+((x711*x712))+((x710*x712))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x717=IKsin(j16);
IkReal x718=IKcos(j16);
IkReal x719=((0.321)*sj18);
IkReal x720=((0.321)*cj18);
IkReal x721=(py*sj15);
IkReal x722=(cj15*px);
IkReal x723=(pz*x717);
IkReal x724=(x718*x722);
evalcond[0]=((((0.4)*x717))+((x717*x720))+pz+((x718*x719)));
evalcond[1]=((((-0.1)*x717))+((x717*x721))+((x717*x722))+x719+((pz*x718)));
evalcond[2]=((0.1)+(((0.4)*x718))+(((-1.0)*x717*x719))+(((-1.0)*x722))+(((-1.0)*x721))+((x718*x720)));
evalcond[3]=((0.4)+(((0.1)*x718))+(((-1.0)*x724))+x720+x723+(((-1.0)*x718*x721)));
evalcond[4]=((-0.066959)+(((0.8)*x724))+(((-1.0)*pp))+(((0.8)*x718*x721))+(((-0.8)*x723))+(((0.2)*x721))+(((0.2)*x722))+(((-0.08)*x718)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x725=((1000.0)*pz);
CheckValue<IkReal> x726 = IKatan2WithCheck((gconst49*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((cj15*px*x725))+((py*sj15*x725))+(((128.4)*sj18))))),(gconst49*(((-160.0)+(((-256.8)*cj18))+((pz*x725))+(((-103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
j16array[0]=x726.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x727=IKsin(j16);
IkReal x728=IKcos(j16);
IkReal x729=((0.321)*sj18);
IkReal x730=((0.321)*cj18);
IkReal x731=(py*sj15);
IkReal x732=(cj15*px);
IkReal x733=(pz*x727);
IkReal x734=(x728*x732);
evalcond[0]=(((x727*x730))+((x728*x729))+pz+(((0.4)*x727)));
evalcond[1]=(((x727*x732))+((x727*x731))+(((-0.1)*x727))+x729+((pz*x728)));
evalcond[2]=((0.1)+(((-1.0)*x727*x729))+((x728*x730))+(((-1.0)*x732))+(((-1.0)*x731))+(((0.4)*x728)));
evalcond[3]=((0.4)+(((-1.0)*x734))+(((-1.0)*x728*x731))+(((0.1)*x728))+x733+x730);
evalcond[4]=((-0.066959)+(((-0.08)*x728))+(((-1.0)*pp))+(((-0.8)*x733))+(((0.8)*x728*x731))+(((0.2)*x731))+(((0.2)*x732))+(((0.8)*x734)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x735=(cj15*py);
IkReal x736=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x735))+x736);
evalcond[2]=((((-1.0)*x736))+x735);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst50;
IkReal x737=((321.0)*cj18);
IkReal x738=(cj15*px);
IkReal x739=(py*sj15);
gconst50=IKsign(((-40.0)+(((-321.0)*pz*sj18))+(((400.0)*x738))+(((400.0)*x739))+(((-32.1)*cj18))+((x737*x738))+((x737*x739))));
IkReal x740=(py*sj15);
IkReal x741=((10.0)*cj18);
IkReal x742=(cj15*px);
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj18))+((x740*x741))+((x741*x742))+(((12.4610591900312)*x740))+(((12.4610591900312)*x742))+(((-1.0)*cj18)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal x743=((10.0)*sj18);
dummyeval[0]=(((py*sj15*x743))+(((10.0)*cj18*pz))+(((-1.0)*sj18))+((cj15*px*x743))+(((12.4610591900312)*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x744=IKsin(j16);
IkReal x745=IKcos(j16);
IkReal x746=((1.0)*py*sj15);
IkReal x747=((1.0)*cj15*px);
IkReal x748=((0.8)*x745);
evalcond[0]=((0.721)*x744);
evalcond[1]=((((0.1)*x744))+(((-1.0)*x744*x746))+(((-1.0)*x744*x747)));
evalcond[2]=((0.721)+(((-1.0)*x745*x746))+(((-1.0)*x745*x747))+(((0.1)*x745)));
evalcond[3]=((-0.5768)+((py*sj15*x748))+(((-0.08)*x745))+((cj15*px*x748)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x749=IKsin(j16);
IkReal x750=IKcos(j16);
IkReal x751=((1.0)*py*sj15);
IkReal x752=((1.0)*cj15*px);
IkReal x753=((0.8)*x750);
evalcond[0]=((0.079)*x749);
evalcond[1]=((((0.1)*x749))+(((-1.0)*x749*x752))+(((-1.0)*x749*x751)));
evalcond[2]=((0.079)+(((0.1)*x750))+(((-1.0)*x750*x752))+(((-1.0)*x750*x751)));
evalcond[3]=((-0.0632)+(((-0.08)*x750))+((cj15*px*x753))+((py*sj15*x753)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x754=((321000.0)*sj18);
IkReal x755=(py*sj15);
IkReal x756=(cj15*px);
IkReal x757=((1000.0)*pz);
IkReal x758=((321.0)*sj18);
IkReal x759=(cj18*pz);
CheckValue<IkReal> x760=IKPowWithIntegerCheck(((((321000.0)*x759))+(((400000.0)*pz))+(((-32100.0)*sj18))+((x754*x755))+((x754*x756))),-1);
if(!x760.valid){
continue;
}
CheckValue<IkReal> x761=IKPowWithIntegerCheck((((x756*x758))+(((321.0)*x759))+(((400.0)*pz))+(((-32.1)*sj18))+((x755*x758))),-1);
if(!x761.valid){
continue;
}
if( IKabs(((x760.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x761.value)*((((x756*x757))+(((-100.0)*pz))+(((103.041)*cj18*sj18))+((x755*x757))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x760.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))))+IKsqr(((x761.value)*((((x756*x757))+(((-100.0)*pz))+(((103.041)*cj18*sj18))+((x755*x757))+(((128.4)*sj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x760.value)*(((((103041.0)*(sj18*sj18)))+(((-1000000.0)*(pz*pz)))))), ((x761.value)*((((x756*x757))+(((-100.0)*pz))+(((103.041)*cj18*sj18))+((x755*x757))+(((128.4)*sj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x762=IKsin(j16);
IkReal x763=IKcos(j16);
IkReal x764=((0.321)*sj18);
IkReal x765=((0.321)*cj18);
IkReal x766=(cj15*px);
IkReal x767=(py*sj15);
IkReal x768=(pz*x762);
IkReal x769=((1.0)*x762);
IkReal x770=((1.0)*x763);
IkReal x771=(x763*x766);
evalcond[0]=((((-1.0)*x763*x764))+((x762*x765))+pz+(((0.4)*x762)));
evalcond[1]=((0.1)+((x763*x765))+((x762*x764))+(((-1.0)*x766))+(((-1.0)*x767))+(((0.4)*x763)));
evalcond[2]=((0.4)+(((0.1)*x763))+(((-1.0)*x767*x770))+(((-1.0)*x766*x770))+x768+x765);
evalcond[3]=((((-1.0)*x766*x769))+(((0.1)*x762))+(((-1.0)*x767*x769))+(((-1.0)*pz*x770))+x764);
evalcond[4]=((-0.066959)+(((0.8)*x763*x767))+(((0.8)*x771))+(((-0.08)*x763))+(((0.2)*x766))+(((0.2)*x767))+(((-1.0)*pp))+(((-0.8)*x768)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x772=((1000.0)*pz);
CheckValue<IkReal> x773 = IKatan2WithCheck((gconst50*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*cj15*px*x772))+(((128.4)*sj18))+(((-1.0)*py*sj15*x772))))),(gconst50*(((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x772))+(((103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x773.valid){
continue;
}
j16array[0]=x773.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x774=IKsin(j16);
IkReal x775=IKcos(j16);
IkReal x776=((0.321)*sj18);
IkReal x777=((0.321)*cj18);
IkReal x778=(cj15*px);
IkReal x779=(py*sj15);
IkReal x780=(pz*x774);
IkReal x781=((1.0)*x774);
IkReal x782=((1.0)*x775);
IkReal x783=(x775*x778);
evalcond[0]=(((x774*x777))+pz+(((-1.0)*x775*x776))+(((0.4)*x774)));
evalcond[1]=((0.1)+((x774*x776))+(((0.4)*x775))+(((-1.0)*x779))+(((-1.0)*x778))+((x775*x777)));
evalcond[2]=((0.4)+(((0.1)*x775))+x777+x780+(((-1.0)*x778*x782))+(((-1.0)*x779*x782)));
evalcond[3]=((((0.1)*x774))+x776+(((-1.0)*pz*x782))+(((-1.0)*x778*x781))+(((-1.0)*x779*x781)));
evalcond[4]=((-0.066959)+(((-0.8)*x780))+(((-0.08)*x775))+(((-1.0)*pp))+(((0.2)*x778))+(((0.2)*x779))+(((0.8)*x783))+(((0.8)*x775*x779)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x784=((-1.0)*cj15*py);
evalcond[0]=((IKabs(px))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x784;
evalcond[2]=x784;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*pz*sj18))+cj18);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst51;
CheckValue<IkReal> x785 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x785.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x786=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x786.valid){
continue;
}
if( (((1.24610591900312)*(x786.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x786.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst51=((((-1.0)*(x785.value)))+(((-1.0)*(IKasin(((1.24610591900312)*(x786.value)))))));
IkReal gconst52;
gconst52=IKsin(gconst51);
IkReal gconst53;
gconst53=IKcos(gconst51);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst51))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst53))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst53+(((-10.0)*gconst52*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x787=(gconst52*pz);
CheckValue<IkReal> x788=IKPowWithIntegerCheck(((40.0)+(((32.1)*gconst53))+(((-321.0)*x787))),-1);
if(!x788.valid){
continue;
}
CheckValue<IkReal> x789=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst53))+(((-321000.0)*x787))),-1);
if(!x789.valid){
continue;
}
if( IKabs(((x788.value)*(((((-100.0)*pz))+(((103.041)*gconst52*gconst53))+(((128.4)*gconst52)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x789.value)*(((-10000.0)+(((103041.0)*(gconst52*gconst52))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x788.value)*(((((-100.0)*pz))+(((103.041)*gconst52*gconst53))+(((128.4)*gconst52))))))+IKsqr(((x789.value)*(((-10000.0)+(((103041.0)*(gconst52*gconst52)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x788.value)*(((((-100.0)*pz))+(((103.041)*gconst52*gconst53))+(((128.4)*gconst52))))), ((x789.value)*(((-10000.0)+(((103041.0)*(gconst52*gconst52)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x790=IKcos(j16);
IkReal x791=IKsin(j16);
IkReal x792=((0.321)*gconst52);
IkReal x793=((0.321)*gconst53);
IkReal x794=(pz*x791);
evalcond[0]=(((pz*x790))+(((-0.1)*x791))+x792);
evalcond[1]=((0.4)+(((0.1)*x790))+x793+x794);
evalcond[2]=((-0.32)+(((-0.8)*x794))+(((-0.08)*x790))+(((-0.2568)*gconst53)));
evalcond[3]=(((x790*x792))+pz+(((0.4)*x791))+((x791*x793)));
evalcond[4]=((0.1)+((x790*x793))+(((-1.0)*x791*x792))+(((0.4)*x790)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x795=pz*pz;
IkReal x796=((321.0)*gconst52);
CheckValue<IkReal> x797=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x795))),-1);
if(!x797.valid){
continue;
}
CheckValue<IkReal> x798=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x795))),-1);
if(!x798.valid){
continue;
}
if( IKabs(((x797.value)*(((((-3210.0)*gconst53*pz))+(((-4000.0)*pz))+x796)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x798.value)*(((-40.0)+(((-1.0)*pz*x796))+(((-32.1)*gconst53)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x797.value)*(((((-3210.0)*gconst53*pz))+(((-4000.0)*pz))+x796))))+IKsqr(((x798.value)*(((-40.0)+(((-1.0)*pz*x796))+(((-32.1)*gconst53))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x797.value)*(((((-3210.0)*gconst53*pz))+(((-4000.0)*pz))+x796))), ((x798.value)*(((-40.0)+(((-1.0)*pz*x796))+(((-32.1)*gconst53))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x799=IKcos(j16);
IkReal x800=IKsin(j16);
IkReal x801=((0.321)*gconst52);
IkReal x802=((0.321)*gconst53);
IkReal x803=(pz*x800);
evalcond[0]=((((-0.1)*x800))+((pz*x799))+x801);
evalcond[1]=((0.4)+(((0.1)*x799))+x803+x802);
evalcond[2]=((-0.32)+(((-0.08)*x799))+(((-0.2568)*gconst53))+(((-0.8)*x803)));
evalcond[3]=(((x800*x802))+((x799*x801))+pz+(((0.4)*x800)));
evalcond[4]=((0.1)+(((-1.0)*x800*x801))+((x799*x802))+(((0.4)*x799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x804=pz*pz;
IkReal x805=((321.0)*gconst52);
CheckValue<IkReal> x806=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x804))),-1);
if(!x806.valid){
continue;
}
CheckValue<IkReal> x807=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x804))),-1);
if(!x807.valid){
continue;
}
if( IKabs(((x806.value)*(((((-3210.0)*gconst53*pz))+(((-4000.0)*pz))+x805)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x807.value)*(((40.0)+((pz*x805))+(((32.1)*gconst53)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x806.value)*(((((-3210.0)*gconst53*pz))+(((-4000.0)*pz))+x805))))+IKsqr(((x807.value)*(((40.0)+((pz*x805))+(((32.1)*gconst53))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x806.value)*(((((-3210.0)*gconst53*pz))+(((-4000.0)*pz))+x805))), ((x807.value)*(((40.0)+((pz*x805))+(((32.1)*gconst53))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x808=IKcos(j16);
IkReal x809=IKsin(j16);
IkReal x810=((0.321)*gconst52);
IkReal x811=((0.321)*gconst53);
IkReal x812=(pz*x809);
evalcond[0]=((((-0.1)*x809))+((pz*x808))+x810);
evalcond[1]=((0.4)+(((0.1)*x808))+x812+x811);
evalcond[2]=((-0.32)+(((-0.8)*x812))+(((-0.08)*x808))+(((-0.2568)*gconst53)));
evalcond[3]=(((x809*x811))+((x808*x810))+pz+(((0.4)*x809)));
evalcond[4]=((0.1)+(((-1.0)*x809*x810))+((x808*x811))+(((0.4)*x808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst54;
CheckValue<IkReal> x813 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x813.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x814=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x814.valid){
continue;
}
if( (((1.24610591900312)*(x814.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x814.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst54=((3.14159265358979)+(((-1.0)*(x813.value)))+(IKasin(((1.24610591900312)*(x814.value)))));
IkReal gconst55;
gconst55=IKsin(gconst54);
IkReal gconst56;
gconst56=IKcos(gconst54);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst54))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst56))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*gconst55*pz))+gconst56);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x815=(gconst55*pz);
CheckValue<IkReal> x816=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x815))+(((32.1)*gconst56))),-1);
if(!x816.valid){
continue;
}
CheckValue<IkReal> x817=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst56))+(((-321000.0)*x815))),-1);
if(!x817.valid){
continue;
}
if( IKabs(((x816.value)*(((((-100.0)*pz))+(((128.4)*gconst55))+(((103.041)*gconst55*gconst56)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x817.value)*(((-10000.0)+(((103041.0)*(gconst55*gconst55))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x816.value)*(((((-100.0)*pz))+(((128.4)*gconst55))+(((103.041)*gconst55*gconst56))))))+IKsqr(((x817.value)*(((-10000.0)+(((103041.0)*(gconst55*gconst55)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x816.value)*(((((-100.0)*pz))+(((128.4)*gconst55))+(((103.041)*gconst55*gconst56))))), ((x817.value)*(((-10000.0)+(((103041.0)*(gconst55*gconst55)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x818=IKcos(j16);
IkReal x819=IKsin(j16);
IkReal x820=((0.321)*x818);
IkReal x821=((0.321)*x819);
IkReal x822=(pz*x819);
evalcond[0]=(((pz*x818))+(((0.321)*gconst55))+(((-0.1)*x819)));
evalcond[1]=((0.4)+(((0.321)*gconst56))+x822+(((0.1)*x818)));
evalcond[2]=((-0.32)+(((-0.8)*x822))+(((-0.2568)*gconst56))+(((-0.08)*x818)));
evalcond[3]=(((gconst56*x821))+(((0.4)*x819))+((gconst55*x820))+pz);
evalcond[4]=((0.1)+(((-1.0)*gconst55*x821))+((gconst56*x820))+(((0.4)*x818)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x823=pz*pz;
IkReal x824=((321.0)*gconst55);
CheckValue<IkReal> x825=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x823))),-1);
if(!x825.valid){
continue;
}
CheckValue<IkReal> x826=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x823))),-1);
if(!x826.valid){
continue;
}
if( IKabs(((x825.value)*(((((-3210.0)*gconst56*pz))+(((-4000.0)*pz))+x824)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x826.value)*(((-40.0)+(((-1.0)*pz*x824))+(((-32.1)*gconst56)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x825.value)*(((((-3210.0)*gconst56*pz))+(((-4000.0)*pz))+x824))))+IKsqr(((x826.value)*(((-40.0)+(((-1.0)*pz*x824))+(((-32.1)*gconst56))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x825.value)*(((((-3210.0)*gconst56*pz))+(((-4000.0)*pz))+x824))), ((x826.value)*(((-40.0)+(((-1.0)*pz*x824))+(((-32.1)*gconst56))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x827=IKcos(j16);
IkReal x828=IKsin(j16);
IkReal x829=((0.321)*x827);
IkReal x830=((0.321)*x828);
IkReal x831=(pz*x828);
evalcond[0]=((((-0.1)*x828))+((pz*x827))+(((0.321)*gconst55)));
evalcond[1]=((0.4)+(((0.1)*x827))+(((0.321)*gconst56))+x831);
evalcond[2]=((-0.32)+(((-0.08)*x827))+(((-0.8)*x831))+(((-0.2568)*gconst56)));
evalcond[3]=((((0.4)*x828))+((gconst56*x830))+((gconst55*x829))+pz);
evalcond[4]=((0.1)+(((-1.0)*gconst55*x830))+(((0.4)*x827))+((gconst56*x829)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x832=pz*pz;
IkReal x833=((321.0)*gconst55);
CheckValue<IkReal> x834=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x832))),-1);
if(!x834.valid){
continue;
}
CheckValue<IkReal> x835=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x832))),-1);
if(!x835.valid){
continue;
}
if( IKabs(((x834.value)*(((((-3210.0)*gconst56*pz))+(((-4000.0)*pz))+x833)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x835.value)*(((40.0)+((pz*x833))+(((32.1)*gconst56)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x834.value)*(((((-3210.0)*gconst56*pz))+(((-4000.0)*pz))+x833))))+IKsqr(((x835.value)*(((40.0)+((pz*x833))+(((32.1)*gconst56))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x834.value)*(((((-3210.0)*gconst56*pz))+(((-4000.0)*pz))+x833))), ((x835.value)*(((40.0)+((pz*x833))+(((32.1)*gconst56))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x836=IKcos(j16);
IkReal x837=IKsin(j16);
IkReal x838=((0.321)*x836);
IkReal x839=((0.321)*x837);
IkReal x840=(pz*x837);
evalcond[0]=(((pz*x836))+(((-0.1)*x837))+(((0.321)*gconst55)));
evalcond[1]=((0.4)+(((0.1)*x836))+(((0.321)*gconst56))+x840);
evalcond[2]=((-0.32)+(((-0.08)*x836))+(((-0.8)*x840))+(((-0.2568)*gconst56)));
evalcond[3]=(((gconst55*x838))+(((0.4)*x837))+((gconst56*x839))+pz);
evalcond[4]=((0.1)+(((-1.0)*gconst55*x839))+(((0.4)*x836))+((gconst56*x838)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x841=(pz*sj18);
CheckValue<IkReal> x842=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x841))+(((32.1)*cj18))),-1);
if(!x842.valid){
continue;
}
CheckValue<IkReal> x843=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((-321000.0)*x841))),-1);
if(!x843.valid){
continue;
}
if( IKabs(((x842.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x843.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x842.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x843.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x842.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x843.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x844=IKcos(j16);
IkReal x845=IKsin(j16);
IkReal x846=((0.321)*sj18);
IkReal x847=((0.321)*cj18);
IkReal x848=(pz*x845);
evalcond[0]=(((pz*x844))+(((-0.1)*x845))+x846);
evalcond[1]=((0.4)+(((0.1)*x844))+x847+x848);
evalcond[2]=((-0.066959)+(((-0.08)*x844))+(((-1.0)*pp))+(((-0.8)*x848)));
evalcond[3]=((((0.4)*x845))+pz+((x845*x847))+((x844*x846)));
evalcond[4]=((0.1)+(((0.4)*x844))+(((-1.0)*x845*x846))+((x844*x847)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x849=pz*pz;
IkReal x850=((321.0)*sj18);
CheckValue<IkReal> x851=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x849))),-1);
if(!x851.valid){
continue;
}
CheckValue<IkReal> x852=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x849))),-1);
if(!x852.valid){
continue;
}
if( IKabs(((x851.value)*(((((-836.9875)*pz))+x850+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x852.value)*(((-8.369875)+(((-1.0)*pz*x850))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x851.value)*(((((-836.9875)*pz))+x850+(((-12500.0)*pp*pz))))))+IKsqr(((x852.value)*(((-8.369875)+(((-1.0)*pz*x850))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x851.value)*(((((-836.9875)*pz))+x850+(((-12500.0)*pp*pz))))), ((x852.value)*(((-8.369875)+(((-1.0)*pz*x850))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x853=IKcos(j16);
IkReal x854=IKsin(j16);
IkReal x855=((0.321)*sj18);
IkReal x856=((0.321)*cj18);
IkReal x857=(pz*x854);
evalcond[0]=((((-0.1)*x854))+x855+((pz*x853)));
evalcond[1]=((0.4)+(((0.1)*x853))+x856+x857);
evalcond[2]=((-0.066959)+(((-0.8)*x857))+(((-1.0)*pp))+(((-0.08)*x853)));
evalcond[3]=(pz+((x854*x856))+(((0.4)*x854))+((x853*x855)));
evalcond[4]=((0.1)+(((0.4)*x853))+((x853*x856))+(((-1.0)*x854*x855)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x858=pz*pz;
IkReal x859=((321.0)*sj18);
CheckValue<IkReal> x860=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x858))),-1);
if(!x860.valid){
continue;
}
CheckValue<IkReal> x861=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x858))),-1);
if(!x861.valid){
continue;
}
if( IKabs(((x860.value)*(((((-3210.0)*cj18*pz))+(((-4000.0)*pz))+x859)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x861.value)*(((40.0)+(((32.1)*cj18))+((pz*x859)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x860.value)*(((((-3210.0)*cj18*pz))+(((-4000.0)*pz))+x859))))+IKsqr(((x861.value)*(((40.0)+(((32.1)*cj18))+((pz*x859))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x860.value)*(((((-3210.0)*cj18*pz))+(((-4000.0)*pz))+x859))), ((x861.value)*(((40.0)+(((32.1)*cj18))+((pz*x859))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x862=IKcos(j16);
IkReal x863=IKsin(j16);
IkReal x864=((0.321)*sj18);
IkReal x865=((0.321)*cj18);
IkReal x866=(pz*x863);
evalcond[0]=((((-0.1)*x863))+((pz*x862))+x864);
evalcond[1]=((0.4)+(((0.1)*x862))+x866+x865);
evalcond[2]=((-0.066959)+(((-0.8)*x866))+(((-1.0)*pp))+(((-0.08)*x862)));
evalcond[3]=(((x863*x865))+pz+((x862*x864))+(((0.4)*x863)));
evalcond[4]=((0.1)+((x862*x865))+(((0.4)*x862))+(((-1.0)*x863*x864)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x867=(cj15*py);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(px)));
evalcond[1]=((-1.0)*x867);
evalcond[2]=x867;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj18))+(((-1.0)*cj18)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst57;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x868=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x868.valid){
continue;
}
if( (((1.24610591900312)*(x868.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x868.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x869 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x869.valid){
continue;
}
gconst57=((IKasin(((1.24610591900312)*(x868.value))))+(((-1.0)*(x869.value))));
IkReal gconst58;
gconst58=IKsin(gconst57);
IkReal gconst59;
gconst59=IKcos(gconst57);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst57))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst59))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*gconst58*pz))+(((-1.0)*gconst59)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x870=(gconst58*pz);
CheckValue<IkReal> x871=IKPowWithIntegerCheck(((-40.0)+(((-32.1)*gconst59))+(((-321.0)*x870))),-1);
if(!x871.valid){
continue;
}
CheckValue<IkReal> x872=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst59))+(((321000.0)*x870))),-1);
if(!x872.valid){
continue;
}
if( IKabs(((x871.value)*(((((100.0)*pz))+(((128.4)*gconst58))+(((103.041)*gconst58*gconst59)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x872.value)*(((-10000.0)+(((103041.0)*(gconst58*gconst58))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x871.value)*(((((100.0)*pz))+(((128.4)*gconst58))+(((103.041)*gconst58*gconst59))))))+IKsqr(((x872.value)*(((-10000.0)+(((103041.0)*(gconst58*gconst58)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x871.value)*(((((100.0)*pz))+(((128.4)*gconst58))+(((103.041)*gconst58*gconst59))))), ((x872.value)*(((-10000.0)+(((103041.0)*(gconst58*gconst58)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x873=IKsin(j16);
IkReal x874=IKcos(j16);
IkReal x875=((0.321)*gconst59);
IkReal x876=((0.321)*gconst58);
IkReal x877=(pz*x873);
evalcond[0]=((0.4)+(((0.1)*x874))+x875+x877);
evalcond[1]=((((0.1)*x873))+(((-1.0)*pz*x874))+x876);
evalcond[2]=((-0.32)+(((-0.8)*x877))+(((-0.08)*x874))+(((-0.2568)*gconst59)));
evalcond[3]=(((x873*x875))+pz+(((0.4)*x873))+(((-1.0)*x874*x876)));
evalcond[4]=((0.1)+((x874*x875))+((x873*x876))+(((0.4)*x874)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x878=pz*pz;
IkReal x879=((321.0)*gconst58);
CheckValue<IkReal> x880=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x878))),-1);
if(!x880.valid){
continue;
}
CheckValue<IkReal> x881=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x878))),-1);
if(!x881.valid){
continue;
}
if( IKabs(((x880.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst59*pz))+(((-1.0)*x879)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x881.value)*(((-40.0)+((pz*x879))+(((-32.1)*gconst59)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x880.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst59*pz))+(((-1.0)*x879))))))+IKsqr(((x881.value)*(((-40.0)+((pz*x879))+(((-32.1)*gconst59))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x880.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst59*pz))+(((-1.0)*x879))))), ((x881.value)*(((-40.0)+((pz*x879))+(((-32.1)*gconst59))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x882=IKsin(j16);
IkReal x883=IKcos(j16);
IkReal x884=((0.321)*gconst59);
IkReal x885=((0.321)*gconst58);
IkReal x886=(pz*x882);
evalcond[0]=((0.4)+x884+x886+(((0.1)*x883)));
evalcond[1]=((((-1.0)*pz*x883))+x885+(((0.1)*x882)));
evalcond[2]=((-0.32)+(((-0.8)*x886))+(((-0.2568)*gconst59))+(((-0.08)*x883)));
evalcond[3]=((((-1.0)*x883*x885))+((x882*x884))+(((0.4)*x882))+pz);
evalcond[4]=((0.1)+((x883*x884))+((x882*x885))+(((0.4)*x883)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x887=pz*pz;
IkReal x888=((321.0)*gconst58);
CheckValue<IkReal> x889=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x887))),-1);
if(!x889.valid){
continue;
}
CheckValue<IkReal> x890=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x887))),-1);
if(!x890.valid){
continue;
}
if( IKabs(((x889.value)*(((((3210.0)*gconst59*pz))+(((4000.0)*pz))+x888)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x890.value)*(((-40.0)+((pz*x888))+(((-32.1)*gconst59)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x889.value)*(((((3210.0)*gconst59*pz))+(((4000.0)*pz))+x888))))+IKsqr(((x890.value)*(((-40.0)+((pz*x888))+(((-32.1)*gconst59))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x889.value)*(((((3210.0)*gconst59*pz))+(((4000.0)*pz))+x888))), ((x890.value)*(((-40.0)+((pz*x888))+(((-32.1)*gconst59))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x891=IKsin(j16);
IkReal x892=IKcos(j16);
IkReal x893=((0.321)*gconst59);
IkReal x894=((0.321)*gconst58);
IkReal x895=(pz*x891);
evalcond[0]=((0.4)+x895+x893+(((0.1)*x892)));
evalcond[1]=((((-1.0)*pz*x892))+x894+(((0.1)*x891)));
evalcond[2]=((-0.32)+(((-0.8)*x895))+(((-0.2568)*gconst59))+(((-0.08)*x892)));
evalcond[3]=((((-1.0)*x892*x894))+(((0.4)*x891))+pz+((x891*x893)));
evalcond[4]=((0.1)+(((0.4)*x892))+((x892*x893))+((x891*x894)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst60;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x896=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x896.valid){
continue;
}
if( (((1.24610591900312)*(x896.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x896.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x897 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x897.valid){
continue;
}
gconst60=((3.14159265358979)+(((-1.0)*(IKasin(((1.24610591900312)*(x896.value))))))+(((-1.0)*(x897.value))));
IkReal gconst61;
gconst61=IKsin(gconst60);
IkReal gconst62;
gconst62=IKcos(gconst60);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst60))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst62))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst62))+(((-10.0)*gconst61*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x898=(gconst61*pz);
CheckValue<IkReal> x899=IKPowWithIntegerCheck(((-40.0)+(((-32.1)*gconst62))+(((-321.0)*x898))),-1);
if(!x899.valid){
continue;
}
CheckValue<IkReal> x900=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst62))+(((321000.0)*x898))),-1);
if(!x900.valid){
continue;
}
if( IKabs(((x899.value)*(((((100.0)*pz))+(((103.041)*gconst61*gconst62))+(((128.4)*gconst61)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x900.value)*(((-10000.0)+(((103041.0)*(gconst61*gconst61))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x899.value)*(((((100.0)*pz))+(((103.041)*gconst61*gconst62))+(((128.4)*gconst61))))))+IKsqr(((x900.value)*(((-10000.0)+(((103041.0)*(gconst61*gconst61)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x899.value)*(((((100.0)*pz))+(((103.041)*gconst61*gconst62))+(((128.4)*gconst61))))), ((x900.value)*(((-10000.0)+(((103041.0)*(gconst61*gconst61)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x901=IKsin(j16);
IkReal x902=IKcos(j16);
IkReal x903=((0.321)*gconst62);
IkReal x904=((0.321)*gconst61);
IkReal x905=((0.321)*x902);
IkReal x906=(pz*x901);
evalcond[0]=((0.4)+x906+x903+(((0.1)*x902)));
evalcond[1]=(x904+(((0.1)*x901))+(((-1.0)*pz*x902)));
evalcond[2]=((-0.32)+(((-0.08)*x902))+(((-0.8)*x906))+(((-0.2568)*gconst62)));
evalcond[3]=((((-1.0)*x902*x904))+((x901*x903))+(((0.4)*x901))+pz);
evalcond[4]=((0.1)+((x901*x904))+((x902*x903))+(((0.4)*x902)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x907=pz*pz;
IkReal x908=((321.0)*gconst61);
CheckValue<IkReal> x909=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x907))),-1);
if(!x909.valid){
continue;
}
CheckValue<IkReal> x910=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x907))),-1);
if(!x910.valid){
continue;
}
if( IKabs(((x909.value)*(((((-1.0)*x908))+(((-4000.0)*pz))+(((-3210.0)*gconst62*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x910.value)*(((-40.0)+(((-32.1)*gconst62))+((pz*x908)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x909.value)*(((((-1.0)*x908))+(((-4000.0)*pz))+(((-3210.0)*gconst62*pz))))))+IKsqr(((x910.value)*(((-40.0)+(((-32.1)*gconst62))+((pz*x908))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x909.value)*(((((-1.0)*x908))+(((-4000.0)*pz))+(((-3210.0)*gconst62*pz))))), ((x910.value)*(((-40.0)+(((-32.1)*gconst62))+((pz*x908))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x911=IKsin(j16);
IkReal x912=IKcos(j16);
IkReal x913=((0.321)*gconst62);
IkReal x914=((0.321)*gconst61);
IkReal x915=((0.321)*x912);
IkReal x916=(pz*x911);
evalcond[0]=((0.4)+(((0.1)*x912))+x913+x916);
evalcond[1]=((((0.1)*x911))+x914+(((-1.0)*pz*x912)));
evalcond[2]=((-0.32)+(((-0.08)*x912))+(((-0.8)*x916))+(((-0.2568)*gconst62)));
evalcond[3]=(((x911*x913))+pz+(((0.4)*x911))+(((-1.0)*x912*x914)));
evalcond[4]=((0.1)+((x911*x914))+(((0.4)*x912))+((x912*x913)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x917=pz*pz;
IkReal x918=((321.0)*gconst61);
CheckValue<IkReal> x919=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x917))),-1);
if(!x919.valid){
continue;
}
CheckValue<IkReal> x920=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x917))),-1);
if(!x920.valid){
continue;
}
if( IKabs(((x919.value)*(((((3210.0)*gconst62*pz))+(((4000.0)*pz))+x918)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x920.value)*(((-40.0)+((pz*x918))+(((-32.1)*gconst62)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x919.value)*(((((3210.0)*gconst62*pz))+(((4000.0)*pz))+x918))))+IKsqr(((x920.value)*(((-40.0)+((pz*x918))+(((-32.1)*gconst62))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x919.value)*(((((3210.0)*gconst62*pz))+(((4000.0)*pz))+x918))), ((x920.value)*(((-40.0)+((pz*x918))+(((-32.1)*gconst62))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x921=IKsin(j16);
IkReal x922=IKcos(j16);
IkReal x923=((0.321)*gconst62);
IkReal x924=((0.321)*gconst61);
IkReal x925=((0.321)*x922);
IkReal x926=(pz*x921);
evalcond[0]=((0.4)+(((0.1)*x922))+x926+x923);
evalcond[1]=((((0.1)*x921))+(((-1.0)*pz*x922))+x924);
evalcond[2]=((-0.32)+(((-0.08)*x922))+(((-0.8)*x926))+(((-0.2568)*gconst62)));
evalcond[3]=(((x921*x923))+pz+(((0.4)*x921))+(((-1.0)*x922*x924)));
evalcond[4]=((0.1)+((x921*x924))+((x922*x923))+(((0.4)*x922)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x927=(pz*sj18);
CheckValue<IkReal> x928=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x927))+(((-32.1)*cj18))),-1);
if(!x928.valid){
continue;
}
CheckValue<IkReal> x929=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((321000.0)*x927))),-1);
if(!x929.valid){
continue;
}
if( IKabs(((x928.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x929.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x928.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x929.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x928.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x929.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x930=IKsin(j16);
IkReal x931=IKcos(j16);
IkReal x932=((0.321)*sj18);
IkReal x933=((0.321)*cj18);
IkReal x934=(pz*x930);
evalcond[0]=((0.4)+(((0.1)*x931))+x934+x933);
evalcond[1]=((((0.1)*x930))+(((-1.0)*pz*x931))+x932);
evalcond[2]=((-0.066959)+(((-0.08)*x931))+(((-0.8)*x934))+(((-1.0)*pp)));
evalcond[3]=((((-1.0)*x931*x932))+((x930*x933))+pz+(((0.4)*x930)));
evalcond[4]=((0.1)+((x930*x932))+((x931*x933))+(((0.4)*x931)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x935=pz*pz;
IkReal x936=((321.0)*sj18);
CheckValue<IkReal> x937=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x935))),-1);
if(!x937.valid){
continue;
}
CheckValue<IkReal> x938=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x935))),-1);
if(!x938.valid){
continue;
}
if( IKabs(((x937.value)*(((((-836.9875)*pz))+(((-12500.0)*pp*pz))+(((-1.0)*x936)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x938.value)*(((-8.369875)+((pz*x936))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x937.value)*(((((-836.9875)*pz))+(((-12500.0)*pp*pz))+(((-1.0)*x936))))))+IKsqr(((x938.value)*(((-8.369875)+((pz*x936))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x937.value)*(((((-836.9875)*pz))+(((-12500.0)*pp*pz))+(((-1.0)*x936))))), ((x938.value)*(((-8.369875)+((pz*x936))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x939=IKsin(j16);
IkReal x940=IKcos(j16);
IkReal x941=((0.321)*sj18);
IkReal x942=((0.321)*cj18);
IkReal x943=(pz*x939);
evalcond[0]=((0.4)+x942+x943+(((0.1)*x940)));
evalcond[1]=((((0.1)*x939))+(((-1.0)*pz*x940))+x941);
evalcond[2]=((-0.066959)+(((-0.08)*x940))+(((-0.8)*x943))+(((-1.0)*pp)));
evalcond[3]=(((x939*x942))+pz+(((0.4)*x939))+(((-1.0)*x940*x941)));
evalcond[4]=((0.1)+((x939*x941))+(((0.4)*x940))+((x940*x942)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x944=pz*pz;
IkReal x945=((321.0)*sj18);
CheckValue<IkReal> x946=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x944))),-1);
if(!x946.valid){
continue;
}
CheckValue<IkReal> x947=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x944))),-1);
if(!x947.valid){
continue;
}
if( IKabs(((x946.value)*(((((4000.0)*pz))+x945+(((3210.0)*cj18*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x947.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x945)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x946.value)*(((((4000.0)*pz))+x945+(((3210.0)*cj18*pz))))))+IKsqr(((x947.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x945))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x946.value)*(((((4000.0)*pz))+x945+(((3210.0)*cj18*pz))))), ((x947.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x945))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x948=IKsin(j16);
IkReal x949=IKcos(j16);
IkReal x950=((0.321)*sj18);
IkReal x951=((0.321)*cj18);
IkReal x952=(pz*x948);
evalcond[0]=((0.4)+x952+x951+(((0.1)*x949)));
evalcond[1]=((((-1.0)*pz*x949))+x950+(((0.1)*x948)));
evalcond[2]=((-0.066959)+(((-0.08)*x949))+(((-0.8)*x952))+(((-1.0)*pp)));
evalcond[3]=(((x948*x951))+pz+(((-1.0)*x949*x950))+(((0.4)*x948)));
evalcond[4]=((0.1)+((x949*x951))+((x948*x950))+(((0.4)*x949)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x953=(px*sj15);
evalcond[0]=((IKabs(py))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x953;
evalcond[2]=x953;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*pz*sj18))+cj18);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst63;
CheckValue<IkReal> x954 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x954.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x955=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x955.valid){
continue;
}
if( (((1.24610591900312)*(x955.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x955.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst63=((((-1.0)*(x954.value)))+(((-1.0)*(IKasin(((1.24610591900312)*(x955.value)))))));
IkReal gconst64;
gconst64=IKsin(gconst63);
IkReal gconst65;
gconst65=IKcos(gconst63);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst63))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst65))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+(((-10.0)*gconst64*pz))+gconst65);
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x956=(gconst64*pz);
CheckValue<IkReal> x957=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x956))+(((32.1)*gconst65))),-1);
if(!x957.valid){
continue;
}
CheckValue<IkReal> x958=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst65))+(((-321000.0)*x956))),-1);
if(!x958.valid){
continue;
}
if( IKabs(((x957.value)*(((((-100.0)*pz))+(((103.041)*gconst64*gconst65))+(((128.4)*gconst64)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x958.value)*(((-10000.0)+(((103041.0)*(gconst64*gconst64))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x957.value)*(((((-100.0)*pz))+(((103.041)*gconst64*gconst65))+(((128.4)*gconst64))))))+IKsqr(((x958.value)*(((-10000.0)+(((103041.0)*(gconst64*gconst64)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x957.value)*(((((-100.0)*pz))+(((103.041)*gconst64*gconst65))+(((128.4)*gconst64))))), ((x958.value)*(((-10000.0)+(((103041.0)*(gconst64*gconst64)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x959=IKcos(j16);
IkReal x960=IKsin(j16);
IkReal x961=((0.321)*gconst64);
IkReal x962=((0.321)*gconst65);
IkReal x963=((0.321)*x960);
IkReal x964=(pz*x960);
evalcond[0]=((((-0.1)*x960))+((pz*x959))+x961);
evalcond[1]=((0.4)+(((0.1)*x959))+x962+x964);
evalcond[2]=((-0.32)+(((-0.8)*x964))+(((-0.2568)*gconst65))+(((-0.08)*x959)));
evalcond[3]=(((x960*x962))+pz+((x959*x961))+(((0.4)*x960)));
evalcond[4]=((0.1)+(((-1.0)*x960*x961))+((x959*x962))+(((0.4)*x959)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x965=pz*pz;
IkReal x966=((321.0)*gconst64);
CheckValue<IkReal> x967=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x965))),-1);
if(!x967.valid){
continue;
}
CheckValue<IkReal> x968=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x965))),-1);
if(!x968.valid){
continue;
}
if( IKabs(((x967.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst65*pz))+x966)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x968.value)*(((-40.0)+(((-1.0)*pz*x966))+(((-32.1)*gconst65)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x967.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst65*pz))+x966))))+IKsqr(((x968.value)*(((-40.0)+(((-1.0)*pz*x966))+(((-32.1)*gconst65))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x967.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst65*pz))+x966))), ((x968.value)*(((-40.0)+(((-1.0)*pz*x966))+(((-32.1)*gconst65))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x969=IKcos(j16);
IkReal x970=IKsin(j16);
IkReal x971=((0.321)*gconst64);
IkReal x972=((0.321)*gconst65);
IkReal x973=((0.321)*x970);
IkReal x974=(pz*x970);
evalcond[0]=((((-0.1)*x970))+((pz*x969))+x971);
evalcond[1]=((0.4)+(((0.1)*x969))+x972+x974);
evalcond[2]=((-0.32)+(((-0.8)*x974))+(((-0.2568)*gconst65))+(((-0.08)*x969)));
evalcond[3]=(((x969*x971))+pz+((x970*x972))+(((0.4)*x970)));
evalcond[4]=((0.1)+((x969*x972))+(((-1.0)*x970*x971))+(((0.4)*x969)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x975=pz*pz;
IkReal x976=((321.0)*gconst64);
CheckValue<IkReal> x977=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x975))),-1);
if(!x977.valid){
continue;
}
CheckValue<IkReal> x978=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x975))),-1);
if(!x978.valid){
continue;
}
if( IKabs(((x977.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst65*pz))+x976)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x978.value)*(((40.0)+((pz*x976))+(((32.1)*gconst65)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x977.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst65*pz))+x976))))+IKsqr(((x978.value)*(((40.0)+((pz*x976))+(((32.1)*gconst65))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x977.value)*(((((-4000.0)*pz))+(((-3210.0)*gconst65*pz))+x976))), ((x978.value)*(((40.0)+((pz*x976))+(((32.1)*gconst65))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x979=IKcos(j16);
IkReal x980=IKsin(j16);
IkReal x981=((0.321)*gconst64);
IkReal x982=((0.321)*gconst65);
IkReal x983=((0.321)*x980);
IkReal x984=(pz*x980);
evalcond[0]=((((-0.1)*x980))+((pz*x979))+x981);
evalcond[1]=((0.4)+(((0.1)*x979))+x984+x982);
evalcond[2]=((-0.32)+(((-0.8)*x984))+(((-0.08)*x979))+(((-0.2568)*gconst65)));
evalcond[3]=((((0.4)*x980))+((x979*x981))+pz+((x980*x982)));
evalcond[4]=((0.1)+((x979*x982))+(((-1.0)*x980*x981))+(((0.4)*x979)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst66;
CheckValue<IkReal> x985 = IKatan2WithCheck(1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x985.valid){
continue;
}
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x986=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x986.valid){
continue;
}
if( (((1.24610591900312)*(x986.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x986.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst66=((3.14159265358979)+(((-1.0)*(x985.value)))+(IKasin(((1.24610591900312)*(x986.value)))));
IkReal gconst67;
gconst67=IKsin(gconst66);
IkReal gconst68;
gconst68=IKcos(gconst66);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst66))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst68))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.24610591900312)+gconst68+(((-10.0)*gconst67*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x987=(gconst67*pz);
CheckValue<IkReal> x988=IKPowWithIntegerCheck(((40.0)+(((-321.0)*x987))+(((32.1)*gconst68))),-1);
if(!x988.valid){
continue;
}
CheckValue<IkReal> x989=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst68))+(((-321000.0)*x987))),-1);
if(!x989.valid){
continue;
}
if( IKabs(((x988.value)*(((((-100.0)*pz))+(((128.4)*gconst67))+(((103.041)*gconst67*gconst68)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x989.value)*(((-10000.0)+(((103041.0)*(gconst67*gconst67))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x988.value)*(((((-100.0)*pz))+(((128.4)*gconst67))+(((103.041)*gconst67*gconst68))))))+IKsqr(((x989.value)*(((-10000.0)+(((103041.0)*(gconst67*gconst67)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x988.value)*(((((-100.0)*pz))+(((128.4)*gconst67))+(((103.041)*gconst67*gconst68))))), ((x989.value)*(((-10000.0)+(((103041.0)*(gconst67*gconst67)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x990=IKcos(j16);
IkReal x991=IKsin(j16);
IkReal x992=((0.321)*gconst68);
IkReal x993=((0.321)*gconst67);
IkReal x994=(pz*x991);
evalcond[0]=(((pz*x990))+(((-0.1)*x991))+x993);
evalcond[1]=((0.4)+(((0.1)*x990))+x992+x994);
evalcond[2]=((-0.32)+(((-0.8)*x994))+(((-0.08)*x990))+(((-0.2568)*gconst68)));
evalcond[3]=((((0.4)*x991))+((x991*x992))+((x990*x993))+pz);
evalcond[4]=((0.1)+(((0.4)*x990))+(((-1.0)*x991*x993))+((x990*x992)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x995=pz*pz;
IkReal x996=((321.0)*gconst67);
CheckValue<IkReal> x997=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x995))),-1);
if(!x997.valid){
continue;
}
CheckValue<IkReal> x998=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x995))),-1);
if(!x998.valid){
continue;
}
if( IKabs(((x997.value)*(((((-3210.0)*gconst68*pz))+(((-4000.0)*pz))+x996)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x998.value)*(((-40.0)+(((-1.0)*pz*x996))+(((-32.1)*gconst68)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x997.value)*(((((-3210.0)*gconst68*pz))+(((-4000.0)*pz))+x996))))+IKsqr(((x998.value)*(((-40.0)+(((-1.0)*pz*x996))+(((-32.1)*gconst68))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x997.value)*(((((-3210.0)*gconst68*pz))+(((-4000.0)*pz))+x996))), ((x998.value)*(((-40.0)+(((-1.0)*pz*x996))+(((-32.1)*gconst68))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x999=IKcos(j16);
IkReal x1000=IKsin(j16);
IkReal x1001=((0.321)*gconst68);
IkReal x1002=((0.321)*gconst67);
IkReal x1003=(pz*x1000);
evalcond[0]=(x1002+((pz*x999))+(((-0.1)*x1000)));
evalcond[1]=((0.4)+x1003+x1001+(((0.1)*x999)));
evalcond[2]=((-0.32)+(((-0.08)*x999))+(((-0.2568)*gconst68))+(((-0.8)*x1003)));
evalcond[3]=((((0.4)*x1000))+((x1000*x1001))+pz+((x1002*x999)));
evalcond[4]=((0.1)+(((0.4)*x999))+((x1001*x999))+(((-1.0)*x1000*x1002)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1004=pz*pz;
IkReal x1005=((321.0)*gconst67);
CheckValue<IkReal> x1006=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1004))),-1);
if(!x1006.valid){
continue;
}
CheckValue<IkReal> x1007=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1004))),-1);
if(!x1007.valid){
continue;
}
if( IKabs(((x1006.value)*(((((-3210.0)*gconst68*pz))+x1005+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1007.value)*(((40.0)+((pz*x1005))+(((32.1)*gconst68)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1006.value)*(((((-3210.0)*gconst68*pz))+x1005+(((-4000.0)*pz))))))+IKsqr(((x1007.value)*(((40.0)+((pz*x1005))+(((32.1)*gconst68))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1006.value)*(((((-3210.0)*gconst68*pz))+x1005+(((-4000.0)*pz))))), ((x1007.value)*(((40.0)+((pz*x1005))+(((32.1)*gconst68))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1008=IKcos(j16);
IkReal x1009=IKsin(j16);
IkReal x1010=((0.321)*gconst68);
IkReal x1011=((0.321)*gconst67);
IkReal x1012=(pz*x1009);
evalcond[0]=(x1011+((pz*x1008))+(((-0.1)*x1009)));
evalcond[1]=((0.4)+(((0.1)*x1008))+x1010+x1012);
evalcond[2]=((-0.32)+(((-0.08)*x1008))+(((-0.2568)*gconst68))+(((-0.8)*x1012)));
evalcond[3]=((((0.4)*x1009))+((x1009*x1010))+pz+((x1008*x1011)));
evalcond[4]=((0.1)+(((0.4)*x1008))+(((-1.0)*x1009*x1011))+((x1008*x1010)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1013=(pz*sj18);
CheckValue<IkReal> x1014=IKPowWithIntegerCheck(((40.0)+(((32.1)*cj18))+(((-321.0)*x1013))),-1);
if(!x1014.valid){
continue;
}
CheckValue<IkReal> x1015=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((-321000.0)*x1013))),-1);
if(!x1015.valid){
continue;
}
if( IKabs(((x1014.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1015.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1014.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1015.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1014.value)*(((((-100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1015.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1016=IKcos(j16);
IkReal x1017=IKsin(j16);
IkReal x1018=((0.321)*sj18);
IkReal x1019=((0.321)*cj18);
IkReal x1020=(pz*x1017);
evalcond[0]=(x1018+((pz*x1016))+(((-0.1)*x1017)));
evalcond[1]=((0.4)+x1019+x1020+(((0.1)*x1016)));
evalcond[2]=((-0.066959)+(((-0.08)*x1016))+(((-1.0)*pp))+(((-0.8)*x1020)));
evalcond[3]=(((x1016*x1018))+(((0.4)*x1017))+((x1017*x1019))+pz);
evalcond[4]=((0.1)+((x1016*x1019))+(((0.4)*x1016))+(((-1.0)*x1017*x1018)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1021=pz*pz;
IkReal x1022=((321.0)*sj18);
CheckValue<IkReal> x1023=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1021))),-1);
if(!x1023.valid){
continue;
}
CheckValue<IkReal> x1024=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1021))),-1);
if(!x1024.valid){
continue;
}
if( IKabs(((x1023.value)*(((((-836.9875)*pz))+x1022+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1024.value)*(((-8.369875)+(((-1.0)*pz*x1022))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1023.value)*(((((-836.9875)*pz))+x1022+(((-12500.0)*pp*pz))))))+IKsqr(((x1024.value)*(((-8.369875)+(((-1.0)*pz*x1022))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1023.value)*(((((-836.9875)*pz))+x1022+(((-12500.0)*pp*pz))))), ((x1024.value)*(((-8.369875)+(((-1.0)*pz*x1022))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1025=IKcos(j16);
IkReal x1026=IKsin(j16);
IkReal x1027=((0.321)*sj18);
IkReal x1028=((0.321)*cj18);
IkReal x1029=(pz*x1026);
evalcond[0]=(x1027+(((-0.1)*x1026))+((pz*x1025)));
evalcond[1]=((0.4)+x1029+x1028+(((0.1)*x1025)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x1025))+(((-0.8)*x1029)));
evalcond[3]=((((0.4)*x1026))+((x1026*x1028))+pz+((x1025*x1027)));
evalcond[4]=((0.1)+(((0.4)*x1025))+(((-1.0)*x1026*x1027))+((x1025*x1028)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1030=pz*pz;
IkReal x1031=((321.0)*sj18);
CheckValue<IkReal> x1032=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1030))),-1);
if(!x1032.valid){
continue;
}
CheckValue<IkReal> x1033=IKPowWithIntegerCheck(((-10.0)+(((-1000.0)*x1030))),-1);
if(!x1033.valid){
continue;
}
if( IKabs(((x1032.value)*(((((-3210.0)*cj18*pz))+x1031+(((-4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1033.value)*(((40.0)+(((32.1)*cj18))+((pz*x1031)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1032.value)*(((((-3210.0)*cj18*pz))+x1031+(((-4000.0)*pz))))))+IKsqr(((x1033.value)*(((40.0)+(((32.1)*cj18))+((pz*x1031))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1032.value)*(((((-3210.0)*cj18*pz))+x1031+(((-4000.0)*pz))))), ((x1033.value)*(((40.0)+(((32.1)*cj18))+((pz*x1031))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1034=IKcos(j16);
IkReal x1035=IKsin(j16);
IkReal x1036=((0.321)*sj18);
IkReal x1037=((0.321)*cj18);
IkReal x1038=(pz*x1035);
evalcond[0]=((((-0.1)*x1035))+x1036+((pz*x1034)));
evalcond[1]=((0.4)+(((0.1)*x1034))+x1038+x1037);
evalcond[2]=((-0.066959)+(((-0.08)*x1034))+(((-1.0)*pp))+(((-0.8)*x1038)));
evalcond[3]=((((0.4)*x1035))+pz+((x1034*x1036))+((x1035*x1037)));
evalcond[4]=((0.1)+(((0.4)*x1034))+(((-1.0)*x1035*x1036))+((x1034*x1037)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1039=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(py)));
evalcond[1]=x1039;
evalcond[2]=((-1.0)*x1039);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-10.0)*pz*sj18))+(((-1.0)*cj18)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst69;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1040=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1040.valid){
continue;
}
if( (((1.24610591900312)*(x1040.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1040.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1041 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1041.valid){
continue;
}
gconst69=((IKasin(((1.24610591900312)*(x1040.value))))+(((-1.0)*(x1041.value))));
IkReal gconst70;
gconst70=IKsin(gconst69);
IkReal gconst71;
gconst71=IKcos(gconst69);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst69))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst71))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst71))+(((-10.0)*gconst70*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1042=(gconst70*pz);
CheckValue<IkReal> x1043=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1042))+(((-32.1)*gconst71))),-1);
if(!x1043.valid){
continue;
}
CheckValue<IkReal> x1044=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst71))+(((321000.0)*x1042))),-1);
if(!x1044.valid){
continue;
}
if( IKabs(((x1043.value)*(((((103.041)*gconst70*gconst71))+(((100.0)*pz))+(((128.4)*gconst70)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1044.value)*(((-10000.0)+(((103041.0)*(gconst70*gconst70))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1043.value)*(((((103.041)*gconst70*gconst71))+(((100.0)*pz))+(((128.4)*gconst70))))))+IKsqr(((x1044.value)*(((-10000.0)+(((103041.0)*(gconst70*gconst70)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1043.value)*(((((103.041)*gconst70*gconst71))+(((100.0)*pz))+(((128.4)*gconst70))))), ((x1044.value)*(((-10000.0)+(((103041.0)*(gconst70*gconst70)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1045=IKsin(j16);
IkReal x1046=IKcos(j16);
IkReal x1047=((0.321)*gconst71);
IkReal x1048=((0.321)*gconst70);
IkReal x1049=(pz*x1045);
evalcond[0]=((0.4)+x1047+x1049+(((0.1)*x1046)));
evalcond[1]=((((-1.0)*pz*x1046))+x1048+(((0.1)*x1045)));
evalcond[2]=((-0.32)+(((-0.8)*x1049))+(((-0.2568)*gconst71))+(((-0.08)*x1046)));
evalcond[3]=((((-1.0)*x1046*x1048))+(((0.4)*x1045))+pz+((x1045*x1047)));
evalcond[4]=((0.1)+(((0.4)*x1046))+((x1045*x1048))+((x1046*x1047)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1050=pz*pz;
IkReal x1051=((321.0)*gconst70);
CheckValue<IkReal> x1052=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1050))),-1);
if(!x1052.valid){
continue;
}
CheckValue<IkReal> x1053=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1050))),-1);
if(!x1053.valid){
continue;
}
if( IKabs(((x1052.value)*(((((-1.0)*x1051))+(((-4000.0)*pz))+(((-3210.0)*gconst71*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1053.value)*(((-40.0)+((pz*x1051))+(((-32.1)*gconst71)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1052.value)*(((((-1.0)*x1051))+(((-4000.0)*pz))+(((-3210.0)*gconst71*pz))))))+IKsqr(((x1053.value)*(((-40.0)+((pz*x1051))+(((-32.1)*gconst71))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1052.value)*(((((-1.0)*x1051))+(((-4000.0)*pz))+(((-3210.0)*gconst71*pz))))), ((x1053.value)*(((-40.0)+((pz*x1051))+(((-32.1)*gconst71))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1054=IKsin(j16);
IkReal x1055=IKcos(j16);
IkReal x1056=((0.321)*gconst71);
IkReal x1057=((0.321)*gconst70);
IkReal x1058=(pz*x1054);
evalcond[0]=((0.4)+x1056+x1058+(((0.1)*x1055)));
evalcond[1]=((((-1.0)*pz*x1055))+x1057+(((0.1)*x1054)));
evalcond[2]=((-0.32)+(((-0.08)*x1055))+(((-0.8)*x1058))+(((-0.2568)*gconst71)));
evalcond[3]=(((x1054*x1056))+(((0.4)*x1054))+(((-1.0)*x1055*x1057))+pz);
evalcond[4]=((0.1)+((x1054*x1057))+((x1055*x1056))+(((0.4)*x1055)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1059=pz*pz;
IkReal x1060=((321.0)*gconst70);
CheckValue<IkReal> x1061=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1059))),-1);
if(!x1061.valid){
continue;
}
CheckValue<IkReal> x1062=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1059))),-1);
if(!x1062.valid){
continue;
}
if( IKabs(((x1061.value)*(((((3210.0)*gconst71*pz))+x1060+(((4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1062.value)*(((-40.0)+((pz*x1060))+(((-32.1)*gconst71)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1061.value)*(((((3210.0)*gconst71*pz))+x1060+(((4000.0)*pz))))))+IKsqr(((x1062.value)*(((-40.0)+((pz*x1060))+(((-32.1)*gconst71))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1061.value)*(((((3210.0)*gconst71*pz))+x1060+(((4000.0)*pz))))), ((x1062.value)*(((-40.0)+((pz*x1060))+(((-32.1)*gconst71))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1063=IKsin(j16);
IkReal x1064=IKcos(j16);
IkReal x1065=((0.321)*gconst71);
IkReal x1066=((0.321)*gconst70);
IkReal x1067=(pz*x1063);
evalcond[0]=((0.4)+x1065+x1067+(((0.1)*x1064)));
evalcond[1]=(x1066+(((-1.0)*pz*x1064))+(((0.1)*x1063)));
evalcond[2]=((-0.32)+(((-0.08)*x1064))+(((-0.8)*x1067))+(((-0.2568)*gconst71)));
evalcond[3]=((((0.4)*x1063))+pz+((x1063*x1065))+(((-1.0)*x1064*x1066)));
evalcond[4]=((0.1)+(((0.4)*x1064))+((x1063*x1066))+((x1064*x1065)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst72;
if((((1.0)+(((100.0)*(pz*pz))))) < -0.00001)
continue;
CheckValue<IkReal> x1068=IKPowWithIntegerCheck(IKabs(IKsqrt(((1.0)+(((100.0)*(pz*pz)))))),-1);
if(!x1068.valid){
continue;
}
if( (((1.24610591900312)*(x1068.value))) < -1-IKFAST_SINCOS_THRESH || (((1.24610591900312)*(x1068.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1069 = IKatan2WithCheck(-1.0,((-10.0)*pz),IKFAST_ATAN2_MAGTHRESH);
if(!x1069.valid){
continue;
}
gconst72=((3.14159265358979)+(((-1.0)*(IKasin(((1.24610591900312)*(x1068.value))))))+(((-1.0)*(x1069.value))));
IkReal gconst73;
gconst73=IKsin(gconst72);
IkReal gconst74;
gconst74=IKcos(gconst72);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst72))+j18)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2568)*gconst74))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((-100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((100.0)*(pz*pz))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.24610591900312)+(((-1.0)*gconst74))+(((-10.0)*gconst73*pz)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1070=(gconst73*pz);
CheckValue<IkReal> x1071=IKPowWithIntegerCheck(((-40.0)+(((-321.0)*x1070))+(((-32.1)*gconst74))),-1);
if(!x1071.valid){
continue;
}
CheckValue<IkReal> x1072=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*gconst74))+(((321000.0)*x1070))),-1);
if(!x1072.valid){
continue;
}
if( IKabs(((x1071.value)*(((((100.0)*pz))+(((103.041)*gconst73*gconst74))+(((128.4)*gconst73)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1072.value)*(((-10000.0)+(((103041.0)*(gconst73*gconst73))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1071.value)*(((((100.0)*pz))+(((103.041)*gconst73*gconst74))+(((128.4)*gconst73))))))+IKsqr(((x1072.value)*(((-10000.0)+(((103041.0)*(gconst73*gconst73)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1071.value)*(((((100.0)*pz))+(((103.041)*gconst73*gconst74))+(((128.4)*gconst73))))), ((x1072.value)*(((-10000.0)+(((103041.0)*(gconst73*gconst73)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1073=IKsin(j16);
IkReal x1074=IKcos(j16);
IkReal x1075=((0.321)*gconst74);
IkReal x1076=((0.321)*gconst73);
IkReal x1077=(pz*x1073);
evalcond[0]=((0.4)+x1077+x1075+(((0.1)*x1074)));
evalcond[1]=(x1076+(((-1.0)*pz*x1074))+(((0.1)*x1073)));
evalcond[2]=((-0.32)+(((-0.08)*x1074))+(((-0.8)*x1077))+(((-0.2568)*gconst74)));
evalcond[3]=((((-1.0)*x1074*x1076))+(((0.4)*x1073))+((x1073*x1075))+pz);
evalcond[4]=((0.1)+((x1074*x1075))+(((0.4)*x1074))+((x1073*x1076)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1078=pz*pz;
IkReal x1079=((321.0)*gconst73);
CheckValue<IkReal> x1080=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1078))),-1);
if(!x1080.valid){
continue;
}
CheckValue<IkReal> x1081=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1078))),-1);
if(!x1081.valid){
continue;
}
if( IKabs(((x1080.value)*(((((-3210.0)*gconst74*pz))+(((-4000.0)*pz))+(((-1.0)*x1079)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1081.value)*(((-40.0)+((pz*x1079))+(((-32.1)*gconst74)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1080.value)*(((((-3210.0)*gconst74*pz))+(((-4000.0)*pz))+(((-1.0)*x1079))))))+IKsqr(((x1081.value)*(((-40.0)+((pz*x1079))+(((-32.1)*gconst74))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1080.value)*(((((-3210.0)*gconst74*pz))+(((-4000.0)*pz))+(((-1.0)*x1079))))), ((x1081.value)*(((-40.0)+((pz*x1079))+(((-32.1)*gconst74))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1082=IKsin(j16);
IkReal x1083=IKcos(j16);
IkReal x1084=((0.321)*gconst74);
IkReal x1085=((0.321)*gconst73);
IkReal x1086=(pz*x1082);
evalcond[0]=((0.4)+x1086+x1084+(((0.1)*x1083)));
evalcond[1]=((((-1.0)*pz*x1083))+x1085+(((0.1)*x1082)));
evalcond[2]=((-0.32)+(((-0.8)*x1086))+(((-0.08)*x1083))+(((-0.2568)*gconst74)));
evalcond[3]=(((x1082*x1084))+pz+(((0.4)*x1082))+(((-1.0)*x1083*x1085)));
evalcond[4]=((0.1)+((x1082*x1085))+(((0.4)*x1083))+((x1083*x1084)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1087=pz*pz;
IkReal x1088=((321.0)*gconst73);
CheckValue<IkReal> x1089=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1087))),-1);
if(!x1089.valid){
continue;
}
CheckValue<IkReal> x1090=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1087))),-1);
if(!x1090.valid){
continue;
}
if( IKabs(((x1089.value)*((x1088+(((3210.0)*gconst74*pz))+(((4000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1090.value)*(((-40.0)+((pz*x1088))+(((-32.1)*gconst74)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1089.value)*((x1088+(((3210.0)*gconst74*pz))+(((4000.0)*pz))))))+IKsqr(((x1090.value)*(((-40.0)+((pz*x1088))+(((-32.1)*gconst74))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1089.value)*((x1088+(((3210.0)*gconst74*pz))+(((4000.0)*pz))))), ((x1090.value)*(((-40.0)+((pz*x1088))+(((-32.1)*gconst74))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1091=IKsin(j16);
IkReal x1092=IKcos(j16);
IkReal x1093=((0.321)*gconst74);
IkReal x1094=((0.321)*gconst73);
IkReal x1095=(pz*x1091);
evalcond[0]=((0.4)+x1095+x1093+(((0.1)*x1092)));
evalcond[1]=(x1094+(((0.1)*x1091))+(((-1.0)*pz*x1092)));
evalcond[2]=((-0.32)+(((-0.8)*x1095))+(((-0.08)*x1092))+(((-0.2568)*gconst74)));
evalcond[3]=(pz+(((-1.0)*x1092*x1094))+((x1091*x1093))+(((0.4)*x1091)));
evalcond[4]=((0.1)+((x1092*x1093))+((x1091*x1094))+(((0.4)*x1092)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1096=(pz*sj18);
CheckValue<IkReal> x1097=IKPowWithIntegerCheck(((-40.0)+(((-32.1)*cj18))+(((-321.0)*x1096))),-1);
if(!x1097.valid){
continue;
}
CheckValue<IkReal> x1098=IKPowWithIntegerCheck(((40000.0)+(((32100.0)*cj18))+(((321000.0)*x1096))),-1);
if(!x1098.valid){
continue;
}
if( IKabs(((x1097.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1098.value)*(((-10000.0)+(((103041.0)*(sj18*sj18))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1097.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1098.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1097.value)*(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1098.value)*(((-10000.0)+(((103041.0)*(sj18*sj18)))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1099=IKsin(j16);
IkReal x1100=IKcos(j16);
IkReal x1101=((0.321)*sj18);
IkReal x1102=((0.321)*cj18);
IkReal x1103=(pz*x1099);
evalcond[0]=((0.4)+x1102+x1103+(((0.1)*x1100)));
evalcond[1]=(x1101+(((0.1)*x1099))+(((-1.0)*pz*x1100)));
evalcond[2]=((-0.066959)+(((-0.8)*x1103))+(((-0.08)*x1100))+(((-1.0)*pp)));
evalcond[3]=(((x1099*x1102))+pz+(((-1.0)*x1100*x1101))+(((0.4)*x1099)));
evalcond[4]=((0.1)+((x1099*x1101))+(((0.4)*x1100))+((x1100*x1102)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1104=pz*pz;
IkReal x1105=((321.0)*sj18);
CheckValue<IkReal> x1106=IKPowWithIntegerCheck(((100.0)+(((10000.0)*x1104))),-1);
if(!x1106.valid){
continue;
}
CheckValue<IkReal> x1107=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1104))),-1);
if(!x1107.valid){
continue;
}
if( IKabs(((x1106.value)*(((((-836.9875)*pz))+(((-1.0)*x1105))+(((-12500.0)*pp*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1107.value)*(((-8.369875)+((pz*x1105))+(((-125.0)*pp)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1106.value)*(((((-836.9875)*pz))+(((-1.0)*x1105))+(((-12500.0)*pp*pz))))))+IKsqr(((x1107.value)*(((-8.369875)+((pz*x1105))+(((-125.0)*pp))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1106.value)*(((((-836.9875)*pz))+(((-1.0)*x1105))+(((-12500.0)*pp*pz))))), ((x1107.value)*(((-8.369875)+((pz*x1105))+(((-125.0)*pp))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1108=IKsin(j16);
IkReal x1109=IKcos(j16);
IkReal x1110=((0.321)*sj18);
IkReal x1111=((0.321)*cj18);
IkReal x1112=(pz*x1108);
evalcond[0]=((0.4)+x1111+x1112+(((0.1)*x1109)));
evalcond[1]=(x1110+(((0.1)*x1108))+(((-1.0)*pz*x1109)));
evalcond[2]=((-0.066959)+(((-0.8)*x1112))+(((-0.08)*x1109))+(((-1.0)*pp)));
evalcond[3]=(((x1108*x1111))+(((-1.0)*x1109*x1110))+pz+(((0.4)*x1108)));
evalcond[4]=((0.1)+((x1109*x1111))+((x1108*x1110))+(((0.4)*x1109)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1113=pz*pz;
IkReal x1114=((321.0)*sj18);
CheckValue<IkReal> x1115=IKPowWithIntegerCheck(((-100.0)+(((-10000.0)*x1113))),-1);
if(!x1115.valid){
continue;
}
CheckValue<IkReal> x1116=IKPowWithIntegerCheck(((10.0)+(((1000.0)*x1113))),-1);
if(!x1116.valid){
continue;
}
if( IKabs(((x1115.value)*((x1114+(((4000.0)*pz))+(((3210.0)*cj18*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1116.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x1114)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1115.value)*((x1114+(((4000.0)*pz))+(((3210.0)*cj18*pz))))))+IKsqr(((x1116.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x1114))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1115.value)*((x1114+(((4000.0)*pz))+(((3210.0)*cj18*pz))))), ((x1116.value)*(((-40.0)+(((-32.1)*cj18))+((pz*x1114))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1117=IKsin(j16);
IkReal x1118=IKcos(j16);
IkReal x1119=((0.321)*sj18);
IkReal x1120=((0.321)*cj18);
IkReal x1121=(pz*x1117);
evalcond[0]=((0.4)+x1120+x1121+(((0.1)*x1118)));
evalcond[1]=((((-1.0)*pz*x1118))+x1119+(((0.1)*x1117)));
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.08)*x1118))+(((-0.8)*x1121)));
evalcond[3]=(pz+((x1117*x1120))+(((0.4)*x1117))+(((-1.0)*x1118*x1119)));
evalcond[4]=((0.1)+((x1117*x1119))+(((0.4)*x1118))+((x1118*x1120)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1122=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j17), 6.28318530717959))))));
evalcond[1]=x1122;
evalcond[2]=x1122;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst75;
gconst75=IKsign(((160000.0)+(((103041.0)*(sj18*sj18)))+(((256800.0)*cj18))+(((103041.0)*(cj18*cj18)))));
dummyeval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+(sj18*sj18)+(cj18*cj18));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*py*sj15))+(((10.0)*cj15*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*py*sj15))+(((10.0)*cj15*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst76;
CheckValue<IkReal> x1123 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1123.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1124=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1124.valid){
continue;
}
if( (x1124.value) < -1-IKFAST_SINCOS_THRESH || (x1124.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst76=((((-1.0)*(x1123.value)))+(IKasin(x1124.value)));
IkReal gconst77;
gconst77=IKsin(gconst76);
IkReal gconst78;
gconst78=IKcos(gconst76);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst76))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst77*py))+(((-1.0)*pp))+(((0.2)*gconst78*px))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst78*px))+(((10.0)*gconst77*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst78*px))+(((10.0)*gconst77*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1125=(gconst77*py);
IkReal x1126=((10.0)*gconst78*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*cj18*x1126))+(((-10.0)*cj18*x1125))+cj18+(((-12.4610591900312)*x1125))+(((-12.4610591900312)*gconst78*px)));
dummyeval[1]=((1.0)+(((-10.0)*x1125))+(((-1.0)*x1126)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1127=(gconst77*py);
IkReal x1128=((321.0)*cj18);
IkReal x1129=(gconst78*px);
CheckValue<IkReal> x1130=IKPowWithIntegerCheck(((40.0)+(((32.1)*cj18))+(((-1.0)*x1127*x1128))+(((-400.0)*x1129))+(((-400.0)*x1127))+(((-1.0)*x1128*x1129))),-1);
if(!x1130.valid){
continue;
}
CheckValue<IkReal> x1131=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1129))+(((-1.0)*x1127))),-1);
if(!x1131.valid){
continue;
}
if( IKabs(((x1130.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1131.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1130.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1131.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1130.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1131.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1132=IKsin(j16);
IkReal x1133=IKcos(j16);
IkReal x1134=((0.321)*sj18);
IkReal x1135=(gconst78*px);
IkReal x1136=((0.321)*cj18);
IkReal x1137=(gconst77*py);
IkReal x1138=((1.0)*x1137);
IkReal x1139=((0.8)*x1133);
evalcond[0]=((((0.4)*x1132))+((x1133*x1134))+((x1132*x1136)));
evalcond[1]=(x1134+(((-0.1)*x1132))+((x1132*x1137))+((x1132*x1135)));
evalcond[2]=((0.4)+x1136+(((-1.0)*x1133*x1135))+(((0.1)*x1133))+(((-1.0)*x1133*x1138)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1135*x1139))+((x1137*x1139))+(((-0.08)*x1133)));
evalcond[4]=((0.1)+(((0.4)*x1133))+(((-1.0)*x1138))+(((-1.0)*x1132*x1134))+(((-1.0)*x1135))+((x1133*x1136)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1140=(gconst77*py);
IkReal x1141=(gconst78*px);
CheckValue<IkReal> x1142=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1141))+(((1000.0)*x1140))),-1);
if(!x1142.valid){
continue;
}
CheckValue<IkReal> x1143=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1140))+(((-1.0)*x1141))),-1);
if(!x1143.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1142.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1143.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1142.value)))+IKsqr(((x1143.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1142.value)), ((x1143.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1144=IKsin(j16);
IkReal x1145=IKcos(j16);
IkReal x1146=((0.321)*sj18);
IkReal x1147=(gconst78*px);
IkReal x1148=((0.321)*cj18);
IkReal x1149=(gconst77*py);
IkReal x1150=((1.0)*x1149);
IkReal x1151=((0.8)*x1145);
evalcond[0]=(((x1145*x1146))+((x1144*x1148))+(((0.4)*x1144)));
evalcond[1]=(x1146+(((-0.1)*x1144))+((x1144*x1149))+((x1144*x1147)));
evalcond[2]=((0.4)+x1148+(((-1.0)*x1145*x1150))+(((-1.0)*x1145*x1147))+(((0.1)*x1145)));
evalcond[3]=((-0.32)+((x1149*x1151))+(((-0.2568)*cj18))+(((-0.08)*x1145))+((x1147*x1151)));
evalcond[4]=((0.1)+((x1145*x1148))+(((-1.0)*x1150))+(((-1.0)*x1147))+(((-1.0)*x1144*x1146))+(((0.4)*x1145)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1152=(gconst78*px);
IkReal x1153=(gconst77*py);
CheckValue<IkReal> x1154=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1152))+(((1000.0)*x1153))),-1);
if(!x1154.valid){
continue;
}
CheckValue<IkReal> x1155=IKPowWithIntegerCheck(((-0.1)+x1153+x1152),-1);
if(!x1155.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1154.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1155.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1154.value)))+IKsqr(((x1155.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1154.value)), ((x1155.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1156=IKsin(j16);
IkReal x1157=IKcos(j16);
IkReal x1158=((0.321)*sj18);
IkReal x1159=(gconst78*px);
IkReal x1160=((0.321)*cj18);
IkReal x1161=(gconst77*py);
IkReal x1162=((1.0)*x1161);
IkReal x1163=((0.8)*x1157);
evalcond[0]=(((x1156*x1160))+(((0.4)*x1156))+((x1157*x1158)));
evalcond[1]=(x1158+((x1156*x1161))+(((-0.1)*x1156))+((x1156*x1159)));
evalcond[2]=((0.4)+(((0.1)*x1157))+x1160+(((-1.0)*x1157*x1159))+(((-1.0)*x1157*x1162)));
evalcond[3]=((-0.32)+((x1159*x1163))+(((-0.2568)*cj18))+(((-0.08)*x1157))+((x1161*x1163)));
evalcond[4]=((0.1)+((x1157*x1160))+(((-1.0)*x1156*x1158))+(((-1.0)*x1159))+(((0.4)*x1157))+(((-1.0)*x1162)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst79;
CheckValue<IkReal> x1164 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1164.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1165=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1165.valid){
continue;
}
if( (x1165.value) < -1-IKFAST_SINCOS_THRESH || (x1165.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst79=((3.14159265358979)+(((-1.0)*(x1164.value)))+(((-1.0)*(IKasin(x1165.value)))));
IkReal gconst80;
gconst80=IKsin(gconst79);
IkReal gconst81;
gconst81=IKcos(gconst79);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst79))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst81*px))+(((-1.0)*pp))+(((0.2568)*cj18))+(((0.2)*gconst80*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst81*px))+(((10.0)*gconst80*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst81*px))+(((10.0)*gconst80*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1166=((10.0)*cj18);
IkReal x1167=(gconst81*px);
IkReal x1168=(gconst80*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1166*x1167))+(((-1.0)*x1166*x1168))+cj18+(((-12.4610591900312)*x1168))+(((-12.4610591900312)*x1167)));
dummyeval[1]=((1.0)+(((-10.0)*x1168))+(((-10.0)*x1167)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1169=(gconst80*py);
IkReal x1170=(gconst81*px);
IkReal x1171=((321.0)*cj18);
CheckValue<IkReal> x1172=IKPowWithIntegerCheck(((40.0)+(((32.1)*cj18))+(((-400.0)*x1170))+(((-1.0)*x1170*x1171))+(((-1.0)*x1169*x1171))+(((-400.0)*x1169))),-1);
if(!x1172.valid){
continue;
}
CheckValue<IkReal> x1173=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1169))+(((-1.0)*x1170))),-1);
if(!x1173.valid){
continue;
}
if( IKabs(((x1172.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1173.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1172.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1173.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1172.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1173.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1174=IKsin(j16);
IkReal x1175=IKcos(j16);
IkReal x1176=((0.321)*sj18);
IkReal x1177=(gconst80*py);
IkReal x1178=((0.321)*cj18);
IkReal x1179=(gconst81*px);
IkReal x1180=((0.8)*x1175);
IkReal x1181=((1.0)*x1175);
evalcond[0]=(((x1174*x1178))+(((0.4)*x1174))+((x1175*x1176)));
evalcond[1]=(x1176+((x1174*x1177))+((x1174*x1179))+(((-0.1)*x1174)));
evalcond[2]=((0.4)+x1178+(((0.1)*x1175))+(((-1.0)*x1179*x1181))+(((-1.0)*x1177*x1181)));
evalcond[3]=((-0.32)+(((-0.08)*x1175))+(((-0.2568)*cj18))+((x1179*x1180))+((x1177*x1180)));
evalcond[4]=((0.1)+(((0.4)*x1175))+((x1175*x1178))+(((-1.0)*x1174*x1176))+(((-1.0)*x1177))+(((-1.0)*x1179)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1182=(gconst81*px);
IkReal x1183=(gconst80*py);
CheckValue<IkReal> x1184=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1183))+(((1000.0)*x1182))),-1);
if(!x1184.valid){
continue;
}
CheckValue<IkReal> x1185=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1182))+(((-1.0)*x1183))),-1);
if(!x1185.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1184.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1185.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1184.value)))+IKsqr(((x1185.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1184.value)), ((x1185.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1186=IKsin(j16);
IkReal x1187=IKcos(j16);
IkReal x1188=((0.321)*sj18);
IkReal x1189=(gconst80*py);
IkReal x1190=((0.321)*cj18);
IkReal x1191=(gconst81*px);
IkReal x1192=((0.8)*x1187);
IkReal x1193=((1.0)*x1187);
evalcond[0]=(((x1187*x1188))+((x1186*x1190))+(((0.4)*x1186)));
evalcond[1]=(x1188+((x1186*x1189))+((x1186*x1191))+(((-0.1)*x1186)));
evalcond[2]=((0.4)+x1190+(((-1.0)*x1191*x1193))+(((-1.0)*x1189*x1193))+(((0.1)*x1187)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1189*x1192))+((x1191*x1192))+(((-0.08)*x1187)));
evalcond[4]=((0.1)+((x1187*x1190))+(((-1.0)*x1186*x1188))+(((0.4)*x1187))+(((-1.0)*x1189))+(((-1.0)*x1191)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1194=(gconst80*py);
IkReal x1195=(gconst81*px);
CheckValue<IkReal> x1196=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1194))+(((1000.0)*x1195))),-1);
if(!x1196.valid){
continue;
}
CheckValue<IkReal> x1197=IKPowWithIntegerCheck(((-0.1)+x1195+x1194),-1);
if(!x1197.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1196.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1197.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1196.value)))+IKsqr(((x1197.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1196.value)), ((x1197.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1198=IKsin(j16);
IkReal x1199=IKcos(j16);
IkReal x1200=((0.321)*sj18);
IkReal x1201=(gconst80*py);
IkReal x1202=((0.321)*cj18);
IkReal x1203=(gconst81*px);
IkReal x1204=((0.8)*x1199);
IkReal x1205=((1.0)*x1199);
evalcond[0]=((((0.4)*x1198))+((x1199*x1200))+((x1198*x1202)));
evalcond[1]=(x1200+(((-0.1)*x1198))+((x1198*x1201))+((x1198*x1203)));
evalcond[2]=((0.4)+x1202+(((-1.0)*x1203*x1205))+(((-1.0)*x1201*x1205))+(((0.1)*x1199)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((x1203*x1204))+((x1201*x1204))+(((-0.08)*x1199)));
evalcond[4]=((0.1)+(((0.4)*x1199))+((x1199*x1202))+(((-1.0)*x1203))+(((-1.0)*x1201))+(((-1.0)*x1198*x1200)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst82;
CheckValue<IkReal> x1206 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1206.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1207=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1207.valid){
continue;
}
if( (x1207.value) < -1-IKFAST_SINCOS_THRESH || (x1207.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst82=((((-1.0)*(x1206.value)))+(IKasin(x1207.value)));
IkReal gconst83;
gconst83=IKsin(gconst82);
IkReal gconst84;
gconst84=IKcos(gconst82);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst82))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst83*py))+(((0.2)*gconst84*px))+(((-1.0)*pp))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst84*px))+(((10.0)*gconst83*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst84*px))+(((10.0)*gconst83*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1208=(gconst84*px);
IkReal x1209=((10.0)*gconst83*py);
dummyeval[0]=((1.24610591900312)+cj18+(((-10.0)*cj18*x1208))+(((-1.0)*cj18*x1209))+(((-12.4610591900312)*gconst83*py))+(((-12.4610591900312)*x1208)));
dummyeval[1]=((1.0)+(((-10.0)*x1208))+(((-1.0)*x1209)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1210=((321.0)*cj18);
IkReal x1211=(gconst84*px);
IkReal x1212=(gconst83*py);
CheckValue<IkReal> x1213=IKPowWithIntegerCheck(((40.0)+(((32.1)*cj18))+(((-400.0)*x1211))+(((-400.0)*x1212))+(((-1.0)*x1210*x1211))+(((-1.0)*x1210*x1212))),-1);
if(!x1213.valid){
continue;
}
CheckValue<IkReal> x1214=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1212))+(((-1.0)*x1211))),-1);
if(!x1214.valid){
continue;
}
if( IKabs(((x1213.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1214.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1213.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1214.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1213.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1214.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1215=IKsin(j16);
IkReal x1216=IKcos(j16);
IkReal x1217=((0.321)*sj18);
IkReal x1218=(gconst84*px);
IkReal x1219=((0.321)*cj18);
IkReal x1220=(gconst83*py);
IkReal x1221=(x1216*x1218);
IkReal x1222=(x1216*x1220);
evalcond[0]=(((x1216*x1217))+(((0.4)*x1215))+((x1215*x1219)));
evalcond[1]=(x1217+(((-0.1)*x1215))+((x1215*x1220))+((x1215*x1218)));
evalcond[2]=((0.4)+x1219+(((0.1)*x1216))+(((-1.0)*x1222))+(((-1.0)*x1221)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((0.8)*x1221))+(((0.8)*x1222))+(((-0.08)*x1216)));
evalcond[4]=((0.1)+(((-1.0)*x1215*x1217))+(((-1.0)*x1220))+((x1216*x1219))+(((0.4)*x1216))+(((-1.0)*x1218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1223=(gconst84*px);
IkReal x1224=(gconst83*py);
CheckValue<IkReal> x1225=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1223))+(((1000.0)*x1224))),-1);
if(!x1225.valid){
continue;
}
CheckValue<IkReal> x1226=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1224))+(((-1.0)*x1223))),-1);
if(!x1226.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1225.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1226.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1225.value)))+IKsqr(((x1226.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1225.value)), ((x1226.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1227=IKsin(j16);
IkReal x1228=IKcos(j16);
IkReal x1229=((0.321)*sj18);
IkReal x1230=(gconst84*px);
IkReal x1231=((0.321)*cj18);
IkReal x1232=(gconst83*py);
IkReal x1233=(x1228*x1230);
IkReal x1234=(x1228*x1232);
evalcond[0]=((((0.4)*x1227))+((x1227*x1231))+((x1228*x1229)));
evalcond[1]=(x1229+(((-0.1)*x1227))+((x1227*x1230))+((x1227*x1232)));
evalcond[2]=((0.4)+(((0.1)*x1228))+(((-1.0)*x1233))+(((-1.0)*x1234))+x1231);
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((0.8)*x1233))+(((0.8)*x1234))+(((-0.08)*x1228)));
evalcond[4]=((0.1)+(((-1.0)*x1232))+(((-1.0)*x1230))+(((-1.0)*x1227*x1229))+(((0.4)*x1228))+((x1228*x1231)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1235=(gconst83*py);
IkReal x1236=(gconst84*px);
CheckValue<IkReal> x1237=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1235))+(((1000.0)*x1236))),-1);
if(!x1237.valid){
continue;
}
CheckValue<IkReal> x1238=IKPowWithIntegerCheck(((-0.1)+x1235+x1236),-1);
if(!x1238.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1237.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1238.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1237.value)))+IKsqr(((x1238.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1237.value)), ((x1238.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1239=IKsin(j16);
IkReal x1240=IKcos(j16);
IkReal x1241=((0.321)*sj18);
IkReal x1242=(gconst84*px);
IkReal x1243=((0.321)*cj18);
IkReal x1244=(gconst83*py);
IkReal x1245=(x1240*x1242);
IkReal x1246=(x1240*x1244);
evalcond[0]=(((x1239*x1243))+((x1240*x1241))+(((0.4)*x1239)));
evalcond[1]=(x1241+((x1239*x1244))+((x1239*x1242))+(((-0.1)*x1239)));
evalcond[2]=((0.4)+x1243+(((-1.0)*x1245))+(((-1.0)*x1246))+(((0.1)*x1240)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((0.8)*x1245))+(((0.8)*x1246))+(((-0.08)*x1240)));
evalcond[4]=((0.1)+(((-1.0)*x1239*x1241))+((x1240*x1243))+(((-1.0)*x1242))+(((-1.0)*x1244))+(((0.4)*x1240)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst85;
CheckValue<IkReal> x1247 = IKatan2WithCheck(((10.0)*px),((10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1247.valid){
continue;
}
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1248=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1248.valid){
continue;
}
if( (x1248.value) < -1-IKFAST_SINCOS_THRESH || (x1248.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
gconst85=((3.14159265358979)+(((-1.0)*(x1247.value)))+(((-1.0)*(IKasin(x1248.value)))));
IkReal gconst86;
gconst86=IKsin(gconst85);
IkReal gconst87;
gconst87=IKcos(gconst85);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst85))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*cj18))+(((0.2)*gconst86*py))+(((0.2)*gconst87*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst87*px))+(((10.0)*gconst86*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((-1.0)+(((10.0)*gconst87*px))+(((10.0)*gconst86*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1249=(gconst87*px);
IkReal x1250=((10.0)*cj18);
IkReal x1251=(gconst86*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*x1249*x1250))+cj18+(((-12.4610591900312)*x1249))+(((-1.0)*x1250*x1251))+(((-12.4610591900312)*x1251)));
dummyeval[1]=((1.0)+(((-10.0)*x1251))+(((-10.0)*x1249)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1252=(gconst86*py);
IkReal x1253=((321.0)*cj18);
IkReal x1254=(gconst87*px);
CheckValue<IkReal> x1255=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1253*x1254))+(((32.1)*cj18))+(((-1.0)*x1252*x1253))+(((-400.0)*x1254))+(((-400.0)*x1252))),-1);
if(!x1255.valid){
continue;
}
CheckValue<IkReal> x1256=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1252))+(((-1.0)*x1254))),-1);
if(!x1256.valid){
continue;
}
if( IKabs(((x1255.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1256.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1255.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))))+IKsqr(((x1256.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1255.value)*(((((103.041)*cj18*sj18))+(((128.4)*sj18))))), ((x1256.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1257=IKsin(j16);
IkReal x1258=IKcos(j16);
IkReal x1259=((0.321)*cj18);
IkReal x1260=((0.321)*sj18);
IkReal x1261=(gconst86*py);
IkReal x1262=(gconst87*px);
IkReal x1263=(x1258*x1261);
IkReal x1264=(x1258*x1262);
evalcond[0]=(((x1258*x1260))+((x1257*x1259))+(((0.4)*x1257)));
evalcond[1]=(x1260+((x1257*x1261))+((x1257*x1262))+(((-0.1)*x1257)));
evalcond[2]=((0.4)+x1259+(((0.1)*x1258))+(((-1.0)*x1264))+(((-1.0)*x1263)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((0.8)*x1264))+(((0.8)*x1263))+(((-0.08)*x1258)));
evalcond[4]=((0.1)+((x1258*x1259))+(((-1.0)*x1257*x1260))+(((-1.0)*x1261))+(((-1.0)*x1262))+(((0.4)*x1258)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1265=(gconst86*py);
IkReal x1266=(gconst87*px);
CheckValue<IkReal> x1267=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1266))+(((1000.0)*x1265))),-1);
if(!x1267.valid){
continue;
}
CheckValue<IkReal> x1268=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1265))+(((-1.0)*x1266))),-1);
if(!x1268.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1267.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1268.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1267.value)))+IKsqr(((x1268.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1267.value)), ((x1268.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1269=IKsin(j16);
IkReal x1270=IKcos(j16);
IkReal x1271=((0.321)*cj18);
IkReal x1272=((0.321)*sj18);
IkReal x1273=(gconst86*py);
IkReal x1274=(gconst87*px);
IkReal x1275=(x1270*x1273);
IkReal x1276=(x1270*x1274);
evalcond[0]=(((x1269*x1271))+((x1270*x1272))+(((0.4)*x1269)));
evalcond[1]=(((x1269*x1273))+((x1269*x1274))+x1272+(((-0.1)*x1269)));
evalcond[2]=((0.4)+x1271+(((0.1)*x1270))+(((-1.0)*x1275))+(((-1.0)*x1276)));
evalcond[3]=((-0.32)+(((0.8)*x1276))+(((0.8)*x1275))+(((-0.2568)*cj18))+(((-0.08)*x1270)));
evalcond[4]=((0.1)+(((0.4)*x1270))+(((-1.0)*x1269*x1272))+((x1270*x1271))+(((-1.0)*x1273))+(((-1.0)*x1274)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1277=(gconst86*py);
IkReal x1278=(gconst87*px);
CheckValue<IkReal> x1279=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1278))+(((1000.0)*x1277))),-1);
if(!x1279.valid){
continue;
}
CheckValue<IkReal> x1280=IKPowWithIntegerCheck(((-0.1)+x1278+x1277),-1);
if(!x1280.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1279.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1280.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1279.value)))+IKsqr(((x1280.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1279.value)), ((x1280.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1281=IKsin(j16);
IkReal x1282=IKcos(j16);
IkReal x1283=((0.321)*cj18);
IkReal x1284=((0.321)*sj18);
IkReal x1285=(gconst86*py);
IkReal x1286=(gconst87*px);
IkReal x1287=(x1282*x1285);
IkReal x1288=(x1282*x1286);
evalcond[0]=(((x1282*x1284))+(((0.4)*x1281))+((x1281*x1283)));
evalcond[1]=(x1284+(((-0.1)*x1281))+((x1281*x1286))+((x1281*x1285)));
evalcond[2]=((0.4)+(((-1.0)*x1288))+(((-1.0)*x1287))+x1283+(((0.1)*x1282)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1282))+(((0.8)*x1287))+(((0.8)*x1288)));
evalcond[4]=((0.1)+(((-1.0)*x1286))+(((-1.0)*x1285))+((x1282*x1283))+(((0.4)*x1282))+(((-1.0)*x1281*x1284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1289=(py*sj15);
IkReal x1290=(cj15*px);
CheckValue<IkReal> x1291=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1289))+(((1000.0)*x1290))),-1);
if(!x1291.valid){
continue;
}
CheckValue<IkReal> x1292=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1289))+(((-1.0)*x1290))),-1);
if(!x1292.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1291.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1292.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1291.value)))+IKsqr(((x1292.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1291.value)), ((x1292.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1293=IKsin(j16);
IkReal x1294=IKcos(j16);
IkReal x1295=((0.321)*sj18);
IkReal x1296=(cj15*px);
IkReal x1297=((0.321)*cj18);
IkReal x1298=(py*sj15);
IkReal x1299=((0.8)*x1294);
IkReal x1300=((1.0)*x1294);
evalcond[0]=(((x1294*x1295))+(((0.4)*x1293))+((x1293*x1297)));
evalcond[1]=(x1295+((x1293*x1298))+((x1293*x1296))+(((-0.1)*x1293)));
evalcond[2]=((0.4)+x1297+(((-1.0)*x1296*x1300))+(((0.1)*x1294))+(((-1.0)*x1298*x1300)));
evalcond[3]=((0.1)+((x1294*x1297))+(((0.4)*x1294))+(((-1.0)*x1293*x1295))+(((-1.0)*x1298))+(((-1.0)*x1296)));
evalcond[4]=((-0.066959)+((x1296*x1299))+(((-0.08)*x1294))+(((-1.0)*pp))+(((0.2)*x1298))+(((0.2)*x1296))+((x1298*x1299)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1301=(py*sj15);
IkReal x1302=(cj15*px);
CheckValue<IkReal> x1303=IKPowWithIntegerCheck(((-100.0)+(((1000.0)*x1302))+(((1000.0)*x1301))),-1);
if(!x1303.valid){
continue;
}
CheckValue<IkReal> x1304=IKPowWithIntegerCheck(((-0.1)+x1301+x1302),-1);
if(!x1304.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1303.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1304.value)*(((0.4)+(((0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1303.value)))+IKsqr(((x1304.value)*(((0.4)+(((0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1303.value)), ((x1304.value)*(((0.4)+(((0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1305=IKsin(j16);
IkReal x1306=IKcos(j16);
IkReal x1307=((0.321)*sj18);
IkReal x1308=(cj15*px);
IkReal x1309=((0.321)*cj18);
IkReal x1310=(py*sj15);
IkReal x1311=((0.8)*x1306);
IkReal x1312=((1.0)*x1306);
evalcond[0]=(((x1306*x1307))+(((0.4)*x1305))+((x1305*x1309)));
evalcond[1]=(x1307+((x1305*x1308))+((x1305*x1310))+(((-0.1)*x1305)));
evalcond[2]=((0.4)+x1309+(((-1.0)*x1308*x1312))+(((0.1)*x1306))+(((-1.0)*x1310*x1312)));
evalcond[3]=((0.1)+((x1306*x1309))+(((0.4)*x1306))+(((-1.0)*x1308))+(((-1.0)*x1310))+(((-1.0)*x1305*x1307)));
evalcond[4]=((-0.066959)+(((0.2)*x1308))+((x1310*x1311))+(((0.2)*x1310))+(((-0.08)*x1306))+((x1308*x1311))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1313=((321000.0)*py*sj15);
IkReal x1314=((321000.0)*cj15*px);
CheckValue<IkReal> x1315 = IKatan2WithCheck((gconst75*(((((32100.0)*sj18))+(((-1.0)*sj18*x1314))+(((-1.0)*sj18*x1313))))),(gconst75*(((-40000.0)+(((-32100.0)*cj18))+((cj18*x1313))+((cj18*x1314))+(((400000.0)*cj15*px))+(((400000.0)*py*sj15))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1315.valid){
continue;
}
j16array[0]=x1315.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1316=IKsin(j16);
IkReal x1317=IKcos(j16);
IkReal x1318=((0.321)*sj18);
IkReal x1319=(cj15*px);
IkReal x1320=((0.321)*cj18);
IkReal x1321=(py*sj15);
IkReal x1322=((0.8)*x1317);
IkReal x1323=((1.0)*x1317);
evalcond[0]=(((x1317*x1318))+((x1316*x1320))+(((0.4)*x1316)));
evalcond[1]=(x1318+((x1316*x1321))+((x1316*x1319))+(((-0.1)*x1316)));
evalcond[2]=((0.4)+x1320+(((-1.0)*x1319*x1323))+(((-1.0)*x1321*x1323))+(((0.1)*x1317)));
evalcond[3]=((0.1)+(((0.4)*x1317))+(((-1.0)*x1319))+(((-1.0)*x1321))+(((-1.0)*x1316*x1318))+((x1317*x1320)));
evalcond[4]=((-0.066959)+(((0.2)*x1321))+(((0.2)*x1319))+((x1319*x1322))+(((-0.08)*x1317))+(((-1.0)*pp))+((x1321*x1322)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1324=(cj15*py);
IkReal x1325=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j17, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=(x1325+(((-1.0)*x1324)));
evalcond[2]=(x1324+(((-1.0)*x1325)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal dummyeval[1];
IkReal gconst88;
gconst88=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1326=(cj15*px);
IkReal x1327=(py*sj15);
IkReal x1328=((10.0)*cj18);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x1327))+(((-12.4610591900312)*x1326))+(((-1.0)*x1327*x1328))+(((-1.0)*x1326*x1328))+cj18);
dummyeval[1]=((1.0)+(((-10.0)*x1326))+(((-10.0)*x1327)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
IkReal gconst89;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1329=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1329.valid){
continue;
}
if( (x1329.value) < -1-IKFAST_SINCOS_THRESH || (x1329.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1330 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1330.valid){
continue;
}
gconst89=((((-1.0)*(IKasin(x1329.value))))+(((-1.0)*(x1330.value))));
IkReal gconst90;
gconst90=IKsin(gconst89);
IkReal gconst91;
gconst91=IKcos(gconst89);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst89))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst91*px))+(((-1.0)*pp))+(((0.2)*gconst90*py))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst101;
gconst101=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst90*py))+(((-10.0)*gconst91*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1331=((10.0)*cj18);
IkReal x1332=(gconst91*px);
IkReal x1333=(gconst90*py);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*x1332))+(((-12.4610591900312)*x1333))+cj18+(((-1.0)*x1331*x1332))+(((-1.0)*x1331*x1333)));
dummyeval[1]=((1.0)+(((-10.0)*x1332))+(((-10.0)*x1333)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1334=(gconst91*px);
IkReal x1335=((321.0)*cj18);
IkReal x1336=(gconst90*py);
CheckValue<IkReal> x1337=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1335*x1336))+(((-1.0)*x1334*x1335))+(((32.1)*cj18))+(((-400.0)*x1336))+(((-400.0)*x1334))),-1);
if(!x1337.valid){
continue;
}
CheckValue<IkReal> x1338=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1334))+(((-1.0)*x1336))),-1);
if(!x1338.valid){
continue;
}
if( IKabs(((x1337.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1338.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1337.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1338.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1337.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1338.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1339=IKsin(j16);
IkReal x1340=IKcos(j16);
IkReal x1341=((0.321)*sj18);
IkReal x1342=(gconst90*py);
IkReal x1343=((0.321)*cj18);
IkReal x1344=((1.0)*gconst91*px);
IkReal x1345=((0.8)*x1340);
evalcond[0]=((((-1.0)*x1340*x1341))+((x1339*x1343))+(((0.4)*x1339)));
evalcond[1]=(x1341+(((-1.0)*x1339*x1342))+(((0.1)*x1339))+(((-1.0)*x1339*x1344)));
evalcond[2]=((0.4)+x1343+(((-1.0)*x1340*x1344))+(((-1.0)*x1340*x1342))+(((0.1)*x1340)));
evalcond[3]=((-0.32)+(((-0.08)*x1340))+(((-0.2568)*cj18))+((gconst91*px*x1345))+((x1342*x1345)));
evalcond[4]=((0.1)+((x1339*x1341))+(((-1.0)*x1344))+((x1340*x1343))+(((0.4)*x1340))+(((-1.0)*x1342)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1346=(gconst91*px);
IkReal x1347=(gconst90*py);
CheckValue<IkReal> x1348=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1347))+(((-1000.0)*x1346))),-1);
if(!x1348.valid){
continue;
}
CheckValue<IkReal> x1349=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1346))+(((-1.0)*x1347))),-1);
if(!x1349.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1348.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1349.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1348.value)))+IKsqr(((x1349.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1348.value)), ((x1349.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1350=IKsin(j16);
IkReal x1351=IKcos(j16);
IkReal x1352=((0.321)*sj18);
IkReal x1353=(gconst90*py);
IkReal x1354=((0.321)*cj18);
IkReal x1355=((1.0)*gconst91*px);
IkReal x1356=((0.8)*x1351);
evalcond[0]=((((0.4)*x1350))+((x1350*x1354))+(((-1.0)*x1351*x1352)));
evalcond[1]=(x1352+(((0.1)*x1350))+(((-1.0)*x1350*x1355))+(((-1.0)*x1350*x1353)));
evalcond[2]=((0.4)+(((-1.0)*x1351*x1353))+x1354+(((0.1)*x1351))+(((-1.0)*x1351*x1355)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1351))+((gconst91*px*x1356))+((x1353*x1356)));
evalcond[4]=((0.1)+(((-1.0)*x1355))+(((-1.0)*x1353))+(((0.4)*x1351))+((x1350*x1352))+((x1351*x1354)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1357=((321000.0)*gconst91*px);
IkReal x1358=((321000.0)*gconst90*py);
CheckValue<IkReal> x1359 = IKatan2WithCheck((gconst101*(((((-1.0)*sj18*x1358))+(((-1.0)*sj18*x1357))+(((32100.0)*sj18))))),(gconst101*(((40000.0)+(((-1.0)*cj18*x1358))+(((-1.0)*cj18*x1357))+(((32100.0)*cj18))+(((-400000.0)*gconst91*px))+(((-400000.0)*gconst90*py))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1359.valid){
continue;
}
j16array[0]=x1359.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1360=IKsin(j16);
IkReal x1361=IKcos(j16);
IkReal x1362=((0.321)*sj18);
IkReal x1363=(gconst90*py);
IkReal x1364=((0.321)*cj18);
IkReal x1365=((1.0)*gconst91*px);
IkReal x1366=((0.8)*x1361);
evalcond[0]=(((x1360*x1364))+(((0.4)*x1360))+(((-1.0)*x1361*x1362)));
evalcond[1]=(x1362+(((0.1)*x1360))+(((-1.0)*x1360*x1365))+(((-1.0)*x1360*x1363)));
evalcond[2]=((0.4)+x1364+(((0.1)*x1361))+(((-1.0)*x1361*x1363))+(((-1.0)*x1361*x1365)));
evalcond[3]=((-0.32)+(((-0.08)*x1361))+(((-0.2568)*cj18))+((gconst91*px*x1366))+((x1363*x1366)));
evalcond[4]=((0.1)+(((-1.0)*x1363))+((x1361*x1364))+((x1360*x1362))+(((0.4)*x1361))+(((-1.0)*x1365)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst92;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1367=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1367.valid){
continue;
}
if( (x1367.value) < -1-IKFAST_SINCOS_THRESH || (x1367.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1368 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1368.valid){
continue;
}
gconst92=((3.14159265358979)+(IKasin(x1367.value))+(((-1.0)*(x1368.value))));
IkReal gconst93;
gconst93=IKsin(gconst92);
IkReal gconst94;
gconst94=IKcos(gconst92);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst92))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst93*py))+(((-1.0)*pp))+(((0.2)*gconst94*px))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst102;
gconst102=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst93*py))+(((-10.0)*gconst94*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1369=(gconst94*px);
IkReal x1370=((10.0)*gconst93*py);
dummyeval[0]=((1.24610591900312)+(((-1.0)*cj18*x1370))+(((-12.4610591900312)*gconst93*py))+cj18+(((-12.4610591900312)*x1369))+(((-10.0)*cj18*x1369)));
dummyeval[1]=((1.0)+(((-10.0)*x1369))+(((-1.0)*x1370)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1371=(gconst93*py);
IkReal x1372=((321.0)*cj18);
IkReal x1373=(gconst94*px);
CheckValue<IkReal> x1374=IKPowWithIntegerCheck(((40.0)+(((-1.0)*x1371*x1372))+(((32.1)*cj18))+(((-1.0)*x1372*x1373))+(((-400.0)*x1371))+(((-400.0)*x1373))),-1);
if(!x1374.valid){
continue;
}
CheckValue<IkReal> x1375=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1373))+(((-1.0)*x1371))),-1);
if(!x1375.valid){
continue;
}
if( IKabs(((x1374.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1375.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1374.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1375.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1374.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1375.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1376=IKsin(j16);
IkReal x1377=IKcos(j16);
IkReal x1378=((0.321)*sj18);
IkReal x1379=((0.321)*cj18);
IkReal x1380=((1.0)*gconst94*px);
IkReal x1381=((1.0)*gconst93*py);
IkReal x1382=((0.8)*x1377);
evalcond[0]=(((x1376*x1379))+(((0.4)*x1376))+(((-1.0)*x1377*x1378)));
evalcond[1]=(x1378+(((-1.0)*x1376*x1380))+(((-1.0)*x1376*x1381))+(((0.1)*x1376)));
evalcond[2]=((0.4)+x1379+(((-1.0)*x1377*x1380))+(((-1.0)*x1377*x1381))+(((0.1)*x1377)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((gconst94*px*x1382))+(((-0.08)*x1377))+((gconst93*py*x1382)));
evalcond[4]=((0.1)+(((-1.0)*x1381))+(((-1.0)*x1380))+((x1376*x1378))+(((0.4)*x1377))+((x1377*x1379)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1383=(gconst94*px);
IkReal x1384=(gconst93*py);
CheckValue<IkReal> x1385=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1384))+(((-1000.0)*x1383))),-1);
if(!x1385.valid){
continue;
}
CheckValue<IkReal> x1386=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1383))+(((-1.0)*x1384))),-1);
if(!x1386.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1385.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1386.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1385.value)))+IKsqr(((x1386.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1385.value)), ((x1386.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1387=IKsin(j16);
IkReal x1388=IKcos(j16);
IkReal x1389=((0.321)*sj18);
IkReal x1390=((0.321)*cj18);
IkReal x1391=((1.0)*gconst94*px);
IkReal x1392=((1.0)*gconst93*py);
IkReal x1393=((0.8)*x1388);
evalcond[0]=((((0.4)*x1387))+((x1387*x1390))+(((-1.0)*x1388*x1389)));
evalcond[1]=(x1389+(((0.1)*x1387))+(((-1.0)*x1387*x1392))+(((-1.0)*x1387*x1391)));
evalcond[2]=((0.4)+x1390+(((0.1)*x1388))+(((-1.0)*x1388*x1392))+(((-1.0)*x1388*x1391)));
evalcond[3]=((-0.32)+((gconst93*py*x1393))+(((-0.2568)*cj18))+((gconst94*px*x1393))+(((-0.08)*x1388)));
evalcond[4]=((0.1)+((x1388*x1390))+((x1387*x1389))+(((0.4)*x1388))+(((-1.0)*x1391))+(((-1.0)*x1392)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1394=(gconst94*px);
IkReal x1395=((321000.0)*cj18);
IkReal x1396=((321000.0)*sj18);
IkReal x1397=(gconst93*py);
CheckValue<IkReal> x1398 = IKatan2WithCheck((gconst102*(((((-1.0)*x1394*x1396))+(((-1.0)*x1396*x1397))+(((32100.0)*sj18))))),(gconst102*(((40000.0)+(((32100.0)*cj18))+(((-1.0)*x1394*x1395))+(((-1.0)*x1395*x1397))+(((-400000.0)*x1394))+(((-400000.0)*x1397))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1398.valid){
continue;
}
j16array[0]=x1398.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1399=IKsin(j16);
IkReal x1400=IKcos(j16);
IkReal x1401=((0.321)*sj18);
IkReal x1402=((0.321)*cj18);
IkReal x1403=((1.0)*gconst94*px);
IkReal x1404=((1.0)*gconst93*py);
IkReal x1405=((0.8)*x1400);
evalcond[0]=((((0.4)*x1399))+((x1399*x1402))+(((-1.0)*x1400*x1401)));
evalcond[1]=((((0.1)*x1399))+(((-1.0)*x1399*x1403))+(((-1.0)*x1399*x1404))+x1401);
evalcond[2]=((0.4)+x1402+(((-1.0)*x1400*x1403))+(((-1.0)*x1400*x1404))+(((0.1)*x1400)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1400))+((gconst93*py*x1405))+((gconst94*px*x1405)));
evalcond[4]=((0.1)+(((0.4)*x1400))+(((-1.0)*x1403))+(((-1.0)*x1404))+((x1399*x1401))+((x1400*x1402)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst95;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1406=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1406.valid){
continue;
}
if( (x1406.value) < -1-IKFAST_SINCOS_THRESH || (x1406.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1407 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1407.valid){
continue;
}
gconst95=((((-1.0)*(IKasin(x1406.value))))+(((-1.0)*(x1407.value))));
IkReal gconst96;
gconst96=IKsin(gconst95);
IkReal gconst97;
gconst97=IKcos(gconst95);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst95))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*cj18))+(((0.2)*gconst97*px))+(((0.2)*gconst96*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst103;
gconst103=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst97*px))+(((-10.0)*gconst96*py)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1408=(gconst97*px);
IkReal x1409=((10.0)*gconst96*py);
dummyeval[0]=((1.24610591900312)+(((-12.4610591900312)*gconst96*py))+cj18+(((-12.4610591900312)*x1408))+(((-1.0)*cj18*x1409))+(((-10.0)*cj18*x1408)));
dummyeval[1]=((1.0)+(((-1.0)*x1409))+(((-10.0)*x1408)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1410=((321.0)*cj18);
IkReal x1411=(gconst97*px);
IkReal x1412=(gconst96*py);
CheckValue<IkReal> x1413=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1411))+(((-400.0)*x1412))+(((32.1)*cj18))+(((-1.0)*x1410*x1411))+(((-1.0)*x1410*x1412))),-1);
if(!x1413.valid){
continue;
}
CheckValue<IkReal> x1414=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1412))+(((-1.0)*x1411))),-1);
if(!x1414.valid){
continue;
}
if( IKabs(((x1413.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1414.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1413.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1414.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1413.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1414.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1415=IKsin(j16);
IkReal x1416=IKcos(j16);
IkReal x1417=((0.321)*cj18);
IkReal x1418=((0.321)*sj18);
IkReal x1419=((1.0)*gconst96*py);
IkReal x1420=((1.0)*gconst97*px);
IkReal x1421=((0.8)*x1416);
evalcond[0]=(((x1415*x1417))+(((0.4)*x1415))+(((-1.0)*x1416*x1418)));
evalcond[1]=((((-1.0)*x1415*x1420))+(((-1.0)*x1415*x1419))+(((0.1)*x1415))+x1418);
evalcond[2]=((0.4)+(((0.1)*x1416))+(((-1.0)*x1416*x1420))+(((-1.0)*x1416*x1419))+x1417);
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1416))+((gconst96*py*x1421))+((gconst97*px*x1421)));
evalcond[4]=((0.1)+((x1415*x1418))+(((0.4)*x1416))+(((-1.0)*x1419))+((x1416*x1417))+(((-1.0)*x1420)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1422=(gconst96*py);
IkReal x1423=(gconst97*px);
CheckValue<IkReal> x1424=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1422))+(((-1000.0)*x1423))),-1);
if(!x1424.valid){
continue;
}
CheckValue<IkReal> x1425=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1423))+(((-1.0)*x1422))),-1);
if(!x1425.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1424.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1425.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1424.value)))+IKsqr(((x1425.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1424.value)), ((x1425.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1426=IKsin(j16);
IkReal x1427=IKcos(j16);
IkReal x1428=((0.321)*cj18);
IkReal x1429=((0.321)*sj18);
IkReal x1430=((1.0)*gconst96*py);
IkReal x1431=((1.0)*gconst97*px);
IkReal x1432=((0.8)*x1427);
evalcond[0]=((((-1.0)*x1427*x1429))+((x1426*x1428))+(((0.4)*x1426)));
evalcond[1]=((((0.1)*x1426))+x1429+(((-1.0)*x1426*x1430))+(((-1.0)*x1426*x1431)));
evalcond[2]=((0.4)+(((0.1)*x1427))+x1428+(((-1.0)*x1427*x1430))+(((-1.0)*x1427*x1431)));
evalcond[3]=((-0.32)+((gconst96*py*x1432))+(((-0.2568)*cj18))+((gconst97*px*x1432))+(((-0.08)*x1427)));
evalcond[4]=((0.1)+((x1426*x1429))+(((-1.0)*x1431))+(((-1.0)*x1430))+(((0.4)*x1427))+((x1427*x1428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1433=(gconst96*py);
IkReal x1434=((321000.0)*sj18);
IkReal x1435=(gconst97*px);
IkReal x1436=((321000.0)*cj18);
CheckValue<IkReal> x1437 = IKatan2WithCheck((gconst103*(((((-1.0)*x1434*x1435))+(((32100.0)*sj18))+(((-1.0)*x1433*x1434))))),(gconst103*(((40000.0)+(((-400000.0)*x1433))+(((-400000.0)*x1435))+(((32100.0)*cj18))+(((-1.0)*x1435*x1436))+(((-1.0)*x1433*x1436))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1437.valid){
continue;
}
j16array[0]=x1437.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1438=IKsin(j16);
IkReal x1439=IKcos(j16);
IkReal x1440=((0.321)*cj18);
IkReal x1441=((0.321)*sj18);
IkReal x1442=((1.0)*gconst96*py);
IkReal x1443=((1.0)*gconst97*px);
IkReal x1444=((0.8)*x1439);
evalcond[0]=(((x1438*x1440))+(((-1.0)*x1439*x1441))+(((0.4)*x1438)));
evalcond[1]=((((-1.0)*x1438*x1443))+(((-1.0)*x1438*x1442))+(((0.1)*x1438))+x1441);
evalcond[2]=((0.4)+(((-1.0)*x1439*x1442))+(((-1.0)*x1439*x1443))+(((0.1)*x1439))+x1440);
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1439))+((gconst96*py*x1444))+((gconst97*px*x1444)));
evalcond[4]=((0.1)+((x1438*x1441))+((x1439*x1440))+(((-1.0)*x1442))+(((-1.0)*x1443))+(((0.4)*x1439)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst98;
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x1445=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x1445.valid){
continue;
}
if( (x1445.value) < -1-IKFAST_SINCOS_THRESH || (x1445.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x1446 = IKatan2WithCheck(((-10.0)*px),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x1446.valid){
continue;
}
gconst98=((3.14159265358979)+(IKasin(x1445.value))+(((-1.0)*(x1446.value))));
IkReal gconst99;
gconst99=IKsin(gconst98);
IkReal gconst100;
gconst100=IKcos(gconst98);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.0)*gconst98))+j15)))), 6.28318530717959)));
evalcond[1]=((0.253041)+(((0.2)*gconst99*py))+(((0.2)*gconst100*px))+(((-1.0)*pp))+(((0.2568)*cj18)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst104;
gconst104=IKsign(((-160000.0)+(((-103041.0)*(sj18*sj18)))+(((-256800.0)*cj18))+(((-103041.0)*(cj18*cj18)))));
dummyeval[0]=((-1.5527799613746)+(((-1.0)*(cj18*cj18)))+(((-2.49221183800623)*cj18))+(((-1.0)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=((1.0)+(((-10.0)*gconst99*py))+(((-10.0)*gconst100*px)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
IkReal x1447=(gconst99*py);
IkReal x1448=((10.0)*gconst100*px);
dummyeval[0]=((1.24610591900312)+(((-1.0)*cj18*x1448))+(((-10.0)*cj18*x1447))+cj18+(((-12.4610591900312)*gconst100*px))+(((-12.4610591900312)*x1447)));
dummyeval[1]=((1.0)+(((-10.0)*x1447))+(((-1.0)*x1448)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1449=(gconst100*px);
IkReal x1450=((321.0)*cj18);
IkReal x1451=(gconst99*py);
CheckValue<IkReal> x1452=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1451))+(((32.1)*cj18))+(((-400.0)*x1449))+(((-1.0)*x1449*x1450))+(((-1.0)*x1450*x1451))),-1);
if(!x1452.valid){
continue;
}
CheckValue<IkReal> x1453=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1451))+(((-1.0)*x1449))),-1);
if(!x1453.valid){
continue;
}
if( IKabs(((x1452.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1453.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1452.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1453.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1452.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1453.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1454=IKsin(j16);
IkReal x1455=IKcos(j16);
IkReal x1456=((0.321)*sj18);
IkReal x1457=((0.321)*cj18);
IkReal x1458=((1.0)*gconst100*px);
IkReal x1459=((1.0)*gconst99*py);
IkReal x1460=((0.8)*x1455);
evalcond[0]=(((x1454*x1457))+(((-1.0)*x1455*x1456))+(((0.4)*x1454)));
evalcond[1]=((((-1.0)*x1454*x1458))+(((-1.0)*x1454*x1459))+x1456+(((0.1)*x1454)));
evalcond[2]=((0.4)+(((-1.0)*x1455*x1458))+(((-1.0)*x1455*x1459))+x1457+(((0.1)*x1455)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+((gconst100*px*x1460))+(((-0.08)*x1455))+((gconst99*py*x1460)));
evalcond[4]=((0.1)+((x1455*x1457))+((x1454*x1456))+(((-1.0)*x1459))+(((-1.0)*x1458))+(((0.4)*x1455)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1461=(gconst99*py);
IkReal x1462=(gconst100*px);
CheckValue<IkReal> x1463=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1461))+(((-1000.0)*x1462))),-1);
if(!x1463.valid){
continue;
}
CheckValue<IkReal> x1464=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1462))+(((-1.0)*x1461))),-1);
if(!x1464.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1463.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1464.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1463.value)))+IKsqr(((x1464.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1463.value)), ((x1464.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1465=IKsin(j16);
IkReal x1466=IKcos(j16);
IkReal x1467=((0.321)*sj18);
IkReal x1468=((0.321)*cj18);
IkReal x1469=((1.0)*gconst100*px);
IkReal x1470=((1.0)*gconst99*py);
IkReal x1471=((0.8)*x1466);
evalcond[0]=((((0.4)*x1465))+((x1465*x1468))+(((-1.0)*x1466*x1467)));
evalcond[1]=((((-1.0)*x1465*x1470))+x1467+(((-1.0)*x1465*x1469))+(((0.1)*x1465)));
evalcond[2]=((0.4)+(((-1.0)*x1466*x1469))+x1468+(((-1.0)*x1466*x1470))+(((0.1)*x1466)));
evalcond[3]=((-0.32)+(((-0.08)*x1466))+(((-0.2568)*cj18))+((gconst99*py*x1471))+((gconst100*px*x1471)));
evalcond[4]=((0.1)+(((0.4)*x1466))+(((-1.0)*x1469))+((x1465*x1467))+((x1466*x1468))+(((-1.0)*x1470)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1472=(gconst100*px);
IkReal x1473=((321000.0)*sj18);
IkReal x1474=(gconst99*py);
IkReal x1475=((321000.0)*cj18);
CheckValue<IkReal> x1476 = IKatan2WithCheck((gconst104*(((((32100.0)*sj18))+(((-1.0)*x1472*x1473))+(((-1.0)*x1473*x1474))))),(gconst104*(((40000.0)+(((32100.0)*cj18))+(((-1.0)*x1474*x1475))+(((-400000.0)*x1472))+(((-400000.0)*x1474))+(((-1.0)*x1472*x1475))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1476.valid){
continue;
}
j16array[0]=x1476.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1477=IKsin(j16);
IkReal x1478=IKcos(j16);
IkReal x1479=((0.321)*sj18);
IkReal x1480=((0.321)*cj18);
IkReal x1481=((1.0)*gconst100*px);
IkReal x1482=((1.0)*gconst99*py);
IkReal x1483=((0.8)*x1478);
evalcond[0]=((((-1.0)*x1478*x1479))+((x1477*x1480))+(((0.4)*x1477)));
evalcond[1]=((((0.1)*x1477))+x1479+(((-1.0)*x1477*x1482))+(((-1.0)*x1477*x1481)));
evalcond[2]=((0.4)+(((0.1)*x1478))+x1480+(((-1.0)*x1478*x1482))+(((-1.0)*x1478*x1481)));
evalcond[3]=((-0.32)+(((-0.2568)*cj18))+(((-0.08)*x1478))+((gconst99*py*x1483))+((gconst100*px*x1483)));
evalcond[4]=((0.1)+(((-1.0)*x1481))+(((-1.0)*x1482))+(((0.4)*x1478))+((x1477*x1479))+((x1478*x1480)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1484=(py*sj15);
IkReal x1485=((321.0)*cj18);
IkReal x1486=(cj15*px);
CheckValue<IkReal> x1487=IKPowWithIntegerCheck(((40.0)+(((-400.0)*x1484))+(((-400.0)*x1486))+(((-1.0)*x1485*x1486))+(((-1.0)*x1484*x1485))+(((32.1)*cj18))),-1);
if(!x1487.valid){
continue;
}
CheckValue<IkReal> x1488=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1486))+(((-1.0)*x1484))),-1);
if(!x1488.valid){
continue;
}
if( IKabs(((x1487.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1488.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x1487.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))))+IKsqr(((x1488.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((x1487.value)*(((((-103.041)*cj18*sj18))+(((-128.4)*sj18))))), ((x1488.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1489=IKsin(j16);
IkReal x1490=IKcos(j16);
IkReal x1491=((0.321)*sj18);
IkReal x1492=(cj15*px);
IkReal x1493=((0.321)*cj18);
IkReal x1494=(py*sj15);
IkReal x1495=((0.8)*x1490);
IkReal x1496=((1.0)*x1494);
evalcond[0]=(((x1489*x1493))+(((-1.0)*x1490*x1491))+(((0.4)*x1489)));
evalcond[1]=((((-1.0)*x1489*x1492))+(((0.1)*x1489))+x1491+(((-1.0)*x1489*x1496)));
evalcond[2]=((0.4)+(((0.1)*x1490))+x1493+(((-1.0)*x1490*x1496))+(((-1.0)*x1490*x1492)));
evalcond[3]=((0.1)+((x1489*x1491))+(((-1.0)*x1496))+(((-1.0)*x1492))+((x1490*x1493))+(((0.4)*x1490)));
evalcond[4]=((-0.066959)+((x1494*x1495))+(((-0.08)*x1490))+(((-1.0)*pp))+((x1492*x1495))+(((0.2)*x1492))+(((0.2)*x1494)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1497=(py*sj15);
IkReal x1498=(cj15*px);
CheckValue<IkReal> x1499=IKPowWithIntegerCheck(((100.0)+(((-1000.0)*x1497))+(((-1000.0)*x1498))),-1);
if(!x1499.valid){
continue;
}
CheckValue<IkReal> x1500=IKPowWithIntegerCheck(((0.1)+(((-1.0)*x1498))+(((-1.0)*x1497))),-1);
if(!x1500.valid){
continue;
}
if( IKabs(((-321.0)*sj18*(x1499.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x1500.value)*(((-0.4)+(((-0.321)*cj18)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-321.0)*sj18*(x1499.value)))+IKsqr(((x1500.value)*(((-0.4)+(((-0.321)*cj18))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j16array[0]=IKatan2(((-321.0)*sj18*(x1499.value)), ((x1500.value)*(((-0.4)+(((-0.321)*cj18))))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1501=IKsin(j16);
IkReal x1502=IKcos(j16);
IkReal x1503=((0.321)*sj18);
IkReal x1504=(cj15*px);
IkReal x1505=((0.321)*cj18);
IkReal x1506=(py*sj15);
IkReal x1507=((0.8)*x1502);
IkReal x1508=((1.0)*x1506);
evalcond[0]=(((x1501*x1505))+(((-1.0)*x1502*x1503))+(((0.4)*x1501)));
evalcond[1]=((((-1.0)*x1501*x1508))+x1503+(((0.1)*x1501))+(((-1.0)*x1501*x1504)));
evalcond[2]=((0.4)+x1505+(((-1.0)*x1502*x1508))+(((0.1)*x1502))+(((-1.0)*x1502*x1504)));
evalcond[3]=((0.1)+(((-1.0)*x1508))+(((-1.0)*x1504))+((x1501*x1503))+((x1502*x1505))+(((0.4)*x1502)));
evalcond[4]=((-0.066959)+((x1504*x1507))+((x1506*x1507))+(((-1.0)*pp))+(((-0.08)*x1502))+(((0.2)*x1506))+(((0.2)*x1504)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1509=((321000.0)*py*sj15);
IkReal x1510=((321000.0)*cj15*px);
CheckValue<IkReal> x1511 = IKatan2WithCheck((gconst88*(((((32100.0)*sj18))+(((-1.0)*sj18*x1510))+(((-1.0)*sj18*x1509))))),(gconst88*(((40000.0)+(((32100.0)*cj18))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))+(((-1.0)*cj18*x1510))+(((-1.0)*cj18*x1509))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1511.valid){
continue;
}
j16array[0]=x1511.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x1512=IKsin(j16);
IkReal x1513=IKcos(j16);
IkReal x1514=((0.321)*sj18);
IkReal x1515=(cj15*px);
IkReal x1516=((0.321)*cj18);
IkReal x1517=(py*sj15);
IkReal x1518=((0.8)*x1513);
IkReal x1519=((1.0)*x1517);
evalcond[0]=((((-1.0)*x1513*x1514))+((x1512*x1516))+(((0.4)*x1512)));
evalcond[1]=(x1514+(((-1.0)*x1512*x1519))+(((0.1)*x1512))+(((-1.0)*x1512*x1515)));
evalcond[2]=((0.4)+(((-1.0)*x1513*x1515))+(((-1.0)*x1513*x1519))+x1516+(((0.1)*x1513)));
evalcond[3]=((0.1)+((x1513*x1516))+(((-1.0)*x1519))+(((-1.0)*x1515))+((x1512*x1514))+(((0.4)*x1513)));
evalcond[4]=((-0.066959)+(((-1.0)*pp))+((x1515*x1518))+((x1517*x1518))+(((-0.08)*x1513))+(((0.2)*x1515))+(((0.2)*x1517)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1520=IKPowWithIntegerCheck(sj17,-1);
if(!x1520.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1520.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1520.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1520.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[2];
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj17*(IKsin(j18)))));
evalcond[1]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*(IKcos(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst45;
IkReal x1521=((321.0)*cj18);
IkReal x1522=(cj15*px);
IkReal x1523=(py*sj15);
gconst45=IKsign(((-40.0)+(((321.0)*cj17*pz*sj18))+(((-32.1)*cj18))+((x1521*x1523))+((x1521*x1522))+(((400.0)*x1523))+(((400.0)*x1522))));
IkReal x1524=(py*sj15);
IkReal x1525=((10.0)*cj18);
IkReal x1526=(cj15*px);
dummyeval[0]=((-1.24610591900312)+((x1524*x1525))+((x1525*x1526))+(((12.4610591900312)*x1524))+(((12.4610591900312)*x1526))+(((10.0)*cj17*pz*sj18))+(((-1.0)*cj18)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst46;
gconst46=IKsign(((160000.0)+(((103041.0)*(cj17*cj17)*(sj18*sj18)))+(((256800.0)*cj18))+(((103041.0)*(cj18*cj18)))));
dummyeval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+(cj18*cj18)+(((cj17*cj17)*(sj18*sj18))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1527=(cj15*px);
IkReal x1528=(py*sj15);
IkReal x1529=((321000.0)*cj18);
IkReal x1530=((321000.0)*cj17*sj18);
CheckValue<IkReal> x1531 = IKatan2WithCheck((gconst46*(((((32100.0)*cj17*sj18))+(((-400000.0)*pz))+(((-1.0)*x1528*x1530))+(((-1.0)*x1527*x1530))+(((-1.0)*pz*x1529))))),(gconst46*(((-40000.0)+((x1528*x1529))+(((-32100.0)*cj18))+((x1527*x1529))+(((400000.0)*x1528))+(((400000.0)*x1527))+(((-1.0)*pz*x1530))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1531.valid){
continue;
}
j16array[0]=x1531.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x1532=IKsin(j16);
IkReal x1533=IKcos(j16);
IkReal x1534=((0.321)*sj18);
IkReal x1535=(cj15*px);
IkReal x1536=(py*sj15);
IkReal x1537=(px*sj15);
IkReal x1538=((1.0)*sj17);
IkReal x1539=(cj15*py);
IkReal x1540=((0.321)*cj18);
IkReal x1541=(pz*x1533);
IkReal x1542=((1.0)*x1535);
IkReal x1543=((0.321)*x1533);
IkReal x1544=(sj17*x1532);
IkReal x1545=(pz*x1532);
IkReal x1546=((0.8)*x1533);
IkReal x1547=(cj17*x1532);
evalcond[0]=((((0.4)*x1532))+((x1532*x1540))+((cj17*x1533*x1534))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1536))+(((0.4)*x1533))+((x1533*x1540))+(((-1.0)*x1534*x1547))+(((-1.0)*x1542)));
evalcond[2]=((0.4)+(((-1.0)*x1533*x1536))+x1545+x1540+(((-1.0)*x1533*x1542))+(((0.1)*x1533)));
evalcond[3]=((-0.066959)+((x1536*x1546))+(((-0.8)*x1545))+(((-1.0)*pp))+(((-0.08)*x1533))+(((0.2)*x1535))+(((0.2)*x1536))+((x1535*x1546)));
evalcond[4]=((((-1.0)*x1532*x1535*x1538))+(((-1.0)*x1532*x1536*x1538))+(((-1.0)*cj17*x1539))+(((-1.0)*x1538*x1541))+(((0.1)*x1544))+((cj17*x1537)));
evalcond[5]=(((x1536*x1547))+((cj17*x1541))+x1534+((sj17*x1537))+(((-1.0)*x1538*x1539))+((x1535*x1547))+(((-0.1)*x1547)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1548=(cj17*sj18);
IkReal x1549=((1000.0)*pz);
CheckValue<IkReal> x1550 = IKatan2WithCheck((gconst45*(((((-103.041)*cj18*x1548))+(((100.0)*pz))+(((-1.0)*py*sj15*x1549))+(((-128.4)*x1548))+(((-1.0)*cj15*px*x1549))))),(gconst45*(((160.0)+(((-1.0)*pz*x1549))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1550.valid){
continue;
}
j16array[0]=x1550.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x1551=IKsin(j16);
IkReal x1552=IKcos(j16);
IkReal x1553=((0.321)*sj18);
IkReal x1554=(cj15*px);
IkReal x1555=(py*sj15);
IkReal x1556=(px*sj15);
IkReal x1557=((1.0)*sj17);
IkReal x1558=(cj15*py);
IkReal x1559=((0.321)*cj18);
IkReal x1560=(pz*x1552);
IkReal x1561=((1.0)*x1554);
IkReal x1562=((0.321)*x1552);
IkReal x1563=(sj17*x1551);
IkReal x1564=(pz*x1551);
IkReal x1565=((0.8)*x1552);
IkReal x1566=(cj17*x1551);
evalcond[0]=(((x1551*x1559))+(((0.4)*x1551))+((cj17*x1552*x1553))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1555))+((x1552*x1559))+(((0.4)*x1552))+(((-1.0)*x1553*x1566))+(((-1.0)*x1561)));
evalcond[2]=((0.4)+(((-1.0)*x1552*x1561))+(((0.1)*x1552))+(((-1.0)*x1552*x1555))+x1564+x1559);
evalcond[3]=((-0.066959)+((x1555*x1565))+(((-0.8)*x1564))+((x1554*x1565))+(((-1.0)*pp))+(((-0.08)*x1552))+(((0.2)*x1554))+(((0.2)*x1555)));
evalcond[4]=((((0.1)*x1563))+(((-1.0)*x1551*x1555*x1557))+((cj17*x1556))+(((-1.0)*x1557*x1560))+(((-1.0)*cj17*x1558))+(((-1.0)*x1551*x1554*x1557)));
evalcond[5]=(((x1555*x1566))+((sj17*x1556))+((cj17*x1560))+((x1554*x1566))+x1553+(((-1.0)*x1557*x1558))+(((-0.1)*x1566)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1567=cj15*cj15;
IkReal x1568=px*px;
IkReal x1569=py*py;
IkReal x1570=sj15*sj15;
IkReal x1571=((5.0)*pp);
IkReal x1572=(py*sj15);
IkReal x1573=(pz*sj17);
IkReal x1574=((0.4)*cj17);
IkReal x1575=(px*sj15);
IkReal x1576=(cj15*px*sj17);
IkReal x1577=((4.0)*cj17*py);
IkReal x1578=((4.0)*cj15*cj17*sj15);
CheckValue<IkReal> x1579 = IKatan2WithCheck((gconst44*((((x1571*x1573))+((x1569*x1578))+((px*x1567*x1577))+(((0.334795)*x1573))+(((-1.0)*x1572*x1573))+(((-1.0)*cj15*px*x1573))+(((-1.0)*cj15*py*x1574))+(((-1.0)*x1568*x1578))+(((-1.0)*px*x1570*x1577))+((x1574*x1575))))),(gconst44*(((((2.0)*x1572*x1576))+(((-1.0)*x1571*x1576))+(((0.5)*pp*sj17))+((sj17*x1567*x1568))+((cj15*pz*x1577))+(((-0.434795)*x1576))+(((-4.0)*cj17*pz*x1575))+((sj17*x1569*x1570))+(((0.0334795)*sj17))+(((-1.0)*sj17*x1571*x1572))+(((-0.434795)*sj17*x1572))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1579.valid){
continue;
}
j16array[0]=x1579.value;
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[2];
IkReal x1580=IKcos(j16);
IkReal x1581=IKsin(j16);
IkReal x1582=((1.0)*py);
IkReal x1583=(cj15*px);
IkReal x1584=(py*sj15);
IkReal x1585=(sj17*x1581);
IkReal x1586=((0.8)*x1580);
evalcond[0]=((-0.066959)+(((-0.8)*pz*x1581))+((x1584*x1586))+(((-0.08)*x1580))+(((-1.0)*pp))+((x1583*x1586))+(((0.2)*x1583))+(((0.2)*x1584)));
evalcond[1]=((((-1.0)*pz*sj17*x1580))+(((-1.0)*x1583*x1585))+(((-1.0)*sj15*x1582*x1585))+((cj17*px*sj15))+(((-1.0)*cj15*cj17*x1582))+(((0.1)*x1585)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=cj16;
dummyeval[1]=cj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1587=((1.0)*py);
IkReal x1588=(cj15*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2)*x1588)));
evalcond[2]=(((cj17*px*sj15))+(((0.1)*sj17))+(((-1.0)*sj15*sj17*x1587))+(((-1.0)*cj15*cj17*x1587))+(((-1.0)*sj17*x1588)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1589=((3.11526479750779)*cj15);
IkReal x1590=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*cj17*px*x1589))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1590))+(((-1.0)*cj17*py*x1590))+((py*sj17*x1589)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj17*px*x1589))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1590))+(((-1.0)*cj17*py*x1590))+((py*sj17*x1589))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*cj17*px*x1589))+(((0.311526479750779)*cj17))+(((-1.0)*px*sj17*x1590))+(((-1.0)*cj17*py*x1590))+((py*sj17*x1589))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1591=IKsin(j18);
IkReal x1592=IKcos(j18);
IkReal x1593=(py*sj15);
IkReal x1594=(px*sj15);
IkReal x1595=(cj15*px);
IkReal x1596=((0.321)*x1591);
IkReal x1597=((1.0)*cj15*py);
evalcond[0]=((0.4)+pz+(((0.321)*x1592)));
evalcond[1]=(((sj17*x1596))+(((-1.0)*x1597))+x1594);
evalcond[2]=((0.1)+(((-1.0)*cj17*x1596))+(((-1.0)*x1593))+(((-1.0)*x1595)));
evalcond[3]=((0.253041)+(((0.2568)*x1592))+(((-1.0)*pp))+(((0.2)*x1595))+(((0.2)*x1593)));
evalcond[4]=(((sj17*x1594))+((cj17*x1593))+((cj17*x1595))+(((-0.1)*cj17))+x1596+(((-1.0)*sj17*x1597)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1598=(cj15*px);
IkReal x1599=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1599))+(((0.2)*x1598)));
evalcond[2]=(((sj17*x1598))+((sj17*x1599))+(((-1.0)*cj15*cj17*py))+(((-0.1)*sj17))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=sj17;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1600=IKcos(j18);
IkReal x1601=(cj15*px);
IkReal x1602=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1600))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1602))+(((-1.0)*x1601))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1600))+(((-1.0)*pp))+(((0.2)*x1601))+(((0.2)*x1602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1603=IKcos(j18);
IkReal x1604=(cj15*px);
IkReal x1605=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1603))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1605))+(((-1.0)*x1604))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1603))+(((-1.0)*pp))+(((0.2)*x1604))+(((0.2)*x1605)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1606=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1606))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x1606))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1607=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1607))+pz);
evalcond[1]=((0.273041)+(((0.2568)*x1607))+(((-1.0)*pp)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1608=IKPowWithIntegerCheck(sj17,-1);
if(!x1608.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1608.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1608.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1608.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1609=IKsin(j18);
IkReal x1610=IKcos(j18);
IkReal x1611=(py*sj15);
IkReal x1612=((1.0)*cj15);
IkReal x1613=(px*sj15);
IkReal x1614=((0.321)*x1609);
evalcond[0]=((-0.4)+(((-0.321)*x1610))+pz);
evalcond[1]=(((sj17*x1614))+x1613+(((-1.0)*py*x1612)));
evalcond[2]=((0.1)+(((-1.0)*x1611))+(((-1.0)*px*x1612))+((cj17*x1614)));
evalcond[3]=((0.253041)+(((0.2568)*x1610))+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1611)));
evalcond[4]=(((sj17*x1613))+x1614+(((-1.0)*cj17*x1611))+(((-1.0)*cj17*px*x1612))+(((-1.0)*py*sj17*x1612))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1615=IKPowWithIntegerCheck(cj17,-1);
if(!x1615.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1615.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1615.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1615.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1616=IKsin(j18);
IkReal x1617=IKcos(j18);
IkReal x1618=(py*sj15);
IkReal x1619=((1.0)*cj15);
IkReal x1620=(px*sj15);
IkReal x1621=((0.321)*x1616);
evalcond[0]=((-0.4)+(((-0.321)*x1617))+pz);
evalcond[1]=(x1620+((sj17*x1621))+(((-1.0)*py*x1619)));
evalcond[2]=((0.1)+(((-1.0)*x1618))+(((-1.0)*px*x1619))+((cj17*x1621)));
evalcond[3]=((0.253041)+(((0.2568)*x1617))+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1618)));
evalcond[4]=(x1621+((sj17*x1620))+(((-1.0)*cj17*x1618))+(((-1.0)*cj17*px*x1619))+(((-1.0)*py*sj17*x1619))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1622=IKPowWithIntegerCheck(sj17,-1);
if(!x1622.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1622.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1622.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1622.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1623=IKsin(j18);
IkReal x1624=IKcos(j18);
IkReal x1625=(py*sj15);
IkReal x1626=((1.0)*cj15);
IkReal x1627=(px*sj15);
IkReal x1628=((0.321)*x1623);
evalcond[0]=((-0.4)+(((-0.321)*x1624))+pz);
evalcond[1]=(x1627+((sj17*x1628))+(((-1.0)*py*x1626)));
evalcond[2]=((0.1)+(((-1.0)*x1625))+(((-1.0)*px*x1626))+((cj17*x1628)));
evalcond[3]=((0.253041)+(((0.2568)*x1624))+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1625)));
evalcond[4]=(x1628+((sj17*x1627))+(((-1.0)*cj17*x1625))+(((-1.0)*cj17*px*x1626))+(((-1.0)*py*sj17*x1626))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1629=((1.0)*sj16);
IkReal x1630=(cj15*px);
IkReal x1631=(py*sj15);
IkReal x1632=((0.8)*cj16);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.2)*x1630))+(((0.2)*x1631))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1631*x1632))+((x1630*x1632)));
evalcond[2]=((((-1.0)*cj16*pz))+(((-1.0)*x1629*x1630))+(((-1.0)*x1629*x1631))+(((0.1)*sj16)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1633=IKcos(j18);
IkReal x1634=(py*sj15);
IkReal x1635=((1.0)*cj16);
IkReal x1636=((1.0)*cj15);
IkReal x1637=(cj15*px);
IkReal x1638=((0.321)*x1633);
evalcond[0]=(((sj16*x1638))+(((0.4)*sj16))+pz);
evalcond[1]=(((px*sj15))+(((-1.0)*py*x1636))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x1637))+(((0.2)*x1634))+(((-1.0)*pp))+(((0.2568)*x1633)));
evalcond[3]=((0.1)+(((-1.0)*px*x1636))+(((-1.0)*x1634))+(((0.4)*cj16))+((cj16*x1638)));
evalcond[4]=((0.4)+(((-1.0)*x1635*x1637))+(((-1.0)*x1634*x1635))+x1638+((pz*sj16))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1639=(cj15*px);
IkReal x1640=((0.8)*cj16);
IkReal x1641=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1640*x1641))+(((0.2)*x1639))+(((0.2)*x1641))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1639*x1640)));
evalcond[2]=(((sj16*x1639))+(((-0.1)*sj16))+((cj16*pz))+((sj16*x1641)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1642=IKcos(j18);
IkReal x1643=(py*sj15);
IkReal x1644=((1.0)*cj16);
IkReal x1645=((1.0)*cj15);
IkReal x1646=(cj15*px);
IkReal x1647=((0.321)*x1642);
evalcond[0]=((((0.4)*sj16))+pz+((sj16*x1647)));
evalcond[1]=((((-1.0)*py*x1645))+((px*sj15))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1642))+(((0.2)*x1643))+(((0.2)*x1646))+(((-1.0)*pp)));
evalcond[3]=((0.1)+(((-1.0)*px*x1645))+(((-1.0)*x1643))+(((0.4)*cj16))+((cj16*x1647)));
evalcond[4]=((0.4)+(((-1.0)*x1644*x1646))+x1647+((pz*sj16))+(((-1.0)*x1643*x1644))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1648=(py*sj15);
IkReal x1649=((0.8)*cj16);
IkReal x1650=(cj15*px);
IkReal x1651=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x1651;
evalcond[2]=((-0.066959)+((x1648*x1649))+(((0.2)*x1650))+(((0.2)*x1648))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+((x1649*x1650))+(((-0.08)*cj16)));
evalcond[3]=x1651;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst47;
gconst47=IKsign(((((321.0)*(cj16*cj16)))+(((321.0)*(sj16*sj16)))));
dummyeval[0]=((sj16*sj16)+(cj16*cj16));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1652=IKcos(j18);
IkReal x1653=(cj15*px);
IkReal x1654=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x1652))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1653))+(((-1.0)*x1654))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x1654))+(((0.2)*x1653))+(((-1.0)*pp))+(((0.2568)*x1652)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1655=(cj16*sj16);
IkReal x1656=(py*sj15);
IkReal x1657=((3.11526479750779)*cj16);
IkReal x1658=((1000.0)*pz);
IkReal x1659=(cj15*px);
CheckValue<IkReal> x1660=IKPowWithIntegerCheck(cj16,-1);
if(!x1660.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1660.value)*(((((100.0)*x1655))+((x1658*(sj16*sj16)))+(((-1.0)*x1658))+(((-1000.0)*x1655*x1659))+(((-1000.0)*x1655*x1656)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x1656*x1657))+(((-3.11526479750779)*pz*sj16))+((x1657*x1659))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1660.value)*(((((100.0)*x1655))+((x1658*(sj16*sj16)))+(((-1.0)*x1658))+(((-1000.0)*x1655*x1659))+(((-1000.0)*x1655*x1656))))))+IKsqr(((-1.24610591900312)+((x1656*x1657))+(((-3.11526479750779)*pz*sj16))+((x1657*x1659))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1660.value)*(((((100.0)*x1655))+((x1658*(sj16*sj16)))+(((-1.0)*x1658))+(((-1000.0)*x1655*x1659))+(((-1000.0)*x1655*x1656))))), ((-1.24610591900312)+((x1656*x1657))+(((-3.11526479750779)*pz*sj16))+((x1657*x1659))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1661=IKcos(j18);
IkReal x1662=IKsin(j18);
IkReal x1663=(py*sj15);
IkReal x1664=(cj15*px);
IkReal x1665=((1.0)*cj16);
IkReal x1666=((0.321)*x1661);
IkReal x1667=((0.321)*x1662);
evalcond[0]=(((sj16*x1666))+(((0.4)*sj16))+pz+((cj16*x1667)));
evalcond[1]=((0.253041)+(((0.2)*x1663))+(((0.2)*x1664))+(((-1.0)*pp))+(((0.2568)*x1661)));
evalcond[2]=(((sj16*x1663))+((sj16*x1664))+(((-0.1)*sj16))+x1667+((cj16*pz)));
evalcond[3]=((0.4)+x1666+((pz*sj16))+(((-1.0)*x1663*x1665))+(((-1.0)*x1664*x1665))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1664))+(((-1.0)*x1663))+(((0.4)*cj16))+((cj16*x1666))+(((-1.0)*sj16*x1667)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1668=((250.0)*sj16);
IkReal x1669=(py*sj15);
IkReal x1670=(cj15*px);
CheckValue<IkReal> x1671=IKPowWithIntegerCheck(cj16,-1);
if(!x1671.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1671.value)*(((((-1000.0)*pz))+((x1668*x1670))+((x1668*x1669))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1670))+(((-0.778816199376947)*x1669)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1671.value)*(((((-1000.0)*pz))+((x1668*x1670))+((x1668*x1669))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1670))+(((-0.778816199376947)*x1669))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1671.value)*(((((-1000.0)*pz))+((x1668*x1670))+((x1668*x1669))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1670))+(((-0.778816199376947)*x1669))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1672=IKcos(j18);
IkReal x1673=IKsin(j18);
IkReal x1674=(py*sj15);
IkReal x1675=(cj15*px);
IkReal x1676=((1.0)*cj16);
IkReal x1677=((0.321)*x1672);
IkReal x1678=((0.321)*x1673);
evalcond[0]=(((cj16*x1678))+(((0.4)*sj16))+pz+((sj16*x1677)));
evalcond[1]=((0.253041)+(((0.2)*x1674))+(((0.2)*x1675))+(((-1.0)*pp))+(((0.2568)*x1672)));
evalcond[2]=((((-0.1)*sj16))+x1678+((sj16*x1674))+((sj16*x1675))+((cj16*pz)));
evalcond[3]=((0.4)+x1677+((pz*sj16))+(((-1.0)*x1674*x1676))+(((0.1)*cj16))+(((-1.0)*x1675*x1676)));
evalcond[4]=((0.1)+((cj16*x1677))+(((-1.0)*sj16*x1678))+(((0.4)*cj16))+(((-1.0)*x1674))+(((-1.0)*x1675)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1679=((1000.0)*cj16);
IkReal x1680=((1000.0)*sj16);
IkReal x1681=(py*sj15);
IkReal x1682=(cj15*px);
CheckValue<IkReal> x1683 = IKatan2WithCheck((gconst47*(((((100.0)*sj16))+(((-1.0)*x1680*x1682))+(((-1.0)*x1680*x1681))+(((-1.0)*pz*x1679))))),(gconst47*(((((-100.0)*cj16))+(((-400.0)*(sj16*sj16)))+(((-400.0)*(cj16*cj16)))+((x1679*x1681))+((x1679*x1682))+(((-1.0)*pz*x1680))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1683.valid){
continue;
}
j18array[0]=x1683.value;
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1684=IKcos(j18);
IkReal x1685=IKsin(j18);
IkReal x1686=(py*sj15);
IkReal x1687=(cj15*px);
IkReal x1688=((1.0)*cj16);
IkReal x1689=((0.321)*x1684);
IkReal x1690=((0.321)*x1685);
evalcond[0]=(((cj16*x1690))+(((0.4)*sj16))+pz+((sj16*x1689)));
evalcond[1]=((0.253041)+(((0.2568)*x1684))+(((-1.0)*pp))+(((0.2)*x1687))+(((0.2)*x1686)));
evalcond[2]=((((-0.1)*sj16))+x1690+((cj16*pz))+((sj16*x1686))+((sj16*x1687)));
evalcond[3]=((0.4)+(((-1.0)*x1686*x1688))+(((-1.0)*x1687*x1688))+x1689+((pz*sj16))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1686))+(((-1.0)*x1687))+((cj16*x1689))+(((-1.0)*sj16*x1690))+(((0.4)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1691=(py*sj15);
IkReal x1692=(cj15*py);
IkReal x1693=((0.8)*cj16);
IkReal x1694=(cj15*px);
IkReal x1695=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(x1695+(((-1.0)*x1692)));
evalcond[2]=((-0.066959)+((x1691*x1693))+(((0.2)*x1694))+(((0.2)*x1691))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1693*x1694)));
evalcond[3]=(x1692+(((-1.0)*x1695)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst48;
gconst48=IKsign(((((321.0)*(cj16*cj16)))+(((321.0)*(sj16*sj16)))));
dummyeval[0]=((sj16*sj16)+(cj16*cj16));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=cj16;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1696=IKcos(j18);
IkReal x1697=(cj15*px);
IkReal x1698=(py*sj15);
evalcond[0]=((0.4)+(((0.321)*x1696))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1698))+(((-1.0)*x1697))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2)*x1697))+(((0.2)*x1698))+(((-1.0)*pp))+(((0.2568)*x1696)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1699=(cj16*sj16);
IkReal x1700=(py*sj15);
IkReal x1701=((3.11526479750779)*cj16);
IkReal x1702=((1000.0)*pz);
IkReal x1703=(cj15*px);
CheckValue<IkReal> x1704=IKPowWithIntegerCheck(cj16,-1);
if(!x1704.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1704.value)*(((((-1.0)*x1702*(sj16*sj16)))+(((1000.0)*x1699*x1700))+(((1000.0)*x1699*x1703))+x1702+(((-100.0)*x1699)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1700*x1701))+((x1701*x1703))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1704.value)*(((((-1.0)*x1702*(sj16*sj16)))+(((1000.0)*x1699*x1700))+(((1000.0)*x1699*x1703))+x1702+(((-100.0)*x1699))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1700*x1701))+((x1701*x1703))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1704.value)*(((((-1.0)*x1702*(sj16*sj16)))+(((1000.0)*x1699*x1700))+(((1000.0)*x1699*x1703))+x1702+(((-100.0)*x1699))))), ((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((x1700*x1701))+((x1701*x1703))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1705=IKcos(j18);
IkReal x1706=IKsin(j18);
IkReal x1707=((1.0)*cj16);
IkReal x1708=(py*sj15);
IkReal x1709=(cj15*px);
IkReal x1710=((0.321)*x1705);
IkReal x1711=((1.0)*x1709);
IkReal x1712=((0.321)*x1706);
evalcond[0]=((((-1.0)*cj16*x1712))+(((0.4)*sj16))+((sj16*x1710))+pz);
evalcond[1]=((0.253041)+(((0.2)*x1708))+(((0.2)*x1709))+(((0.2568)*x1705))+(((-1.0)*pp)));
evalcond[2]=((0.4)+x1710+(((-1.0)*x1707*x1709))+(((-1.0)*x1707*x1708))+((pz*sj16))+(((0.1)*cj16)));
evalcond[3]=((((-1.0)*pz*x1707))+x1712+(((-1.0)*sj16*x1708))+(((-1.0)*sj16*x1711))+(((0.1)*sj16)));
evalcond[4]=((0.1)+(((-1.0)*x1708))+(((-1.0)*x1711))+((cj16*x1710))+((sj16*x1712))+(((0.4)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1713=((250.0)*sj16);
IkReal x1714=(py*sj15);
IkReal x1715=(cj15*px);
CheckValue<IkReal> x1716=IKPowWithIntegerCheck(cj16,-1);
if(!x1716.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1716.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((-1.0)*x1713*x1715))+(((-1.0)*x1713*x1714))+(((1000.0)*pz)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1715))+(((-0.778816199376947)*x1714)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1716.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((-1.0)*x1713*x1715))+(((-1.0)*x1713*x1714))+(((1000.0)*pz))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1715))+(((-0.778816199376947)*x1714))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1716.value)*(((((83.69875)*sj16))+(((1250.0)*pp*sj16))+(((-1.0)*x1713*x1715))+(((-1.0)*x1713*x1714))+(((1000.0)*pz))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1715))+(((-0.778816199376947)*x1714))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1717=IKcos(j18);
IkReal x1718=IKsin(j18);
IkReal x1719=((1.0)*cj16);
IkReal x1720=(py*sj15);
IkReal x1721=(cj15*px);
IkReal x1722=((0.321)*x1717);
IkReal x1723=((1.0)*x1721);
IkReal x1724=((0.321)*x1718);
evalcond[0]=(((sj16*x1722))+(((0.4)*sj16))+pz+(((-1.0)*cj16*x1724)));
evalcond[1]=((0.253041)+(((0.2568)*x1717))+(((-1.0)*pp))+(((0.2)*x1720))+(((0.2)*x1721)));
evalcond[2]=((0.4)+x1722+((pz*sj16))+(((-1.0)*x1719*x1721))+(((-1.0)*x1719*x1720))+(((0.1)*cj16)));
evalcond[3]=(x1724+(((0.1)*sj16))+(((-1.0)*pz*x1719))+(((-1.0)*sj16*x1723))+(((-1.0)*sj16*x1720)));
evalcond[4]=((0.1)+((sj16*x1724))+(((0.4)*cj16))+((cj16*x1722))+(((-1.0)*x1720))+(((-1.0)*x1723)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1725=((1000.0)*cj16);
IkReal x1726=((1000.0)*sj16);
IkReal x1727=(py*sj15);
IkReal x1728=(cj15*px);
CheckValue<IkReal> x1729 = IKatan2WithCheck((gconst48*((((pz*x1725))+((x1726*x1728))+((x1726*x1727))+(((-100.0)*sj16))))),(gconst48*((((x1725*x1727))+((x1725*x1728))+(((-100.0)*cj16))+(((-1.0)*pz*x1726))+(((-400.0)*(sj16*sj16)))+(((-400.0)*(cj16*cj16)))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1729.valid){
continue;
}
j18array[0]=x1729.value;
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1730=IKcos(j18);
IkReal x1731=IKsin(j18);
IkReal x1732=((1.0)*cj16);
IkReal x1733=(py*sj15);
IkReal x1734=(cj15*px);
IkReal x1735=((0.321)*x1730);
IkReal x1736=((1.0)*x1734);
IkReal x1737=((0.321)*x1731);
evalcond[0]=(((sj16*x1735))+(((0.4)*sj16))+pz+(((-1.0)*cj16*x1737)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1734))+(((0.2)*x1733))+(((0.2568)*x1730)));
evalcond[2]=((0.4)+x1735+((pz*sj16))+(((-1.0)*x1732*x1733))+(((-1.0)*x1732*x1734))+(((0.1)*cj16)));
evalcond[3]=((((-1.0)*sj16*x1733))+x1737+(((-1.0)*pz*x1732))+(((0.1)*sj16))+(((-1.0)*sj16*x1736)));
evalcond[4]=((0.1)+((sj16*x1737))+(((0.4)*cj16))+((cj16*x1735))+(((-1.0)*x1733))+(((-1.0)*x1736)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1738=((250.0)*sj16);
IkReal x1739=(py*sj15);
IkReal x1740=(cj15*px);
CheckValue<IkReal> x1741=IKPowWithIntegerCheck(cj16,-1);
if(!x1741.valid){
continue;
}
CheckValue<IkReal> x1742=IKPowWithIntegerCheck(cj17,-1);
if(!x1742.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1741.value)*(x1742.value)*(((((-1000.0)*pz))+((x1738*x1739))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))+((x1738*x1740)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x1740))+(((-0.778816199376947)*x1739))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1741.value)*(x1742.value)*(((((-1000.0)*pz))+((x1738*x1739))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))+((x1738*x1740))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x1740))+(((-0.778816199376947)*x1739))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1741.value)*(x1742.value)*(((((-1000.0)*pz))+((x1738*x1739))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))+((x1738*x1740))))), ((-0.98536214953271)+(((-0.778816199376947)*x1740))+(((-0.778816199376947)*x1739))+(((3.89408099688474)*pp))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1743=IKcos(j18);
IkReal x1744=IKsin(j18);
IkReal x1745=(cj17*sj16);
IkReal x1746=(cj16*cj17);
IkReal x1747=(cj15*px);
IkReal x1748=((1.0)*cj16);
IkReal x1749=(py*sj15);
IkReal x1750=(px*sj15);
IkReal x1751=((0.321)*x1744);
IkReal x1752=((0.321)*x1743);
IkReal x1753=((1.0)*cj15*py);
evalcond[0]=(x1750+((sj17*x1751))+(((-1.0)*x1753)));
evalcond[1]=((0.253041)+(((0.2)*x1747))+(((0.2)*x1749))+(((0.2568)*x1743))+(((-1.0)*pp)));
evalcond[2]=(((x1746*x1751))+((sj16*x1752))+(((0.4)*sj16))+pz);
evalcond[3]=((0.4)+(((-1.0)*x1748*x1749))+x1752+((pz*sj16))+(((-1.0)*x1747*x1748))+(((0.1)*cj16)));
evalcond[4]=((0.1)+((cj16*x1752))+(((-1.0)*x1747))+(((-1.0)*x1749))+(((-1.0)*x1745*x1751))+(((0.4)*cj16)));
evalcond[5]=(((pz*x1746))+x1751+((x1745*x1749))+((x1745*x1747))+((sj17*x1750))+(((-1.0)*sj17*x1753))+(((-0.1)*x1745)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1754=((3.11526479750779)*cj16);
CheckValue<IkReal> x1755=IKPowWithIntegerCheck(sj17,-1);
if(!x1755.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1755.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((cj15*px*x1754))+((py*sj15*x1754))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1755.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((cj15*px*x1754))+((py*sj15*x1754))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1755.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((-3.11526479750779)*pz*sj16))+((cj15*px*x1754))+((py*sj15*x1754))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1756=IKcos(j18);
IkReal x1757=IKsin(j18);
IkReal x1758=(cj17*sj16);
IkReal x1759=(cj16*cj17);
IkReal x1760=(cj15*px);
IkReal x1761=((1.0)*cj16);
IkReal x1762=(py*sj15);
IkReal x1763=(px*sj15);
IkReal x1764=((0.321)*x1757);
IkReal x1765=((0.321)*x1756);
IkReal x1766=((1.0)*cj15*py);
evalcond[0]=((((-1.0)*x1766))+x1763+((sj17*x1764)));
evalcond[1]=((0.253041)+(((0.2568)*x1756))+(((0.2)*x1760))+(((0.2)*x1762))+(((-1.0)*pp)));
evalcond[2]=(((x1759*x1764))+(((0.4)*sj16))+pz+((sj16*x1765)));
evalcond[3]=((0.4)+x1765+((pz*sj16))+(((-1.0)*x1761*x1762))+(((-1.0)*x1760*x1761))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1760))+(((-1.0)*x1762))+((cj16*x1765))+(((0.4)*cj16))+(((-1.0)*x1758*x1764)));
evalcond[5]=(((pz*x1759))+x1764+(((-1.0)*sj17*x1766))+((x1758*x1760))+((x1758*x1762))+(((-0.1)*x1758))+((sj17*x1763)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1767=IKPowWithIntegerCheck(sj17,-1);
if(!x1767.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1767.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1767.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1767.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1768=IKcos(j18);
IkReal x1769=IKsin(j18);
IkReal x1770=(cj17*sj16);
IkReal x1771=(cj16*cj17);
IkReal x1772=(cj15*px);
IkReal x1773=((1.0)*cj16);
IkReal x1774=(py*sj15);
IkReal x1775=(px*sj15);
IkReal x1776=((0.321)*x1769);
IkReal x1777=((0.321)*x1768);
IkReal x1778=((1.0)*cj15*py);
evalcond[0]=(x1775+(((-1.0)*x1778))+((sj17*x1776)));
evalcond[1]=((0.253041)+(((0.2)*x1772))+(((0.2)*x1774))+(((-1.0)*pp))+(((0.2568)*x1768)));
evalcond[2]=(((x1771*x1776))+(((0.4)*sj16))+pz+((sj16*x1777)));
evalcond[3]=((0.4)+(((-1.0)*x1772*x1773))+x1777+((pz*sj16))+(((-1.0)*x1773*x1774))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1774))+(((-1.0)*x1772))+((cj16*x1777))+(((0.4)*cj16))+(((-1.0)*x1770*x1776)));
evalcond[5]=((((-1.0)*sj17*x1778))+x1776+((x1770*x1772))+((x1770*x1774))+((sj17*x1775))+((pz*x1771))+(((-0.1)*x1770)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x145=((1.0)*cj17);
IkReal x146=(cj18*sj16);
IkReal x147=(cj16*sj17);
IkReal x148=(sj16*sj18);
IkReal x149=(sj16*sj17);
IkReal x150=(cj16*cj18);
IkReal x151=(sj17*sj18);
IkReal x152=(cj16*sj18);
IkReal x153=(cj18*sj15*sj17);
IkReal x154=(x148+(((-1.0)*x145*x150)));
IkReal x155=(((sj15*x149))+((cj15*cj17)));
IkReal x156=((((-1.0)*sj15*x145))+((cj15*x149)));
IkReal x157=(x150+(((-1.0)*x145*x148)));
IkReal x158=(cj15*x157);
IkReal x159=((((-1.0)*x152))+(((-1.0)*x145*x146)));
IkReal x160=((((-1.0)*x146))+(((-1.0)*x145*x152)));
IkReal x161=(cj15*x159);
IkReal x162=(((sj15*x157))+((cj15*x151)));
IkReal x163=(x158+(((-1.0)*sj15*x151)));
IkReal x164=(((cj15*cj18*sj17))+((sj15*x159)));
IkReal x165=(x161+(((-1.0)*x153)));
new_r00=(((r00*x165))+((r20*x154))+((r10*x164)));
new_r01=(((r01*x165))+((r21*x154))+((r11*x164)));
new_r02=(((r02*((x161+(((-1.0)*x153))))))+((r12*x164))+((r22*x154)));
new_r10=(((r20*x147))+((r00*x156))+((r10*x155)));
new_r11=(((r01*x156))+((r21*x147))+((r11*x155)));
new_r12=(((r02*x156))+((r22*x147))+((r12*x155)));
new_r20=(((r20*x160))+((r10*x162))+((r00*((x158+(((-1.0)*sj15*x151)))))));
new_r21=(((r01*x163))+((r21*x160))+((r11*x162)));
new_r22=(((r22*x160))+((r12*x162))+((r02*x163)));
{
IkReal j20array[2], cj20array[2], sj20array[2];
bool j20valid[2]={false};
_nj20 = 2;
cj20array[0]=new_r22;
if( cj20array[0] >= -1-IKFAST_SINCOS_THRESH && cj20array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j20valid[0] = j20valid[1] = true;
    j20array[0] = IKacos(cj20array[0]);
    sj20array[0] = IKsin(j20array[0]);
    cj20array[1] = cj20array[0];
    j20array[1] = -j20array[0];
    sj20array[1] = -sj20array[0];
}
else if( isnan(cj20array[0]) )
{
    // probably any value will work
    j20valid[0] = true;
    cj20array[0] = 1; sj20array[0] = 0; j20array[0] = 0;
}
for(int ij20 = 0; ij20 < 2; ++ij20)
{
if( !j20valid[ij20] )
{
    continue;
}
_ij20[0] = ij20; _ij20[1] = -1;
for(int iij20 = ij20+1; iij20 < 2; ++iij20)
{
if( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )
{
    j20valid[iij20]=false; _ij20[1] = iij20; break; 
}
}
j20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];

{
IkReal dummyeval[1];
IkReal gconst105;
gconst105=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst106;
gconst106=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst107;
gconst107=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x166=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x166;
evalcond[2]=x166;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x166;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
IkReal j21mul = 1;
j21=0;
j19mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j19=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].fmul = j19mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].fmul = j21mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x167=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x167;
evalcond[2]=x167;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
CheckValue<IkReal> x169 = IKatan2WithCheck(new_r02,new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x169.valid){
continue;
}
IkReal x168=x169.value;
j19array[0]=((-1.0)*x168);
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
j19array[1]=((3.14159265358979)+(((-1.0)*x168)));
sj19array[1]=IKsin(j19array[1]);
cj19array[1]=IKcos(j19array[1]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
if( j19array[1] > IKPI )
{
    j19array[1]-=IK2PI;
}
else if( j19array[1] < -IKPI )
{    j19array[1]+=IK2PI;
}
j19valid[1] = true;
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst141;
gconst141=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst142;
gconst142=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x170=((1.0)*sj19);
CheckValue<IkReal> x171 = IKatan2WithCheck((gconst142*((((cj19*new_r10))+(((-1.0)*new_r00*x170))))),(gconst142*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x170))))),IKFAST_ATAN2_MAGTHRESH);
if(!x171.valid){
continue;
}
j21array[0]=x171.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x172=IKsin(j21);
IkReal x173=IKcos(j21);
IkReal x174=((1.0)*cj19);
IkReal x175=((1.0)*sj19);
IkReal x176=((1.0)*x172);
IkReal x177=(sj19*x173);
IkReal x178=(sj19*x172);
IkReal x179=(x172*x174);
evalcond[0]=(x173+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x176))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x173))+x178+new_r00);
evalcond[3]=((((-1.0)*x176))+((cj19*new_r10))+(((-1.0)*new_r00*x175)));
evalcond[4]=((((-1.0)*x173))+((cj19*new_r11))+(((-1.0)*new_r01*x175)));
evalcond[5]=((((-1.0)*x179))+x177+new_r01);
evalcond[6]=((((-1.0)*x179))+x177+new_r10);
evalcond[7]=(new_r11+(((-1.0)*x172*x175))+(((-1.0)*x173*x174)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x180=((1.0)*sj19);
CheckValue<IkReal> x181 = IKatan2WithCheck((gconst141*(((((-1.0)*new_r00*x180))+((cj19*new_r01))))),(gconst141*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x180))))),IKFAST_ATAN2_MAGTHRESH);
if(!x181.valid){
continue;
}
j21array[0]=x181.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x182=IKsin(j21);
IkReal x183=IKcos(j21);
IkReal x184=((1.0)*cj19);
IkReal x185=((1.0)*sj19);
IkReal x186=((1.0)*x182);
IkReal x187=(sj19*x183);
IkReal x188=(sj19*x182);
IkReal x189=(x182*x184);
evalcond[0]=(x183+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x186))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x183))+x188+new_r00);
evalcond[3]=((((-1.0)*x186))+((cj19*new_r10))+(((-1.0)*new_r00*x185)));
evalcond[4]=((((-1.0)*x183))+(((-1.0)*new_r01*x185))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x189))+x187+new_r01);
evalcond[6]=((((-1.0)*x189))+x187+new_r10);
evalcond[7]=(new_r11+(((-1.0)*x183*x184))+(((-1.0)*x182*x185)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x190 = IKatan2WithCheck((gconst107*new_r21),((-1.0)*gconst107*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x190.valid){
continue;
}
j21array[0]=x190.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[2];
evalcond[0]=(((sj20*(IKcos(j21))))+new_r20);
evalcond[1]=((((-1.0)*sj20*(IKsin(j21))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst108;
gconst108=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst109;
gconst109=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x191=((-1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x191;
evalcond[2]=x191;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r20;
evalcond[10]=new_r21;
evalcond[11]=x191;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst110;
gconst110=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst111;
gconst111=IKsign(((((-1.0)*cj21*new_r02))+((new_r12*sj21))));
dummyeval[0]=((((-1.0)*cj21*new_r02))+((new_r12*sj21)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst112;
CheckValue<IkReal> x192 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x192.valid){
continue;
}
gconst112=((-1.0)*(x192.value));
IkReal gconst113;
gconst113=IKsin(gconst112);
IkReal gconst114;
gconst114=IKcos(gconst112);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst112)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst118;
gconst118=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst119;
gconst119=IKsign((((gconst113*new_r12))+(((-1.0)*gconst114*new_r02))));
dummyeval[0]=(((gconst113*new_r12))+(((-1.0)*gconst114*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x193=(gconst119*new_r01);
CheckValue<IkReal> x194 = IKatan2WithCheck((new_r02*x193),((-1.0)*new_r12*x193),IKFAST_ATAN2_MAGTHRESH);
if(!x194.valid){
continue;
}
j19array[0]=x194.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x195=IKcos(j19);
IkReal x196=IKsin(j19);
IkReal x197=((1.0)*gconst114);
IkReal x198=(gconst113*x196);
IkReal x199=(gconst114*x196);
IkReal x200=(gconst113*x195);
IkReal x201=((1.0)*x196);
IkReal x202=(x195*x197);
evalcond[0]=(((new_r02*x195))+((new_r12*x196)));
evalcond[1]=((((-1.0)*new_r02*x201))+((new_r12*x195)));
evalcond[2]=(((new_r11*x196))+((new_r01*x195))+gconst113);
evalcond[3]=(x199+x200+new_r01);
evalcond[4]=(x198+(((-1.0)*x202))+new_r00);
evalcond[5]=(x198+(((-1.0)*x202))+new_r11);
evalcond[6]=(((new_r10*x196))+((new_r00*x195))+(((-1.0)*x197)));
evalcond[7]=((((-1.0)*x196*x197))+new_r10+(((-1.0)*x200)));
evalcond[8]=((((-1.0)*new_r00*x201))+((new_r10*x195))+(((-1.0)*gconst113)));
evalcond[9]=(((new_r11*x195))+(((-1.0)*x197))+(((-1.0)*new_r01*x201)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x203=(gconst113*gconst118);
CheckValue<IkReal> x204 = IKatan2WithCheck((new_r02*x203),((-1.0)*new_r12*x203),IKFAST_ATAN2_MAGTHRESH);
if(!x204.valid){
continue;
}
j19array[0]=x204.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x205=IKcos(j19);
IkReal x206=IKsin(j19);
IkReal x207=((1.0)*gconst114);
IkReal x208=(gconst113*x206);
IkReal x209=(gconst114*x206);
IkReal x210=(gconst113*x205);
IkReal x211=((1.0)*x206);
IkReal x212=(x205*x207);
evalcond[0]=(((new_r02*x205))+((new_r12*x206)));
evalcond[1]=((((-1.0)*new_r02*x211))+((new_r12*x205)));
evalcond[2]=(((new_r11*x206))+((new_r01*x205))+gconst113);
evalcond[3]=(x210+x209+new_r01);
evalcond[4]=(x208+new_r00+(((-1.0)*x212)));
evalcond[5]=(x208+new_r11+(((-1.0)*x212)));
evalcond[6]=(((new_r10*x206))+((new_r00*x205))+(((-1.0)*x207)));
evalcond[7]=((((-1.0)*x206*x207))+(((-1.0)*x210))+new_r10);
evalcond[8]=(((new_r10*x205))+(((-1.0)*new_r00*x211))+(((-1.0)*gconst113)));
evalcond[9]=(((new_r11*x205))+(((-1.0)*x207))+(((-1.0)*new_r01*x211)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst115;
CheckValue<IkReal> x213 = IKatan2WithCheck(((-1.0)*new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x213.valid){
continue;
}
gconst115=((3.14159265358979)+(((-1.0)*(x213.value))));
IkReal gconst116;
gconst116=IKsin(gconst115);
IkReal gconst117;
gconst117=IKcos(gconst115);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst115)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst120;
gconst120=IKsign((((new_r01*new_r12))+(((-1.0)*new_r02*new_r11))));
dummyeval[0]=(((new_r01*new_r12))+(((-1.0)*new_r02*new_r11)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst121;
gconst121=IKsign(((((-1.0)*gconst117*new_r02))+((gconst116*new_r12))));
dummyeval[0]=((((-1.0)*gconst117*new_r02))+((gconst116*new_r12)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x214=(gconst121*new_r01);
CheckValue<IkReal> x215 = IKatan2WithCheck((new_r02*x214),((-1.0)*new_r12*x214),IKFAST_ATAN2_MAGTHRESH);
if(!x215.valid){
continue;
}
j19array[0]=x215.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x216=IKcos(j19);
IkReal x217=IKsin(j19);
IkReal x218=((1.0)*gconst117);
IkReal x219=((1.0)*gconst116);
IkReal x220=(gconst116*x217);
IkReal x221=((1.0)*x217);
IkReal x222=(x216*x218);
evalcond[0]=(((new_r02*x216))+((new_r12*x217)));
evalcond[1]=((((-1.0)*new_r02*x221))+((new_r12*x216)));
evalcond[2]=(((new_r01*x216))+gconst116+((new_r11*x217)));
evalcond[3]=(new_r01+((gconst116*x216))+((gconst117*x217)));
evalcond[4]=(x220+new_r00+(((-1.0)*x222)));
evalcond[5]=(x220+new_r11+(((-1.0)*x222)));
evalcond[6]=(((new_r00*x216))+(((-1.0)*x218))+((new_r10*x217)));
evalcond[7]=((((-1.0)*x217*x218))+new_r10+(((-1.0)*x216*x219)));
evalcond[8]=((((-1.0)*x219))+((new_r10*x216))+(((-1.0)*new_r00*x221)));
evalcond[9]=((((-1.0)*new_r01*x221))+(((-1.0)*x218))+((new_r11*x216)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x223=(gconst116*gconst120);
CheckValue<IkReal> x224 = IKatan2WithCheck((new_r02*x223),((-1.0)*new_r12*x223),IKFAST_ATAN2_MAGTHRESH);
if(!x224.valid){
continue;
}
j19array[0]=x224.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x225=IKcos(j19);
IkReal x226=IKsin(j19);
IkReal x227=((1.0)*gconst117);
IkReal x228=((1.0)*gconst116);
IkReal x229=(gconst116*x226);
IkReal x230=((1.0)*x226);
IkReal x231=(x225*x227);
evalcond[0]=(((new_r02*x225))+((new_r12*x226)));
evalcond[1]=((((-1.0)*new_r02*x230))+((new_r12*x225)));
evalcond[2]=(((new_r01*x225))+((new_r11*x226))+gconst116);
evalcond[3]=(new_r01+((gconst117*x226))+((gconst116*x225)));
evalcond[4]=((((-1.0)*x231))+x229+new_r00);
evalcond[5]=((((-1.0)*x231))+x229+new_r11);
evalcond[6]=(((new_r00*x225))+((new_r10*x226))+(((-1.0)*x227)));
evalcond[7]=((((-1.0)*x225*x228))+new_r10+(((-1.0)*x226*x227)));
evalcond[8]=(((new_r10*x225))+(((-1.0)*new_r00*x230))+(((-1.0)*x228)));
evalcond[9]=(((new_r11*x225))+(((-1.0)*new_r01*x230))+(((-1.0)*x227)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x232=(gconst111*new_r01);
CheckValue<IkReal> x233 = IKatan2WithCheck((new_r02*x232),((-1.0)*new_r12*x232),IKFAST_ATAN2_MAGTHRESH);
if(!x233.valid){
continue;
}
j19array[0]=x233.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x234=IKcos(j19);
IkReal x235=IKsin(j19);
IkReal x236=((1.0)*cj21);
IkReal x237=(sj21*x235);
IkReal x238=((1.0)*x234);
IkReal x239=((1.0)*x235);
IkReal x240=(x234*x236);
evalcond[0]=(((new_r02*x234))+((new_r12*x235)));
evalcond[1]=((((-1.0)*new_r02*x239))+((new_r12*x234)));
evalcond[2]=(((new_r11*x235))+((new_r01*x234))+sj21);
evalcond[3]=(((sj21*x234))+new_r01+((cj21*x235)));
evalcond[4]=(x237+(((-1.0)*x240))+new_r00);
evalcond[5]=(x237+(((-1.0)*x240))+new_r11);
evalcond[6]=(((new_r10*x235))+((new_r00*x234))+(((-1.0)*x236)));
evalcond[7]=((((-1.0)*sj21*x238))+(((-1.0)*x235*x236))+new_r10);
evalcond[8]=(((new_r10*x234))+(((-1.0)*sj21))+(((-1.0)*new_r00*x239)));
evalcond[9]=(((new_r11*x234))+(((-1.0)*x236))+(((-1.0)*new_r01*x239)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x241=(gconst110*sj21);
CheckValue<IkReal> x242 = IKatan2WithCheck((new_r02*x241),((-1.0)*new_r12*x241),IKFAST_ATAN2_MAGTHRESH);
if(!x242.valid){
continue;
}
j19array[0]=x242.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x243=IKcos(j19);
IkReal x244=IKsin(j19);
IkReal x245=((1.0)*cj21);
IkReal x246=(sj21*x244);
IkReal x247=((1.0)*x243);
IkReal x248=((1.0)*x244);
IkReal x249=(x243*x245);
evalcond[0]=(((new_r12*x244))+((new_r02*x243)));
evalcond[1]=(((new_r12*x243))+(((-1.0)*new_r02*x248)));
evalcond[2]=(sj21+((new_r01*x243))+((new_r11*x244)));
evalcond[3]=(((cj21*x244))+new_r01+((sj21*x243)));
evalcond[4]=(x246+(((-1.0)*x249))+new_r00);
evalcond[5]=(x246+(((-1.0)*x249))+new_r11);
evalcond[6]=(((new_r00*x243))+(((-1.0)*x245))+((new_r10*x244)));
evalcond[7]=(new_r10+(((-1.0)*sj21*x247))+(((-1.0)*x244*x245)));
evalcond[8]=((((-1.0)*new_r00*x248))+(((-1.0)*sj21))+((new_r10*x243)));
evalcond[9]=((((-1.0)*new_r01*x248))+(((-1.0)*x245))+((new_r11*x243)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x250=((1.0)+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x250;
evalcond[2]=x250;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r20);
evalcond[10]=((-1.0)*new_r21);
evalcond[11]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst122;
gconst122=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst123;
gconst123=IKsign((((cj21*new_r12))+(((-1.0)*new_r02*sj21))));
dummyeval[0]=(((cj21*new_r12))+(((-1.0)*new_r02*sj21)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal gconst124;
CheckValue<IkReal> x251 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x251.valid){
continue;
}
gconst124=((-1.0)*(x251.value));
IkReal gconst125;
gconst125=IKsin(gconst124);
IkReal gconst126;
gconst126=IKcos(gconst124);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst124)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst130;
gconst130=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst131;
gconst131=IKsign((((gconst126*new_r12))+(((-1.0)*gconst125*new_r02))));
dummyeval[0]=(((gconst126*new_r12))+(((-1.0)*gconst125*new_r02)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x252=(gconst131*new_r00);
CheckValue<IkReal> x253 = IKatan2WithCheck((new_r02*x252),((-1.0)*new_r12*x252),IKFAST_ATAN2_MAGTHRESH);
if(!x253.valid){
continue;
}
j19array[0]=x253.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x254=IKcos(j19);
IkReal x255=IKsin(j19);
IkReal x256=((1.0)*gconst125);
IkReal x257=(gconst126*x255);
IkReal x258=(gconst126*x254);
IkReal x259=((1.0)*x255);
IkReal x260=(x254*x256);
evalcond[0]=(((new_r02*x254))+((new_r12*x255)));
evalcond[1]=(((new_r12*x254))+(((-1.0)*new_r02*x259)));
evalcond[2]=(((new_r00*x254))+((new_r10*x255))+gconst126);
evalcond[3]=(((gconst125*x255))+x258+new_r00);
evalcond[4]=(x257+new_r01+(((-1.0)*x260)));
evalcond[5]=(x257+new_r10+(((-1.0)*x260)));
evalcond[6]=(((new_r01*x254))+((new_r11*x255))+(((-1.0)*x256)));
evalcond[7]=((((-1.0)*x255*x256))+new_r11+(((-1.0)*x258)));
evalcond[8]=(((new_r10*x254))+(((-1.0)*new_r00*x259))+(((-1.0)*x256)));
evalcond[9]=((((-1.0)*new_r01*x259))+((new_r11*x254))+(((-1.0)*gconst126)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x261=(gconst126*gconst130);
CheckValue<IkReal> x262 = IKatan2WithCheck((new_r02*x261),((-1.0)*new_r12*x261),IKFAST_ATAN2_MAGTHRESH);
if(!x262.valid){
continue;
}
j19array[0]=x262.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x263=IKcos(j19);
IkReal x264=IKsin(j19);
IkReal x265=((1.0)*gconst125);
IkReal x266=(gconst126*x264);
IkReal x267=(gconst126*x263);
IkReal x268=((1.0)*x264);
IkReal x269=(x263*x265);
evalcond[0]=(((new_r12*x264))+((new_r02*x263)));
evalcond[1]=(((new_r12*x263))+(((-1.0)*new_r02*x268)));
evalcond[2]=(((new_r00*x263))+gconst126+((new_r10*x264)));
evalcond[3]=(x267+((gconst125*x264))+new_r00);
evalcond[4]=(x266+new_r01+(((-1.0)*x269)));
evalcond[5]=(x266+new_r10+(((-1.0)*x269)));
evalcond[6]=(((new_r01*x263))+(((-1.0)*x265))+((new_r11*x264)));
evalcond[7]=((((-1.0)*x267))+new_r11+(((-1.0)*x264*x265)));
evalcond[8]=((((-1.0)*new_r00*x268))+(((-1.0)*x265))+((new_r10*x263)));
evalcond[9]=((((-1.0)*new_r01*x268))+(((-1.0)*gconst126))+((new_r11*x263)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal gconst127;
CheckValue<IkReal> x270 = IKatan2WithCheck(new_r12,((-1.0)*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x270.valid){
continue;
}
gconst127=((3.14159265358979)+(((-1.0)*(x270.value))));
IkReal gconst128;
gconst128=IKsin(gconst127);
IkReal gconst129;
gconst129=IKcos(gconst127);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((j21+(((-1.0)*gconst127)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst132;
gconst132=IKsign((((new_r00*new_r12))+(((-1.0)*new_r02*new_r10))));
dummyeval[0]=(((new_r00*new_r12))+(((-1.0)*new_r02*new_r10)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst133;
gconst133=IKsign(((((-1.0)*gconst128*new_r02))+((gconst129*new_r12))));
dummyeval[0]=((((-1.0)*gconst128*new_r02))+((gconst129*new_r12)));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x271=(gconst133*new_r00);
CheckValue<IkReal> x272 = IKatan2WithCheck((new_r02*x271),((-1.0)*new_r12*x271),IKFAST_ATAN2_MAGTHRESH);
if(!x272.valid){
continue;
}
j19array[0]=x272.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x273=IKcos(j19);
IkReal x274=IKsin(j19);
IkReal x275=((1.0)*gconst128);
IkReal x276=((1.0)*gconst129);
IkReal x277=(gconst129*x274);
IkReal x278=(gconst128*x274);
IkReal x279=((1.0)*x274);
IkReal x280=(x273*x275);
evalcond[0]=(((new_r02*x273))+((new_r12*x274)));
evalcond[1]=((((-1.0)*new_r02*x279))+((new_r12*x273)));
evalcond[2]=(((new_r00*x273))+gconst129+((new_r10*x274)));
evalcond[3]=(x278+((gconst129*x273))+new_r00);
evalcond[4]=(x277+(((-1.0)*x280))+new_r01);
evalcond[5]=(x277+(((-1.0)*x280))+new_r10);
evalcond[6]=(((new_r01*x273))+(((-1.0)*x275))+((new_r11*x274)));
evalcond[7]=((((-1.0)*x273*x276))+(((-1.0)*x274*x275))+new_r11);
evalcond[8]=((((-1.0)*new_r00*x279))+(((-1.0)*x275))+((new_r10*x273)));
evalcond[9]=((((-1.0)*new_r01*x279))+(((-1.0)*x276))+((new_r11*x273)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x281=(gconst129*gconst132);
CheckValue<IkReal> x282 = IKatan2WithCheck((new_r02*x281),((-1.0)*new_r12*x281),IKFAST_ATAN2_MAGTHRESH);
if(!x282.valid){
continue;
}
j19array[0]=x282.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x283=IKcos(j19);
IkReal x284=IKsin(j19);
IkReal x285=((1.0)*gconst128);
IkReal x286=((1.0)*gconst129);
IkReal x287=(gconst129*x284);
IkReal x288=(gconst128*x284);
IkReal x289=((1.0)*x284);
IkReal x290=(x283*x285);
evalcond[0]=(((new_r02*x283))+((new_r12*x284)));
evalcond[1]=((((-1.0)*new_r02*x289))+((new_r12*x283)));
evalcond[2]=(gconst129+((new_r00*x283))+((new_r10*x284)));
evalcond[3]=(((gconst129*x283))+x288+new_r00);
evalcond[4]=((((-1.0)*x290))+x287+new_r01);
evalcond[5]=((((-1.0)*x290))+x287+new_r10);
evalcond[6]=((((-1.0)*x285))+((new_r11*x284))+((new_r01*x283)));
evalcond[7]=((((-1.0)*x284*x285))+new_r11+(((-1.0)*x283*x286)));
evalcond[8]=((((-1.0)*new_r00*x289))+(((-1.0)*x285))+((new_r10*x283)));
evalcond[9]=((((-1.0)*new_r01*x289))+(((-1.0)*x286))+((new_r11*x283)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x291=(gconst123*new_r00);
CheckValue<IkReal> x292 = IKatan2WithCheck((new_r02*x291),((-1.0)*new_r12*x291),IKFAST_ATAN2_MAGTHRESH);
if(!x292.valid){
continue;
}
j19array[0]=x292.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x293=IKcos(j19);
IkReal x294=IKsin(j19);
IkReal x295=((1.0)*sj21);
IkReal x296=(cj21*x294);
IkReal x297=((1.0)*x293);
IkReal x298=((1.0)*x294);
IkReal x299=(x293*x295);
evalcond[0]=(((new_r02*x293))+((new_r12*x294)));
evalcond[1]=(((new_r12*x293))+(((-1.0)*new_r02*x298)));
evalcond[2]=(((new_r10*x294))+((new_r00*x293))+cj21);
evalcond[3]=(((cj21*x293))+((sj21*x294))+new_r00);
evalcond[4]=((((-1.0)*x299))+x296+new_r01);
evalcond[5]=((((-1.0)*x299))+x296+new_r10);
evalcond[6]=(((new_r11*x294))+(((-1.0)*x295))+((new_r01*x293)));
evalcond[7]=((((-1.0)*cj21*x297))+new_r11+(((-1.0)*x294*x295)));
evalcond[8]=((((-1.0)*x295))+((new_r10*x293))+(((-1.0)*new_r00*x298)));
evalcond[9]=((((-1.0)*new_r01*x298))+((new_r11*x293))+(((-1.0)*cj21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
IkReal x300=(cj21*gconst122);
CheckValue<IkReal> x301 = IKatan2WithCheck((new_r02*x300),((-1.0)*new_r12*x300),IKFAST_ATAN2_MAGTHRESH);
if(!x301.valid){
continue;
}
j19array[0]=x301.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[10];
IkReal x302=IKcos(j19);
IkReal x303=IKsin(j19);
IkReal x304=((1.0)*sj21);
IkReal x305=(cj21*x303);
IkReal x306=((1.0)*x302);
IkReal x307=((1.0)*x303);
IkReal x308=(x302*x304);
evalcond[0]=(((new_r12*x303))+((new_r02*x302)));
evalcond[1]=((((-1.0)*new_r02*x307))+((new_r12*x302)));
evalcond[2]=(((new_r00*x302))+((new_r10*x303))+cj21);
evalcond[3]=(((sj21*x303))+new_r00+((cj21*x302)));
evalcond[4]=(x305+new_r01+(((-1.0)*x308)));
evalcond[5]=(x305+new_r10+(((-1.0)*x308)));
evalcond[6]=(((new_r01*x302))+((new_r11*x303))+(((-1.0)*x304)));
evalcond[7]=((((-1.0)*x303*x304))+(((-1.0)*cj21*x306))+new_r11);
evalcond[8]=(((new_r10*x302))+(((-1.0)*new_r00*x307))+(((-1.0)*x304)));
evalcond[9]=(((new_r11*x302))+(((-1.0)*cj21))+(((-1.0)*new_r01*x307)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x309 = IKatan2WithCheck((gconst109*new_r12),(gconst109*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x309.valid){
continue;
}
j19array[0]=x309.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[18];
IkReal x310=IKcos(j19);
IkReal x311=IKsin(j19);
IkReal x312=((1.0)*cj21);
IkReal x313=((1.0)*sj21);
IkReal x314=((1.0)*sj20);
IkReal x315=(new_r11*x311);
IkReal x316=(new_r00*x310);
IkReal x317=(cj20*x311);
IkReal x318=(sj20*x311);
IkReal x319=(new_r01*x310);
IkReal x320=((1.0)*x311);
IkReal x321=(new_r02*x310);
IkReal x322=(cj20*x310);
evalcond[0]=((((-1.0)*x310*x314))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x311*x314)));
evalcond[2]=((((-1.0)*new_r02*x320))+((new_r12*x310)));
evalcond[3]=(((cj21*x311))+((sj21*x322))+new_r01);
evalcond[4]=(x321+(((-1.0)*x314))+((new_r12*x311)));
evalcond[5]=(x319+x315+((cj20*sj21)));
evalcond[6]=(new_r00+((sj21*x311))+(((-1.0)*x312*x322)));
evalcond[7]=((((-1.0)*x310*x312))+new_r11+((sj21*x317)));
evalcond[8]=((((-1.0)*x313))+((new_r10*x310))+(((-1.0)*new_r00*x320)));
evalcond[9]=((((-1.0)*new_r01*x320))+(((-1.0)*x312))+((new_r11*x310)));
evalcond[10]=((((-1.0)*cj20*x312))+x316+((new_r10*x311)));
evalcond[11]=((((-1.0)*x310*x313))+(((-1.0)*x312*x317))+new_r10);
evalcond[12]=(((new_r10*x318))+((cj20*new_r20))+((sj20*x316)));
evalcond[13]=(((cj20*new_r21))+((sj20*x315))+((sj20*x319)));
evalcond[14]=((-1.0)+((sj20*x321))+((new_r12*x318))+((cj20*new_r22)));
evalcond[15]=((((-1.0)*new_r22*x314))+((new_r12*x317))+((cj20*x321)));
evalcond[16]=((((-1.0)*new_r21*x314))+sj21+((cj20*x315))+((cj20*x319)));
evalcond[17]=((((-1.0)*new_r20*x314))+(((-1.0)*x312))+((new_r10*x317))+((cj20*x316)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x323 = IKatan2WithCheck((gconst108*new_r12),(gconst108*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x323.valid){
continue;
}
j19array[0]=x323.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[18];
IkReal x324=IKcos(j19);
IkReal x325=IKsin(j19);
IkReal x326=((1.0)*cj21);
IkReal x327=((1.0)*sj21);
IkReal x328=((1.0)*sj20);
IkReal x329=(new_r11*x325);
IkReal x330=(new_r00*x324);
IkReal x331=(cj20*x325);
IkReal x332=(sj20*x325);
IkReal x333=(new_r01*x324);
IkReal x334=((1.0)*x325);
IkReal x335=(new_r02*x324);
IkReal x336=(cj20*x324);
evalcond[0]=(new_r02+(((-1.0)*x324*x328)));
evalcond[1]=((((-1.0)*x325*x328))+new_r12);
evalcond[2]=(((new_r12*x324))+(((-1.0)*new_r02*x334)));
evalcond[3]=(((sj21*x336))+new_r01+((cj21*x325)));
evalcond[4]=(((new_r12*x325))+(((-1.0)*x328))+x335);
evalcond[5]=(x333+x329+((cj20*sj21)));
evalcond[6]=(((sj21*x325))+new_r00+(((-1.0)*x326*x336)));
evalcond[7]=(((sj21*x331))+new_r11+(((-1.0)*x324*x326)));
evalcond[8]=((((-1.0)*x327))+(((-1.0)*new_r00*x334))+((new_r10*x324)));
evalcond[9]=((((-1.0)*x326))+(((-1.0)*new_r01*x334))+((new_r11*x324)));
evalcond[10]=((((-1.0)*cj20*x326))+x330+((new_r10*x325)));
evalcond[11]=(new_r10+(((-1.0)*x324*x327))+(((-1.0)*x326*x331)));
evalcond[12]=(((sj20*x330))+((new_r10*x332))+((cj20*new_r20)));
evalcond[13]=(((sj20*x333))+((sj20*x329))+((cj20*new_r21)));
evalcond[14]=((-1.0)+((new_r12*x332))+((sj20*x335))+((cj20*new_r22)));
evalcond[15]=(((cj20*x335))+(((-1.0)*new_r22*x328))+((new_r12*x331)));
evalcond[16]=(((cj20*x333))+sj21+(((-1.0)*new_r21*x328))+((cj20*x329)));
evalcond[17]=(((cj20*x330))+(((-1.0)*x326))+((new_r10*x331))+(((-1.0)*new_r20*x328)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x337 = IKatan2WithCheck((gconst106*new_r12),(gconst106*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x337.valid){
continue;
}
j19array[0]=x337.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x338=IKcos(j19);
IkReal x339=IKsin(j19);
IkReal x340=((1.0)*sj20);
IkReal x341=(new_r02*x338);
IkReal x342=(new_r12*x339);
IkReal x343=(sj20*x338);
IkReal x344=(sj20*x339);
evalcond[0]=(new_r02+(((-1.0)*x338*x340)));
evalcond[1]=(new_r12+(((-1.0)*x339*x340)));
evalcond[2]=(((new_r12*x338))+(((-1.0)*new_r02*x339)));
evalcond[3]=(x342+x341+(((-1.0)*x340)));
evalcond[4]=(((new_r00*x343))+((new_r10*x344))+((cj20*new_r20)));
evalcond[5]=(((new_r11*x344))+((new_r01*x343))+((cj20*new_r21)));
evalcond[6]=((-1.0)+((sj20*x342))+((sj20*x341))+((cj20*new_r22)));
evalcond[7]=(((cj20*x341))+((cj20*x342))+(((-1.0)*new_r22*x340)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst134;
gconst134=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj19;
dummyeval[1]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[3];
dummyeval[0]=cj19;
dummyeval[1]=cj20;
dummyeval[2]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  || IKabs(dummyeval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x345=((((-1.0)*cj20))+new_r22);
IkReal x346=((((-1.0)*sj20))+new_r12);
IkReal x347=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x345;
evalcond[2]=x345;
evalcond[3]=new_r02;
evalcond[4]=x346;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x346;
evalcond[7]=(((new_r10*sj20))+((cj20*new_r20)));
evalcond[8]=(((new_r11*sj20))+((cj20*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj20))+((cj20*new_r22)));
evalcond[10]=(((cj20*new_r12))+(((-1.0)*new_r22*x347)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst135;
gconst135=IKsign(new_r12);
dummyeval[0]=new_r12;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=new_r22;
dummyeval[1]=new_r12;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x348=IKPowWithIntegerCheck(new_r22,-1);
if(!x348.valid){
continue;
}
CheckValue<IkReal> x349=IKPowWithIntegerCheck(new_r12,-1);
if(!x349.valid){
continue;
}
if( IKabs(((-1.0)*new_r11*(x348.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x349.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11*(x348.value)))+IKsqr(((-1.0)*new_r20*(x349.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r11*(x348.value)), ((-1.0)*new_r20*(x349.value)));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x350=IKsin(j21);
IkReal x351=IKcos(j21);
IkReal x352=((1.0)*new_r12);
IkReal x353=((1.0)*x351);
IkReal x354=((1.0)*x350);
evalcond[0]=(new_r20+((new_r12*x351)));
evalcond[1]=(((new_r22*x350))+new_r11);
evalcond[2]=(new_r21+(((-1.0)*x350*x352)));
evalcond[3]=((((-1.0)*new_r22*x353))+new_r10);
evalcond[4]=((((-1.0)*x354))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x353))+(((-1.0)*new_r01)));
evalcond[6]=(x350+((new_r11*new_r22))+(((-1.0)*new_r21*x352)));
evalcond[7]=((((-1.0)*x353))+((new_r10*new_r22))+(((-1.0)*new_r20*x352)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x355 = IKatan2WithCheck((gconst135*new_r21),((-1.0)*gconst135*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x355.valid){
continue;
}
j21array[0]=x355.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x356=IKsin(j21);
IkReal x357=IKcos(j21);
IkReal x358=((1.0)*new_r12);
IkReal x359=((1.0)*x357);
IkReal x360=((1.0)*x356);
evalcond[0]=(new_r20+((new_r12*x357)));
evalcond[1]=(((new_r22*x356))+new_r11);
evalcond[2]=((((-1.0)*x356*x358))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x359))+new_r10);
evalcond[4]=((((-1.0)*x360))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x359))+(((-1.0)*new_r01)));
evalcond[6]=(x356+((new_r11*new_r22))+(((-1.0)*new_r21*x358)));
evalcond[7]=((((-1.0)*x359))+((new_r10*new_r22))+(((-1.0)*new_r20*x358)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x361=((((-1.0)*cj20))+new_r22);
IkReal x362=((1.0)*new_r12);
IkReal x363=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x361;
evalcond[2]=x361;
evalcond[3]=new_r02;
evalcond[4]=(sj20+new_r12);
evalcond[5]=new_r02;
evalcond[6]=new_r02;
evalcond[7]=((((-1.0)*x363))+(((-1.0)*x362)));
evalcond[8]=((((-1.0)*new_r10*x363))+((cj20*new_r20)));
evalcond[9]=((((-1.0)*new_r11*x363))+((cj20*new_r21)));
evalcond[10]=((-1.0)+(((-1.0)*sj20*x362))+((cj20*new_r22)));
evalcond[11]=((((-1.0)*new_r22*x363))+(((-1.0)*cj20*x362)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r00, new_r01);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x364=IKsin(j21);
IkReal x365=IKcos(j21);
IkReal x366=((1.0)*new_r10);
IkReal x367=((1.0)*new_r11);
IkReal x368=((1.0)*x365);
evalcond[0]=(new_r21+((new_r12*x364)));
evalcond[1]=((((-1.0)*x364))+new_r00);
evalcond[2]=((((-1.0)*x368))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x368))+new_r20);
evalcond[4]=(((new_r22*x364))+(((-1.0)*x367)));
evalcond[5]=((((-1.0)*x366))+(((-1.0)*new_r22*x368)));
evalcond[6]=((((-1.0)*new_r22*x367))+x364+((new_r12*new_r21)));
evalcond[7]=((((-1.0)*x368))+(((-1.0)*new_r22*x366))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x369=((1.0)*sj19);
IkReal x370=(((cj19*new_r12))+(((-1.0)*new_r02*x369)));
IkReal x371=(((new_r10*sj19))+((cj19*new_r00)));
IkReal x372=(((cj19*new_r01))+((new_r11*sj19)));
IkReal x373=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((((-1.0)*cj19))+new_r02);
evalcond[4]=((((-1.0)*x369))+new_r12);
evalcond[5]=x370;
evalcond[6]=x370;
evalcond[7]=x373;
evalcond[8]=x372;
evalcond[9]=x371;
evalcond[10]=x371;
evalcond[11]=x372;
evalcond[12]=x373;
evalcond[13]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x374=IKcos(j21);
IkReal x375=IKsin(j21);
IkReal x376=((1.0)*new_r12);
IkReal x377=((1.0)*x375);
IkReal x378=((1.0)*x374);
evalcond[0]=(x374+new_r20);
evalcond[1]=((((-1.0)*x377))+new_r21);
evalcond[2]=(((new_r12*x374))+new_r01);
evalcond[3]=(((new_r12*x375))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x378)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x377)));
evalcond[6]=((((-1.0)*new_r00*x376))+(((-1.0)*x377))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x378))+((new_r02*new_r11))+(((-1.0)*new_r01*x376)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x379=(new_r12*sj19);
IkReal x380=((1.0)*sj19);
IkReal x381=(cj19*new_r00);
IkReal x382=((1.0)*cj19);
IkReal x383=((((-1.0)*new_r02*x380))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=(cj19+new_r02);
evalcond[4]=(sj19+new_r12);
evalcond[5]=x383;
evalcond[6]=x383;
evalcond[7]=((1.0)+x379+((cj19*new_r02)));
evalcond[8]=(((cj19*new_r01))+((new_r11*sj19)));
evalcond[9]=(x381+((new_r10*sj19)));
evalcond[10]=((((-1.0)*new_r10*x380))+(((-1.0)*x381)));
evalcond[11]=((((-1.0)*new_r11*x380))+(((-1.0)*new_r01*x382)));
evalcond[12]=((-1.0)+(((-1.0)*x379))+(((-1.0)*new_r02*x382)));
evalcond[13]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x384=IKcos(j21);
IkReal x385=IKsin(j21);
IkReal x386=((1.0)*new_r02);
IkReal x387=((1.0)*x384);
IkReal x388=((1.0)*x385);
evalcond[0]=(x385+new_r21);
evalcond[1]=((((-1.0)*x387))+new_r20);
evalcond[2]=(((new_r02*x384))+new_r11);
evalcond[3]=(((new_r02*x385))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x387))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x388))+new_r00);
evalcond[6]=((((-1.0)*new_r10*x386))+((new_r00*new_r12))+(((-1.0)*x388)));
evalcond[7]=((((-1.0)*new_r11*x386))+((new_r01*new_r12))+(((-1.0)*x387)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x389=((-1.0)+new_r22);
IkReal x390=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x391=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x389;
evalcond[2]=x389;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x390;
evalcond[10]=x390;
evalcond[11]=x391;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x389;
evalcond[15]=x391;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst136;
gconst136=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst137;
gconst137=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x392 = IKatan2WithCheck((gconst137*((((cj19*new_r01))+((new_r11*sj19))))),(gconst137*(((((-1.0)*cj19*new_r11))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x392.valid){
continue;
}
j21array[0]=x392.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x393=IKsin(j21);
IkReal x394=IKcos(j21);
IkReal x395=((1.0)*sj19);
IkReal x396=((1.0)*x394);
IkReal x397=(sj19*x393);
IkReal x398=((1.0)*x393);
IkReal x399=(cj19*x396);
evalcond[0]=(x393+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x394))+((cj19*x393))+new_r01);
evalcond[2]=((((-1.0)*x396))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*x398))+((cj19*new_r10))+(((-1.0)*new_r00*x395)));
evalcond[4]=((((-1.0)*new_r01*x395))+(((-1.0)*x396))+((cj19*new_r11)));
evalcond[5]=((((-1.0)*x399))+x397+new_r00);
evalcond[6]=((((-1.0)*x399))+x397+new_r11);
evalcond[7]=((((-1.0)*cj19*x398))+(((-1.0)*x394*x395))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x400 = IKatan2WithCheck((gconst136*((((new_r00*sj19))+((cj19*new_r01))))),(gconst136*(((((-1.0)*cj19*new_r00))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x400.valid){
continue;
}
j21array[0]=x400.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x401=IKsin(j21);
IkReal x402=IKcos(j21);
IkReal x403=((1.0)*sj19);
IkReal x404=((1.0)*x402);
IkReal x405=(sj19*x401);
IkReal x406=((1.0)*x401);
IkReal x407=(cj19*x404);
evalcond[0]=(x401+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x402))+new_r01+((cj19*x401)));
evalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x404)));
evalcond[3]=((((-1.0)*new_r00*x403))+((cj19*new_r10))+(((-1.0)*x406)));
evalcond[4]=(((cj19*new_r11))+(((-1.0)*new_r01*x403))+(((-1.0)*x404)));
evalcond[5]=(x405+new_r00+(((-1.0)*x407)));
evalcond[6]=(x405+new_r11+(((-1.0)*x407)));
evalcond[7]=((((-1.0)*x402*x403))+new_r10+(((-1.0)*cj19*x406)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x408=((1.0)+new_r22);
IkReal x409=(new_r12*sj19);
IkReal x410=((1.0)*new_r02);
IkReal x411=((((-1.0)*sj19*x410))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x408;
evalcond[2]=x408;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x411;
evalcond[10]=x411;
evalcond[11]=(x409+((cj19*new_r02)));
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*cj19*x410))+(((-1.0)*x409)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst138;
gconst138=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst139;
gconst139=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x412=((1.0)*sj19);
CheckValue<IkReal> x413 = IKatan2WithCheck((gconst139*((((cj19*new_r10))+(((-1.0)*new_r00*x412))))),(gconst139*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x412))))),IKFAST_ATAN2_MAGTHRESH);
if(!x413.valid){
continue;
}
j21array[0]=x413.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x414=IKsin(j21);
IkReal x415=IKcos(j21);
IkReal x416=((1.0)*cj19);
IkReal x417=((1.0)*sj19);
IkReal x418=((1.0)*x414);
IkReal x419=(sj19*x415);
IkReal x420=(sj19*x414);
IkReal x421=(x414*x416);
evalcond[0]=(x415+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=(((cj19*new_r01))+(((-1.0)*x418))+((new_r11*sj19)));
evalcond[2]=(((cj19*x415))+x420+new_r00);
evalcond[3]=(((cj19*new_r10))+(((-1.0)*new_r00*x417))+(((-1.0)*x418)));
evalcond[4]=(((cj19*new_r11))+(((-1.0)*new_r01*x417))+(((-1.0)*x415)));
evalcond[5]=((((-1.0)*x421))+x419+new_r01);
evalcond[6]=((((-1.0)*x421))+x419+new_r10);
evalcond[7]=((((-1.0)*x415*x416))+new_r11+(((-1.0)*x414*x417)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x422=((1.0)*new_r00);
CheckValue<IkReal> x423 = IKatan2WithCheck((gconst138*(((((-1.0)*sj19*x422))+((cj19*new_r01))))),(gconst138*(((((-1.0)*new_r01*sj19))+(((-1.0)*cj19*x422))))),IKFAST_ATAN2_MAGTHRESH);
if(!x423.valid){
continue;
}
j21array[0]=x423.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x424=IKsin(j21);
IkReal x425=IKcos(j21);
IkReal x426=((1.0)*cj19);
IkReal x427=((1.0)*sj19);
IkReal x428=((1.0)*x424);
IkReal x429=(sj19*x425);
IkReal x430=(sj19*x424);
IkReal x431=(x424*x426);
evalcond[0]=(x425+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x428))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x425))+x430+new_r00);
evalcond[3]=((((-1.0)*new_r00*x427))+(((-1.0)*x428))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x425))+((cj19*new_r11))+(((-1.0)*new_r01*x427)));
evalcond[5]=((((-1.0)*x431))+x429+new_r01);
evalcond[6]=((((-1.0)*x431))+x429+new_r10);
evalcond[7]=((((-1.0)*x425*x426))+(((-1.0)*x424*x427))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x432=((((-1.0)*cj20))+new_r22);
IkReal x433=((((-1.0)*sj20))+new_r02);
IkReal x434=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x432;
evalcond[2]=x432;
evalcond[3]=x433;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x433;
evalcond[8]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[9]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[10]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[11]=(((cj20*new_r02))+(((-1.0)*new_r22*x434)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x435=IKcos(j21);
IkReal x436=IKsin(j21);
IkReal x437=((1.0)*new_r02);
IkReal x438=((1.0)*x435);
evalcond[0]=(new_r20+((new_r02*x435)));
evalcond[1]=((((-1.0)*x436))+new_r10);
evalcond[2]=((((-1.0)*x438))+new_r11);
evalcond[3]=(new_r01+((new_r22*x436)));
evalcond[4]=((((-1.0)*x436*x437))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*new_r22*x438)));
evalcond[6]=(((new_r01*new_r22))+x436+(((-1.0)*new_r21*x437)));
evalcond[7]=((((-1.0)*x438))+((new_r00*new_r22))+(((-1.0)*new_r20*x437)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x439=((((-1.0)*cj20))+new_r22);
IkReal x440=((1.0)*sj20);
IkReal x441=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x439;
evalcond[2]=x439;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x440))+(((-1.0)*new_r02)));
evalcond[7]=((((-1.0)*new_r00*x440))+((cj20*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x440))+((cj20*new_r21)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x440))+((cj20*new_r22)));
evalcond[10]=((((-1.0)*new_r02*x441))+(((-1.0)*new_r22*x440)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst140;
gconst140=IKsign(new_r02);
dummyeval[0]=new_r02;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=new_r02;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=new_r02;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x442=IKPowWithIntegerCheck(new_r02,-1);
if(!x442.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x442.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x442.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21*(x442.value)), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x443=IKsin(j21);
IkReal x444=IKcos(j21);
IkReal x445=((1.0)*new_r22);
IkReal x446=((1.0)*x444);
evalcond[0]=(((new_r02*x443))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x446))+new_r20);
evalcond[2]=((((-1.0)*x443))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x446))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x443))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x444*x445))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x445))+x443+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x446))+(((-1.0)*new_r00*x445))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x447=IKPowWithIntegerCheck(new_r02,-1);
if(!x447.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x447.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x447.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x447.value)));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x448=IKsin(j21);
IkReal x449=IKcos(j21);
IkReal x450=((1.0)*new_r22);
IkReal x451=((1.0)*x449);
evalcond[0]=(((new_r02*x448))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x451))+new_r20);
evalcond[2]=((((-1.0)*x448))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x451))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x448))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x449*x450)));
evalcond[6]=((((-1.0)*new_r01*x450))+x448+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x450))+(((-1.0)*x451))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x452 = IKatan2WithCheck(((-1.0)*gconst140*new_r21),(gconst140*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x452.valid){
continue;
}
j21array[0]=x452.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x453=IKsin(j21);
IkReal x454=IKcos(j21);
IkReal x455=((1.0)*new_r22);
IkReal x456=((1.0)*x454);
evalcond[0]=(((new_r02*x453))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x456))+new_r20);
evalcond[2]=((((-1.0)*x453))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x456))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x453))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x454*x455))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x455))+x453+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x455))+(((-1.0)*x456))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x457=((-1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x457;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x457;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=new_r00;
evalcond[13]=new_r01;
evalcond[14]=x457;
evalcond[15]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x458=IKcos(j21);
IkReal x459=((1.0)*(IKsin(j21)));
evalcond[0]=(x458+new_r20);
evalcond[1]=((((-1.0)*x459))+new_r21);
evalcond[2]=((((-1.0)*x459))+new_r10);
evalcond[3]=((((-1.0)*x458))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((-1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x460=IKcos(j21);
IkReal x461=((1.0)*(IKsin(j21)));
evalcond[0]=(x460+new_r20);
evalcond[1]=((((-1.0)*x461))+new_r21);
evalcond[2]=((((-1.0)*x461))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x460))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x462=((1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x462;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x462;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=((-1.0)*new_r00);
evalcond[13]=((-1.0)*new_r01);
evalcond[14]=((-1.0)+(((-1.0)*new_r02)));
evalcond[15]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x463=IKsin(j21);
IkReal x464=((1.0)*(IKcos(j21)));
evalcond[0]=(x463+new_r21);
evalcond[1]=((((-1.0)*x464))+new_r20);
evalcond[2]=((((-1.0)*x463))+new_r10);
evalcond[3]=((((-1.0)*x464))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((-1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x465=IKsin(j21);
IkReal x466=((1.0)*(IKcos(j21)));
evalcond[0]=(x465+new_r21);
evalcond[1]=((((-1.0)*x466))+new_r20);
evalcond[2]=((((-1.0)*x465))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x466))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x467=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x467;
evalcond[2]=x467;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x467;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x468=IKsin(j21);
IkReal x469=((1.0)*(IKcos(j21)));
evalcond[0]=(x468+new_r01);
evalcond[1]=((((-1.0)*x468))+new_r10);
evalcond[2]=((((-1.0)*x469))+new_r11);
evalcond[3]=((((-1.0)*x469))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x470=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x470;
evalcond[2]=x470;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x470;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x471=IKsin(j21);
IkReal x472=((1.0)*(IKcos(j21)));
evalcond[0]=(x471+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x471))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x472))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x472))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x473=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x473;
evalcond[2]=x473;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x474=IKcos(j21);
IkReal x475=((1.0)*(IKsin(j21)));
evalcond[0]=(x474+new_r00);
evalcond[1]=((((-1.0)*x475))+new_r10);
evalcond[2]=((((-1.0)*x474))+new_r11);
evalcond[3]=((((-1.0)*x475))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x476=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x476;
evalcond[2]=x476;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x477=IKcos(j21);
IkReal x478=((1.0)*(IKsin(j21)));
evalcond[0]=(x477+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x478))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x477))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x478))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x480=IKPowWithIntegerCheck(sj20,-1);
if(!x480.valid){
continue;
}
IkReal x479=x480.value;
CheckValue<IkReal> x481=IKPowWithIntegerCheck(cj19,-1);
if(!x481.valid){
continue;
}
CheckValue<IkReal> x482=IKPowWithIntegerCheck(cj20,-1);
if(!x482.valid){
continue;
}
if( IKabs((x479*(x481.value)*(x482.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x479)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x479*(x481.value)*(x482.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))))+IKsqr(((-1.0)*new_r20*x479))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x479*(x481.value)*(x482.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))), ((-1.0)*new_r20*x479));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x483=IKsin(j21);
IkReal x484=IKcos(j21);
IkReal x485=(cj20*sj19);
IkReal x486=(cj19*new_r01);
IkReal x487=((1.0)*sj20);
IkReal x488=(cj19*new_r00);
IkReal x489=((1.0)*sj19);
IkReal x490=((1.0)*x484);
IkReal x491=(cj20*x483);
IkReal x492=((1.0)*x483);
IkReal x493=(cj19*x490);
evalcond[0]=(((sj20*x484))+new_r20);
evalcond[1]=((((-1.0)*x483*x487))+new_r21);
evalcond[2]=(x486+x491+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x492))+(((-1.0)*new_r00*x489))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x489))+(((-1.0)*x490))+((cj19*new_r11)));
evalcond[5]=(((sj19*x484))+new_r01+((cj19*x491)));
evalcond[6]=(x488+((new_r10*sj19))+(((-1.0)*cj20*x490)));
evalcond[7]=(((sj19*x483))+new_r00+(((-1.0)*cj20*x493)));
evalcond[8]=((((-1.0)*x493))+((x483*x485))+new_r11);
evalcond[9]=((((-1.0)*cj19*x492))+(((-1.0)*x485*x490))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x487))+((new_r11*x485))+x483+((cj20*x486)));
evalcond[11]=((((-1.0)*x490))+(((-1.0)*new_r20*x487))+((new_r10*x485))+((cj20*x488)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x495=IKPowWithIntegerCheck(sj20,-1);
if(!x495.valid){
continue;
}
IkReal x494=x495.value;
CheckValue<IkReal> x496=IKPowWithIntegerCheck(sj19,-1);
if(!x496.valid){
continue;
}
if( IKabs((x494*(x496.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x494)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x494*(x496.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x494))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x494*(x496.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x494));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x497=IKsin(j21);
IkReal x498=IKcos(j21);
IkReal x499=(cj20*sj19);
IkReal x500=(cj19*new_r01);
IkReal x501=((1.0)*sj20);
IkReal x502=(cj19*new_r00);
IkReal x503=((1.0)*sj19);
IkReal x504=((1.0)*x498);
IkReal x505=(cj20*x497);
IkReal x506=((1.0)*x497);
IkReal x507=(cj19*x504);
evalcond[0]=(((sj20*x498))+new_r20);
evalcond[1]=((((-1.0)*x497*x501))+new_r21);
evalcond[2]=(x500+x505+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x503))+(((-1.0)*x506))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x503))+(((-1.0)*x504))+((cj19*new_r11)));
evalcond[5]=(((sj19*x498))+((cj19*x505))+new_r01);
evalcond[6]=(x502+(((-1.0)*cj20*x504))+((new_r10*sj19)));
evalcond[7]=(((sj19*x497))+(((-1.0)*cj20*x507))+new_r00);
evalcond[8]=((((-1.0)*x507))+((x497*x499))+new_r11);
evalcond[9]=((((-1.0)*x499*x504))+(((-1.0)*cj19*x506))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x501))+((new_r11*x499))+x497+((cj20*x500)));
evalcond[11]=((((-1.0)*new_r20*x501))+(((-1.0)*x504))+((new_r10*x499))+((cj20*x502)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x508 = IKatan2WithCheck((gconst134*new_r21),((-1.0)*gconst134*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x508.valid){
continue;
}
j21array[0]=x508.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x509=IKsin(j21);
IkReal x510=IKcos(j21);
IkReal x511=(cj20*sj19);
IkReal x512=(cj19*new_r01);
IkReal x513=((1.0)*sj20);
IkReal x514=(cj19*new_r00);
IkReal x515=((1.0)*sj19);
IkReal x516=((1.0)*x510);
IkReal x517=(cj20*x509);
IkReal x518=((1.0)*x509);
IkReal x519=(cj19*x516);
evalcond[0]=(((sj20*x510))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x509*x513)));
evalcond[2]=(x517+x512+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x515))+((cj19*new_r10))+(((-1.0)*x518)));
evalcond[4]=((((-1.0)*new_r01*x515))+((cj19*new_r11))+(((-1.0)*x516)));
evalcond[5]=(((sj19*x510))+((cj19*x517))+new_r01);
evalcond[6]=((((-1.0)*cj20*x516))+x514+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x519))+((sj19*x509))+new_r00);
evalcond[8]=(new_r11+(((-1.0)*x519))+((x509*x511)));
evalcond[9]=((((-1.0)*x511*x516))+(((-1.0)*cj19*x518))+new_r10);
evalcond[10]=(((new_r11*x511))+((cj20*x512))+x509+(((-1.0)*new_r21*x513)));
evalcond[11]=(((new_r10*x511))+((cj20*x514))+(((-1.0)*new_r20*x513))+(((-1.0)*x516)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x520 = IKatan2WithCheck((gconst105*new_r12),(gconst105*new_r02),IKFAST_ATAN2_MAGTHRESH);
if(!x520.valid){
continue;
}
j19array[0]=x520.value;
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x521=IKcos(j19);
IkReal x522=IKsin(j19);
IkReal x523=((1.0)*sj20);
IkReal x524=(new_r02*x521);
IkReal x525=(new_r12*x522);
IkReal x526=(sj20*x521);
IkReal x527=(sj20*x522);
evalcond[0]=((((-1.0)*x521*x523))+new_r02);
evalcond[1]=((((-1.0)*x522*x523))+new_r12);
evalcond[2]=(((new_r12*x521))+(((-1.0)*new_r02*x522)));
evalcond[3]=((((-1.0)*x523))+x524+x525);
evalcond[4]=(((new_r10*x527))+((cj20*new_r20))+((new_r00*x526)));
evalcond[5]=(((new_r01*x526))+((new_r11*x527))+((cj20*new_r21)));
evalcond[6]=((-1.0)+((sj20*x524))+((sj20*x525))+((cj20*new_r22)));
evalcond[7]=((((-1.0)*new_r22*x523))+((cj20*x525))+((cj20*x524)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal dummyeval[1];
IkReal gconst134;
gconst134=IKsign(sj20);
dummyeval[0]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=sj19;
dummyeval[1]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
{
IkReal dummyeval[3];
dummyeval[0]=cj19;
dummyeval[1]=cj20;
dummyeval[2]=sj20;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  || IKabs(dummyeval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[16];
bool bgotonextstatement = true;
do
{
IkReal x528=((((-1.0)*cj20))+new_r22);
IkReal x529=((((-1.0)*sj20))+new_r12);
IkReal x530=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x528;
evalcond[2]=x528;
evalcond[3]=new_r02;
evalcond[4]=x529;
evalcond[5]=((-1.0)*new_r02);
evalcond[6]=x529;
evalcond[7]=(((new_r10*sj20))+((cj20*new_r20)));
evalcond[8]=(((new_r11*sj20))+((cj20*new_r21)));
evalcond[9]=((-1.0)+((new_r12*sj20))+((cj20*new_r22)));
evalcond[10]=((((-1.0)*new_r22*x530))+((cj20*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst135;
gconst135=IKsign(new_r12);
dummyeval[0]=new_r12;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[2];
dummyeval[0]=new_r22;
dummyeval[1]=new_r12;
if( IKabs(dummyeval[0]) < 0.0000010000000000  || IKabs(dummyeval[1]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x531=IKPowWithIntegerCheck(new_r22,-1);
if(!x531.valid){
continue;
}
CheckValue<IkReal> x532=IKPowWithIntegerCheck(new_r12,-1);
if(!x532.valid){
continue;
}
if( IKabs(((-1.0)*new_r11*(x531.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*(x532.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11*(x531.value)))+IKsqr(((-1.0)*new_r20*(x532.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r11*(x531.value)), ((-1.0)*new_r20*(x532.value)));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x533=IKsin(j21);
IkReal x534=IKcos(j21);
IkReal x535=((1.0)*new_r12);
IkReal x536=((1.0)*x534);
IkReal x537=((1.0)*x533);
evalcond[0]=(((new_r12*x534))+new_r20);
evalcond[1]=(((new_r22*x533))+new_r11);
evalcond[2]=((((-1.0)*x533*x535))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x536))+new_r10);
evalcond[4]=((((-1.0)*x537))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x536))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x535))+x533+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*x536))+(((-1.0)*new_r20*x535))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x538 = IKatan2WithCheck((gconst135*new_r21),((-1.0)*gconst135*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x538.valid){
continue;
}
j21array[0]=x538.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x539=IKsin(j21);
IkReal x540=IKcos(j21);
IkReal x541=((1.0)*new_r12);
IkReal x542=((1.0)*x540);
IkReal x543=((1.0)*x539);
evalcond[0]=(((new_r12*x540))+new_r20);
evalcond[1]=(((new_r22*x539))+new_r11);
evalcond[2]=((((-1.0)*x539*x541))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x542))+new_r10);
evalcond[4]=((((-1.0)*x543))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x542))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x541))+x539+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*new_r20*x541))+(((-1.0)*x542))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x544=((((-1.0)*cj20))+new_r22);
IkReal x545=((1.0)*new_r12);
IkReal x546=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x544;
evalcond[2]=x544;
evalcond[3]=new_r02;
evalcond[4]=(sj20+new_r12);
evalcond[5]=new_r02;
evalcond[6]=new_r02;
evalcond[7]=((((-1.0)*x546))+(((-1.0)*x545)));
evalcond[8]=((((-1.0)*new_r10*x546))+((cj20*new_r20)));
evalcond[9]=((((-1.0)*new_r11*x546))+((cj20*new_r21)));
evalcond[10]=((-1.0)+(((-1.0)*sj20*x545))+((cj20*new_r22)));
evalcond[11]=((((-1.0)*new_r22*x546))+(((-1.0)*cj20*x545)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r00, new_r01);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x547=IKsin(j21);
IkReal x548=IKcos(j21);
IkReal x549=((1.0)*new_r10);
IkReal x550=((1.0)*new_r11);
IkReal x551=((1.0)*x548);
evalcond[0]=(((new_r12*x547))+new_r21);
evalcond[1]=((((-1.0)*x547))+new_r00);
evalcond[2]=((((-1.0)*x551))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x551))+new_r20);
evalcond[4]=((((-1.0)*x550))+((new_r22*x547)));
evalcond[5]=((((-1.0)*new_r22*x551))+(((-1.0)*x549)));
evalcond[6]=((((-1.0)*new_r22*x550))+((new_r12*new_r21))+x547);
evalcond[7]=((((-1.0)*new_r22*x549))+((new_r12*new_r20))+(((-1.0)*x551)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x552=((1.0)*sj19);
IkReal x553=(((cj19*new_r12))+(((-1.0)*new_r02*x552)));
IkReal x554=(((new_r10*sj19))+((cj19*new_r00)));
IkReal x555=(((cj19*new_r01))+((new_r11*sj19)));
IkReal x556=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((((-1.0)*cj19))+new_r02);
evalcond[4]=((((-1.0)*x552))+new_r12);
evalcond[5]=x553;
evalcond[6]=x553;
evalcond[7]=x556;
evalcond[8]=x555;
evalcond[9]=x554;
evalcond[10]=x554;
evalcond[11]=x555;
evalcond[12]=x556;
evalcond[13]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x557=IKcos(j21);
IkReal x558=IKsin(j21);
IkReal x559=((1.0)*new_r12);
IkReal x560=((1.0)*x558);
IkReal x561=((1.0)*x557);
evalcond[0]=(x557+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x560)));
evalcond[2]=(((new_r12*x557))+new_r01);
evalcond[3]=(((new_r12*x558))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x561))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x560))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x559))+((new_r02*new_r10))+(((-1.0)*x560)));
evalcond[7]=((((-1.0)*new_r01*x559))+((new_r02*new_r11))+(((-1.0)*x561)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x562=(new_r12*sj19);
IkReal x563=((1.0)*sj19);
IkReal x564=(cj19*new_r00);
IkReal x565=((1.0)*cj19);
IkReal x566=((((-1.0)*new_r02*x563))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=(cj19+new_r02);
evalcond[4]=(sj19+new_r12);
evalcond[5]=x566;
evalcond[6]=x566;
evalcond[7]=((1.0)+x562+((cj19*new_r02)));
evalcond[8]=(((cj19*new_r01))+((new_r11*sj19)));
evalcond[9]=(x564+((new_r10*sj19)));
evalcond[10]=((((-1.0)*x564))+(((-1.0)*new_r10*x563)));
evalcond[11]=((((-1.0)*new_r11*x563))+(((-1.0)*new_r01*x565)));
evalcond[12]=((-1.0)+(((-1.0)*new_r02*x565))+(((-1.0)*x562)));
evalcond[13]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x567=IKcos(j21);
IkReal x568=IKsin(j21);
IkReal x569=((1.0)*new_r02);
IkReal x570=((1.0)*x567);
IkReal x571=((1.0)*x568);
evalcond[0]=(x568+new_r21);
evalcond[1]=((((-1.0)*x570))+new_r20);
evalcond[2]=(((new_r02*x567))+new_r11);
evalcond[3]=(((new_r02*x568))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x570))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x571))+new_r00);
evalcond[6]=(((new_r00*new_r12))+(((-1.0)*x571))+(((-1.0)*new_r10*x569)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*x570))+(((-1.0)*new_r11*x569)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x572=((-1.0)+new_r22);
IkReal x573=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x574=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=x572;
evalcond[2]=x572;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x573;
evalcond[10]=x573;
evalcond[11]=x574;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x572;
evalcond[15]=x574;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst136;
gconst136=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst137;
gconst137=IKsign(((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19)))));
dummyeval[0]=((((-1.0)*(sj19*sj19)))+(((-1.0)*(cj19*cj19))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x575 = IKatan2WithCheck((gconst137*((((cj19*new_r01))+((new_r11*sj19))))),(gconst137*(((((-1.0)*cj19*new_r11))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x575.valid){
continue;
}
j21array[0]=x575.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x576=IKsin(j21);
IkReal x577=IKcos(j21);
IkReal x578=((1.0)*sj19);
IkReal x579=((1.0)*x577);
IkReal x580=(sj19*x576);
IkReal x581=((1.0)*x576);
IkReal x582=(cj19*x579);
evalcond[0]=(x576+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x577))+((cj19*x576))+new_r01);
evalcond[2]=((((-1.0)*x579))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x578))+((cj19*new_r10))+(((-1.0)*x581)));
evalcond[4]=((((-1.0)*x579))+(((-1.0)*new_r01*x578))+((cj19*new_r11)));
evalcond[5]=(x580+new_r00+(((-1.0)*x582)));
evalcond[6]=(x580+new_r11+(((-1.0)*x582)));
evalcond[7]=((((-1.0)*x577*x578))+(((-1.0)*cj19*x581))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x583 = IKatan2WithCheck((gconst136*((((new_r00*sj19))+((cj19*new_r01))))),(gconst136*(((((-1.0)*cj19*new_r00))+((new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x583.valid){
continue;
}
j21array[0]=x583.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x584=IKsin(j21);
IkReal x585=IKcos(j21);
IkReal x586=((1.0)*sj19);
IkReal x587=((1.0)*x585);
IkReal x588=(sj19*x584);
IkReal x589=((1.0)*x584);
IkReal x590=(cj19*x587);
evalcond[0]=(x584+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x585))+((cj19*x584))+new_r01);
evalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x587)));
evalcond[3]=(((cj19*new_r10))+(((-1.0)*x589))+(((-1.0)*new_r00*x586)));
evalcond[4]=((((-1.0)*new_r01*x586))+((cj19*new_r11))+(((-1.0)*x587)));
evalcond[5]=((((-1.0)*x590))+x588+new_r00);
evalcond[6]=((((-1.0)*x590))+x588+new_r11);
evalcond[7]=((((-1.0)*x585*x586))+(((-1.0)*cj19*x589))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x591=((1.0)+new_r22);
IkReal x592=(new_r12*sj19);
IkReal x593=((1.0)*new_r02);
IkReal x594=((((-1.0)*sj19*x593))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=x591;
evalcond[2]=x591;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=x594;
evalcond[10]=x594;
evalcond[11]=(x592+((cj19*new_r02)));
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((((-1.0)*cj19*x593))+(((-1.0)*x592)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst138;
gconst138=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst139;
gconst139=IKsign(((sj19*sj19)+(cj19*cj19)));
dummyeval[0]=((sj19*sj19)+(cj19*cj19));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x595=((1.0)*sj19);
CheckValue<IkReal> x596 = IKatan2WithCheck((gconst139*(((((-1.0)*new_r00*x595))+((cj19*new_r10))))),(gconst139*(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r10*x595))))),IKFAST_ATAN2_MAGTHRESH);
if(!x596.valid){
continue;
}
j21array[0]=x596.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x597=IKsin(j21);
IkReal x598=IKcos(j21);
IkReal x599=((1.0)*cj19);
IkReal x600=((1.0)*sj19);
IkReal x601=((1.0)*x597);
IkReal x602=(sj19*x598);
IkReal x603=(sj19*x597);
IkReal x604=(x597*x599);
evalcond[0]=(x598+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x601))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x598))+x603+new_r00);
evalcond[3]=((((-1.0)*x601))+((cj19*new_r10))+(((-1.0)*new_r00*x600)));
evalcond[4]=((((-1.0)*x598))+((cj19*new_r11))+(((-1.0)*new_r01*x600)));
evalcond[5]=(x602+(((-1.0)*x604))+new_r01);
evalcond[6]=(x602+(((-1.0)*x604))+new_r10);
evalcond[7]=((((-1.0)*x598*x599))+(((-1.0)*x597*x600))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x605=((1.0)*new_r00);
CheckValue<IkReal> x606 = IKatan2WithCheck((gconst138*(((((-1.0)*sj19*x605))+((cj19*new_r01))))),(gconst138*(((((-1.0)*cj19*x605))+(((-1.0)*new_r01*sj19))))),IKFAST_ATAN2_MAGTHRESH);
if(!x606.valid){
continue;
}
j21array[0]=x606.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x607=IKsin(j21);
IkReal x608=IKcos(j21);
IkReal x609=((1.0)*cj19);
IkReal x610=((1.0)*sj19);
IkReal x611=((1.0)*x607);
IkReal x612=(sj19*x608);
IkReal x613=(sj19*x607);
IkReal x614=(x607*x609);
evalcond[0]=(x608+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x611))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x608))+x613+new_r00);
evalcond[3]=((((-1.0)*x611))+(((-1.0)*new_r00*x610))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x608))+((cj19*new_r11))+(((-1.0)*new_r01*x610)));
evalcond[5]=((((-1.0)*x614))+x612+new_r01);
evalcond[6]=((((-1.0)*x614))+x612+new_r10);
evalcond[7]=((((-1.0)*x608*x609))+(((-1.0)*x607*x610))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x615=((((-1.0)*cj20))+new_r22);
IkReal x616=((((-1.0)*sj20))+new_r02);
IkReal x617=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x615;
evalcond[2]=x615;
evalcond[3]=x616;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x616;
evalcond[8]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[9]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[10]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[11]=(((cj20*new_r02))+(((-1.0)*new_r22*x617)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x618=IKcos(j21);
IkReal x619=IKsin(j21);
IkReal x620=((1.0)*new_r02);
IkReal x621=((1.0)*x618);
evalcond[0]=(((new_r02*x618))+new_r20);
evalcond[1]=((((-1.0)*x619))+new_r10);
evalcond[2]=((((-1.0)*x621))+new_r11);
evalcond[3]=(new_r01+((new_r22*x619)));
evalcond[4]=((((-1.0)*x619*x620))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x621))+new_r00);
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x620))+x619);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*x621))+(((-1.0)*new_r20*x620)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x622=((((-1.0)*cj20))+new_r22);
IkReal x623=((1.0)*sj20);
IkReal x624=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x622;
evalcond[2]=x622;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((((-1.0)*x623))+(((-1.0)*new_r02)));
evalcond[7]=((((-1.0)*new_r00*x623))+((cj20*new_r20)));
evalcond[8]=((((-1.0)*new_r01*x623))+((cj20*new_r21)));
evalcond[9]=((-1.0)+(((-1.0)*new_r02*x623))+((cj20*new_r22)));
evalcond[10]=((((-1.0)*new_r02*x624))+(((-1.0)*new_r22*x623)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal dummyeval[1];
IkReal gconst140;
gconst140=IKsign(new_r02);
dummyeval[0]=new_r02;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=new_r02;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
dummyeval[0]=new_r02;
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x625=IKPowWithIntegerCheck(new_r02,-1);
if(!x625.valid){
continue;
}
if( IKabs(((-1.0)*new_r21*(x625.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21*(x625.value)))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21*(x625.value)), ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x626=IKsin(j21);
IkReal x627=IKcos(j21);
IkReal x628=((1.0)*new_r22);
IkReal x629=((1.0)*x627);
evalcond[0]=(((new_r02*x626))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x629))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x626)));
evalcond[3]=((((-1.0)*x629))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x626))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x627*x628))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x628))+x626+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x628))+(((-1.0)*x629))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x630=IKPowWithIntegerCheck(new_r02,-1);
if(!x630.valid){
continue;
}
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r20*(x630.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr((new_r20*(x630.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), (new_r20*(x630.value)));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x631=IKsin(j21);
IkReal x632=IKcos(j21);
IkReal x633=((1.0)*new_r22);
IkReal x634=((1.0)*x632);
evalcond[0]=(((new_r02*x631))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x634))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x631)));
evalcond[3]=((((-1.0)*x634))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x631))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x632*x633)));
evalcond[6]=((((-1.0)*new_r01*x633))+x631+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x633))+(((-1.0)*x634))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x635 = IKatan2WithCheck(((-1.0)*gconst140*new_r21),(gconst140*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x635.valid){
continue;
}
j21array[0]=x635.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x636=IKsin(j21);
IkReal x637=IKcos(j21);
IkReal x638=((1.0)*new_r22);
IkReal x639=((1.0)*x637);
evalcond[0]=(((new_r02*x636))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x639))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x636)));
evalcond[3]=((((-1.0)*x639))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x636))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x637*x638))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x638))+x636+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x638))+(((-1.0)*x639))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x640=((-1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x640;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x640;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=new_r00;
evalcond[13]=new_r01;
evalcond[14]=x640;
evalcond[15]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x641=IKcos(j21);
IkReal x642=((1.0)*(IKsin(j21)));
evalcond[0]=(x641+new_r20);
evalcond[1]=((((-1.0)*x642))+new_r21);
evalcond[2]=((((-1.0)*x642))+new_r10);
evalcond[3]=((((-1.0)*x641))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((-1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=((-1.0)*new_r22);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x643=IKcos(j21);
IkReal x644=((1.0)*(IKsin(j21)));
evalcond[0]=(x643+new_r20);
evalcond[1]=((((-1.0)*x644))+new_r21);
evalcond[2]=((((-1.0)*x644))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x643))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x645=((1.0)+new_r02);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=x645;
evalcond[4]=new_r12;
evalcond[5]=new_r12;
evalcond[6]=new_r12;
evalcond[7]=x645;
evalcond[8]=new_r01;
evalcond[9]=new_r01;
evalcond[10]=new_r00;
evalcond[11]=new_r00;
evalcond[12]=((-1.0)*new_r00);
evalcond[13]=((-1.0)*new_r01);
evalcond[14]=((-1.0)+(((-1.0)*new_r02)));
evalcond[15]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x646=IKsin(j21);
IkReal x647=((1.0)*(IKcos(j21)));
evalcond[0]=(x646+new_r21);
evalcond[1]=((((-1.0)*x647))+new_r20);
evalcond[2]=((((-1.0)*x646))+new_r10);
evalcond[3]=((((-1.0)*x647))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=new_r22;
evalcond[2]=new_r22;
evalcond[3]=((-1.0)+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((-1.0)*new_r12);
evalcond[6]=((1.0)+(((-1.0)*new_r02)));
evalcond[7]=((-1.0)*new_r01);
evalcond[8]=new_r01;
evalcond[9]=((-1.0)*new_r00);
evalcond[10]=new_r00;
evalcond[11]=new_r22;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x648=IKsin(j21);
IkReal x649=((1.0)*(IKcos(j21)));
evalcond[0]=(x648+new_r21);
evalcond[1]=((((-1.0)*x649))+new_r20);
evalcond[2]=((((-1.0)*x648))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x649))+(((-1.0)*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x650=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x650;
evalcond[2]=x650;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=new_r20;
evalcond[13]=new_r21;
evalcond[14]=x650;
evalcond[15]=new_r02;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r01), new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x651=IKsin(j21);
IkReal x652=((1.0)*(IKcos(j21)));
evalcond[0]=(x651+new_r01);
evalcond[1]=((((-1.0)*x651))+new_r10);
evalcond[2]=((((-1.0)*x652))+new_r11);
evalcond[3]=((((-1.0)*x652))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x653=((-1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x653;
evalcond[2]=x653;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=new_r20;
evalcond[12]=new_r21;
evalcond[13]=x653;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x654=IKsin(j21);
IkReal x655=((1.0)*(IKcos(j21)));
evalcond[0]=(x654+(((-1.0)*new_r01)));
evalcond[1]=((((-1.0)*x654))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x655))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x655))+(((-1.0)*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x656=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959))))));
evalcond[1]=x656;
evalcond[2]=x656;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=new_r12;
evalcond[10]=new_r12;
evalcond[11]=new_r02;
evalcond[12]=((-1.0)*new_r20);
evalcond[13]=((-1.0)*new_r21);
evalcond[14]=((-1.0)+(((-1.0)*new_r22)));
evalcond[15]=((-1.0)*new_r02);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  && IKabs(evalcond[14]) < 0.0000010000000000  && IKabs(evalcond[15]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, ((-1.0)*new_r00));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x657=IKcos(j21);
IkReal x658=((1.0)*(IKsin(j21)));
evalcond[0]=(x657+new_r00);
evalcond[1]=((((-1.0)*x658))+new_r10);
evalcond[2]=((((-1.0)*x657))+new_r11);
evalcond[3]=((((-1.0)*x658))+new_r01);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x659=((1.0)+new_r22);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959))))));
evalcond[1]=x659;
evalcond[2]=x659;
evalcond[3]=new_r20;
evalcond[4]=new_r20;
evalcond[5]=new_r02;
evalcond[6]=new_r12;
evalcond[7]=new_r21;
evalcond[8]=new_r21;
evalcond[9]=((-1.0)*new_r12);
evalcond[10]=((-1.0)*new_r02);
evalcond[11]=((-1.0)*new_r20);
evalcond[12]=((-1.0)*new_r21);
evalcond[13]=((-1.0)+(((-1.0)*new_r22)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  && IKabs(evalcond[12]) < 0.0000010000000000  && IKabs(evalcond[13]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r10), new_r00);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[4];
IkReal x660=IKcos(j21);
IkReal x661=((1.0)*(IKsin(j21)));
evalcond[0]=(x660+(((-1.0)*new_r00)));
evalcond[1]=((((-1.0)*x661))+(((-1.0)*new_r10)));
evalcond[2]=((((-1.0)*x660))+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x661))+(((-1.0)*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue;

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x663=IKPowWithIntegerCheck(sj20,-1);
if(!x663.valid){
continue;
}
IkReal x662=x663.value;
CheckValue<IkReal> x664=IKPowWithIntegerCheck(cj19,-1);
if(!x664.valid){
continue;
}
CheckValue<IkReal> x665=IKPowWithIntegerCheck(cj20,-1);
if(!x665.valid){
continue;
}
if( IKabs((x662*(x664.value)*(x665.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x662)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x662*(x664.value)*(x665.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))))+IKsqr(((-1.0)*new_r20*x662))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x662*(x664.value)*(x665.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))), ((-1.0)*new_r20*x662));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x666=IKsin(j21);
IkReal x667=IKcos(j21);
IkReal x668=(cj20*sj19);
IkReal x669=(cj19*new_r01);
IkReal x670=((1.0)*sj20);
IkReal x671=(cj19*new_r00);
IkReal x672=((1.0)*sj19);
IkReal x673=((1.0)*x667);
IkReal x674=(cj20*x666);
IkReal x675=((1.0)*x666);
IkReal x676=(cj19*x673);
evalcond[0]=(new_r20+((sj20*x667)));
evalcond[1]=((((-1.0)*x666*x670))+new_r21);
evalcond[2]=(x669+x674+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x672))+((cj19*new_r10))+(((-1.0)*x675)));
evalcond[4]=((((-1.0)*new_r01*x672))+((cj19*new_r11))+(((-1.0)*x673)));
evalcond[5]=(((sj19*x667))+((cj19*x674))+new_r01);
evalcond[6]=(x671+((new_r10*sj19))+(((-1.0)*cj20*x673)));
evalcond[7]=(((sj19*x666))+new_r00+(((-1.0)*cj20*x676)));
evalcond[8]=(((x666*x668))+new_r11+(((-1.0)*x676)));
evalcond[9]=((((-1.0)*cj19*x675))+(((-1.0)*x668*x673))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x670))+((new_r11*x668))+((cj20*x669))+x666);
evalcond[11]=(((cj20*x671))+(((-1.0)*new_r20*x670))+((new_r10*x668))+(((-1.0)*x673)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x678=IKPowWithIntegerCheck(sj20,-1);
if(!x678.valid){
continue;
}
IkReal x677=x678.value;
CheckValue<IkReal> x679=IKPowWithIntegerCheck(sj19,-1);
if(!x679.valid){
continue;
}
if( IKabs((x677*(x679.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x677)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x677*(x679.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x677))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x677*(x679.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x677));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x680=IKsin(j21);
IkReal x681=IKcos(j21);
IkReal x682=(cj20*sj19);
IkReal x683=(cj19*new_r01);
IkReal x684=((1.0)*sj20);
IkReal x685=(cj19*new_r00);
IkReal x686=((1.0)*sj19);
IkReal x687=((1.0)*x681);
IkReal x688=(cj20*x680);
IkReal x689=((1.0)*x680);
IkReal x690=(cj19*x687);
evalcond[0]=(((sj20*x681))+new_r20);
evalcond[1]=((((-1.0)*x680*x684))+new_r21);
evalcond[2]=(x688+x683+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x689))+((cj19*new_r10))+(((-1.0)*new_r00*x686)));
evalcond[4]=((((-1.0)*new_r01*x686))+(((-1.0)*x687))+((cj19*new_r11)));
evalcond[5]=(((cj19*x688))+new_r01+((sj19*x681)));
evalcond[6]=(x685+((new_r10*sj19))+(((-1.0)*cj20*x687)));
evalcond[7]=((((-1.0)*cj20*x690))+new_r00+((sj19*x680)));
evalcond[8]=(((x680*x682))+(((-1.0)*x690))+new_r11);
evalcond[9]=((((-1.0)*x682*x687))+(((-1.0)*cj19*x689))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x684))+x680+((new_r11*x682))+((cj20*x683)));
evalcond[11]=((((-1.0)*x687))+(((-1.0)*new_r20*x684))+((new_r10*x682))+((cj20*x685)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x691 = IKatan2WithCheck((gconst134*new_r21),((-1.0)*gconst134*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x691.valid){
continue;
}
j21array[0]=x691.value;
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x692=IKsin(j21);
IkReal x693=IKcos(j21);
IkReal x694=(cj20*sj19);
IkReal x695=(cj19*new_r01);
IkReal x696=((1.0)*sj20);
IkReal x697=(cj19*new_r00);
IkReal x698=((1.0)*sj19);
IkReal x699=((1.0)*x693);
IkReal x700=(cj20*x692);
IkReal x701=((1.0)*x692);
IkReal x702=(cj19*x699);
evalcond[0]=(((sj20*x693))+new_r20);
evalcond[1]=((((-1.0)*x692*x696))+new_r21);
evalcond[2]=(x695+x700+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x698))+(((-1.0)*x701))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x698))+(((-1.0)*x699))+((cj19*new_r11)));
evalcond[5]=(((sj19*x693))+((cj19*x700))+new_r01);
evalcond[6]=((((-1.0)*cj20*x699))+x697+((new_r10*sj19)));
evalcond[7]=(((sj19*x692))+new_r00+(((-1.0)*cj20*x702)));
evalcond[8]=(((x692*x694))+(((-1.0)*x702))+new_r11);
evalcond[9]=((((-1.0)*cj19*x701))+(((-1.0)*x694*x699))+new_r10);
evalcond[10]=(((cj20*x695))+((new_r11*x694))+x692+(((-1.0)*new_r21*x696)));
evalcond[11]=(((new_r10*x694))+((cj20*x697))+(((-1.0)*x699))+(((-1.0)*new_r20*x696)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                if( abs(roots[i]-roots[j]) < 8*tolsqrt ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "c45a6ca7742b52feb0b51dbc6c01064f"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
