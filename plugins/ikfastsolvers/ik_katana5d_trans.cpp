#define IKFAST_NAMESPACE ik_katana5d_trans
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 64 generated on 2013-07-12 00:38:19.638753
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==64);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#define IKFAST_STRINGIZE2(s) #s
#define IKFAST_STRINGIZE(s) IKFAST_STRINGIZE2(s)

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
#ifndef isfinite
#define isfinite _isfinite
#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16;
x0=IKcos(j[0]);
x1=IKsin(j[1]);
x2=IKcos(j[1]);
x3=IKsin(j[2]);
x4=IKcos(j[2]);
x5=IKsin(j[3]);
x6=IKsin(j[0]);
x7=IKcos(j[3]);
x8=((IkReal(0.139000000000000))*(x0));
x9=((IkReal(0.273000000000000))*(x0));
x10=((IkReal(0.273000000000000))*(x6));
x11=((IkReal(0.139000000000000))*(x6));
x12=((IkReal(0.190000000000000))*(x1));
x13=((x2)*(x3));
x14=((x1)*(x3));
x15=((x1)*(x4));
x16=((x2)*(x4));
eetrans[0]=((((x0)*(x12)))+(((x5)*(((((IkReal(-1.00000000000000))*(x16)*(x9)))+(((x14)*(x9)))))))+(((x13)*(x8)))+(((x7)*(((((x13)*(x9)))+(((x15)*(x9)))))))+(((x15)*(x8))));
IkReal x17=((IkReal(1.00000000000000))*(x10));
IkReal x18=((IkReal(1.00000000000000))*(x11));
eetrans[1]=((((IkReal(-1.00000000000000))*(x12)*(x6)))+(((x5)*(((((IkReal(-1.00000000000000))*(x14)*(x17)))+(((x10)*(x16)))))))+(((IkReal(-1.00000000000000))*(x13)*(x18)))+(((IkReal(-1.00000000000000))*(x15)*(x18)))+(((x7)*(((((IkReal(-1.00000000000000))*(x13)*(x17)))+(((IkReal(-1.00000000000000))*(x15)*(x17))))))));
eetrans[2]=((IkReal(0.201500000000000))+(((x7)*(((((IkReal(-0.273000000000000))*(x14)))+(((IkReal(0.273000000000000))*(x16)))))))+(((IkReal(-0.139000000000000))*(x14)))+(((x5)*(((((IkReal(0.273000000000000))*(x15)))+(((IkReal(0.273000000000000))*(x13)))))))+(((IkReal(0.190000000000000))*(x2)))+(((IkReal(0.139000000000000))*(x16))));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3, 4}; return freeparams; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j1,cj1,sj1,htj1,j2,cj2,sj2,htj2,j3,cj3,sj3,htj3,j4,cj4,sj4,htj4,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0;  _ij4[0] = -1; _ij4[1] = -1; _nj4 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]);
j4=pfree[1]; cj4=cos(pfree[1]); sj4=sin(pfree[1]);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=px;
new_py=((IkReal(-1.00000000000000))*(py));
new_pz=((IkReal(0.201500000000000))+(((IkReal(-1.00000000000000))*(pz))));
px = new_px; py = new_py; pz = new_pz;
CheckValue<IkReal> x19 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x19.valid ) {
    continue;
}
CheckValue<IkReal> x20 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x20.valid ) {
    continue;
}
CheckValue<IkReal> x21 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x21.valid ) {
    continue;
}
pp=((x19.value)+(x20.value)+(x21.value));
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x23 = IKatan2WithCheck(py,((IkReal(-1.00000000000000))*(px)),IKFAST_ATAN2_MAGTHRESH);
if( !x23.valid ) {
    continue;
}
IkReal x22=x23.value;
j0array[0]=((IkReal(-1.00000000000000))*(x22));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((IkReal(3.14159265358979))+(((IkReal(-1.00000000000000))*(x22))));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal dummyeval[1];
CheckValue<IkReal> x24 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x24.valid ) {
    continue;
}
CheckValue<IkReal> x25 = IKPowWithIntegerCheck(cj3,2.00000000000000);
if( !x25.valid ) {
    continue;
}
dummyeval[0]=((IkReal(1.00000000000000))+(((IkReal(3.92805755395683))*(cj3)))+(((IkReal(3.85740903679934))*(x24.value)))+(((IkReal(3.85740903679934))*(x25.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
CheckValue<IkReal> x26 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x26.valid ) {
    continue;
}
CheckValue<IkReal> x27 = IKPowWithIntegerCheck(cj3,2.00000000000000);
if( !x27.valid ) {
    continue;
}
dummyeval[0]=((IkReal(1.00000000000000))+(((IkReal(3.92805755395683))*(cj3)))+(((IkReal(3.85740903679934))*(x26.value)))+(((IkReal(3.85740903679934))*(x27.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
CheckValue<IkReal> x28 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x28.valid ) {
    continue;
}
CheckValue<IkReal> x29 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x29.valid ) {
    continue;
}
CheckValue<IkReal> x30 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x30.valid ) {
    continue;
}
CheckValue<IkReal> x31 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x31.valid ) {
    continue;
}
CheckValue<IkReal> x32 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x32.valid ) {
    continue;
}
dummyeval[0]=((((x28.value)*(x29.value)))+(x30.value)+(((x31.value)*(x32.value)))+(((IkReal(2.00000000000000))*(cj0)*(px)*(py)*(sj0))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x33=((((IkReal(0.380000000000000))*(cj0)*(px)))+(((IkReal(0.380000000000000))*(py)*(sj0))));
CheckValue<IkReal> x36 = IKatan2WithCheck(((IkReal(-0.380000000000000))*(pz)),x33,IKFAST_ATAN2_MAGTHRESH);
if( !x36.valid ) {
    continue;
}
IkReal x34=((IkReal(1.00000000000000))*(x36.value));
CheckValue<IkReal> x38 = IKPowWithIntegerCheck(x33,2.00000000000000);
if( !x38.valid ) {
    continue;
}
CheckValue<IkReal> x39 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x39.valid ) {
    continue;
}
if( (((x38.value)+(((IkReal(0.144400000000000))*(x39.value))))) < (IkReal)-0.00001 )
    continue;
CheckValue<IkReal> x37 = IKPowWithIntegerCheck(IKabs(IKsqrt(((x38.value)+(((IkReal(0.144400000000000))*(x39.value)))))),-1.00000000000000);
if( !x37.valid ) {
    continue;
}
if( (((x37.value)*(((IkReal(0.0577500000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3))))))) < -1-IKFAST_SINCOS_THRESH || (((x37.value)*(((IkReal(0.0577500000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x35=IKasin(((x37.value)*(((IkReal(0.0577500000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3)))))));
j1array[0]=((((IkReal(-1.00000000000000))*(x35)))+(((IkReal(-1.00000000000000))*(x34))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((IkReal(3.14159265358979))+(((IkReal(-1.00000000000000))*(x34)))+(x35));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal dummyeval[1];
IkReal gconst0;
CheckValue<IkReal> x40 = IKPowWithIntegerCheck(cj3,2.00000000000000);
if( !x40.valid ) {
    continue;
}
CheckValue<IkReal> x41 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x41.valid ) {
    continue;
}
gconst0=IKsign(((IkReal(-367099.000000000))+(((IkReal(-1416051.00000000))*(x40.value)))+(((IkReal(-1416051.00000000))*(x41.value)))+(((IkReal(-1441986.00000000))*(cj3)))));
CheckValue<IkReal> x42 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x42.valid ) {
    continue;
}
CheckValue<IkReal> x43 = IKPowWithIntegerCheck(cj3,2.00000000000000);
if( !x43.valid ) {
    continue;
}
dummyeval[0]=((IkReal(-1.00000000000000))+(((IkReal(-3.92805755395683))*(cj3)))+(((IkReal(-3.85740903679934))*(x42.value)))+(((IkReal(-3.85740903679934))*(x43.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst1;
CheckValue<IkReal> x44 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x44.valid ) {
    continue;
}
CheckValue<IkReal> x45 = IKPowWithIntegerCheck(cj3,2.00000000000000);
if( !x45.valid ) {
    continue;
}
gconst1=IKsign(((IkReal(19321.0000000000))+(((IkReal(75894.0000000000))*(cj3)))+(((IkReal(74529.0000000000))*(x44.value)))+(((IkReal(74529.0000000000))*(x45.value)))));
CheckValue<IkReal> x46 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x46.valid ) {
    continue;
}
CheckValue<IkReal> x47 = IKPowWithIntegerCheck(cj3,2.00000000000000);
if( !x47.valid ) {
    continue;
}
dummyeval[0]=((IkReal(1.00000000000000))+(((IkReal(3.92805755395683))*(cj3)))+(((IkReal(3.85740903679934))*(x46.value)))+(((IkReal(3.85740903679934))*(x47.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x48=((IkReal(139000.000000000))*(cj1));
IkReal x49=((py)*(sj0));
IkReal x50=((cj0)*(px));
IkReal x51=((IkReal(273000.000000000))*(cj3));
IkReal x52=((IkReal(139000.000000000))*(sj1));
IkReal x53=((IkReal(273000.000000000))*(cj1)*(sj3));
IkReal x54=((IkReal(273000.000000000))*(sj1)*(sj3));
CheckValue<IkReal> x55 = IKatan2WithCheck(((gconst1)*(((((x48)*(x49)))+(((IkReal(-51870.0000000000))*(sj3)))+(((x50)*(x54)))+(((pz)*(sj1)*(x51)))+(((x49)*(x54)))+(((x48)*(x50)))+(((IkReal(-1.00000000000000))*(pz)*(x53)))+(((pz)*(x52)))+(((cj1)*(x49)*(x51)))+(((cj1)*(x50)*(x51)))))),((gconst1)*(((IkReal(-26410.0000000000))+(((sj1)*(x50)*(x51)))+(((IkReal(-1.00000000000000))*(pz)*(x48)))+(((IkReal(-1.00000000000000))*(x49)*(x53)))+(((x50)*(x52)))+(((x49)*(x52)))+(((IkReal(-1.00000000000000))*(cj1)*(pz)*(x51)))+(((IkReal(-1.00000000000000))*(pz)*(x54)))+(((sj1)*(x49)*(x51)))+(((IkReal(-1.00000000000000))*(x50)*(x53)))+(((IkReal(-51870.0000000000))*(cj3)))))),IKFAST_ATAN2_MAGTHRESH);
if( !x55.valid ) {
    continue;
}
j2array[0]=x55.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x56=IKcos(j2);
IkReal x57=IKsin(j2);
IkReal x58=((cj0)*(px));
IkReal x59=((py)*(sj0));
IkReal x60=((IkReal(1.00000000000000))*(pz));
IkReal x61=((IkReal(0.273000000000000))*(cj1));
IkReal x62=((IkReal(1.00000000000000))*(cj1));
IkReal x63=((IkReal(0.273000000000000))*(sj1));
IkReal x64=((cj3)*(x56));
IkReal x65=((IkReal(0.139000000000000))*(x57));
IkReal x66=((IkReal(0.139000000000000))*(x56));
IkReal x67=((sj3)*(x57));
IkReal x68=((IkReal(0.273000000000000))*(cj3)*(x57));
IkReal x69=((IkReal(0.273000000000000))*(sj3)*(x56));
evalcond[0]=((IkReal(0.129950000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3)))+(((IkReal(0.0528200000000000))*(x56)))+(((IkReal(0.103740000000000))*(x64)))+(((IkReal(0.103740000000000))*(x67))));
evalcond[1]=((IkReal(-0.190000000000000))+(((IkReal(-1.00000000000000))*(cj1)*(x60)))+(((sj1)*(x58)))+(((sj1)*(x59)))+(((IkReal(-1.00000000000000))*(x66)))+(((IkReal(-0.273000000000000))*(x64)))+(((IkReal(-0.273000000000000))*(x67))));
evalcond[2]=((((IkReal(-1.00000000000000))*(x59)*(x62)))+(x65)+(x68)+(((IkReal(-1.00000000000000))*(x58)*(x62)))+(((IkReal(-1.00000000000000))*(sj1)*(x60)))+(((IkReal(-1.00000000000000))*(x69))));
evalcond[3]=((((IkReal(-1.00000000000000))*(x61)*(x64)))+(((IkReal(-1.00000000000000))*(x61)*(x67)))+(((IkReal(-1.00000000000000))*(cj1)*(x66)))+(((cj3)*(x57)*(x63)))+(((sj1)*(x65)))+(((IkReal(-0.190000000000000))*(cj1)))+(((IkReal(-1.00000000000000))*(x60)))+(((IkReal(-1.00000000000000))*(sj3)*(x56)*(x63))));
evalcond[4]=((((cj3)*(x57)*(x61)))+(((cj1)*(x65)))+(((sj1)*(x66)))+(((IkReal(0.190000000000000))*(sj1)))+(((x63)*(x67)))+(((x63)*(x64)))+(((IkReal(-1.00000000000000))*(sj3)*(x56)*(x61)))+(((IkReal(-1.00000000000000))*(x59)))+(((IkReal(-1.00000000000000))*(x58))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x70=((IkReal(13650000.0000000))*(pp));
IkReal x71=((IkReal(5187000.00000000))*(pz)*(sj1));
IkReal x72=((cj0)*(cj1)*(px));
IkReal x73=((IkReal(5187000.00000000))*(cj1)*(py)*(sj0));
CheckValue<IkReal> x75 = IKPowWithIntegerCheck(cj3,2.00000000000000);
if( !x75.valid ) {
    continue;
}
CheckValue<IkReal> x74 = IKatan2WithCheck(((gconst0)*(((((IkReal(1035953.10000000))*(cj3)*(sj3)))+(((IkReal(-1.00000000000000))*(cj3)*(x73)))+(((IkReal(-1.00000000000000))*(cj3)*(x71)))+(((IkReal(-2641000.00000000))*(cj1)*(py)*(sj0)))+(((IkReal(-5187000.00000000))*(cj3)*(x72)))+(((IkReal(-2641000.00000000))*(pz)*(sj1)))+(((IkReal(-2641000.00000000))*(x72)))+(((IkReal(-1.00000000000000))*(sj3)*(x70)))+(((IkReal(1773817.50000000))*(sj3)))))),((gconst0)*(((IkReal(903152.500000000))+(((IkReal(-1.00000000000000))*(cj3)*(x70)))+(((IkReal(-6950000.00000000))*(pp)))+(((sj3)*(x71)))+(((sj3)*(x73)))+(((IkReal(2301280.80000000))*(cj3)))+(((IkReal(5187000.00000000))*(sj3)*(x72)))+(((IkReal(1035953.10000000))*(x75.value)))))),IKFAST_ATAN2_MAGTHRESH);
if( !x74.valid ) {
    continue;
}
j2array[0]=x74.value;
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x76=IKcos(j2);
IkReal x77=IKsin(j2);
IkReal x78=((cj0)*(px));
IkReal x79=((py)*(sj0));
IkReal x80=((IkReal(1.00000000000000))*(pz));
IkReal x81=((IkReal(0.273000000000000))*(cj1));
IkReal x82=((IkReal(1.00000000000000))*(cj1));
IkReal x83=((IkReal(0.273000000000000))*(sj1));
IkReal x84=((cj3)*(x76));
IkReal x85=((IkReal(0.139000000000000))*(x77));
IkReal x86=((IkReal(0.139000000000000))*(x76));
IkReal x87=((sj3)*(x77));
IkReal x88=((IkReal(0.273000000000000))*(cj3)*(x77));
IkReal x89=((IkReal(0.273000000000000))*(sj3)*(x76));
evalcond[0]=((IkReal(0.129950000000000))+(((IkReal(0.103740000000000))*(x87)))+(((IkReal(0.103740000000000))*(x84)))+(((IkReal(0.0528200000000000))*(x76)))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3))));
evalcond[1]=((IkReal(-0.190000000000000))+(((IkReal(-0.273000000000000))*(x84)))+(((IkReal(-0.273000000000000))*(x87)))+(((sj1)*(x78)))+(((sj1)*(x79)))+(((IkReal(-1.00000000000000))*(cj1)*(x80)))+(((IkReal(-1.00000000000000))*(x86))));
evalcond[2]=((((IkReal(-1.00000000000000))*(sj1)*(x80)))+(((IkReal(-1.00000000000000))*(x79)*(x82)))+(((IkReal(-1.00000000000000))*(x78)*(x82)))+(x88)+(x85)+(((IkReal(-1.00000000000000))*(x89))));
evalcond[3]=((((IkReal(-1.00000000000000))*(x81)*(x87)))+(((IkReal(-1.00000000000000))*(x81)*(x84)))+(((IkReal(-1.00000000000000))*(sj3)*(x76)*(x83)))+(((IkReal(-0.190000000000000))*(cj1)))+(((cj3)*(x77)*(x83)))+(((sj1)*(x85)))+(((IkReal(-1.00000000000000))*(cj1)*(x86)))+(((IkReal(-1.00000000000000))*(x80))));
evalcond[4]=((((IkReal(-1.00000000000000))*(sj3)*(x76)*(x81)))+(((IkReal(0.190000000000000))*(sj1)))+(((cj3)*(x77)*(x81)))+(((sj1)*(x86)))+(((IkReal(-1.00000000000000))*(x79)))+(((IkReal(-1.00000000000000))*(x78)))+(((x83)*(x87)))+(((x83)*(x84)))+(((cj1)*(x85))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x90=((IkReal(0.0528200000000000))+(((IkReal(0.103740000000000))*(cj3))));
CheckValue<IkReal> x93 = IKatan2WithCheck(x90,((IkReal(0.103740000000000))*(sj3)),IKFAST_ATAN2_MAGTHRESH);
if( !x93.valid ) {
    continue;
}
IkReal x91=((IkReal(1.00000000000000))*(x93.value));
CheckValue<IkReal> x95 = IKPowWithIntegerCheck(x90,2.00000000000000);
if( !x95.valid ) {
    continue;
}
CheckValue<IkReal> x96 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x96.valid ) {
    continue;
}
if( (((x95.value)+(((IkReal(0.0107619876000000))*(x96.value))))) < (IkReal)-0.00001 )
    continue;
CheckValue<IkReal> x94 = IKPowWithIntegerCheck(IKabs(IKsqrt(((x95.value)+(((IkReal(0.0107619876000000))*(x96.value)))))),-1.00000000000000);
if( !x94.valid ) {
    continue;
}
if( (((x94.value)*(((IkReal(0.129950000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3))))))) < -1-IKFAST_SINCOS_THRESH || (((x94.value)*(((IkReal(0.129950000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x92=IKasin(((x94.value)*(((IkReal(0.129950000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3)))))));
j2array[0]=((((IkReal(-1.00000000000000))*(x92)))+(((IkReal(-1.00000000000000))*(x91))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((IkReal(3.14159265358979))+(x92)+(((IkReal(-1.00000000000000))*(x91))));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal dummyeval[1];
IkReal gconst2;
CheckValue<IkReal> x97 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x97.valid ) {
    continue;
}
CheckValue<IkReal> x98 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x98.valid ) {
    continue;
}
CheckValue<IkReal> x99 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x99.valid ) {
    continue;
}
CheckValue<IkReal> x100 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x100.valid ) {
    continue;
}
CheckValue<IkReal> x101 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x101.valid ) {
    continue;
}
gconst2=IKsign(((((IkReal(-19.0000000000000))*(x97.value)*(x98.value)))+(((IkReal(-19.0000000000000))*(x99.value)*(x100.value)))+(((IkReal(-38.0000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-19.0000000000000))*(x101.value)))));
CheckValue<IkReal> x102 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x102.valid ) {
    continue;
}
CheckValue<IkReal> x103 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x103.valid ) {
    continue;
}
CheckValue<IkReal> x104 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x104.valid ) {
    continue;
}
CheckValue<IkReal> x105 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x105.valid ) {
    continue;
}
CheckValue<IkReal> x106 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x106.valid ) {
    continue;
}
dummyeval[0]=((((IkReal(-1.00000000000000))*(x102.value)*(x103.value)))+(((IkReal(-1.00000000000000))*(x104.value)))+(((IkReal(-2.00000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-1.00000000000000))*(x105.value)*(x106.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst3;
CheckValue<IkReal> x107 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x107.valid ) {
    continue;
}
CheckValue<IkReal> x108 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x108.valid ) {
    continue;
}
CheckValue<IkReal> x109 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x109.valid ) {
    continue;
}
CheckValue<IkReal> x110 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x110.valid ) {
    continue;
}
CheckValue<IkReal> x111 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x111.valid ) {
    continue;
}
gconst3=IKsign(((((IkReal(-1.00000000000000))*(x107.value)*(x108.value)))+(((IkReal(-1.00000000000000))*(x109.value)))+(((IkReal(-2.00000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-1.00000000000000))*(x110.value)*(x111.value)))));
CheckValue<IkReal> x112 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x112.valid ) {
    continue;
}
CheckValue<IkReal> x113 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x113.valid ) {
    continue;
}
CheckValue<IkReal> x114 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x114.valid ) {
    continue;
}
CheckValue<IkReal> x115 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x115.valid ) {
    continue;
}
CheckValue<IkReal> x116 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x116.valid ) {
    continue;
}
dummyeval[0]=((((IkReal(-1.00000000000000))*(x112.value)*(x113.value)))+(((IkReal(-1.00000000000000))*(x114.value)))+(((IkReal(-2.00000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-1.00000000000000))*(x115.value)*(x116.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x117=((IkReal(0.273000000000000))*(cj3));
IkReal x118=((py)*(sj0));
IkReal x119=((IkReal(0.273000000000000))*(sj3));
IkReal x120=((pz)*(sj2));
IkReal x121=((IkReal(0.139000000000000))*(cj2));
IkReal x122=((cj0)*(px));
IkReal x123=((cj2)*(pz));
IkReal x124=((IkReal(0.139000000000000))*(sj2));
IkReal x125=((cj2)*(x122));
CheckValue<IkReal> x126 = IKatan2WithCheck(((gconst3)*(((((IkReal(-1.00000000000000))*(x118)*(x121)))+(((IkReal(-0.139000000000000))*(x120)))+(((IkReal(-1.00000000000000))*(sj2)*(x118)*(x119)))+(((IkReal(-1.00000000000000))*(sj2)*(x119)*(x122)))+(((IkReal(-1.00000000000000))*(x117)*(x125)))+(((IkReal(-1.00000000000000))*(x117)*(x120)))+(((IkReal(-0.190000000000000))*(x118)))+(((IkReal(-0.190000000000000))*(x122)))+(((IkReal(-1.00000000000000))*(x121)*(x122)))+(((IkReal(-1.00000000000000))*(cj2)*(x117)*(x118)))+(((x119)*(x123)))))),((gconst3)*(((((x117)*(x123)))+(((IkReal(-1.00000000000000))*(x118)*(x124)))+(((IkReal(0.190000000000000))*(pz)))+(((pz)*(x121)))+(((IkReal(-1.00000000000000))*(sj2)*(x117)*(x118)))+(((IkReal(-1.00000000000000))*(sj2)*(x117)*(x122)))+(((x119)*(x120)))+(((x119)*(x125)))+(((IkReal(-1.00000000000000))*(x122)*(x124)))+(((cj2)*(x118)*(x119)))))),IKFAST_ATAN2_MAGTHRESH);
if( !x126.valid ) {
    continue;
}
j1array[0]=x126.value;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x127=IKsin(j1);
IkReal x128=IKcos(j1);
IkReal x129=((IkReal(0.273000000000000))*(sj3));
IkReal x130=((cj0)*(px));
IkReal x131=((IkReal(0.273000000000000))*(cj3));
IkReal x132=((py)*(sj0));
IkReal x133=((IkReal(1.00000000000000))*(pz));
IkReal x134=((IkReal(0.139000000000000))*(sj2));
IkReal x135=((sj2)*(x127));
IkReal x136=((IkReal(1.00000000000000))*(x128));
IkReal x137=((cj2)*(x128));
IkReal x138=((cj2)*(x127));
IkReal x139=((IkReal(0.380000000000000))*(x127));
IkReal x140=((sj2)*(x128));
evalcond[0]=((IkReal(0.0577500000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((x130)*(x139)))+(((IkReal(-0.380000000000000))*(pz)*(x128)))+(((IkReal(0.0758940000000000))*(cj3)))+(((x132)*(x139))));
evalcond[1]=((IkReal(-0.190000000000000))+(((x127)*(x130)))+(((x127)*(x132)))+(((IkReal(-1.00000000000000))*(sj2)*(x129)))+(((IkReal(-1.00000000000000))*(x128)*(x133)))+(((IkReal(-1.00000000000000))*(cj2)*(x131)))+(((IkReal(-0.139000000000000))*(cj2))));
evalcond[2]=((((sj2)*(x131)))+(((IkReal(-1.00000000000000))*(cj2)*(x129)))+(x134)+(((IkReal(-1.00000000000000))*(x132)*(x136)))+(((IkReal(-1.00000000000000))*(x127)*(x133)))+(((IkReal(-1.00000000000000))*(x130)*(x136))));
evalcond[3]=((((x127)*(x134)))+(((IkReal(-0.139000000000000))*(x137)))+(((IkReal(-1.00000000000000))*(x129)*(x140)))+(((IkReal(-1.00000000000000))*(x133)))+(((x131)*(x135)))+(((IkReal(-0.190000000000000))*(x128)))+(((IkReal(-1.00000000000000))*(x129)*(x138)))+(((IkReal(-1.00000000000000))*(x131)*(x137))));
evalcond[4]=((((x131)*(x140)))+(((x129)*(x135)))+(((IkReal(0.139000000000000))*(x138)))+(((x131)*(x138)))+(((IkReal(-1.00000000000000))*(x130)))+(((IkReal(-1.00000000000000))*(x132)))+(((x128)*(x134)))+(((IkReal(-1.00000000000000))*(x129)*(x137)))+(((IkReal(0.190000000000000))*(x127))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x141=((IkReal(50.0000000000000))*(pp));
IkReal x142=((cj0)*(px));
IkReal x143=((py)*(sj0));
IkReal x144=((IkReal(2.64100000000000))*(sj2));
IkReal x145=((IkReal(3.79470000000000))*(cj3));
IkReal x146=((IkReal(5.18700000000000))*(cj3)*(sj2));
IkReal x147=((IkReal(5.18700000000000))*(cj2)*(sj3));
CheckValue<IkReal> x148 = IKatan2WithCheck(((gconst2)*(((((pz)*(x147)))+(((x142)*(x145)))+(((IkReal(-1.00000000000000))*(pz)*(x144)))+(((IkReal(-1.00000000000000))*(pz)*(x146)))+(((IkReal(-1.00000000000000))*(x141)*(x143)))+(((IkReal(-1.00000000000000))*(x141)*(x142)))+(((IkReal(2.88750000000000))*(x142)))+(((IkReal(2.88750000000000))*(x143)))+(((x143)*(x145)))))),((gconst2)*(((((IkReal(-2.88750000000000))*(pz)))+(((pz)*(x141)))+(((x142)*(x147)))+(((IkReal(-1.00000000000000))*(x143)*(x144)))+(((IkReal(-1.00000000000000))*(x143)*(x146)))+(((IkReal(-1.00000000000000))*(x142)*(x144)))+(((IkReal(-1.00000000000000))*(x142)*(x146)))+(((IkReal(-1.00000000000000))*(pz)*(x145)))+(((x143)*(x147)))))),IKFAST_ATAN2_MAGTHRESH);
if( !x148.valid ) {
    continue;
}
j1array[0]=x148.value;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x149=IKsin(j1);
IkReal x150=IKcos(j1);
IkReal x151=((IkReal(0.273000000000000))*(sj3));
IkReal x152=((cj0)*(px));
IkReal x153=((IkReal(0.273000000000000))*(cj3));
IkReal x154=((py)*(sj0));
IkReal x155=((IkReal(1.00000000000000))*(pz));
IkReal x156=((IkReal(0.139000000000000))*(sj2));
IkReal x157=((sj2)*(x149));
IkReal x158=((IkReal(1.00000000000000))*(x150));
IkReal x159=((cj2)*(x150));
IkReal x160=((cj2)*(x149));
IkReal x161=((IkReal(0.380000000000000))*(x149));
IkReal x162=((sj2)*(x150));
evalcond[0]=((IkReal(0.0577500000000000))+(((x152)*(x161)))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(-0.380000000000000))*(pz)*(x150)))+(((x154)*(x161)))+(((IkReal(0.0758940000000000))*(cj3))));
evalcond[1]=((IkReal(-0.190000000000000))+(((x149)*(x152)))+(((x149)*(x154)))+(((IkReal(-1.00000000000000))*(x150)*(x155)))+(((IkReal(-1.00000000000000))*(cj2)*(x153)))+(((IkReal(-1.00000000000000))*(sj2)*(x151)))+(((IkReal(-0.139000000000000))*(cj2))));
evalcond[2]=((((IkReal(-1.00000000000000))*(x154)*(x158)))+(x156)+(((IkReal(-1.00000000000000))*(x152)*(x158)))+(((IkReal(-1.00000000000000))*(cj2)*(x151)))+(((IkReal(-1.00000000000000))*(x149)*(x155)))+(((sj2)*(x153))));
evalcond[3]=((((x153)*(x157)))+(((x149)*(x156)))+(((IkReal(-1.00000000000000))*(x155)))+(((IkReal(-1.00000000000000))*(x153)*(x159)))+(((IkReal(-0.190000000000000))*(x150)))+(((IkReal(-1.00000000000000))*(x151)*(x160)))+(((IkReal(-1.00000000000000))*(x151)*(x162)))+(((IkReal(-0.139000000000000))*(x159))));
evalcond[4]=((((IkReal(0.190000000000000))*(x149)))+(((IkReal(0.139000000000000))*(x160)))+(((IkReal(-1.00000000000000))*(x151)*(x159)))+(((x150)*(x156)))+(((x151)*(x157)))+(((IkReal(-1.00000000000000))*(x152)))+(((IkReal(-1.00000000000000))*(x154)))+(((x153)*(x162)))+(((x153)*(x160))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x163=((IkReal(0.0528200000000000))+(((IkReal(0.103740000000000))*(cj3))));
CheckValue<IkReal> x166 = IKatan2WithCheck(x163,((IkReal(0.103740000000000))*(sj3)),IKFAST_ATAN2_MAGTHRESH);
if( !x166.valid ) {
    continue;
}
IkReal x164=((IkReal(1.00000000000000))*(x166.value));
CheckValue<IkReal> x168 = IKPowWithIntegerCheck(x163,2.00000000000000);
if( !x168.valid ) {
    continue;
}
CheckValue<IkReal> x169 = IKPowWithIntegerCheck(sj3,2.00000000000000);
if( !x169.valid ) {
    continue;
}
if( (((x168.value)+(((IkReal(0.0107619876000000))*(x169.value))))) < (IkReal)-0.00001 )
    continue;
CheckValue<IkReal> x167 = IKPowWithIntegerCheck(IKabs(IKsqrt(((x168.value)+(((IkReal(0.0107619876000000))*(x169.value)))))),-1.00000000000000);
if( !x167.valid ) {
    continue;
}
if( (((x167.value)*(((IkReal(0.129950000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3))))))) < -1-IKFAST_SINCOS_THRESH || (((x167.value)*(((IkReal(0.129950000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x165=IKasin(((x167.value)*(((IkReal(0.129950000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3)))))));
j2array[0]=((((IkReal(-1.00000000000000))*(x164)))+(((IkReal(-1.00000000000000))*(x165))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((IkReal(3.14159265358979))+(((IkReal(-1.00000000000000))*(x164)))+(x165));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal dummyeval[1];
IkReal gconst2;
CheckValue<IkReal> x170 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x170.valid ) {
    continue;
}
CheckValue<IkReal> x171 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x171.valid ) {
    continue;
}
CheckValue<IkReal> x172 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x172.valid ) {
    continue;
}
CheckValue<IkReal> x173 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x173.valid ) {
    continue;
}
CheckValue<IkReal> x174 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x174.valid ) {
    continue;
}
gconst2=IKsign(((((IkReal(-19.0000000000000))*(x170.value)*(x171.value)))+(((IkReal(-19.0000000000000))*(x172.value)*(x173.value)))+(((IkReal(-38.0000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-19.0000000000000))*(x174.value)))));
CheckValue<IkReal> x175 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x175.valid ) {
    continue;
}
CheckValue<IkReal> x176 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x176.valid ) {
    continue;
}
CheckValue<IkReal> x177 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x177.valid ) {
    continue;
}
CheckValue<IkReal> x178 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x178.valid ) {
    continue;
}
CheckValue<IkReal> x179 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x179.valid ) {
    continue;
}
dummyeval[0]=((((IkReal(-1.00000000000000))*(x175.value)*(x176.value)))+(((IkReal(-1.00000000000000))*(x177.value)))+(((IkReal(-2.00000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-1.00000000000000))*(x178.value)*(x179.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
{
IkReal dummyeval[1];
IkReal gconst3;
CheckValue<IkReal> x180 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x180.valid ) {
    continue;
}
CheckValue<IkReal> x181 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x181.valid ) {
    continue;
}
CheckValue<IkReal> x182 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x182.valid ) {
    continue;
}
CheckValue<IkReal> x183 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x183.valid ) {
    continue;
}
CheckValue<IkReal> x184 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x184.valid ) {
    continue;
}
gconst3=IKsign(((((IkReal(-1.00000000000000))*(x180.value)*(x181.value)))+(((IkReal(-1.00000000000000))*(x182.value)))+(((IkReal(-2.00000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-1.00000000000000))*(x183.value)*(x184.value)))));
CheckValue<IkReal> x185 = IKPowWithIntegerCheck(cj0,2.00000000000000);
if( !x185.valid ) {
    continue;
}
CheckValue<IkReal> x186 = IKPowWithIntegerCheck(px,2.00000000000000);
if( !x186.valid ) {
    continue;
}
CheckValue<IkReal> x187 = IKPowWithIntegerCheck(pz,2.00000000000000);
if( !x187.valid ) {
    continue;
}
CheckValue<IkReal> x188 = IKPowWithIntegerCheck(py,2.00000000000000);
if( !x188.valid ) {
    continue;
}
CheckValue<IkReal> x189 = IKPowWithIntegerCheck(sj0,2.00000000000000);
if( !x189.valid ) {
    continue;
}
dummyeval[0]=((((IkReal(-1.00000000000000))*(x185.value)*(x186.value)))+(((IkReal(-1.00000000000000))*(x187.value)))+(((IkReal(-2.00000000000000))*(cj0)*(px)*(py)*(sj0)))+(((IkReal(-1.00000000000000))*(x188.value)*(x189.value))));
if( IKabs(dummyeval[0]) < 0.0000010000000000  )
{
continue;

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x190=((IkReal(0.273000000000000))*(cj3));
IkReal x191=((py)*(sj0));
IkReal x192=((IkReal(0.273000000000000))*(sj3));
IkReal x193=((pz)*(sj2));
IkReal x194=((IkReal(0.139000000000000))*(cj2));
IkReal x195=((cj0)*(px));
IkReal x196=((cj2)*(pz));
IkReal x197=((IkReal(0.139000000000000))*(sj2));
IkReal x198=((cj2)*(x195));
CheckValue<IkReal> x199 = IKatan2WithCheck(((gconst3)*(((((IkReal(-1.00000000000000))*(x194)*(x195)))+(((IkReal(-1.00000000000000))*(x191)*(x194)))+(((IkReal(-0.139000000000000))*(x193)))+(((IkReal(-1.00000000000000))*(x190)*(x198)))+(((IkReal(-1.00000000000000))*(x190)*(x193)))+(((IkReal(-0.190000000000000))*(x191)))+(((IkReal(-0.190000000000000))*(x195)))+(((IkReal(-1.00000000000000))*(cj2)*(x190)*(x191)))+(((x192)*(x196)))+(((IkReal(-1.00000000000000))*(sj2)*(x192)*(x195)))+(((IkReal(-1.00000000000000))*(sj2)*(x191)*(x192)))))),((gconst3)*(((((IkReal(0.190000000000000))*(pz)))+(((IkReal(-1.00000000000000))*(x195)*(x197)))+(((IkReal(-1.00000000000000))*(x191)*(x197)))+(((x192)*(x198)))+(((x192)*(x193)))+(((cj2)*(x191)*(x192)))+(((IkReal(-1.00000000000000))*(sj2)*(x190)*(x191)))+(((IkReal(-1.00000000000000))*(sj2)*(x190)*(x195)))+(((x190)*(x196)))+(((pz)*(x194)))))),IKFAST_ATAN2_MAGTHRESH);
if( !x199.valid ) {
    continue;
}
j1array[0]=x199.value;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x200=IKsin(j1);
IkReal x201=IKcos(j1);
IkReal x202=((IkReal(0.273000000000000))*(sj3));
IkReal x203=((cj0)*(px));
IkReal x204=((IkReal(0.273000000000000))*(cj3));
IkReal x205=((py)*(sj0));
IkReal x206=((IkReal(1.00000000000000))*(pz));
IkReal x207=((IkReal(0.139000000000000))*(sj2));
IkReal x208=((sj2)*(x200));
IkReal x209=((IkReal(1.00000000000000))*(x201));
IkReal x210=((cj2)*(x201));
IkReal x211=((cj2)*(x200));
IkReal x212=((IkReal(0.380000000000000))*(x200));
IkReal x213=((sj2)*(x201));
evalcond[0]=((IkReal(0.0577500000000000))+(((x203)*(x212)))+(((x205)*(x212)))+(((IkReal(-1.00000000000000))*(pp)))+(((IkReal(0.0758940000000000))*(cj3)))+(((IkReal(-0.380000000000000))*(pz)*(x201))));
evalcond[1]=((IkReal(-0.190000000000000))+(((IkReal(-1.00000000000000))*(x201)*(x206)))+(((x200)*(x203)))+(((x200)*(x205)))+(((IkReal(-1.00000000000000))*(cj2)*(x204)))+(((IkReal(-1.00000000000000))*(sj2)*(x202)))+(((IkReal(-0.139000000000000))*(cj2))));
evalcond[2]=((((IkReal(-1.00000000000000))*(x200)*(x206)))+(((IkReal(-1.00000000000000))*(x203)*(x209)))+(x207)+(((IkReal(-1.00000000000000))*(x205)*(x209)))+(((IkReal(-1.00000000000000))*(cj2)*(x202)))+(((sj2)*(x204))));
evalcond[3]=((((IkReal(-0.139000000000000))*(x210)))+(((x200)*(x207)))+(((IkReal(-1.00000000000000))*(x204)*(x210)))+(((IkReal(-1.00000000000000))*(x206)))+(((x204)*(x208)))+(((IkReal(-0.190000000000000))*(x201)))+(((IkReal(-1.00000000000000))*(x202)*(x213)))+(((IkReal(-1.00000000000000))*(x202)*(x211))));
evalcond[4]=((((x204)*(x213)))+(((x204)*(x211)))+(((x201)*(x207)))+(((IkReal(0.190000000000000))*(x200)))+(((IkReal(0.139000000000000))*(x211)))+(((x202)*(x208)))+(((IkReal(-1.00000000000000))*(x202)*(x210)))+(((IkReal(-1.00000000000000))*(x203)))+(((IkReal(-1.00000000000000))*(x205))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x214=((IkReal(50.0000000000000))*(pp));
IkReal x215=((cj0)*(px));
IkReal x216=((py)*(sj0));
IkReal x217=((IkReal(2.64100000000000))*(sj2));
IkReal x218=((IkReal(3.79470000000000))*(cj3));
IkReal x219=((IkReal(5.18700000000000))*(cj3)*(sj2));
IkReal x220=((IkReal(5.18700000000000))*(cj2)*(sj3));
CheckValue<IkReal> x221 = IKatan2WithCheck(((gconst2)*(((((IkReal(-1.00000000000000))*(pz)*(x219)))+(((IkReal(-1.00000000000000))*(pz)*(x217)))+(((x216)*(x218)))+(((pz)*(x220)))+(((x215)*(x218)))+(((IkReal(2.88750000000000))*(x215)))+(((IkReal(2.88750000000000))*(x216)))+(((IkReal(-1.00000000000000))*(x214)*(x216)))+(((IkReal(-1.00000000000000))*(x214)*(x215)))))),((gconst2)*(((((IkReal(-2.88750000000000))*(pz)))+(((IkReal(-1.00000000000000))*(pz)*(x218)))+(((x216)*(x220)))+(((x215)*(x220)))+(((pz)*(x214)))+(((IkReal(-1.00000000000000))*(x216)*(x219)))+(((IkReal(-1.00000000000000))*(x216)*(x217)))+(((IkReal(-1.00000000000000))*(x215)*(x217)))+(((IkReal(-1.00000000000000))*(x215)*(x219)))))),IKFAST_ATAN2_MAGTHRESH);
if( !x221.valid ) {
    continue;
}
j1array[0]=x221.value;
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x222=IKsin(j1);
IkReal x223=IKcos(j1);
IkReal x224=((IkReal(0.273000000000000))*(sj3));
IkReal x225=((cj0)*(px));
IkReal x226=((IkReal(0.273000000000000))*(cj3));
IkReal x227=((py)*(sj0));
IkReal x228=((IkReal(1.00000000000000))*(pz));
IkReal x229=((IkReal(0.139000000000000))*(sj2));
IkReal x230=((sj2)*(x222));
IkReal x231=((IkReal(1.00000000000000))*(x223));
IkReal x232=((cj2)*(x223));
IkReal x233=((cj2)*(x222));
IkReal x234=((IkReal(0.380000000000000))*(x222));
IkReal x235=((sj2)*(x223));
evalcond[0]=((IkReal(0.0577500000000000))+(((IkReal(-1.00000000000000))*(pp)))+(((x225)*(x234)))+(((IkReal(0.0758940000000000))*(cj3)))+(((x227)*(x234)))+(((IkReal(-0.380000000000000))*(pz)*(x223))));
evalcond[1]=((IkReal(-0.190000000000000))+(((x222)*(x225)))+(((x222)*(x227)))+(((IkReal(-1.00000000000000))*(x223)*(x228)))+(((IkReal(-1.00000000000000))*(sj2)*(x224)))+(((IkReal(-1.00000000000000))*(cj2)*(x226)))+(((IkReal(-0.139000000000000))*(cj2))));
evalcond[2]=((((IkReal(-1.00000000000000))*(x225)*(x231)))+(((IkReal(-1.00000000000000))*(x227)*(x231)))+(((IkReal(-1.00000000000000))*(x222)*(x228)))+(x229)+(((sj2)*(x226)))+(((IkReal(-1.00000000000000))*(cj2)*(x224))));
evalcond[3]=((((IkReal(-0.190000000000000))*(x223)))+(((IkReal(-1.00000000000000))*(x224)*(x233)))+(((IkReal(-1.00000000000000))*(x224)*(x235)))+(((x222)*(x229)))+(((x226)*(x230)))+(((IkReal(-0.139000000000000))*(x232)))+(((IkReal(-1.00000000000000))*(x226)*(x232)))+(((IkReal(-1.00000000000000))*(x228))));
evalcond[4]=((((IkReal(0.139000000000000))*(x233)))+(((IkReal(-1.00000000000000))*(x224)*(x232)))+(((IkReal(0.190000000000000))*(x222)))+(((x226)*(x233)))+(((x226)*(x235)))+(((x223)*(x229)))+(((x224)*(x230)))+(((IkReal(-1.00000000000000))*(x225)))+(((IkReal(-1.00000000000000))*(x227))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "afe50514bf09aff5f2a84beb078bafbd"; }

IKFAST_API const char* GetIkFastVersion() { return IKFAST_STRINGIZE(IKFAST_VERSION); }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
